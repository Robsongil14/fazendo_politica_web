"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@supabase";
exports.ids = ["vendor-chunks/@supabase"];
exports.modules = {

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n\nconst AuthAdminApi = _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthAdminApi); //# sourceMappingURL=AuthAdminApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aEFkbWluQXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQThDO0FBQzlDLE1BQU1DLGVBQWVELHVEQUFjQTtBQUNuQyxpRUFBZUMsWUFBWUEsRUFBQyxDQUM1Qix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9BdXRoQWRtaW5BcGkuanM/MjA2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR29UcnVlQWRtaW5BcGkgZnJvbSAnLi9Hb1RydWVBZG1pbkFwaSc7XG5jb25zdCBBdXRoQWRtaW5BcGkgPSBHb1RydWVBZG1pbkFwaTtcbmV4cG9ydCBkZWZhdWx0IEF1dGhBZG1pbkFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhBZG1pbkFwaS5qcy5tYXAiXSwibmFtZXMiOlsiR29UcnVlQWRtaW5BcGkiLCJBdXRoQWRtaW5BcGkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/AuthClient.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueClient */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n\nconst AuthClient = _GoTrueClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AuthClient); //# sourceMappingURL=AuthClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aENsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQztBQUMxQyxNQUFNQyxhQUFhRCxxREFBWUE7QUFDL0IsaUVBQWVDLFVBQVVBLEVBQUMsQ0FDMUIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvQXV0aENsaWVudC5qcz80ZjhmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBHb1RydWVDbGllbnQgZnJvbSAnLi9Hb1RydWVDbGllbnQnO1xuY29uc3QgQXV0aENsaWVudCA9IEdvVHJ1ZUNsaWVudDtcbmV4cG9ydCBkZWZhdWx0IEF1dGhDbGllbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BdXRoQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJHb1RydWVDbGllbnQiLCJBdXRoQ2xpZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ GoTrueAdminApi)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/fetch */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/types */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n\n\n\n\n\nclass GoTrueAdminApi {\n    constructor({ url = \"\", headers = {}, fetch }){\n        this.url = url;\n        this.headers = headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n        this.mfa = {\n            listFactors: this._listFactors.bind(this),\n            deleteFactor: this._deleteFactor.bind(this)\n        };\n        this.oauth = {\n            listClients: this._listOAuthClients.bind(this),\n            createClient: this._createOAuthClient.bind(this),\n            getClient: this._getOAuthClient.bind(this),\n            updateClient: this._updateOAuthClient.bind(this),\n            deleteClient: this._deleteOAuthClient.bind(this),\n            regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)\n        };\n    }\n    /**\n     * Removes a logged-in session.\n     * @param jwt A valid, logged-in JWT.\n     * @param scope The logout sope.\n     */ async signOut(jwt, scope = _lib_types__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES[0]) {\n        if (_lib_types__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES.indexOf(scope) < 0) {\n            throw new Error(`@supabase/auth-js: Parameter scope must be one of ${_lib_types__WEBPACK_IMPORTED_MODULE_2__.SIGN_OUT_SCOPES.join(\", \")}`);\n        }\n        try {\n            await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/logout?scope=${scope}`, {\n                headers: this.headers,\n                jwt,\n                noResolveJson: true\n            });\n            return {\n                data: null,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends an invite link to an email address.\n     * @param email The email address of the user.\n     * @param options Additional options to be included when inviting.\n     */ async inviteUserByEmail(email, options = {}) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/invite`, {\n                body: {\n                    email,\n                    data: options.data\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates email links and OTPs to be sent via a custom email provider.\n     * @param email The user's email.\n     * @param options.password User password. For signup only.\n     * @param options.data Optional user metadata. For signup only.\n     * @param options.redirectTo The redirect url which should be appended to the generated link\n     */ async generateLink(params) {\n        try {\n            const { options } = params, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(params, [\n                \"options\"\n            ]);\n            const body = Object.assign(Object.assign({}, rest), options);\n            if (\"newEmail\" in rest) {\n                // replace newEmail with new_email in request body\n                body.new_email = rest === null || rest === void 0 ? void 0 : rest.newEmail;\n                delete body[\"newEmail\"];\n            }\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/generate_link`, {\n                body: body,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._generateLinkResponse,\n                redirectTo: options === null || options === void 0 ? void 0 : options.redirectTo\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        properties: null,\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    // User Admin API\n    /**\n     * Creates a new user.\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async createUser(attributes) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/users`, {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get a list of users.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     * @param params An object which supports `page` and `perPage` as numbers, to alter the paginated results.\n     */ async listUsers(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        try {\n            const pagination = {\n                nextPage: null,\n                lastPage: 0,\n                total: 0\n            };\n            const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/users`, {\n                headers: this.headers,\n                noResolveJson: true,\n                query: {\n                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\",\n                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : \"\"\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._noResolveJsonResponse\n            });\n            if (response.error) throw response.error;\n            const users = await response.json();\n            const total = (_e = response.headers.get(\"x-total-count\")) !== null && _e !== void 0 ? _e : 0;\n            const links = (_g = (_f = response.headers.get(\"link\")) === null || _f === void 0 ? void 0 : _f.split(\",\")) !== null && _g !== void 0 ? _g : [];\n            if (links.length > 0) {\n                links.forEach((link)=>{\n                    const page = parseInt(link.split(\";\")[0].split(\"=\")[1].substring(0, 1));\n                    const rel = JSON.parse(link.split(\";\")[1].split(\"=\")[1]);\n                    pagination[`${rel}Page`] = page;\n                });\n                pagination.total = parseInt(total);\n            }\n            return {\n                data: Object.assign(Object.assign({}, users), pagination),\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        users: []\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Get user by id.\n     *\n     * @param uid The user's unique identifier\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async getUserById(uid) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(uid);\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/users/${uid}`, {\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates the user data.\n     *\n     * @param attributes The data you want to update.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async updateUserById(uid, attributes) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(uid);\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"PUT\", `${this.url}/admin/users/${uid}`, {\n                body: attributes,\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Delete a user. Requires a `service_role` key.\n     *\n     * @param id The user id you want to remove.\n     * @param shouldSoftDelete If true, then the user will be soft-deleted from the auth schema. Soft deletion allows user identification from the hashed user ID but is not reversible.\n     * Defaults to false for backward compatibility.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async deleteUser(id, shouldSoftDelete = false) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(id);\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", `${this.url}/admin/users/${id}`, {\n                headers: this.headers,\n                body: {\n                    should_soft_delete: shouldSoftDelete\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._userResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _listFactors(params) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(params.userId);\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/users/${params.userId}/factors`, {\n                headers: this.headers,\n                xform: (factors)=>{\n                    return {\n                        data: {\n                            factors\n                        },\n                        error: null\n                    };\n                }\n            });\n            return {\n                data,\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _deleteFactor(params) {\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(params.userId);\n        (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.validateUUID)(params.id);\n        try {\n            const data = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", `${this.url}/admin/users/${params.userId}/factors/${params.id}`, {\n                headers: this.headers\n            });\n            return {\n                data,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Lists all OAuth clients with optional pagination.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _listOAuthClients(params) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        try {\n            const pagination = {\n                nextPage: null,\n                lastPage: 0,\n                total: 0\n            };\n            const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/oauth/clients`, {\n                headers: this.headers,\n                noResolveJson: true,\n                query: {\n                    page: (_b = (_a = params === null || params === void 0 ? void 0 : params.page) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : \"\",\n                    per_page: (_d = (_c = params === null || params === void 0 ? void 0 : params.perPage) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : \"\"\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_0__._noResolveJsonResponse\n            });\n            if (response.error) throw response.error;\n            const clients = await response.json();\n            const total = (_e = response.headers.get(\"x-total-count\")) !== null && _e !== void 0 ? _e : 0;\n            const links = (_g = (_f = response.headers.get(\"link\")) === null || _f === void 0 ? void 0 : _f.split(\",\")) !== null && _g !== void 0 ? _g : [];\n            if (links.length > 0) {\n                links.forEach((link)=>{\n                    const page = parseInt(link.split(\";\")[0].split(\"=\")[1].substring(0, 1));\n                    const rel = JSON.parse(link.split(\";\")[1].split(\"=\")[1]);\n                    pagination[`${rel}Page`] = page;\n                });\n                pagination.total = parseInt(total);\n            }\n            return {\n                data: Object.assign(Object.assign({}, clients), pagination),\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: {\n                        clients: []\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates a new OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _createOAuthClient(params) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/oauth/clients`, {\n                body: params,\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets details of a specific OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _getOAuthClient(clientId) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"GET\", `${this.url}/admin/oauth/clients/${clientId}`, {\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates an existing OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _updateOAuthClient(clientId, params) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"PUT\", `${this.url}/admin/oauth/clients/${clientId}`, {\n                body: params,\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Deletes an OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _deleteOAuthClient(clientId) {\n        try {\n            await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"DELETE\", `${this.url}/admin/oauth/clients/${clientId}`, {\n                headers: this.headers,\n                noResolveJson: true\n            });\n            return {\n                data: null,\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Regenerates the secret for an OAuth client.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * This function should only be called on a server. Never expose your `service_role` key in the browser.\n     */ async _regenerateOAuthClientSecret(clientId) {\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_0__._request)(this.fetch, \"POST\", `${this.url}/admin/oauth/clients/${clientId}/regenerate_secret`, {\n                headers: this.headers,\n                xform: (client)=>{\n                    return {\n                        data: client,\n                        error: null\n                    };\n                }\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n} //# sourceMappingURL=GoTrueAdminApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQWRtaW5BcGkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQStCO0FBQ3VFO0FBQzNDO0FBQ1o7QUFDSjtBQUM1QixNQUFNUztJQUNqQkMsWUFBWSxFQUFFQyxNQUFNLEVBQUUsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRUMsS0FBSyxFQUFHLENBQUU7UUFDNUMsSUFBSSxDQUFDRixHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxLQUFLLEdBQUdSLDBEQUFZQSxDQUFDUTtRQUMxQixJQUFJLENBQUNDLEdBQUcsR0FBRztZQUNQQyxhQUFhLElBQUksQ0FBQ0MsWUFBWSxDQUFDQyxJQUFJLENBQUMsSUFBSTtZQUN4Q0MsY0FBYyxJQUFJLENBQUNDLGFBQWEsQ0FBQ0YsSUFBSSxDQUFDLElBQUk7UUFDOUM7UUFDQSxJQUFJLENBQUNHLEtBQUssR0FBRztZQUNUQyxhQUFhLElBQUksQ0FBQ0MsaUJBQWlCLENBQUNMLElBQUksQ0FBQyxJQUFJO1lBQzdDTSxjQUFjLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNQLElBQUksQ0FBQyxJQUFJO1lBQy9DUSxXQUFXLElBQUksQ0FBQ0MsZUFBZSxDQUFDVCxJQUFJLENBQUMsSUFBSTtZQUN6Q1UsY0FBYyxJQUFJLENBQUNDLGtCQUFrQixDQUFDWCxJQUFJLENBQUMsSUFBSTtZQUMvQ1ksY0FBYyxJQUFJLENBQUNDLGtCQUFrQixDQUFDYixJQUFJLENBQUMsSUFBSTtZQUMvQ2Msd0JBQXdCLElBQUksQ0FBQ0MsNEJBQTRCLENBQUNmLElBQUksQ0FBQyxJQUFJO1FBQ3ZFO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0QsTUFBTWdCLFFBQVFDLEdBQUcsRUFBRUMsUUFBUTVCLHVEQUFlLENBQUMsRUFBRSxFQUFFO1FBQzNDLElBQUlBLHVEQUFlQSxDQUFDNkIsT0FBTyxDQUFDRCxTQUFT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TUM7Z0JBQU07WUFDL0I7WUFDQSxNQUFNQTtRQUNWO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNELE1BQU1ULDZCQUE2QnFFLFFBQVEsRUFBRTtRQUN6QyxJQUFJO1lBQ0EsT0FBTyxNQUFNbEcsb0RBQVFBLENBQUMsSUFBSSxDQUFDVSxLQUFLLEVBQUUsUUFBUSxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMscUJBQXFCLEVBQUUwRixTQUFTLGtCQUFrQixDQUFDLEVBQUU7Z0JBQ3ZHekYsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQ3JCbUMsT0FBTyxDQUFDcUQ7b0JBQ0osT0FBTzt3QkFBRTVELE1BQU00RDt3QkFBUTNELE9BQU87b0JBQUs7Z0JBQ3ZDO1lBQ0o7UUFDSixFQUNBLE9BQU9BLE9BQU87WUFDVixJQUFJakMsd0RBQVdBLENBQUNpQyxRQUFRO2dCQUNwQixPQUFPO29CQUFFRCxNQUFNO29CQUFNQztnQkFBTTtZQUMvQjtZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtBQUNKLEVBQ0EsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQWRtaW5BcGkuanM/NGEwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IF9nZW5lcmF0ZUxpbmtSZXNwb25zZSwgX25vUmVzb2x2ZUpzb25SZXNwb25zZSwgX3JlcXVlc3QsIF91c2VyUmVzcG9uc2UsIH0gZnJvbSAnLi9saWIvZmV0Y2gnO1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoLCB2YWxpZGF0ZVVVSUQgfSBmcm9tICcuL2xpYi9oZWxwZXJzJztcbmltcG9ydCB7IFNJR05fT1VUX1NDT1BFUywgfSBmcm9tICcuL2xpYi90eXBlcyc7XG5pbXBvcnQgeyBpc0F1dGhFcnJvciB9IGZyb20gJy4vbGliL2Vycm9ycyc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHb1RydWVBZG1pbkFwaSB7XG4gICAgY29uc3RydWN0b3IoeyB1cmwgPSAnJywgaGVhZGVycyA9IHt9LCBmZXRjaCwgfSkge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaCk7XG4gICAgICAgIHRoaXMubWZhID0ge1xuICAgICAgICAgICAgbGlzdEZhY3RvcnM6IHRoaXMuX2xpc3RGYWN0b3JzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBkZWxldGVGYWN0b3I6IHRoaXMuX2RlbGV0ZUZhY3Rvci5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9hdXRoID0ge1xuICAgICAgICAgICAgbGlzdENsaWVudHM6IHRoaXMuX2xpc3RPQXV0aENsaWVudHMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNyZWF0ZUNsaWVudDogdGhpcy5fY3JlYXRlT0F1dGhDbGllbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldENsaWVudDogdGhpcy5fZ2V0T0F1dGhDbGllbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHVwZGF0ZUNsaWVudDogdGhpcy5fdXBkYXRlT0F1dGhDbGllbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGRlbGV0ZUNsaWVudDogdGhpcy5fZGVsZXRlT0F1dGhDbGllbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHJlZ2VuZXJhdGVDbGllbnRTZWNyZXQ6IHRoaXMuX3JlZ2VuZXJhdGVPQXV0aENsaWVudFNlY3JldC5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgbG9nZ2VkLWluIHNlc3Npb24uXG4gICAgICogQHBhcmFtIGp3dCBBIHZhbGlkLCBsb2dnZWQtaW4gSldULlxuICAgICAqIEBwYXJhbSBzY29wZSBUaGUgbG9nb3V0IHNvcGUuXG4gICAgICovXG4gICAgYXN5bmMgc2lnbk91dChqd3QsIHNjb3BlID0gU0lHTl9PVVRfU0NPUEVTWzBdKSB7XG4gICAgICAgIGlmIChTSUdOX09VVF9TQ09QRVMuaW5kZXhPZihzY29wZSkgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBQYXJhbWV0ZXIgc2NvcGUgbXVzdCBiZSBvbmUgb2YgJHtTSUdOX09VVF9TQ09QRVMuam9pbignLCAnKX1gKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vbG9nb3V0P3Njb3BlPSR7c2NvcGV9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBqd3QsXG4gICAgICAgICAgICAgICAgbm9SZXNvbHZlSnNvbjogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYW4gaW52aXRlIGxpbmsgdG8gYW4gZW1haWwgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIGJlIGluY2x1ZGVkIHdoZW4gaW52aXRpbmcuXG4gICAgICovXG4gICAgYXN5bmMgaW52aXRlVXNlckJ5RW1haWwoZW1haWwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ludml0ZWAsIHtcbiAgICAgICAgICAgICAgICBib2R5OiB7IGVtYWlsLCBkYXRhOiBvcHRpb25zLmRhdGEgfSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucy5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgZW1haWwgbGlua3MgYW5kIE9UUHMgdG8gYmUgc2VudCB2aWEgYSBjdXN0b20gZW1haWwgcHJvdmlkZXIuXG4gICAgICogQHBhcmFtIGVtYWlsIFRoZSB1c2VyJ3MgZW1haWwuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucGFzc3dvcmQgVXNlciBwYXNzd29yZC4gRm9yIHNpZ251cCBvbmx5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRhdGEgT3B0aW9uYWwgdXNlciBtZXRhZGF0YS4gRm9yIHNpZ251cCBvbmx5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0VG8gVGhlIHJlZGlyZWN0IHVybCB3aGljaCBzaG91bGQgYmUgYXBwZW5kZWQgdG8gdGhlIGdlbmVyYXRlZCBsaW5rXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVMaW5rKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBwYXJhbXMsIHJlc3QgPSBfX3Jlc3QocGFyYW1zLCBbXCJvcHRpb25zXCJdKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmICgnbmV3RW1haWwnIGluIHJlc3QpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIG5ld0VtYWlsIHdpdGggbmV3X2VtYWlsIGluIHJlcXVlc3QgYm9keVxuICAgICAgICAgICAgICAgIGJvZHkubmV3X2VtYWlsID0gcmVzdCA9PT0gbnVsbCB8fCByZXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN0Lm5ld0VtYWlsO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBib2R5WyduZXdFbWFpbCddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL2dlbmVyYXRlX2xpbmtgLCB7XG4gICAgICAgICAgICAgICAgYm9keTogYm9keSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF9nZW5lcmF0ZUxpbmtSZXNwb25zZSxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVXNlciBBZG1pbiBBUElcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHVzZXIuXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVVc2VyKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vyc2AsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBhdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgbGlzdCBvZiB1c2Vycy5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICogQHBhcmFtIHBhcmFtcyBBbiBvYmplY3Qgd2hpY2ggc3VwcG9ydHMgYHBhZ2VgIGFuZCBgcGVyUGFnZWAgYXMgbnVtYmVycywgdG8gYWx0ZXIgdGhlIHBhZ2luYXRlZCByZXN1bHRzLlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RVc2VycyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFnaW5hdGlvbiA9IHsgbmV4dFBhZ2U6IG51bGwsIGxhc3RQYWdlOiAwLCB0b3RhbDogMCB9O1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgICAgIHBhZ2U6IChfYiA9IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsXG4gICAgICAgICAgICAgICAgICAgIHBlcl9wYWdlOiAoX2QgPSAoX2MgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGVyUGFnZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvU3RyaW5nKCkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICcnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IF9ub1Jlc29sdmVKc29uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyByZXNwb25zZS5lcnJvcjtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc3QgdG90YWwgPSAoX2UgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC10b3RhbC1jb3VudCcpKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwO1xuICAgICAgICAgICAgY29uc3QgbGlua3MgPSAoX2cgPSAoX2YgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnbGluaycpKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc3BsaXQoJywnKSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogW107XG4gICAgICAgICAgICBpZiAobGlua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxpbmtzLmZvckVhY2goKGxpbmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFnZSA9IHBhcnNlSW50KGxpbmsuc3BsaXQoJzsnKVswXS5zcGxpdCgnPScpWzFdLnN1YnN0cmluZygwLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbCA9IEpTT04ucGFyc2UobGluay5zcGxpdCgnOycpWzFdLnNwbGl0KCc9JylbMV0pO1xuICAgICAgICAgICAgICAgICAgICBwYWdpbmF0aW9uW2Ake3JlbH1QYWdlYF0gPSBwYWdlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHBhZ2luYXRpb24udG90YWwgPSBwYXJzZUludCh0b3RhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHVzZXJzKSwgcGFnaW5hdGlvbiksIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyczogW10gfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB1c2VyIGJ5IGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVpZCBUaGUgdXNlcidzIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFVzZXJCeUlkKHVpZCkge1xuICAgICAgICB2YWxpZGF0ZVVVSUQodWlkKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL3VzZXJzLyR7dWlkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHVzZXIgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBkYXRhIHlvdSB3YW50IHRvIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlVXNlckJ5SWQodWlkLCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHZhbGlkYXRlVVVJRCh1aWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQVVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHt1aWR9YCwge1xuICAgICAgICAgICAgICAgIGJvZHk6IGF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSB1c2VyLiBSZXF1aXJlcyBhIGBzZXJ2aWNlX3JvbGVgIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgdXNlciBpZCB5b3Ugd2FudCB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHNob3VsZFNvZnREZWxldGUgSWYgdHJ1ZSwgdGhlbiB0aGUgdXNlciB3aWxsIGJlIHNvZnQtZGVsZXRlZCBmcm9tIHRoZSBhdXRoIHNjaGVtYS4gU29mdCBkZWxldGlvbiBhbGxvd3MgdXNlciBpZGVudGlmaWNhdGlvbiBmcm9tIHRoZSBoYXNoZWQgdXNlciBJRCBidXQgaXMgbm90IHJldmVyc2libGUuXG4gICAgICogRGVmYXVsdHMgdG8gZmFsc2UgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZVVzZXIoaWQsIHNob3VsZFNvZnREZWxldGUgPSBmYWxzZSkge1xuICAgICAgICB2YWxpZGF0ZVVVSUQoaWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHtpZH1gLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkX3NvZnRfZGVsZXRlOiBzaG91bGRTb2Z0RGVsZXRlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IF91c2VyUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9saXN0RmFjdG9ycyhwYXJhbXMpIHtcbiAgICAgICAgdmFsaWRhdGVVVUlEKHBhcmFtcy51c2VySWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi91c2Vycy8ke3BhcmFtcy51c2VySWR9L2ZhY3RvcnNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiAoZmFjdG9ycykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGZhY3RvcnMgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZGVsZXRlRmFjdG9yKHBhcmFtcykge1xuICAgICAgICB2YWxpZGF0ZVVVSUQocGFyYW1zLnVzZXJJZCk7XG4gICAgICAgIHZhbGlkYXRlVVVJRChwYXJhbXMuaWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vYWRtaW4vdXNlcnMvJHtwYXJhbXMudXNlcklkfS9mYWN0b3JzLyR7cGFyYW1zLmlkfWAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIGFsbCBPQXV0aCBjbGllbnRzIHdpdGggb3B0aW9uYWwgcGFnaW5hdGlvbi5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBfbGlzdE9BdXRoQ2xpZW50cyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFnaW5hdGlvbiA9IHsgbmV4dFBhZ2U6IG51bGwsIGxhc3RQYWdlOiAwLCB0b3RhbDogMCB9O1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L2FkbWluL29hdXRoL2NsaWVudHNgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIG5vUmVzb2x2ZUpzb246IHRydWUsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgICAgICAgcGFnZTogKF9iID0gKF9hID0gcGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgcGVyX3BhZ2U6IChfZCA9IChfYyA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5wZXJQYWdlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9TdHJpbmcoKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJycsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX25vUmVzb2x2ZUpzb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IHJlc3BvbnNlLmVycm9yO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50cyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsID0gKF9lID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtdG90YWwtY291bnQnKSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtzID0gKF9nID0gKF9mID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2xpbmsnKSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnNwbGl0KCcsJykpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IFtdO1xuICAgICAgICAgICAgaWYgKGxpbmtzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsaW5rcy5mb3JFYWNoKChsaW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2UgPSBwYXJzZUludChsaW5rLnNwbGl0KCc7JylbMF0uc3BsaXQoJz0nKVsxXS5zdWJzdHJpbmcoMCwgMSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWwgPSBKU09OLnBhcnNlKGxpbmsuc3BsaXQoJzsnKVsxXS5zcGxpdCgnPScpWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgcGFnaW5hdGlvbltgJHtyZWx9UGFnZWBdID0gcGFnZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBwYWdpbmF0aW9uLnRvdGFsID0gcGFyc2VJbnQodG90YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjbGllbnRzKSwgcGFnaW5hdGlvbiksIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBjbGllbnRzOiBbXSB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPQXV0aCBjbGllbnQuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgX2NyZWF0ZU9BdXRoQ2xpZW50KHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL29hdXRoL2NsaWVudHNgLCB7XG4gICAgICAgICAgICAgICAgYm9keTogcGFyYW1zLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogKGNsaWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBjbGllbnQsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGRldGFpbHMgb2YgYSBzcGVjaWZpYyBPQXV0aCBjbGllbnQuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgX2dldE9BdXRoQ2xpZW50KGNsaWVudElkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9hZG1pbi9vYXV0aC9jbGllbnRzLyR7Y2xpZW50SWR9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogKGNsaWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBjbGllbnQsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIE9BdXRoIGNsaWVudC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gYSBzZXJ2ZXIuIE5ldmVyIGV4cG9zZSB5b3VyIGBzZXJ2aWNlX3JvbGVgIGtleSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBhc3luYyBfdXBkYXRlT0F1dGhDbGllbnQoY2xpZW50SWQsIHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQVVQnLCBgJHt0aGlzLnVybH0vYWRtaW4vb2F1dGgvY2xpZW50cy8ke2NsaWVudElkfWAsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiAoY2xpZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGNsaWVudCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYW4gT0F1dGggY2xpZW50LlxuICAgICAqIE9ubHkgcmVsZXZhbnQgd2hlbiB0aGUgT0F1dGggMi4xIHNlcnZlciBpcyBlbmFibGVkIGluIFN1cGFiYXNlIEF1dGguXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbiBhIHNlcnZlci4gTmV2ZXIgZXhwb3NlIHlvdXIgYHNlcnZpY2Vfcm9sZWAga2V5IGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIF9kZWxldGVPQXV0aENsaWVudChjbGllbnRJZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS9hZG1pbi9vYXV0aC9jbGllbnRzLyR7Y2xpZW50SWR9YCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdlbmVyYXRlcyB0aGUgc2VjcmV0IGZvciBhbiBPQXV0aCBjbGllbnQuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uIGEgc2VydmVyLiBOZXZlciBleHBvc2UgeW91ciBgc2VydmljZV9yb2xlYCBrZXkgaW4gdGhlIGJyb3dzZXIuXG4gICAgICovXG4gICAgYXN5bmMgX3JlZ2VuZXJhdGVPQXV0aENsaWVudFNlY3JldChjbGllbnRJZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2FkbWluL29hdXRoL2NsaWVudHMvJHtjbGllbnRJZH0vcmVnZW5lcmF0ZV9zZWNyZXRgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIHhmb3JtOiAoY2xpZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGNsaWVudCwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9R29UcnVlQWRtaW5BcGkuanMubWFwIl0sIm5hbWVzIjpbIl9fcmVzdCIsIl9nZW5lcmF0ZUxpbmtSZXNwb25zZSIsIl9ub1Jlc29sdmVKc29uUmVzcG9uc2UiLCJfcmVxdWVzdCIsIl91c2VyUmVzcG9uc2UiLCJyZXNvbHZlRmV0Y2giLCJ2YWxpZGF0ZVVVSUQiLCJTSUdOX09VVF9TQ09QRVMiLCJpc0F1dGhFcnJvciIsIkdvVHJ1ZUFkbWluQXBpIiwiY29uc3RydWN0b3IiLCJ1cmwiLCJoZWFkZXJzIiwiZmV0Y2giLCJtZmEiLCJsaXN0RmFjdG9ycyIsIl9saXN0RmFjdG9ycyIsImJpbmQiLCJkZWxldGVGYWN0b3IiLCJfZGVsZXRlRmFjdG9yIiwib2F1dGgiLCJsaXN0Q2xpZW50cyIsIl9saXN0T0F1dGhDbGllbnRzIiwiY3JlYXRlQ2xpZW50IiwiX2NyZWF0ZU9BdXRoQ2xpZW50IiwiZ2V0Q2xpZW50IiwiX2dldE9BdXRoQ2xpZW50IiwidXBkYXRlQ2xpZW50IiwiX3VwZGF0ZU9BdXRoQ2xpZW50IiwiZGVsZXRlQ2xpZW50IiwiX2RlbGV0ZU9BdXRoQ2xpZW50IiwicmVnZW5lcmF0ZUNsaWVudFNlY3JldCIsIl9yZWdlbmVyYXRlT0F1dGhDbGllbnRTZWNyZXQiLCJzaWduT3V0Iiwiand0Iiwic2NvcGUiLCJpbmRleE9mIiwiRXJyb3IiLCJqb2luIiwibm9SZXNvbHZlSnNvbiIsImRhdGEiLCJlcnJvciIsImludml0ZVVzZXJCeUVtYWlsIiwiZW1haWwiLCJvcHRpb25zIiwiYm9keSIsInJlZGlyZWN0VG8iLCJ4Zm9ybSIsInVzZXIiLCJnZW5lcmF0ZUxpbmsiLCJwYXJhbXMiLCJyZXN0IiwiT2JqZWN0IiwiYXNzaWduIiwibmV3X2VtYWlsIiwibmV3RW1haWwiLCJwcm9wZXJ0aWVzIiwiY3JlYXRlVXNlciIsImF0dHJpYnV0ZXMiLCJsaXN0VXNlcnMiLCJfYSIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiX2YiLCJfZyIsInBhZ2luYXRpb24iLCJuZXh0UGFnZSIsImxhc3RQYWdlIiwidG90YWwiLCJyZXNwb25zZSIsInF1ZXJ5IiwicGFnZSIsInRvU3RyaW5nIiwicGVyX3BhZ2UiLCJwZXJQYWdlIiwidXNlcnMiLCJqc29uIiwiZ2V0IiwibGlua3MiLCJzcGxpdCIsImxlbmd0aCIsImZvckVhY2giLCJsaW5rIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJyZWwiLCJKU09OIiwicGFyc2UiLCJnZXRVc2VyQnlJZCIsInVpZCIsInVwZGF0ZVVzZXJCeUlkIiwiZGVsZXRlVXNlciIsImlkIiwic2hvdWxkU29mdERlbGV0ZSIsInNob3VsZF9zb2Z0X2RlbGV0ZSIsInVzZXJJZCIsImZhY3RvcnMiLCJjbGllbnRzIiwiY2xpZW50IiwiY2xpZW50SWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/fetch */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_local_storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/local-storage */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/locks */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n/* harmony import */ var _lib_polyfills__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/polyfills */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\");\n/* harmony import */ var _lib_version__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/version */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n/* harmony import */ var _lib_base64url__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/base64url */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n/* harmony import */ var _lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/web3/ethereum */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js\");\n/* harmony import */ var _lib_webauthn__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/webauthn */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n(0,_lib_polyfills__WEBPACK_IMPORTED_MODULE_7__.polyfillGlobalThis)(); // Make \"globalThis\" available\nconst DEFAULT_OPTIONS = {\n    url: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.GOTRUE_URL,\n    storageKey: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.STORAGE_KEY,\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    headers: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_HEADERS,\n    flowType: \"implicit\",\n    debug: false,\n    hasCustomAuthorizationHeader: false\n};\nasync function lockNoOp(name, acquireTimeout, fn) {\n    return await fn();\n}\n/**\n * Caches JWKS values for all clients created in the same environment. This is\n * especially useful for shared-memory execution environments such as Vercel's\n * Fluid Compute, AWS Lambda or Supabase's Edge Functions. Regardless of how\n * many clients are created, if they share the same storage key they will use\n * the same JWKS cache, significantly speeding up getClaims() with asymmetric\n * JWTs.\n */ const GLOBAL_JWKS = {};\nclass GoTrueClient {\n    /**\n     * The JWKS used for verifying asymmetric JWTs\n     */ get jwks() {\n        var _a, _b;\n        return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.jwks) !== null && _b !== void 0 ? _b : {\n            keys: []\n        };\n    }\n    set jwks(value) {\n        GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), {\n            jwks: value\n        });\n    }\n    get jwks_cached_at() {\n        var _a, _b;\n        return (_b = (_a = GLOBAL_JWKS[this.storageKey]) === null || _a === void 0 ? void 0 : _a.cachedAt) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;\n    }\n    set jwks_cached_at(value) {\n        GLOBAL_JWKS[this.storageKey] = Object.assign(Object.assign({}, GLOBAL_JWKS[this.storageKey]), {\n            cachedAt: value\n        });\n    }\n    /**\n     * Create a new client for use in the browser.\n     */ constructor(options){\n        var _a, _b;\n        /**\n         * @experimental\n         */ this.userStorage = null;\n        this.memoryStorage = null;\n        this.stateChangeEmitters = new Map();\n        this.autoRefreshTicker = null;\n        this.visibilityChangedCallback = null;\n        this.refreshingDeferred = null;\n        /**\n         * Keeps track of the async client initialization.\n         * When null or not yet resolved the auth state is `unknown`\n         * Once resolved the auth state is known and it's safe to call any further client methods.\n         * Keep extra care to never reject or throw uncaught errors\n         */ this.initializePromise = null;\n        this.detectSessionInUrl = true;\n        this.hasCustomAuthorizationHeader = false;\n        this.suppressGetSessionWarning = false;\n        this.lockAcquired = false;\n        this.pendingInLock = [];\n        /**\n         * Used to broadcast state change events to other tabs listening.\n         */ this.broadcastChannel = null;\n        this.logger = console.log;\n        this.instanceID = GoTrueClient.nextInstanceID;\n        GoTrueClient.nextInstanceID += 1;\n        if (this.instanceID > 0 && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n            console.warn(\"Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.\");\n        }\n        const settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n        this.logDebugMessages = !!settings.debug;\n        if (typeof settings.debug === \"function\") {\n            this.logger = settings.debug;\n        }\n        this.persistSession = settings.persistSession;\n        this.storageKey = settings.storageKey;\n        this.autoRefreshToken = settings.autoRefreshToken;\n        this.admin = new _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({\n            url: settings.url,\n            headers: settings.headers,\n            fetch: settings.fetch\n        });\n        this.url = settings.url;\n        this.headers = settings.headers;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.resolveFetch)(settings.fetch);\n        this.lock = settings.lock || lockNoOp;\n        this.detectSessionInUrl = settings.detectSessionInUrl;\n        this.flowType = settings.flowType;\n        this.hasCustomAuthorizationHeader = settings.hasCustomAuthorizationHeader;\n        if (settings.lock) {\n            this.lock = settings.lock;\n        } else if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.locks)) {\n            this.lock = _lib_locks__WEBPACK_IMPORTED_MODULE_6__.navigatorLock;\n        } else {\n            this.lock = lockNoOp;\n        }\n        if (!this.jwks) {\n            this.jwks = {\n                keys: []\n            };\n            this.jwks_cached_at = Number.MIN_SAFE_INTEGER;\n        }\n        this.mfa = {\n            verify: this._verify.bind(this),\n            enroll: this._enroll.bind(this),\n            unenroll: this._unenroll.bind(this),\n            challenge: this._challenge.bind(this),\n            listFactors: this._listFactors.bind(this),\n            challengeAndVerify: this._challengeAndVerify.bind(this),\n            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n            webauthn: new _lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.WebAuthnApi(this)\n        };\n        this.oauth = {\n            getAuthorizationDetails: this._getAuthorizationDetails.bind(this),\n            approveAuthorization: this._approveAuthorization.bind(this),\n            denyAuthorization: this._denyAuthorization.bind(this)\n        };\n        if (this.persistSession) {\n            if (settings.storage) {\n                this.storage = settings.storage;\n            } else {\n                if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.supportsLocalStorage)()) {\n                    this.storage = globalThis.localStorage;\n                } else {\n                    this.memoryStorage = {};\n                    this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n                }\n            }\n            if (settings.userStorage) {\n                this.userStorage = settings.userStorage;\n            }\n        } else {\n            this.memoryStorage = {};\n            this.storage = (0,_lib_local_storage__WEBPACK_IMPORTED_MODULE_5__.memoryLocalStorageAdapter)(this.memoryStorage);\n        }\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n            try {\n                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n            } catch (e) {\n                console.error(\"Failed to create a new BroadcastChannel, multi-tab state changes will not be available\", e);\n            }\n            (_b = this.broadcastChannel) === null || _b === void 0 ? void 0 : _b.addEventListener(\"message\", async (event)=>{\n                this._debug(\"received broadcast notification from other tab or client\", event);\n                await this._notifyAllSubscribers(event.data.event, event.data.session, false); // broadcast = false so we don't get an endless loop of messages\n            });\n        }\n        this.initialize();\n    }\n    _debug(...args) {\n        if (this.logDebugMessages) {\n            this.logger(`GoTrueClient@${this.instanceID} (${_lib_version__WEBPACK_IMPORTED_MODULE_8__.version}) ${new Date().toISOString()}`, ...args);\n        }\n        return this;\n    }\n    /**\n     * Initializes the client session either from the url or from storage.\n     * This method is automatically called when instantiating the client, but should also be called\n     * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n     */ async initialize() {\n        if (this.initializePromise) {\n            return await this.initializePromise;\n        }\n        this.initializePromise = (async ()=>{\n            return await this._acquireLock(-1, async ()=>{\n                return await this._initialize();\n            });\n        })();\n        return await this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */ async _initialize() {\n        var _a;\n        try {\n            const params = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.parseParametersFromURL)(window.location.href);\n            let callbackUrlType = \"none\";\n            if (this._isImplicitGrantCallback(params)) {\n                callbackUrlType = \"implicit\";\n            } else if (await this._isPKCECallback(params)) {\n                callbackUrlType = \"pkce\";\n            }\n            /**\n             * Attempt to get the session from the URL only if these conditions are fulfilled\n             *\n             * Note: If the URL isn't one of the callback url types (implicit or pkce),\n             * then there could be an existing session so we don't want to prematurely remove it\n             */ if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && this.detectSessionInUrl && callbackUrlType !== \"none\") {\n                const { data, error } = await this._getSessionFromURL(params, callbackUrlType);\n                if (error) {\n                    this._debug(\"#_initialize()\", \"error detecting session from URL\", error);\n                    if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthImplicitGrantRedirectError)(error)) {\n                        const errorCode = (_a = error.details) === null || _a === void 0 ? void 0 : _a.code;\n                        if (errorCode === \"identity_already_exists\" || errorCode === \"identity_not_found\" || errorCode === \"single_identity_not_deletable\") {\n                            return {\n                                error\n                            };\n                        }\n                    }\n                    // failed login attempt via url,\n                    // remove old session as in verifyOtp, signUp and signInWith*\n                    await this._removeSession();\n                    return {\n                        error\n                    };\n                }\n                const { session, redirectType } = data;\n                this._debug(\"#_initialize()\", \"detected session in URL\", session, \"redirect type\", redirectType);\n                await this._saveSession(session);\n                setTimeout(async ()=>{\n                    if (redirectType === \"recovery\") {\n                        await this._notifyAllSubscribers(\"PASSWORD_RECOVERY\", session);\n                    } else {\n                        await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n                    }\n                }, 0);\n                return {\n                    error: null\n                };\n            }\n            // no login attempt via callback url try to recover session from storage\n            await this._recoverAndRefresh();\n            return {\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    error\n                };\n            }\n            return {\n                error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError(\"Unexpected error during initialization\", error)\n            };\n        } finally{\n            await this._handleVisibilityChange();\n            this._debug(\"#_initialize()\", \"end\");\n        }\n    }\n    /**\n     * Creates a new anonymous user.\n     *\n     * @returns A session where the is_anonymous claim in the access token JWT set to true\n     */ async signInAnonymously(credentials) {\n        var _a, _b, _c;\n        try {\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                headers: this.headers,\n                body: {\n                    data: (_b = (_a = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {},\n                    gotrue_meta_security: {\n                        captcha_token: (_c = credentials === null || credentials === void 0 ? void 0 : credentials.options) === null || _c === void 0 ? void 0 : _c.captchaToken\n                    }\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            const { data, error } = res;\n            if (error || !data) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: error\n                };\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return {\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Creates a new user.\n     *\n     * Be aware that if a user account exists in the system you may get back an\n     * error message that attempts to hide this information from the user.\n     * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */ async signUp(credentials) {\n        var _a, _b, _c;\n        try {\n            let res;\n            if (\"email\" in credentials) {\n                const { email, password, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\") {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: {\n                        email,\n                        password,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/signup`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        data: (_b = options === null || options === void 0 ? void 0 : options.data) !== null && _b !== void 0 ? _b : {},\n                        channel: (_c = options === null || options === void 0 ? void 0 : options.channel) !== null && _c !== void 0 ? _c : \"sms\",\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            } else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n            }\n            const { data, error } = res;\n            if (error || !data) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: error\n                };\n            }\n            const session = data.session;\n            const user = data.user;\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return {\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or that the\n     * email/phone and password combination is wrong or that the account can only\n     * be accessed via social login.\n     */ async signInWithPassword(credentials) {\n        try {\n            let res;\n            if (\"email\" in credentials) {\n                const { email, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        password,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword\n                });\n            } else if (\"phone\" in credentials) {\n                const { phone, password, options } = credentials;\n                res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=password`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        password,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponsePassword\n                });\n            } else {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a password\");\n            }\n            const { data, error } = res;\n            if (error) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            } else if (!data || !data.session || !data.user) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return {\n                data: Object.assign({\n                    user: data.user,\n                    session: data.session\n                }, data.weak_password ? {\n                    weakPassword: data.weak_password\n                } : null),\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     * This method supports the PKCE flow.\n     */ async signInWithOAuth(credentials) {\n        var _a, _b, _c, _d;\n        return await this._handleProviderSignIn(credentials.provider, {\n            redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n            scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n            queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n            skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect\n        });\n    }\n    /**\n     * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.\n     */ async exchangeCodeForSession(authCode) {\n        await this.initializePromise;\n        return this._acquireLock(-1, async ()=>{\n            return this._exchangeCodeForSession(authCode);\n        });\n    }\n    /**\n     * Signs in a user by verifying a message signed by the user's private key.\n     * Supports Ethereum (via Sign-In-With-Ethereum) & Solana (Sign-In-With-Solana) standards,\n     * both of which derive from the EIP-4361 standard\n     * With slight variation on Solana's side.\n     * @reference https://eips.ethereum.org/EIPS/eip-4361\n     */ async signInWithWeb3(credentials) {\n        const { chain } = credentials;\n        switch(chain){\n            case \"ethereum\":\n                return await this.signInWithEthereum(credentials);\n            case \"solana\":\n                return await this.signInWithSolana(credentials);\n            default:\n                throw new Error(`@supabase/auth-js: Unsupported chain \"${chain}\"`);\n        }\n    }\n    async signInWithEthereum(credentials) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        // TODO: flatten type\n        let message;\n        let signature;\n        if (\"message\" in credentials) {\n            message = credentials.message;\n            signature = credentials.signature;\n        } else {\n            const { chain, wallet, statement, options } = credentials;\n            let resolvedWallet;\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n                if (typeof wallet !== \"object\" || !(options === null || options === void 0 ? void 0 : options.url)) {\n                    throw new Error(\"@supabase/auth-js: Both wallet and url must be specified in non-browser environments.\");\n                }\n                resolvedWallet = wallet;\n            } else if (typeof wallet === \"object\") {\n                resolvedWallet = wallet;\n            } else {\n                const windowAny = window;\n                if (\"ethereum\" in windowAny && typeof windowAny.ethereum === \"object\" && \"request\" in windowAny.ethereum && typeof windowAny.ethereum.request === \"function\") {\n                    resolvedWallet = windowAny.ethereum;\n                } else {\n                    throw new Error(`@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.`);\n                }\n            }\n            const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);\n            const accounts = await resolvedWallet.request({\n                method: \"eth_requestAccounts\"\n            }).then((accs)=>accs).catch(()=>{\n                throw new Error(`@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid`);\n            });\n            if (!accounts || accounts.length === 0) {\n                throw new Error(`@supabase/auth-js: No accounts available. Please ensure the wallet is connected.`);\n            }\n            const address = (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.getAddress)(accounts[0]);\n            let chainId = (_b = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _b === void 0 ? void 0 : _b.chainId;\n            if (!chainId) {\n                const chainIdHex = await resolvedWallet.request({\n                    method: \"eth_chainId\"\n                });\n                chainId = (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.fromHex)(chainIdHex);\n            }\n            const siweMessage = {\n                domain: url.host,\n                address: address,\n                statement: statement,\n                uri: url.href,\n                version: \"1\",\n                chainId: chainId,\n                nonce: (_c = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _c === void 0 ? void 0 : _c.nonce,\n                issuedAt: (_e = (_d = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _d === void 0 ? void 0 : _d.issuedAt) !== null && _e !== void 0 ? _e : new Date(),\n                expirationTime: (_f = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _f === void 0 ? void 0 : _f.expirationTime,\n                notBefore: (_g = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _g === void 0 ? void 0 : _g.notBefore,\n                requestId: (_h = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _h === void 0 ? void 0 : _h.requestId,\n                resources: (_j = options === null || options === void 0 ? void 0 : options.signInWithEthereum) === null || _j === void 0 ? void 0 : _j.resources\n            };\n            message = (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.createSiweMessage)(siweMessage);\n            // Sign message\n            signature = await resolvedWallet.request({\n                method: \"personal_sign\",\n                params: [\n                    (0,_lib_web3_ethereum__WEBPACK_IMPORTED_MODULE_10__.toHex)(message),\n                    address\n                ]\n            });\n        }\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=web3`, {\n                headers: this.headers,\n                body: Object.assign({\n                    chain: \"ethereum\",\n                    message,\n                    signature\n                }, ((_k = credentials.options) === null || _k === void 0 ? void 0 : _k.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: (_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken\n                    }\n                } : null),\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return {\n                data: Object.assign({}, data),\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async signInWithSolana(credentials) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n        let message;\n        let signature;\n        if (\"message\" in credentials) {\n            message = credentials.message;\n            signature = credentials.signature;\n        } else {\n            const { chain, wallet, statement, options } = credentials;\n            let resolvedWallet;\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) {\n                if (typeof wallet !== \"object\" || !(options === null || options === void 0 ? void 0 : options.url)) {\n                    throw new Error(\"@supabase/auth-js: Both wallet and url must be specified in non-browser environments.\");\n                }\n                resolvedWallet = wallet;\n            } else if (typeof wallet === \"object\") {\n                resolvedWallet = wallet;\n            } else {\n                const windowAny = window;\n                if (\"solana\" in windowAny && typeof windowAny.solana === \"object\" && (\"signIn\" in windowAny.solana && typeof windowAny.solana.signIn === \"function\" || \"signMessage\" in windowAny.solana && typeof windowAny.solana.signMessage === \"function\")) {\n                    resolvedWallet = windowAny.solana;\n                } else {\n                    throw new Error(`@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.`);\n                }\n            }\n            const url = new URL((_a = options === null || options === void 0 ? void 0 : options.url) !== null && _a !== void 0 ? _a : window.location.href);\n            if (\"signIn\" in resolvedWallet && resolvedWallet.signIn) {\n                const output = await resolvedWallet.signIn(Object.assign(Object.assign(Object.assign({\n                    issuedAt: new Date().toISOString()\n                }, options === null || options === void 0 ? void 0 : options.signInWithSolana), {\n                    // non-overridable properties\n                    version: \"1\",\n                    domain: url.host,\n                    uri: url.href\n                }), statement ? {\n                    statement\n                } : null));\n                let outputToProcess;\n                if (Array.isArray(output) && output[0] && typeof output[0] === \"object\") {\n                    outputToProcess = output[0];\n                } else if (output && typeof output === \"object\" && \"signedMessage\" in output && \"signature\" in output) {\n                    outputToProcess = output;\n                } else {\n                    throw new Error(\"@supabase/auth-js: Wallet method signIn() returned unrecognized value\");\n                }\n                if (\"signedMessage\" in outputToProcess && \"signature\" in outputToProcess && (typeof outputToProcess.signedMessage === \"string\" || outputToProcess.signedMessage instanceof Uint8Array) && outputToProcess.signature instanceof Uint8Array) {\n                    message = typeof outputToProcess.signedMessage === \"string\" ? outputToProcess.signedMessage : new TextDecoder().decode(outputToProcess.signedMessage);\n                    signature = outputToProcess.signature;\n                } else {\n                    throw new Error(\"@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields\");\n                }\n            } else {\n                if (!(\"signMessage\" in resolvedWallet) || typeof resolvedWallet.signMessage !== \"function\" || !(\"publicKey\" in resolvedWallet) || typeof resolvedWallet !== \"object\" || !resolvedWallet.publicKey || !(\"toBase58\" in resolvedWallet.publicKey) || typeof resolvedWallet.publicKey.toBase58 !== \"function\") {\n                    throw new Error(\"@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API\");\n                }\n                message = [\n                    `${url.host} wants you to sign in with your Solana account:`,\n                    resolvedWallet.publicKey.toBase58(),\n                    ...statement ? [\n                        \"\",\n                        statement,\n                        \"\"\n                    ] : [\n                        \"\"\n                    ],\n                    \"Version: 1\",\n                    `URI: ${url.href}`,\n                    `Issued At: ${(_c = (_b = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _b === void 0 ? void 0 : _b.issuedAt) !== null && _c !== void 0 ? _c : new Date().toISOString()}`,\n                    ...((_d = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _d === void 0 ? void 0 : _d.notBefore) ? [\n                        `Not Before: ${options.signInWithSolana.notBefore}`\n                    ] : [],\n                    ...((_e = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _e === void 0 ? void 0 : _e.expirationTime) ? [\n                        `Expiration Time: ${options.signInWithSolana.expirationTime}`\n                    ] : [],\n                    ...((_f = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _f === void 0 ? void 0 : _f.chainId) ? [\n                        `Chain ID: ${options.signInWithSolana.chainId}`\n                    ] : [],\n                    ...((_g = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _g === void 0 ? void 0 : _g.nonce) ? [\n                        `Nonce: ${options.signInWithSolana.nonce}`\n                    ] : [],\n                    ...((_h = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _h === void 0 ? void 0 : _h.requestId) ? [\n                        `Request ID: ${options.signInWithSolana.requestId}`\n                    ] : [],\n                    ...((_k = (_j = options === null || options === void 0 ? void 0 : options.signInWithSolana) === null || _j === void 0 ? void 0 : _j.resources) === null || _k === void 0 ? void 0 : _k.length) ? [\n                        \"Resources\",\n                        ...options.signInWithSolana.resources.map((resource)=>`- ${resource}`)\n                    ] : []\n                ].join(\"\\n\");\n                const maybeSignature = await resolvedWallet.signMessage(new TextEncoder().encode(message), \"utf8\");\n                if (!maybeSignature || !(maybeSignature instanceof Uint8Array)) {\n                    throw new Error(\"@supabase/auth-js: Wallet signMessage() API returned an recognized value\");\n                }\n                signature = maybeSignature;\n            }\n        }\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=web3`, {\n                headers: this.headers,\n                body: Object.assign({\n                    chain: \"solana\",\n                    message,\n                    signature: (0,_lib_base64url__WEBPACK_IMPORTED_MODULE_9__.bytesToBase64URL)(signature)\n                }, ((_l = credentials.options) === null || _l === void 0 ? void 0 : _l.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: (_m = credentials.options) === null || _m === void 0 ? void 0 : _m.captchaToken\n                    }\n                } : null),\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return {\n                data: Object.assign({}, data),\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _exchangeCodeForSession(authCode) {\n        const storageItem = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        const [codeVerifier, redirectType] = (storageItem !== null && storageItem !== void 0 ? storageItem : \"\").split(\"/\");\n        try {\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=pkce`, {\n                headers: this.headers,\n                body: {\n                    auth_code: authCode,\n                    code_verifier: codeVerifier\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            if (error) {\n                throw error;\n            }\n            if (!data || !data.session || !data.user) {\n                return {\n                    data: {\n                        user: null,\n                        session: null,\n                        redirectType: null\n                    },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return {\n                data: Object.assign(Object.assign({}, data), {\n                    redirectType: redirectType !== null && redirectType !== void 0 ? redirectType : null\n                }),\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null,\n                        redirectType: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Allows signing in with an OIDC ID token. The authentication provider used\n     * should be enabled and configured.\n     */ async signInWithIdToken(credentials) {\n        try {\n            const { options, provider, token, access_token, nonce } = credentials;\n            const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=id_token`, {\n                headers: this.headers,\n                body: {\n                    provider,\n                    id_token: token,\n                    access_token,\n                    nonce,\n                    gotrue_meta_security: {\n                        captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                    }\n                },\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            const { data, error } = res;\n            if (error) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            } else if (!data || !data.session || !data.user) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()\n                };\n            }\n            if (data.session) {\n                await this._saveSession(data.session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", data.session);\n            }\n            return {\n                data,\n                error\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     *\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or, that the account\n     * can only be accessed via social login.\n     *\n     * Do note that you will need to configure a Whatsapp sender on Twilio\n     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n     * channel is not supported on other providers\n     * at this time.\n     * This method supports PKCE when an email is passed.\n     */ async signInWithOtp(credentials) {\n        var _a, _b, _c, _d, _e;\n        try {\n            if (\"email\" in credentials) {\n                const { email, options } = credentials;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\") {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                        create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            if (\"phone\" in credentials) {\n                const { phone, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/otp`, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        data: (_c = options === null || options === void 0 ? void 0 : options.data) !== null && _c !== void 0 ? _c : {},\n                        create_user: (_d = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        },\n                        channel: (_e = options === null || options === void 0 ? void 0 : options.channel) !== null && _e !== void 0 ? _e : \"sms\"\n                    }\n                });\n                return {\n                    data: {\n                        user: null,\n                        session: null,\n                        messageId: data === null || data === void 0 ? void 0 : data.message_id\n                    },\n                    error\n                };\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number.\");\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Log in a user given a User supplied OTP or TokenHash received through mobile or email.\n     */ async verifyOtp(params) {\n        var _a, _b;\n        try {\n            let redirectTo = undefined;\n            let captchaToken = undefined;\n            if (\"options\" in params) {\n                redirectTo = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo;\n                captchaToken = (_b = params.options) === null || _b === void 0 ? void 0 : _b.captchaToken;\n            }\n            const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/verify`, {\n                headers: this.headers,\n                body: Object.assign(Object.assign({}, params), {\n                    gotrue_meta_security: {\n                        captcha_token: captchaToken\n                    }\n                }),\n                redirectTo,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n            });\n            if (error) {\n                throw error;\n            }\n            if (!data) {\n                throw new Error(\"An error occurred on token verification.\");\n            }\n            const session = data.session;\n            const user = data.user;\n            if (session === null || session === void 0 ? void 0 : session.access_token) {\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(params.type == \"recovery\" ? \"PASSWORD_RECOVERY\" : \"SIGNED_IN\", session);\n            }\n            return {\n                data: {\n                    user,\n                    session\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     */ async signInWithSSO(params) {\n        var _a, _b, _c;\n        try {\n            let codeChallenge = null;\n            let codeChallengeMethod = null;\n            if (this.flowType === \"pkce\") {\n                ;\n                [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            }\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/sso`, {\n                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, \"providerId\" in params ? {\n                    provider_id: params.providerId\n                } : null), \"domain\" in params ? {\n                    domain: params.domain\n                } : null), {\n                    redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n                }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n                    gotrue_meta_security: {\n                        captcha_token: params.options.captchaToken\n                    }\n                } : null), {\n                    skip_http_redirect: true,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod\n                }),\n                headers: this.headers,\n                xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._ssoResponse\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sends a reauthentication OTP to the user's email or phone number.\n     * Requires the user to be signed-in.\n     */ async reauthenticate() {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async ()=>{\n            return await this._reauthenticate();\n        });\n    }\n    async _reauthenticate() {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) throw sessionError;\n                if (!session) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/reauthenticate`, {\n                    headers: this.headers,\n                    jwt: session.access_token\n                });\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\n     */ async resend(credentials) {\n        try {\n            const endpoint = `${this.url}/resend`;\n            if (\"email\" in credentials) {\n                const { email, type, options } = credentials;\n                const { error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", endpoint, {\n                    headers: this.headers,\n                    body: {\n                        email,\n                        type,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n                });\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            } else if (\"phone\" in credentials) {\n                const { phone, type, options } = credentials;\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", endpoint, {\n                    headers: this.headers,\n                    body: {\n                        phone,\n                        type,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    }\n                });\n                return {\n                    data: {\n                        user: null,\n                        session: null,\n                        messageId: data === null || data === void 0 ? void 0 : data.message_id\n                    },\n                    error\n                };\n            }\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidCredentialsError(\"You must provide either an email or phone number and a type\");\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     *\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     *\n     * **IMPORTANT:** This method loads values directly from the storage attached\n     * to the client. If that storage is based on request cookies for example,\n     * the values in it may not be authentic and therefore it's strongly advised\n     * against using this method and its results in such circumstances. A warning\n     * will be emitted if this is detected. Use {@link #getUser()} instead.\n     */ async getSession() {\n        await this.initializePromise;\n        const result = await this._acquireLock(-1, async ()=>{\n            return this._useSession(async (result)=>{\n                return result;\n            });\n        });\n        return result;\n    }\n    /**\n     * Acquires a global lock based on the storage key.\n     */ async _acquireLock(acquireTimeout, fn) {\n        this._debug(\"#_acquireLock\", \"begin\", acquireTimeout);\n        try {\n            if (this.lockAcquired) {\n                const last = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve();\n                const result = (async ()=>{\n                    await last;\n                    return await fn();\n                })();\n                this.pendingInLock.push((async ()=>{\n                    try {\n                        await result;\n                    } catch (e) {\n                    // we just care if it finished\n                    }\n                })());\n                return result;\n            }\n            return await this.lock(`lock:${this.storageKey}`, acquireTimeout, async ()=>{\n                this._debug(\"#_acquireLock\", \"lock acquired for storage key\", this.storageKey);\n                try {\n                    this.lockAcquired = true;\n                    const result = fn();\n                    this.pendingInLock.push((async ()=>{\n                        try {\n                            await result;\n                        } catch (e) {\n                        // we just care if it finished\n                        }\n                    })());\n                    await result;\n                    // keep draining the queue until there's nothing to wait on\n                    while(this.pendingInLock.length){\n                        const waitOn = [\n                            ...this.pendingInLock\n                        ];\n                        await Promise.all(waitOn);\n                        this.pendingInLock.splice(0, waitOn.length);\n                    }\n                    return await result;\n                } finally{\n                    this._debug(\"#_acquireLock\", \"lock released for storage key\", this.storageKey);\n                    this.lockAcquired = false;\n                }\n            });\n        } finally{\n            this._debug(\"#_acquireLock\", \"end\");\n        }\n    }\n    /**\n     * Use instead of {@link #getSession} inside the library. It is\n     * semantically usually what you want, as getting a session involves some\n     * processing afterwards that requires only one client operating on the\n     * session at once across multiple tabs or processes.\n     */ async _useSession(fn) {\n        this._debug(\"#_useSession\", \"begin\");\n        try {\n            // the use of __loadSession here is the only correct use of the function!\n            const result = await this.__loadSession();\n            return await fn(result);\n        } finally{\n            this._debug(\"#_useSession\", \"end\");\n        }\n    }\n    /**\n     * NEVER USE DIRECTLY!\n     *\n     * Always use {@link #_useSession}.\n     */ async __loadSession() {\n        this._debug(\"#__loadSession()\", \"begin\");\n        if (!this.lockAcquired) {\n            this._debug(\"#__loadSession()\", \"used outside of an acquired lock!\", new Error().stack);\n        }\n        try {\n            let currentSession = null;\n            const maybeSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);\n            this._debug(\"#getSession()\", \"session from storage\", maybeSession);\n            if (maybeSession !== null) {\n                if (this._isValidSession(maybeSession)) {\n                    currentSession = maybeSession;\n                } else {\n                    this._debug(\"#getSession()\", \"session from storage is not valid\");\n                    await this._removeSession();\n                }\n            }\n            if (!currentSession) {\n                return {\n                    data: {\n                        session: null\n                    },\n                    error: null\n                };\n            }\n            // A session is considered expired before the access token _actually_\n            // expires. When the autoRefreshToken option is off (or when the tab is\n            // in the background), very eager users of getSession() -- like\n            // realtime-js -- might send a valid JWT which will expire by the time it\n            // reaches the server.\n            const hasExpired = currentSession.expires_at ? currentSession.expires_at * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS : false;\n            this._debug(\"#__loadSession()\", `session has${hasExpired ? \"\" : \" not\"} expired`, \"expires_at\", currentSession.expires_at);\n            if (!hasExpired) {\n                if (this.userStorage) {\n                    const maybeUser = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.userStorage, this.storageKey + \"-user\");\n                    if (maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) {\n                        currentSession.user = maybeUser.user;\n                    } else {\n                        currentSession.user = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.userNotAvailableProxy)();\n                    }\n                }\n                // Wrap the user object with a warning proxy on the server\n                // This warns when properties of the user are accessed, not when session.user itself is accessed\n                if (this.storage.isServer && currentSession.user && !currentSession.user.__isUserNotAvailableProxy) {\n                    const suppressWarningRef = {\n                        value: this.suppressGetSessionWarning\n                    };\n                    currentSession.user = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.insecureUserWarningProxy)(currentSession.user, suppressWarningRef);\n                    // Update the client-level suppression flag when the proxy suppresses the warning\n                    if (suppressWarningRef.value) {\n                        this.suppressGetSessionWarning = true;\n                    }\n                }\n                return {\n                    data: {\n                        session: currentSession\n                    },\n                    error: null\n                };\n            }\n            const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);\n            if (error) {\n                return {\n                    data: {\n                        session: null\n                    },\n                    error\n                };\n            }\n            return {\n                data: {\n                    session\n                },\n                error: null\n            };\n        } finally{\n            this._debug(\"#__loadSession()\", \"end\");\n        }\n    }\n    /**\n     * Gets the current user details if there is an existing session. This method\n     * performs a network request to the Supabase Auth server, so the returned\n     * value is authentic and can be used to base authorization rules on.\n     *\n     * @param jwt Takes in an optional access token JWT. If no JWT is provided, the JWT from the current session is used.\n     */ async getUser(jwt) {\n        if (jwt) {\n            return await this._getUser(jwt);\n        }\n        await this.initializePromise;\n        const result = await this._acquireLock(-1, async ()=>{\n            return await this._getUser();\n        });\n        return result;\n    }\n    async _getUser(jwt) {\n        try {\n            if (jwt) {\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: jwt,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n            }\n            return await this._useSession(async (result)=>{\n                var _a, _b, _c;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                // returns an error if there is no access_token or custom authorization header\n                if (!((_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) && !this.hasCustomAuthorizationHeader) {\n                    return {\n                        data: {\n                            user: null\n                        },\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    };\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/user`, {\n                    headers: this.headers,\n                    jwt: (_c = (_b = data.session) === null || _b === void 0 ? void 0 : _b.access_token) !== null && _c !== void 0 ? _c : undefined,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthSessionMissingError)(error)) {\n                    // JWT contains a `session_id` which does not correspond to an active\n                    // session in the database, indicating the user is signed out.\n                    await this._removeSession();\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n                }\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Updates user data for a logged in user.\n     */ async updateUser(attributes, options = {}) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async ()=>{\n            return await this._updateUser(attributes, options);\n        });\n    }\n    async _updateUser(attributes, options = {}) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    throw sessionError;\n                }\n                if (!sessionData.session) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const session = sessionData.session;\n                let codeChallenge = null;\n                let codeChallengeMethod = null;\n                if (this.flowType === \"pkce\" && attributes.email != null) {\n                    ;\n                    [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n                }\n                const { data, error: userError } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"PUT\", `${this.url}/user`, {\n                    headers: this.headers,\n                    redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                    body: Object.assign(Object.assign({}, attributes), {\n                        code_challenge: codeChallenge,\n                        code_challenge_method: codeChallengeMethod\n                    }),\n                    jwt: session.access_token,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._userResponse\n                });\n                if (userError) throw userError;\n                session.user = data.user;\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(\"USER_UPDATED\", session);\n                return {\n                    data: {\n                        user: session.user\n                    },\n                    error: null\n                };\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */ async setSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async ()=>{\n            return await this._setSession(currentSession);\n        });\n    }\n    async _setSession(currentSession) {\n        try {\n            if (!currentSession.access_token || !currentSession.refresh_token) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            }\n            const timeNow = Date.now() / 1000;\n            let expiresAt = timeNow;\n            let hasExpired = true;\n            let session = null;\n            const { payload } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(currentSession.access_token);\n            if (payload.exp) {\n                expiresAt = payload.exp;\n                hasExpired = expiresAt <= timeNow;\n            }\n            if (hasExpired) {\n                const { data: refreshedSession, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: error\n                    };\n                }\n                if (!refreshedSession) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: null\n                    };\n                }\n                session = refreshedSession;\n            } else {\n                const { data, error } = await this._getUser(currentSession.access_token);\n                if (error) {\n                    throw error;\n                }\n                session = {\n                    access_token: currentSession.access_token,\n                    refresh_token: currentSession.refresh_token,\n                    user: data.user,\n                    token_type: \"bearer\",\n                    expires_in: expiresAt - timeNow,\n                    expires_at: expiresAt\n                };\n                await this._saveSession(session);\n                await this._notifyAllSubscribers(\"SIGNED_IN\", session);\n            }\n            return {\n                data: {\n                    user: session.user,\n                    session\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        session: null,\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */ async refreshSession(currentSession) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async ()=>{\n            return await this._refreshSession(currentSession);\n        });\n    }\n    async _refreshSession(currentSession) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a;\n                if (!currentSession) {\n                    const { data, error } = result;\n                    if (error) {\n                        throw error;\n                    }\n                    currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n                }\n                if (!(currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token)) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n                }\n                const { data: session, error } = await this._callRefreshToken(currentSession.refresh_token);\n                if (error) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: error\n                    };\n                }\n                if (!session) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: null\n                    };\n                }\n                return {\n                    data: {\n                        user: session.user,\n                        session\n                    },\n                    error: null\n                };\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        user: null,\n                        session: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets the session data from a URL string\n     */ async _getSessionFromURL(params, callbackUrlType) {\n        try {\n            if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)()) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"No browser detected.\");\n            // If there's an error in the URL, it doesn't matter what flow it is, we just return the error.\n            if (params.error || params.error_description || params.error_code) {\n                // The error class returned implies that the redirect is from an implicit grant flow\n                // but it could also be from a redirect error from a PKCE flow.\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(params.error_description || \"Error in URL with unspecified error_description\", {\n                    error: params.error || \"unspecified_error\",\n                    code: params.error_code || \"unspecified_code\"\n                });\n            }\n            // Checks for mismatches between the flowType initialised in the client and the URL parameters\n            switch(callbackUrlType){\n                case \"implicit\":\n                    if (this.flowType === \"pkce\") {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError(\"Not a valid PKCE flow url.\");\n                    }\n                    break;\n                case \"pkce\":\n                    if (this.flowType === \"implicit\") {\n                        throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"Not a valid implicit grant flow url.\");\n                    }\n                    break;\n                default:\n            }\n            // Since this is a redirect for PKCE, we attempt to retrieve the code from the URL for the code exchange\n            if (callbackUrlType === \"pkce\") {\n                this._debug(\"#_initialize()\", \"begin\", \"is PKCE flow\", true);\n                if (!params.code) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthPKCEGrantCodeExchangeError(\"No code detected.\");\n                const { data, error } = await this._exchangeCodeForSession(params.code);\n                if (error) throw error;\n                const url = new URL(window.location.href);\n                url.searchParams.delete(\"code\");\n                window.history.replaceState(window.history.state, \"\", url.toString());\n                return {\n                    data: {\n                        session: data.session,\n                        redirectType: null\n                    },\n                    error: null\n                };\n            }\n            const { provider_token, provider_refresh_token, access_token, refresh_token, expires_in, expires_at, token_type } = params;\n            if (!access_token || !expires_in || !refresh_token || !token_type) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthImplicitGrantRedirectError(\"No session defined in URL\");\n            }\n            const timeNow = Math.round(Date.now() / 1000);\n            const expiresIn = parseInt(expires_in);\n            let expiresAt = timeNow + expiresIn;\n            if (expires_at) {\n                expiresAt = parseInt(expires_at);\n            }\n            const actuallyExpiresIn = expiresAt - timeNow;\n            if (actuallyExpiresIn * 1000 <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS) {\n                console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${actuallyExpiresIn}s, should have been closer to ${expiresIn}s`);\n            }\n            const issuedAt = expiresAt - expiresIn;\n            if (timeNow - issuedAt >= 120) {\n                console.warn(\"@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale\", issuedAt, expiresAt, timeNow);\n            } else if (timeNow - issuedAt < 0) {\n                console.warn(\"@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew\", issuedAt, expiresAt, timeNow);\n            }\n            const { data, error } = await this._getUser(access_token);\n            if (error) throw error;\n            const session = {\n                provider_token,\n                provider_refresh_token,\n                access_token,\n                expires_in: expiresIn,\n                expires_at: expiresAt,\n                refresh_token,\n                token_type: token_type,\n                user: data.user\n            };\n            // Remove tokens from URL\n            window.location.hash = \"\";\n            this._debug(\"#_getSessionFromURL()\", \"clearing window.location.hash\");\n            return {\n                data: {\n                    session,\n                    redirectType: params.type\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        session: null,\n                        redirectType: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     */ _isImplicitGrantCallback(params) {\n        return Boolean(params.access_token || params.error_description);\n    }\n    /**\n     * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n     */ async _isPKCECallback(params) {\n        const currentStorageContent = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n        return !!(params.code && currentStorageContent);\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     *\n     * If using `others` scope, no `SIGNED_OUT` event is fired!\n     */ async signOut(options = {\n        scope: \"global\"\n    }) {\n        await this.initializePromise;\n        return await this._acquireLock(-1, async ()=>{\n            return await this._signOut(options);\n        });\n    }\n    async _signOut({ scope } = {\n        scope: \"global\"\n    }) {\n        return await this._useSession(async (result)=>{\n            var _a;\n            const { data, error: sessionError } = result;\n            if (sessionError) {\n                return {\n                    error: sessionError\n                };\n            }\n            const accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n            if (accessToken) {\n                const { error } = await this.admin.signOut(accessToken, scope);\n                if (error) {\n                    // ignore 404s since user might not exist anymore\n                    // ignore 401s since an invalid or expired JWT should sign out the current session\n                    if (!((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthApiError)(error) && (error.status === 404 || error.status === 401 || error.status === 403))) {\n                        return {\n                            error\n                        };\n                    }\n                }\n            }\n            if (scope !== \"others\") {\n                await this._removeSession();\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, `${this.storageKey}-code-verifier`);\n            }\n            return {\n                error: null\n            };\n        });\n    }\n    onAuthStateChange(callback) {\n        const id = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.uuid)();\n        const subscription = {\n            id,\n            callback,\n            unsubscribe: ()=>{\n                this._debug(\"#unsubscribe()\", \"state change callback with id removed\", id);\n                this.stateChangeEmitters.delete(id);\n            }\n        };\n        this._debug(\"#onAuthStateChange()\", \"registered callback with id\", id);\n        this.stateChangeEmitters.set(id, subscription);\n        (async ()=>{\n            await this.initializePromise;\n            await this._acquireLock(-1, async ()=>{\n                this._emitInitialSession(id);\n            });\n        })();\n        return {\n            data: {\n                subscription\n            }\n        };\n    }\n    async _emitInitialSession(id) {\n        return await this._useSession(async (result)=>{\n            var _a, _b;\n            try {\n                const { data: { session }, error } = result;\n                if (error) throw error;\n                await ((_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback(\"INITIAL_SESSION\", session));\n                this._debug(\"INITIAL_SESSION\", \"callback id\", id, \"session\", session);\n            } catch (err) {\n                await ((_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback(\"INITIAL_SESSION\", null));\n                this._debug(\"INITIAL_SESSION\", \"callback id\", id, \"error\", err);\n                console.error(err);\n            }\n        });\n    }\n    /**\n     * Sends a password reset request to an email address. This method supports the PKCE flow.\n     *\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */ async resetPasswordForEmail(email, options = {}) {\n        let codeChallenge = null;\n        let codeChallengeMethod = null;\n        if (this.flowType === \"pkce\") {\n            ;\n            [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey, true // isPasswordRecovery\n            );\n        }\n        try {\n            return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/recover`, {\n                body: {\n                    email,\n                    code_challenge: codeChallenge,\n                    code_challenge_method: codeChallengeMethod,\n                    gotrue_meta_security: {\n                        captcha_token: options.captchaToken\n                    }\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Gets all the identities linked to a user.\n     */ async getUserIdentities() {\n        var _a;\n        try {\n            const { data, error } = await this.getUser();\n            if (error) throw error;\n            return {\n                data: {\n                    identities: (_a = data.user.identities) !== null && _a !== void 0 ? _a : []\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async linkIdentity(credentials) {\n        if (\"token\" in credentials) {\n            return this.linkIdentityIdToken(credentials);\n        }\n        return this.linkIdentityOAuth(credentials);\n    }\n    async linkIdentityOAuth(credentials) {\n        var _a;\n        try {\n            const { data, error } = await this._useSession(async (result)=>{\n                var _a, _b, _c, _d, _e;\n                const { data, error } = result;\n                if (error) throw error;\n                const url = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, credentials.provider, {\n                    redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                    scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                    queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n                    skipBrowserRedirect: true\n                });\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", url, {\n                    headers: this.headers,\n                    jwt: (_e = (_d = data.session) === null || _d === void 0 ? void 0 : _d.access_token) !== null && _e !== void 0 ? _e : undefined\n                });\n            });\n            if (error) throw error;\n            if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !((_a = credentials.options) === null || _a === void 0 ? void 0 : _a.skipBrowserRedirect)) {\n                window.location.assign(data === null || data === void 0 ? void 0 : data.url);\n            }\n            return {\n                data: {\n                    provider: credentials.provider,\n                    url: data === null || data === void 0 ? void 0 : data.url\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        provider: credentials.provider,\n                        url: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async linkIdentityIdToken(credentials) {\n        return await this._useSession(async (result)=>{\n            var _a;\n            try {\n                const { error: sessionError, data: { session } } = result;\n                if (sessionError) throw sessionError;\n                const { options, provider, token, access_token, nonce } = credentials;\n                const res = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=id_token`, {\n                    headers: this.headers,\n                    jwt: (_a = session === null || session === void 0 ? void 0 : session.access_token) !== null && _a !== void 0 ? _a : undefined,\n                    body: {\n                        provider,\n                        id_token: token,\n                        access_token,\n                        nonce,\n                        link_identity: true,\n                        gotrue_meta_security: {\n                            captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                        }\n                    },\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n                const { data, error } = res;\n                if (error) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error\n                    };\n                } else if (!data || !data.session || !data.user) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidTokenResponseError()\n                    };\n                }\n                if (data.session) {\n                    await this._saveSession(data.session);\n                    await this._notifyAllSubscribers(\"USER_UPDATED\", data.session);\n                }\n                return {\n                    data,\n                    error\n                };\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return {\n                        data: {\n                            user: null,\n                            session: null\n                        },\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Unlinks an identity from a user by deleting it. The user will no longer be able to sign in with that identity once it's unlinked.\n     */ async unlinkIdentity(identity) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data, error } = result;\n                if (error) {\n                    throw error;\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"DELETE\", `${this.url}/user/identities/${identity.identity_id}`, {\n                    headers: this.headers,\n                    jwt: (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */ async _refreshAccessToken(refreshToken) {\n        const debugName = `#_refreshAccessToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, \"begin\");\n        try {\n            const startedAt = Date.now();\n            // will attempt to refresh the token with exponential backoff\n            return await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.retryable)(async (attempt)=>{\n                if (attempt > 0) {\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.sleep)(200 * Math.pow(2, attempt - 1)); // 200, 400, 800, ...\n                }\n                this._debug(debugName, \"refreshing attempt\", attempt);\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/token?grant_type=refresh_token`, {\n                    body: {\n                        refresh_token: refreshToken\n                    },\n                    headers: this.headers,\n                    xform: _lib_fetch__WEBPACK_IMPORTED_MODULE_3__._sessionResponse\n                });\n            }, (attempt, error)=>{\n                const nextBackOffInterval = 200 * Math.pow(2, attempt);\n                return error && (0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error) && // retryable only if the request can be sent before the backoff overflows the tick duration\n                Date.now() + nextBackOffInterval - startedAt < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS;\n            });\n        } catch (error) {\n            this._debug(debugName, \"error\", error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: {\n                        session: null,\n                        user: null\n                    },\n                    error\n                };\n            }\n            throw error;\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    _isValidSession(maybeSession) {\n        const isValidSession = typeof maybeSession === \"object\" && maybeSession !== null && \"access_token\" in maybeSession && \"refresh_token\" in maybeSession && \"expires_at\" in maybeSession;\n        return isValidSession;\n    }\n    async _handleProviderSignIn(provider, options) {\n        const url = await this._getUrlForProvider(`${this.url}/authorize`, provider, {\n            redirectTo: options.redirectTo,\n            scopes: options.scopes,\n            queryParams: options.queryParams\n        });\n        this._debug(\"#_handleProviderSignIn()\", \"provider\", provider, \"options\", options, \"url\", url);\n        // try to open on the browser\n        if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !options.skipBrowserRedirect) {\n            window.location.assign(url);\n        }\n        return {\n            data: {\n                provider,\n                url\n            },\n            error: null\n        };\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes the token\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */ async _recoverAndRefresh() {\n        var _a, _b;\n        const debugName = \"#_recoverAndRefresh()\";\n        this._debug(debugName, \"begin\");\n        try {\n            const currentSession = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey);\n            if (currentSession && this.userStorage) {\n                let maybeUser = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.userStorage, this.storageKey + \"-user\");\n                if (!this.storage.isServer && Object.is(this.storage, this.userStorage) && !maybeUser) {\n                    // storage and userStorage are the same storage medium, for example\n                    // window.localStorage if userStorage does not have the user from\n                    // storage stored, store it first thereby migrating the user object\n                    // from storage -> userStorage\n                    maybeUser = {\n                        user: currentSession.user\n                    };\n                    await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.userStorage, this.storageKey + \"-user\", maybeUser);\n                }\n                currentSession.user = (_a = maybeUser === null || maybeUser === void 0 ? void 0 : maybeUser.user) !== null && _a !== void 0 ? _a : (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.userNotAvailableProxy)();\n            } else if (currentSession && !currentSession.user) {\n                // user storage is not set, let's check if it was previously enabled so\n                // we bring back the storage as it should be\n                if (!currentSession.user) {\n                    // test if userStorage was previously enabled and the storage medium was the same, to move the user back under the same key\n                    const separateUser = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getItemAsync)(this.storage, this.storageKey + \"-user\");\n                    if (separateUser && (separateUser === null || separateUser === void 0 ? void 0 : separateUser.user)) {\n                        currentSession.user = separateUser.user;\n                        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey + \"-user\");\n                        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, currentSession);\n                    } else {\n                        currentSession.user = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.userNotAvailableProxy)();\n                    }\n                }\n            }\n            this._debug(debugName, \"session from storage\", currentSession);\n            if (!this._isValidSession(currentSession)) {\n                this._debug(debugName, \"session is not valid\");\n                if (currentSession !== null) {\n                    await this._removeSession();\n                }\n                return;\n            }\n            const expiresWithMargin = ((_b = currentSession.expires_at) !== null && _b !== void 0 ? _b : Infinity) * 1000 - Date.now() < _lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS;\n            this._debug(debugName, `session has${expiresWithMargin ? \"\" : \" not\"} expired with margin of ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.EXPIRY_MARGIN_MS}s`);\n            if (expiresWithMargin) {\n                if (this.autoRefreshToken && currentSession.refresh_token) {\n                    const { error } = await this._callRefreshToken(currentSession.refresh_token);\n                    if (error) {\n                        console.error(error);\n                        if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                            this._debug(debugName, \"refresh failed with a non-retryable error, removing the session\", error);\n                            await this._removeSession();\n                        }\n                    }\n                }\n            } else if (currentSession.user && currentSession.user.__isUserNotAvailableProxy === true) {\n                // If we have a proxy user, try to get the real user data\n                try {\n                    const { data, error: userError } = await this._getUser(currentSession.access_token);\n                    if (!userError && (data === null || data === void 0 ? void 0 : data.user)) {\n                        currentSession.user = data.user;\n                        await this._saveSession(currentSession);\n                        await this._notifyAllSubscribers(\"SIGNED_IN\", currentSession);\n                    } else {\n                        this._debug(debugName, \"could not get user data, skipping SIGNED_IN notification\");\n                    }\n                } catch (getUserError) {\n                    console.error(\"Error getting user data:\", getUserError);\n                    this._debug(debugName, \"error getting user data, skipping SIGNED_IN notification\", getUserError);\n                }\n            } else {\n                // no need to persist currentSession again, as we just loaded it from\n                // local storage; persisting it again may overwrite a value saved by\n                // another client with access to the same local storage\n                await this._notifyAllSubscribers(\"SIGNED_IN\", currentSession);\n            }\n        } catch (err) {\n            this._debug(debugName, \"error\", err);\n            console.error(err);\n            return;\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    async _callRefreshToken(refreshToken) {\n        var _a, _b;\n        if (!refreshToken) {\n            throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n        }\n        // refreshing is already in progress\n        if (this.refreshingDeferred) {\n            return this.refreshingDeferred.promise;\n        }\n        const debugName = `#_callRefreshToken(${refreshToken.substring(0, 5)}...)`;\n        this._debug(debugName, \"begin\");\n        try {\n            this.refreshingDeferred = new _lib_helpers__WEBPACK_IMPORTED_MODULE_4__.Deferred();\n            const { data, error } = await this._refreshAccessToken(refreshToken);\n            if (error) throw error;\n            if (!data.session) throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n            await this._saveSession(data.session);\n            await this._notifyAllSubscribers(\"TOKEN_REFRESHED\", data.session);\n            const result = {\n                data: data.session,\n                error: null\n            };\n            this.refreshingDeferred.resolve(result);\n            return result;\n        } catch (error) {\n            this._debug(debugName, \"error\", error);\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                const result = {\n                    data: null,\n                    error\n                };\n                if (!(0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthRetryableFetchError)(error)) {\n                    await this._removeSession();\n                }\n                (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(result);\n                return result;\n            }\n            (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(error);\n            throw error;\n        } finally{\n            this.refreshingDeferred = null;\n            this._debug(debugName, \"end\");\n        }\n    }\n    async _notifyAllSubscribers(event, session, broadcast = true) {\n        const debugName = `#_notifyAllSubscribers(${event})`;\n        this._debug(debugName, \"begin\", session, `broadcast = ${broadcast}`);\n        try {\n            if (this.broadcastChannel && broadcast) {\n                this.broadcastChannel.postMessage({\n                    event,\n                    session\n                });\n            }\n            const errors = [];\n            const promises = Array.from(this.stateChangeEmitters.values()).map(async (x)=>{\n                try {\n                    await x.callback(event, session);\n                } catch (e) {\n                    errors.push(e);\n                }\n            });\n            await Promise.all(promises);\n            if (errors.length > 0) {\n                for(let i = 0; i < errors.length; i += 1){\n                    console.error(errors[i]);\n                }\n                throw errors[0];\n            }\n        } finally{\n            this._debug(debugName, \"end\");\n        }\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */ async _saveSession(session) {\n        this._debug(\"#_saveSession()\", session);\n        // _saveSession is always called whenever a new session has been acquired\n        // so we can safely suppress the warning returned by future getSession calls\n        this.suppressGetSessionWarning = true;\n        // Create a shallow copy to work with, to avoid mutating the original session object if it's used elsewhere\n        const sessionToProcess = Object.assign({}, session);\n        const userIsProxy = sessionToProcess.user && sessionToProcess.user.__isUserNotAvailableProxy === true;\n        if (this.userStorage) {\n            if (!userIsProxy && sessionToProcess.user) {\n                // If it's a real user object, save it to userStorage.\n                await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.userStorage, this.storageKey + \"-user\", {\n                    user: sessionToProcess.user\n                });\n            } else if (userIsProxy) {\n            // If it's the proxy, it means user was not found in userStorage.\n            // We should ensure no stale user data for this key exists in userStorage if we were to save null,\n            // or simply not save the proxy. For now, we don't save the proxy here.\n            // If there's a need to clear userStorage if user becomes proxy, that logic would go here.\n            }\n            // Prepare the main session data for primary storage: remove the user property before cloning\n            // This is important because the original session.user might be the proxy\n            const mainSessionData = Object.assign({}, sessionToProcess);\n            delete mainSessionData.user; // Remove user (real or proxy) before cloning for main storage\n            const clonedMainSessionData = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.deepClone)(mainSessionData);\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, clonedMainSessionData);\n        } else {\n            // No userStorage is configured.\n            // In this case, session.user should ideally not be a proxy.\n            // If it were, structuredClone would fail. This implies an issue elsewhere if user is a proxy here\n            const clonedSession = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.deepClone)(sessionToProcess); // sessionToProcess still has its original user property\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.setItemAsync)(this.storage, this.storageKey, clonedSession);\n        }\n    }\n    async _removeSession() {\n        this._debug(\"#_removeSession()\");\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey);\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey + \"-code-verifier\");\n        await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.storage, this.storageKey + \"-user\");\n        if (this.userStorage) {\n            await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.removeItemAsync)(this.userStorage, this.storageKey + \"-user\");\n        }\n        await this._notifyAllSubscribers(\"SIGNED_OUT\", null);\n    }\n    /**\n     * Removes any registered visibilitychange callback.\n     *\n     * {@see #startAutoRefresh}\n     * {@see #stopAutoRefresh}\n     */ _removeVisibilityChangedCallback() {\n        this._debug(\"#_removeVisibilityChangedCallback()\");\n        const callback = this.visibilityChangedCallback;\n        this.visibilityChangedCallback = null;\n        try {\n            if (callback && (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n                window.removeEventListener(\"visibilitychange\", callback);\n            }\n        } catch (e) {\n            console.error(\"removing visibilitychange callback failed\", e);\n        }\n    }\n    /**\n     * This is the private implementation of {@link #startAutoRefresh}. Use this\n     * within the library.\n     */ async _startAutoRefresh() {\n        await this._stopAutoRefresh();\n        this._debug(\"#_startAutoRefresh()\");\n        const ticker = setInterval(()=>this._autoRefreshTokenTick(), _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);\n        this.autoRefreshTicker = ticker;\n        if (ticker && typeof ticker === \"object\" && typeof ticker.unref === \"function\") {\n            // ticker is a NodeJS Timeout object that has an `unref` method\n            // https://nodejs.org/api/timers.html#timeoutunref\n            // When auto refresh is used in NodeJS (like for testing) the\n            // `setInterval` is preventing the process from being marked as\n            // finished and tests run endlessly. This can be prevented by calling\n            // `unref()` on the returned object.\n            ticker.unref();\n        // @ts-expect-error TS has no context of Deno\n        } else if (typeof Deno !== \"undefined\" && typeof Deno.unrefTimer === \"function\") {\n            // similar like for NodeJS, but with the Deno API\n            // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n            // @ts-expect-error TS has no context of Deno\n            Deno.unrefTimer(ticker);\n        }\n        // run the tick immediately, but in the next pass of the event loop so that\n        // #_initialize can be allowed to complete without recursively waiting on\n        // itself\n        setTimeout(async ()=>{\n            await this.initializePromise;\n            await this._autoRefreshTokenTick();\n        }, 0);\n    }\n    /**\n     * This is the private implementation of {@link #stopAutoRefresh}. Use this\n     * within the library.\n     */ async _stopAutoRefresh() {\n        this._debug(\"#_stopAutoRefresh()\");\n        const ticker = this.autoRefreshTicker;\n        this.autoRefreshTicker = null;\n        if (ticker) {\n            clearInterval(ticker);\n        }\n    }\n    /**\n     * Starts an auto-refresh process in the background. The session is checked\n     * every few seconds. Close to the time of expiration a process is started to\n     * refresh the session. If refreshing fails it will be retried for as long as\n     * necessary.\n     *\n     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n     * to call this function, it will be called for you.\n     *\n     * On browsers the refresh process works only when the tab/window is in the\n     * foreground to conserve resources as well as prevent race conditions and\n     * flooding auth with requests. If you call this method any managed\n     * visibility change callback will be removed and you must manage visibility\n     * changes on your own.\n     *\n     * On non-browser platforms the refresh process works *continuously* in the\n     * background, which may not be desirable. You should hook into your\n     * platform's foreground indication mechanism and call these methods\n     * appropriately to conserve resources.\n     *\n     * {@see #stopAutoRefresh}\n     */ async startAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._startAutoRefresh();\n    }\n    /**\n     * Stops an active auto refresh process running in the background (if any).\n     *\n     * If you call this method any managed visibility change callback will be\n     * removed and you must manage visibility changes on your own.\n     *\n     * See {@link #startAutoRefresh} for more details.\n     */ async stopAutoRefresh() {\n        this._removeVisibilityChangedCallback();\n        await this._stopAutoRefresh();\n    }\n    /**\n     * Runs the auto refresh token tick.\n     */ async _autoRefreshTokenTick() {\n        this._debug(\"#_autoRefreshTokenTick()\", \"begin\");\n        try {\n            await this._acquireLock(0, async ()=>{\n                try {\n                    const now = Date.now();\n                    try {\n                        return await this._useSession(async (result)=>{\n                            const { data: { session } } = result;\n                            if (!session || !session.refresh_token || !session.expires_at) {\n                                this._debug(\"#_autoRefreshTokenTick()\", \"no session\");\n                                return;\n                            }\n                            // session will expire in this many ticks (or has already expired if <= 0)\n                            const expiresInTicks = Math.floor((session.expires_at * 1000 - now) / _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS);\n                            this._debug(\"#_autoRefreshTokenTick()\", `access token expires in ${expiresInTicks} ticks, a tick lasts ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_DURATION_MS}ms, refresh threshold is ${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD} ticks`);\n                            if (expiresInTicks <= _lib_constants__WEBPACK_IMPORTED_MODULE_1__.AUTO_REFRESH_TICK_THRESHOLD) {\n                                await this._callRefreshToken(session.refresh_token);\n                            }\n                        });\n                    } catch (e) {\n                        console.error(\"Auto refresh tick failed with error. This is likely a transient error.\", e);\n                    }\n                } finally{\n                    this._debug(\"#_autoRefreshTokenTick()\", \"end\");\n                }\n            });\n        } catch (e) {\n            if (e.isAcquireTimeout || e instanceof _lib_locks__WEBPACK_IMPORTED_MODULE_6__.LockAcquireTimeoutError) {\n                this._debug(\"auto refresh token tick lock not available\");\n            } else {\n                throw e;\n            }\n        }\n    }\n    /**\n     * Registers callbacks on the browser / platform, which in-turn run\n     * algorithms when the browser window/tab are in foreground. On non-browser\n     * platforms it assumes always foreground.\n     */ async _handleVisibilityChange() {\n        this._debug(\"#_handleVisibilityChange()\");\n        if (!(0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() || !(window === null || window === void 0 ? void 0 : window.addEventListener)) {\n            if (this.autoRefreshToken) {\n                // in non-browser environments the refresh token ticker runs always\n                this.startAutoRefresh();\n            }\n            return false;\n        }\n        try {\n            this.visibilityChangedCallback = async ()=>await this._onVisibilityChanged(false);\n            window === null || window === void 0 ? void 0 : window.addEventListener(\"visibilitychange\", this.visibilityChangedCallback);\n            // now immediately call the visbility changed callback to setup with the\n            // current visbility state\n            await this._onVisibilityChanged(true); // initial call\n        } catch (error) {\n            console.error(\"_handleVisibilityChange\", error);\n        }\n    }\n    /**\n     * Callback registered with `window.addEventListener('visibilitychange')`.\n     */ async _onVisibilityChanged(calledFromInitialize) {\n        const methodName = `#_onVisibilityChanged(${calledFromInitialize})`;\n        this._debug(methodName, \"visibilityState\", document.visibilityState);\n        if (document.visibilityState === \"visible\") {\n            if (this.autoRefreshToken) {\n                // in browser environments the refresh token ticker runs only on focused tabs\n                // which prevents race conditions\n                this._startAutoRefresh();\n            }\n            if (!calledFromInitialize) {\n                // called when the visibility has changed, i.e. the browser\n                // transitioned from hidden -> visible so we need to see if the session\n                // should be recovered immediately... but to do that we need to acquire\n                // the lock first asynchronously\n                await this.initializePromise;\n                await this._acquireLock(-1, async ()=>{\n                    if (document.visibilityState !== \"visible\") {\n                        this._debug(methodName, \"acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting\");\n                        // visibility has changed while waiting for the lock, abort\n                        return;\n                    }\n                    // recover the session\n                    await this._recoverAndRefresh();\n                });\n            }\n        } else if (document.visibilityState === \"hidden\") {\n            if (this.autoRefreshToken) {\n                this._stopAutoRefresh();\n            }\n        }\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */ async _getUrlForProvider(url, provider, options) {\n        const urlParams = [\n            `provider=${encodeURIComponent(provider)}`\n        ];\n        if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n            urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`);\n        }\n        if (options === null || options === void 0 ? void 0 : options.scopes) {\n            urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`);\n        }\n        if (this.flowType === \"pkce\") {\n            const [codeChallenge, codeChallengeMethod] = await (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getCodeChallengeAndMethod)(this.storage, this.storageKey);\n            const flowParams = new URLSearchParams({\n                code_challenge: `${encodeURIComponent(codeChallenge)}`,\n                code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`\n            });\n            urlParams.push(flowParams.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.queryParams) {\n            const query = new URLSearchParams(options.queryParams);\n            urlParams.push(query.toString());\n        }\n        if (options === null || options === void 0 ? void 0 : options.skipBrowserRedirect) {\n            urlParams.push(`skip_http_redirect=${options.skipBrowserRedirect}`);\n        }\n        return `${url}?${urlParams.join(\"&\")}`;\n    }\n    async _unenroll(params) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return {\n                        data: null,\n                        error: sessionError\n                    };\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"DELETE\", `${this.url}/factors/${params.factorId}`, {\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _enroll(params) {\n        try {\n            return await this._useSession(async (result)=>{\n                var _a, _b;\n                const { data: sessionData, error: sessionError } = result;\n                if (sessionError) {\n                    return {\n                        data: null,\n                        error: sessionError\n                    };\n                }\n                const body = Object.assign({\n                    friendly_name: params.friendlyName,\n                    factor_type: params.factorType\n                }, params.factorType === \"phone\" ? {\n                    phone: params.phone\n                } : params.factorType === \"totp\" ? {\n                    issuer: params.issuer\n                } : {});\n                const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/factors`, {\n                    body,\n                    headers: this.headers,\n                    jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                });\n                if (error) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                if (params.factorType === \"totp\" && data.type === \"totp\" && ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code)) {\n                    data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`;\n                }\n                return {\n                    data,\n                    error: null\n                };\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async _verify(params) {\n        return this._acquireLock(-1, async ()=>{\n            try {\n                return await this._useSession(async (result)=>{\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return {\n                            data: null,\n                            error: sessionError\n                        };\n                    }\n                    const body = Object.assign({\n                        challenge_id: params.challengeId\n                    }, \"webauthn\" in params ? {\n                        webauthn: Object.assign(Object.assign({}, params.webauthn), {\n                            credential_response: params.webauthn.type === \"create\" ? (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.serializeCredentialCreationResponse)(params.webauthn.credential_response) : (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.serializeCredentialRequestResponse)(params.webauthn.credential_response)\n                        })\n                    } : {\n                        code: params.code\n                    });\n                    const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/verify`, {\n                        body,\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                    });\n                    if (error) {\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n                    await this._saveSession(Object.assign({\n                        expires_at: Math.round(Date.now() / 1000) + data.expires_in\n                    }, data));\n                    await this._notifyAllSubscribers(\"MFA_CHALLENGE_VERIFIED\", data);\n                    return {\n                        data,\n                        error\n                    };\n                });\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    async _challenge(params) {\n        return this._acquireLock(-1, async ()=>{\n            try {\n                return await this._useSession(async (result)=>{\n                    var _a;\n                    const { data: sessionData, error: sessionError } = result;\n                    if (sessionError) {\n                        return {\n                            data: null,\n                            error: sessionError\n                        };\n                    }\n                    const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/factors/${params.factorId}/challenge`, {\n                        body: params,\n                        headers: this.headers,\n                        jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n                    });\n                    if (response.error) {\n                        return response;\n                    }\n                    const { data } = response;\n                    if (data.type !== \"webauthn\") {\n                        return {\n                            data,\n                            error: null\n                        };\n                    }\n                    switch(data.webauthn.type){\n                        case \"create\":\n                            return {\n                                data: Object.assign(Object.assign({}, data), {\n                                    webauthn: Object.assign(Object.assign({}, data.webauthn), {\n                                        credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), {\n                                            publicKey: (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.deserializeCredentialCreationOptions)(data.webauthn.credential_options.publicKey)\n                                        })\n                                    })\n                                }),\n                                error: null\n                            };\n                        case \"request\":\n                            return {\n                                data: Object.assign(Object.assign({}, data), {\n                                    webauthn: Object.assign(Object.assign({}, data.webauthn), {\n                                        credential_options: Object.assign(Object.assign({}, data.webauthn.credential_options), {\n                                            publicKey: (0,_lib_webauthn__WEBPACK_IMPORTED_MODULE_11__.deserializeCredentialRequestOptions)(data.webauthn.credential_options.publicKey)\n                                        })\n                                    })\n                                }),\n                                error: null\n                            };\n                    }\n                });\n            } catch (error) {\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#challengeAndVerify}\n     */ async _challengeAndVerify(params) {\n        // both _challenge and _verify independently acquire the lock, so no need\n        // to acquire it here\n        const { data: challengeData, error: challengeError } = await this._challenge({\n            factorId: params.factorId\n        });\n        if (challengeError) {\n            return {\n                data: null,\n                error: challengeError\n            };\n        }\n        return await this._verify({\n            factorId: params.factorId,\n            challengeId: challengeData.id,\n            code: params.code\n        });\n    }\n    /**\n     * {@see GoTrueMFAApi#listFactors}\n     */ async _listFactors() {\n        var _a;\n        // use #getUser instead of #_getUser as the former acquires a lock\n        const { data: { user }, error: userError } = await this.getUser();\n        if (userError) {\n            return {\n                data: null,\n                error: userError\n            };\n        }\n        const data = {\n            all: [],\n            phone: [],\n            totp: [],\n            webauthn: []\n        };\n        // loop over the factors ONCE\n        for (const factor of (_a = user === null || user === void 0 ? void 0 : user.factors) !== null && _a !== void 0 ? _a : []){\n            data.all.push(factor);\n            if (factor.status === \"verified\") {\n                ;\n                data[factor.factor_type].push(factor);\n            }\n        }\n        return {\n            data,\n            error: null\n        };\n    }\n    /**\n     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n     */ async _getAuthenticatorAssuranceLevel() {\n        var _a, _b;\n        const { data: { session }, error: sessionError } = await this.getSession();\n        if (sessionError) {\n            return {\n                data: null,\n                error: sessionError\n            };\n        }\n        if (!session) {\n            return {\n                data: {\n                    currentLevel: null,\n                    nextLevel: null,\n                    currentAuthenticationMethods: []\n                },\n                error: null\n            };\n        }\n        const { payload } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(session.access_token);\n        let currentLevel = null;\n        if (payload.aal) {\n            currentLevel = payload.aal;\n        }\n        let nextLevel = currentLevel;\n        const verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter((factor)=>factor.status === \"verified\")) !== null && _b !== void 0 ? _b : [];\n        if (verifiedFactors.length > 0) {\n            nextLevel = \"aal2\";\n        }\n        const currentAuthenticationMethods = payload.amr || [];\n        return {\n            data: {\n                currentLevel,\n                nextLevel,\n                currentAuthenticationMethods\n            },\n            error: null\n        };\n    }\n    /**\n     * Retrieves details about an OAuth authorization request.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     *\n     * Returns authorization details including client info, scopes, and user information.\n     * If the API returns a redirect_uri, it means consent was already given - the caller\n     * should handle the redirect manually if needed.\n     */ async _getAuthorizationDetails(authorizationId) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return {\n                        data: null,\n                        error: sessionError\n                    };\n                }\n                if (!session) {\n                    return {\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    };\n                }\n                return await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/oauth/authorizations/${authorizationId}`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Approves an OAuth authorization request.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _approveAuthorization(authorizationId, options) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return {\n                        data: null,\n                        error: sessionError\n                    };\n                }\n                if (!session) {\n                    return {\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    };\n                }\n                const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    body: {\n                        action: \"approve\"\n                    },\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n                if (response.data && response.data.redirect_url) {\n                    // Automatically redirect in browser unless skipBrowserRedirect is true\n                    if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {\n                        window.location.assign(response.data.redirect_url);\n                    }\n                }\n                return response;\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    /**\n     * Denies an OAuth authorization request.\n     * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\n     */ async _denyAuthorization(authorizationId, options) {\n        try {\n            return await this._useSession(async (result)=>{\n                const { data: { session }, error: sessionError } = result;\n                if (sessionError) {\n                    return {\n                        data: null,\n                        error: sessionError\n                    };\n                }\n                if (!session) {\n                    return {\n                        data: null,\n                        error: new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError()\n                    };\n                }\n                const response = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"POST\", `${this.url}/oauth/authorizations/${authorizationId}/consent`, {\n                    headers: this.headers,\n                    jwt: session.access_token,\n                    body: {\n                        action: \"deny\"\n                    },\n                    xform: (data)=>({\n                            data,\n                            error: null\n                        })\n                });\n                if (response.data && response.data.redirect_url) {\n                    // Automatically redirect in browser unless skipBrowserRedirect is true\n                    if ((0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.isBrowser)() && !(options === null || options === void 0 ? void 0 : options.skipBrowserRedirect)) {\n                        window.location.assign(response.data.redirect_url);\n                    }\n                }\n                return response;\n            });\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n    async fetchJwk(kid, jwks = {\n        keys: []\n    }) {\n        // try fetching from the supplied jwks\n        let jwk = jwks.keys.find((key)=>key.kid === kid);\n        if (jwk) {\n            return jwk;\n        }\n        const now = Date.now();\n        // try fetching from cache\n        jwk = this.jwks.keys.find((key)=>key.kid === kid);\n        // jwk exists and jwks isn't stale\n        if (jwk && this.jwks_cached_at + _lib_constants__WEBPACK_IMPORTED_MODULE_1__.JWKS_TTL > now) {\n            return jwk;\n        }\n        // jwk isn't cached in memory so we need to fetch it from the well-known endpoint\n        const { data, error } = await (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__._request)(this.fetch, \"GET\", `${this.url}/.well-known/jwks.json`, {\n            headers: this.headers\n        });\n        if (error) {\n            throw error;\n        }\n        if (!data.keys || data.keys.length === 0) {\n            return null;\n        }\n        this.jwks = data;\n        this.jwks_cached_at = now;\n        // Find the signing key\n        jwk = data.keys.find((key)=>key.kid === kid);\n        if (!jwk) {\n            return null;\n        }\n        return jwk;\n    }\n    /**\n     * Extracts the JWT claims present in the access token by first verifying the\n     * JWT against the server's JSON Web Key Set endpoint\n     * `/.well-known/jwks.json` which is often cached, resulting in significantly\n     * faster responses. Prefer this method over {@link #getUser} which always\n     * sends a request to the Auth server for each JWT.\n     *\n     * If the project is not using an asymmetric JWT signing key (like ECC or\n     * RSA) it always sends a request to the Auth server (similar to {@link\n     * #getUser}) to verify the JWT.\n     *\n     * @param jwt An optional specific JWT you wish to verify, not the one you\n     *            can obtain from {@link #getSession}.\n     * @param options Various additional options that allow you to customize the\n     *                behavior of this method.\n     */ async getClaims(jwt, options = {}) {\n        try {\n            let token = jwt;\n            if (!token) {\n                const { data, error } = await this.getSession();\n                if (error || !data.session) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                token = data.session.access_token;\n            }\n            const { header, payload, signature, raw: { header: rawHeader, payload: rawPayload } } = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.decodeJWT)(token);\n            if (!(options === null || options === void 0 ? void 0 : options.allowExpired)) {\n                // Reject expired JWTs should only happen if jwt argument was passed\n                (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.validateExp)(payload.exp);\n            }\n            const signingKey = !header.alg || header.alg.startsWith(\"HS\") || !header.kid || !(\"crypto\" in globalThis && \"subtle\" in globalThis.crypto) ? null : await this.fetchJwk(header.kid, (options === null || options === void 0 ? void 0 : options.keys) ? {\n                keys: options.keys\n            } : options === null || options === void 0 ? void 0 : options.jwks);\n            // If symmetric algorithm or WebCrypto API is unavailable, fallback to getUser()\n            if (!signingKey) {\n                const { error } = await this.getUser(token);\n                if (error) {\n                    throw error;\n                }\n                // getUser succeeds so the claims in the JWT can be trusted\n                return {\n                    data: {\n                        claims: payload,\n                        header,\n                        signature\n                    },\n                    error: null\n                };\n            }\n            const algorithm = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_4__.getAlgorithm)(header.alg);\n            // Convert JWK to CryptoKey\n            const publicKey = await crypto.subtle.importKey(\"jwk\", signingKey, algorithm, true, [\n                \"verify\"\n            ]);\n            // Verify the signature\n            const isValid = await crypto.subtle.verify(algorithm, publicKey, signature, (0,_lib_base64url__WEBPACK_IMPORTED_MODULE_9__.stringToUint8Array)(`${rawHeader}.${rawPayload}`));\n            if (!isValid) {\n                throw new _lib_errors__WEBPACK_IMPORTED_MODULE_2__.AuthInvalidJwtError(\"Invalid JWT signature\");\n            }\n            // If verification succeeds, decode and return claims\n            return {\n                data: {\n                    claims: payload,\n                    header,\n                    signature\n                },\n                error: null\n            };\n        } catch (error) {\n            if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            throw error;\n        }\n    }\n}\nGoTrueClient.nextInstanceID = 0;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GoTrueClient); //# sourceMappingURL=GoTrueClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvR29UcnVlQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDc0g7QUFDNEs7QUFDL047QUFDa007QUFDblA7QUFDSztBQUNoQjtBQUNiO0FBQytCO0FBQ2M7QUFDNkc7QUFDbE04QyxrRUFBa0JBLElBQUksOEJBQThCO0FBQ3BELE1BQU1hLGtCQUFrQjtJQUNwQkMsS0FBS3ZELHNEQUFVQTtJQUNmd0QsWUFBWXRELHVEQUFXQTtJQUN2QnVELGtCQUFrQjtJQUNsQkMsZ0JBQWdCO0lBQ2hCQyxvQkFBb0I7SUFDcEJDLFNBQVM5RCwyREFBZUE7SUFDeEIrRCxVQUFVO0lBQ1ZDLE9BQU87SUFDUEMsOEJBQThCO0FBQ2xDO0FBQ0EsZUFBZUMsU0FBU0MsSUFBSSxFQUFFQyxjQUFjLEVBQUVDLEVBQUU7SUFDNUMsT0FBTyxNQUFNQTtBQUNqQjtBQUNBOzs7Ozs7O0NBT0MsR0FDRCxNQUFNQyxjQUFjLENBQUM7QUFDckIsTUFBTUM7SUFDRjs7S0FFQyxHQUNELElBQUlDLE9BQU87UUFDUCxJQUFJQyxJQUFJQztRQUNSLE9BQU8sQ0FBQ0EsS0FBSyxDQUFDRCxLQUFLSCxXQUFXLENBQUMsSUFBSSxDQUFDWixVQUFVLENBQUMsTUFBTSxRQUFRZSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdELElBQUksTUFBTSxRQUFRRSxPQUFPLEtBQUssSUFBSUEsS0FBSztZQUFFQyxNQUFNLEVBQUU7UUFBQztJQUMvSTtJQUNBLElBQUlILEtBQUtJLEtBQUssRUFBRTtRQUNaTixXQUFXLENBQUMsSUFBSSxDQUFDWixVQUFVLENBQUMsR0FBR21CLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR1IsV0FBVyxDQUFDLElBQUksQ0FBQ1osVUFBVSxDQUFDLEdBQUc7WUFBRWMsTUFBTUk7UUFBTTtJQUNoSDtJQUNBLElBQUlHLGlC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T0csTUFBTSxDQUFDM1csTUFBTSxDQUFDMFcsV0FBVzNOLFdBQVd2QyxXQUFXMUssa0VBQWtCQSxDQUFDLENBQUMsRUFBRW9hLFVBQVUsQ0FBQyxFQUFFQyxXQUFXLENBQUM7WUFDM0gsSUFBSSxDQUFDVSxTQUFTO2dCQUNWLE1BQU0sSUFBSXRkLDREQUFtQkEsQ0FBQztZQUNsQztZQUNBLHFEQUFxRDtZQUNyRCxPQUFPO2dCQUNIeUksTUFBTTtvQkFDRnlVLFFBQVFuSjtvQkFDUjBJO29CQUNBeFA7Z0JBQ0o7Z0JBQ0E3RSxPQUFPO1lBQ1g7UUFDSixFQUNBLE9BQU9BLE9BQU87WUFDVixJQUFJOUgsd0RBQVdBLENBQUM4SCxRQUFRO2dCQUNwQixPQUFPO29CQUFFSyxNQUFNO29CQUFNTDtnQkFBTTtZQUMvQjtZQUNBLE1BQU1BO1FBQ1Y7SUFDSjtBQUNKO0FBQ0FwRSxhQUFhOEIsY0FBYyxHQUFHO0FBQzlCLGlFQUFlOUIsWUFBWUEsRUFBQyxDQUM1Qix3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9Hb1RydWVDbGllbnQuanM/ZjY3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR29UcnVlQWRtaW5BcGkgZnJvbSAnLi9Hb1RydWVBZG1pbkFwaSc7XG5pbXBvcnQgeyBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUywgQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xELCBERUZBVUxUX0hFQURFUlMsIEVYUElSWV9NQVJHSU5fTVMsIEdPVFJVRV9VUkwsIEpXS1NfVFRMLCBTVE9SQUdFX0tFWSwgfSBmcm9tICcuL2xpYi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yLCBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IsIEF1dGhJbnZhbGlkSnd0RXJyb3IsIEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yLCBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IsIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yLCBBdXRoVW5rbm93bkVycm9yLCBpc0F1dGhBcGlFcnJvciwgaXNBdXRoRXJyb3IsIGlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yLCBpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yLCBpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yLCB9IGZyb20gJy4vbGliL2Vycm9ycyc7XG5pbXBvcnQgeyBfcmVxdWVzdCwgX3Nlc3Npb25SZXNwb25zZSwgX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkLCBfc3NvUmVzcG9uc2UsIF91c2VyUmVzcG9uc2UsIH0gZnJvbSAnLi9saWIvZmV0Y2gnO1xuaW1wb3J0IHsgZGVjb2RlSldULCBkZWVwQ2xvbmUsIERlZmVycmVkLCBnZXRBbGdvcml0aG0sIGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QsIGdldEl0ZW1Bc3luYywgaW5zZWN1cmVVc2VyV2FybmluZ1Byb3h5LCBpc0Jyb3dzZXIsIHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwsIHJlbW92ZUl0ZW1Bc3luYywgcmVzb2x2ZUZldGNoLCByZXRyeWFibGUsIHNldEl0ZW1Bc3luYywgc2xlZXAsIHN1cHBvcnRzTG9jYWxTdG9yYWdlLCB1c2VyTm90QXZhaWxhYmxlUHJveHksIHV1aWQsIHZhbGlkYXRlRXhwLCB9IGZyb20gJy4vbGliL2hlbHBlcnMnO1xuaW1wb3J0IHsgbWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlciB9IGZyb20gJy4vbGliL2xvY2FsLXN0b3JhZ2UnO1xuaW1wb3J0IHsgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IsIG5hdmlnYXRvckxvY2sgfSBmcm9tICcuL2xpYi9sb2Nrcyc7XG5pbXBvcnQgeyBwb2x5ZmlsbEdsb2JhbFRoaXMgfSBmcm9tICcuL2xpYi9wb2x5ZmlsbHMnO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vbGliL3ZlcnNpb24nO1xuaW1wb3J0IHsgYnl0ZXNUb0Jhc2U2NFVSTCwgc3RyaW5nVG9VaW50OEFycmF5IH0gZnJvbSAnLi9saWIvYmFzZTY0dXJsJztcbmltcG9ydCB7IGNyZWF0ZVNpd2VNZXNzYWdlLCBmcm9tSGV4LCBnZXRBZGRyZXNzLCB0b0hleCwgfSBmcm9tICcuL2xpYi93ZWIzL2V0aGVyZXVtJztcbmltcG9ydCB7IGRlc2VyaWFsaXplQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucywgZGVzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMsIHNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvblJlc3BvbnNlLCBzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdFJlc3BvbnNlLCBXZWJBdXRobkFwaSwgfSBmcm9tICcuL2xpYi93ZWJhdXRobic7XG5wb2x5ZmlsbEdsb2JhbFRoaXMoKTsgLy8gTWFrZSBcImdsb2JhbFRoaXNcIiBhdmFpbGFibGVcbmNvbnN0IERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICB1cmw6IEdPVFJVRV9VUkwsXG4gICAgc3RvcmFnZUtleTogU1RPUkFHRV9LRVksXG4gICAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgICBwZXJzaXN0U2Vzc2lvbjogdHJ1ZSxcbiAgICBkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG4gICAgaGVhZGVyczogREVGQVVMVF9IRUFERVJTLFxuICAgIGZsb3dUeXBlOiAnaW1wbGljaXQnLFxuICAgIGRlYnVnOiBmYWxzZSxcbiAgICBoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyOiBmYWxzZSxcbn07XG5hc3luYyBmdW5jdGlvbiBsb2NrTm9PcChuYW1lLCBhY3F1aXJlVGltZW91dCwgZm4pIHtcbiAgICByZXR1cm4gYXdhaXQgZm4oKTtcbn1cbi8qKlxuICogQ2FjaGVzIEpXS1MgdmFsdWVzIGZvciBhbGwgY2xpZW50cyBjcmVhdGVkIGluIHRoZSBzYW1lIGVudmlyb25tZW50LiBUaGlzIGlzXG4gKiBlc3BlY2lhbGx5IHVzZWZ1bCBmb3Igc2hhcmVkLW1lbW9yeSBleGVjdXRpb24gZW52aXJvbm1lbnRzIHN1Y2ggYXMgVmVyY2VsJ3NcbiAqIEZsdWlkIENvbXB1dGUsIEFXUyBMYW1iZGEgb3IgU3VwYWJhc2UncyBFZGdlIEZ1bmN0aW9ucy4gUmVnYXJkbGVzcyBvZiBob3dcbiAqIG1hbnkgY2xpZW50cyBhcmUgY3JlYXRlZCwgaWYgdGhleSBzaGFyZSB0aGUgc2FtZSBzdG9yYWdlIGtleSB0aGV5IHdpbGwgdXNlXG4gKiB0aGUgc2FtZSBKV0tTIGNhY2hlLCBzaWduaWZpY2FudGx5IHNwZWVkaW5nIHVwIGdldENsYWltcygpIHdpdGggYXN5bW1ldHJpY1xuICogSldUcy5cbiAqL1xuY29uc3QgR0xPQkFMX0pXS1MgPSB7fTtcbmNsYXNzIEdvVHJ1ZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogVGhlIEpXS1MgdXNlZCBmb3IgdmVyaWZ5aW5nIGFzeW1tZXRyaWMgSldUc1xuICAgICAqL1xuICAgIGdldCBqd2tzKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gR0xPQkFMX0pXS1NbdGhpcy5zdG9yYWdlS2V5XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmp3a3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHsga2V5czogW10gfTtcbiAgICB9XG4gICAgc2V0IGp3a3ModmFsdWUpIHtcbiAgICAgICAgR0xPQkFMX0pXS1NbdGhpcy5zdG9yYWdlS2V5XSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgR0xPQkFMX0pXS1NbdGhpcy5zdG9yYWdlS2V5XSksIHsgandrczogdmFsdWUgfSk7XG4gICAgfVxuICAgIGdldCBqd2tzX2NhY2hlZF9hdCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IEdMT0JBTF9KV0tTW3RoaXMuc3RvcmFnZUtleV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWNoZWRBdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVI7XG4gICAgfVxuICAgIHNldCBqd2tzX2NhY2hlZF9hdCh2YWx1ZSkge1xuICAgICAgICBHTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBHTE9CQUxfSldLU1t0aGlzLnN0b3JhZ2VLZXldKSwgeyBjYWNoZWRBdDogdmFsdWUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBjbGllbnQgZm9yIHVzZSBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVzZXJTdG9yYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmF1dG9SZWZyZXNoVGlja2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGFzeW5jIGNsaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgICogV2hlbiBudWxsIG9yIG5vdCB5ZXQgcmVzb2x2ZWQgdGhlIGF1dGggc3RhdGUgaXMgYHVua25vd25gXG4gICAgICAgICAqIE9uY2UgcmVzb2x2ZWQgdGhlIGF1dGggc3RhdGUgaXMga25vd24gYW5kIGl0J3Mgc2FmZSB0byBjYWxsIGFueSBmdXJ0aGVyIGNsaWVudCBtZXRob2RzLlxuICAgICAgICAgKiBLZWVwIGV4dHJhIGNhcmUgdG8gbmV2ZXIgcmVqZWN0IG9yIHRocm93IHVuY2F1Z2h0IGVycm9yc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbml0aWFsaXplUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGV0ZWN0U2Vzc2lvbkluVXJsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvY2tBY3F1aXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2sgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgdG8gYnJvYWRjYXN0IHN0YXRlIGNoYW5nZSBldmVudHMgdG8gb3RoZXIgdGFicyBsaXN0ZW5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJyb2FkY2FzdENoYW5uZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGNvbnNvbGUubG9nO1xuICAgICAgICB0aGlzLmluc3RhbmNlSUQgPSBHb1RydWVDbGllbnQubmV4dEluc3RhbmNlSUQ7XG4gICAgICAgIEdvVHJ1ZUNsaWVudC5uZXh0SW5zdGFuY2VJRCArPSAxO1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZUlEID4gMCAmJiBpc0Jyb3dzZXIoKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdNdWx0aXBsZSBHb1RydWVDbGllbnQgaW5zdGFuY2VzIGRldGVjdGVkIGluIHRoZSBzYW1lIGJyb3dzZXIgY29udGV4dC4gSXQgaXMgbm90IGFuIGVycm9yLCBidXQgdGhpcyBzaG91bGQgYmUgYXZvaWRlZCBhcyBpdCBtYXkgcHJvZHVjZSB1bmRlZmluZWQgYmVoYXZpb3Igd2hlbiB1c2VkIGNvbmN1cnJlbnRseSB1bmRlciB0aGUgc2FtZSBzdG9yYWdlIGtleS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TKSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMubG9nRGVidWdNZXNzYWdlcyA9ICEhc2V0dGluZ3MuZGVidWc7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuZGVidWcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gc2V0dGluZ3MuZGVidWc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZXJzaXN0U2Vzc2lvbiA9IHNldHRpbmdzLnBlcnNpc3RTZXNzaW9uO1xuICAgICAgICB0aGlzLnN0b3JhZ2VLZXkgPSBzZXR0aW5ncy5zdG9yYWdlS2V5O1xuICAgICAgICB0aGlzLmF1dG9SZWZyZXNoVG9rZW4gPSBzZXR0aW5ncy5hdXRvUmVmcmVzaFRva2VuO1xuICAgICAgICB0aGlzLmFkbWluID0gbmV3IEdvVHJ1ZUFkbWluQXBpKHtcbiAgICAgICAgICAgIHVybDogc2V0dGluZ3MudXJsLFxuICAgICAgICAgICAgaGVhZGVyczogc2V0dGluZ3MuaGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoOiBzZXR0aW5ncy5mZXRjaCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXJsID0gc2V0dGluZ3MudXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBzZXR0aW5ncy5oZWFkZXJzO1xuICAgICAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKHNldHRpbmdzLmZldGNoKTtcbiAgICAgICAgdGhpcy5sb2NrID0gc2V0dGluZ3MubG9jayB8fCBsb2NrTm9PcDtcbiAgICAgICAgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgPSBzZXR0aW5ncy5kZXRlY3RTZXNzaW9uSW5Vcmw7XG4gICAgICAgIHRoaXMuZmxvd1R5cGUgPSBzZXR0aW5ncy5mbG93VHlwZTtcbiAgICAgICAgdGhpcy5oYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyID0gc2V0dGluZ3MuaGFzQ3VzdG9tQXV0aG9yaXphdGlvbkhlYWRlcjtcbiAgICAgICAgaWYgKHNldHRpbmdzLmxvY2spIHtcbiAgICAgICAgICAgIHRoaXMubG9jayA9IHNldHRpbmdzLmxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCcm93c2VyKCkgJiYgKChfYSA9IGdsb2JhbFRoaXMgPT09IG51bGwgfHwgZ2xvYmFsVGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2xvYmFsVGhpcy5uYXZpZ2F0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NrcykpIHtcbiAgICAgICAgICAgIHRoaXMubG9jayA9IG5hdmlnYXRvckxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvY2sgPSBsb2NrTm9PcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuandrcykge1xuICAgICAgICAgICAgdGhpcy5qd2tzID0geyBrZXlzOiBbXSB9O1xuICAgICAgICAgICAgdGhpcy5qd2tzX2NhY2hlZF9hdCA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWZhID0ge1xuICAgICAgICAgICAgdmVyaWZ5OiB0aGlzLl92ZXJpZnkuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGVucm9sbDogdGhpcy5fZW5yb2xsLmJpbmQodGhpcyksXG4gICAgICAgICAgICB1bmVucm9sbDogdGhpcy5fdW5lbnJvbGwuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNoYWxsZW5nZTogdGhpcy5fY2hhbGxlbmdlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBsaXN0RmFjdG9yczogdGhpcy5fbGlzdEZhY3RvcnMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNoYWxsZW5nZUFuZFZlcmlmeTogdGhpcy5fY2hhbGxlbmdlQW5kVmVyaWZ5LmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWw6IHRoaXMuX2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgd2ViYXV0aG46IG5ldyBXZWJBdXRobkFwaSh0aGlzKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vYXV0aCA9IHtcbiAgICAgICAgICAgIGdldEF1dGhvcml6YXRpb25EZXRhaWxzOiB0aGlzLl9nZXRBdXRob3JpemF0aW9uRGV0YWlscy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgYXBwcm92ZUF1dGhvcml6YXRpb246IHRoaXMuX2FwcHJvdmVBdXRob3JpemF0aW9uLmJpbmQodGhpcyksXG4gICAgICAgICAgICBkZW55QXV0aG9yaXphdGlvbjogdGhpcy5fZGVueUF1dGhvcml6YXRpb24uYmluZCh0aGlzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucGVyc2lzdFNlc3Npb24pIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlID0gc2V0dGluZ3Muc3RvcmFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0c0xvY2FsU3RvcmFnZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1vcnlTdG9yYWdlID0ge307XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIodGhpcy5tZW1vcnlTdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MudXNlclN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJTdG9yYWdlID0gc2V0dGluZ3MudXNlclN0b3JhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lbW9yeVN0b3JhZ2UgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IG1lbW9yeUxvY2FsU3RvcmFnZUFkYXB0ZXIodGhpcy5tZW1vcnlTdG9yYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgZ2xvYmFsVGhpcy5Ccm9hZGNhc3RDaGFubmVsICYmIHRoaXMucGVyc2lzdFNlc3Npb24gJiYgdGhpcy5zdG9yYWdlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCA9IG5ldyBnbG9iYWxUaGlzLkJyb2FkY2FzdENoYW5uZWwodGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBhIG5ldyBCcm9hZGNhc3RDaGFubmVsLCBtdWx0aS10YWIgc3RhdGUgY2hhbmdlcyB3aWxsIG5vdCBiZSBhdmFpbGFibGUnLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IHRoaXMuYnJvYWRjYXN0Q2hhbm5lbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygncmVjZWl2ZWQgYnJvYWRjYXN0IG5vdGlmaWNhdGlvbiBmcm9tIG90aGVyIHRhYiBvciBjbGllbnQnLCBldmVudCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoZXZlbnQuZGF0YS5ldmVudCwgZXZlbnQuZGF0YS5zZXNzaW9uLCBmYWxzZSk7IC8vIGJyb2FkY2FzdCA9IGZhbHNlIHNvIHdlIGRvbid0IGdldCBhbiBlbmRsZXNzIGxvb3Agb2YgbWVzc2FnZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICBfZGVidWcoLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5sb2dEZWJ1Z01lc3NhZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlcihgR29UcnVlQ2xpZW50QCR7dGhpcy5pbnN0YW5jZUlEfSAoJHt2ZXJzaW9ufSkgJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YCwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBjbGllbnQgc2Vzc2lvbiBlaXRoZXIgZnJvbSB0aGUgdXJsIG9yIGZyb20gc3RvcmFnZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuIGluc3RhbnRpYXRpbmcgdGhlIGNsaWVudCwgYnV0IHNob3VsZCBhbHNvIGJlIGNhbGxlZFxuICAgICAqIG1hbnVhbGx5IHdoZW4gY2hlY2tpbmcgZm9yIGFuIGVycm9yIGZyb20gYW4gYXV0aCByZWRpcmVjdCAob2F1dGgsIG1hZ2ljbGluaywgcGFzc3dvcmQgcmVjb3ZlcnksIGV0YykuXG4gICAgICovXG4gICAgYXN5bmMgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZVByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVByb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSU1QT1JUQU5UOlxuICAgICAqIDEuIE5ldmVyIHRocm93IGluIHRoaXMgbWV0aG9kLCBhcyBpdCBpcyBjYWxsZWQgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAgKiAyLiBOZXZlciByZXR1cm4gYSBzZXNzaW9uIGZyb20gdGhpcyBtZXRob2QgYXMgaXQgd291bGQgYmUgY2FjaGVkIG92ZXJcbiAgICAgKiAgICB0aGUgd2hvbGUgbGlmZXRpbWUgb2YgdGhlIGNsaWVudFxuICAgICAqL1xuICAgIGFzeW5jIF9pbml0aWFsaXplKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBwYXJzZVBhcmFtZXRlcnNGcm9tVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIGxldCBjYWxsYmFja1VybFR5cGUgPSAnbm9uZSc7XG4gICAgICAgICAgICBpZiAodGhpcy5faXNJbXBsaWNpdEdyYW50Q2FsbGJhY2socGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrVXJsVHlwZSA9ICdpbXBsaWNpdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhd2FpdCB0aGlzLl9pc1BLQ0VDYWxsYmFjayhwYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tVcmxUeXBlID0gJ3BrY2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBdHRlbXB0IHRvIGdldCB0aGUgc2Vzc2lvbiBmcm9tIHRoZSBVUkwgb25seSBpZiB0aGVzZSBjb25kaXRpb25zIGFyZSBmdWxmaWxsZWRcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBOb3RlOiBJZiB0aGUgVVJMIGlzbid0IG9uZSBvZiB0aGUgY2FsbGJhY2sgdXJsIHR5cGVzIChpbXBsaWNpdCBvciBwa2NlKSxcbiAgICAgICAgICAgICAqIHRoZW4gdGhlcmUgY291bGQgYmUgYW4gZXhpc3Rpbmcgc2Vzc2lvbiBzbyB3ZSBkb24ndCB3YW50IHRvIHByZW1hdHVyZWx5IHJlbW92ZSBpdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgdGhpcy5kZXRlY3RTZXNzaW9uSW5VcmwgJiYgY2FsbGJhY2tVcmxUeXBlICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9nZXRTZXNzaW9uRnJvbVVSTChwYXJhbXMsIGNhbGxiYWNrVXJsVHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdlcnJvciBkZXRlY3Rpbmcgc2Vzc2lvbiBmcm9tIFVSTCcsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gKF9hID0gZXJyb3IuZGV0YWlscykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDb2RlID09PSAnaWRlbnRpdHlfYWxyZWFkeV9leGlzdHMnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlID09PSAnaWRlbnRpdHlfbm90X2ZvdW5kJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gJ3NpbmdsZV9pZGVudGl0eV9ub3RfZGVsZXRhYmxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gZmFpbGVkIGxvZ2luIGF0dGVtcHQgdmlhIHVybCxcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG9sZCBzZXNzaW9uIGFzIGluIHZlcmlmeU90cCwgc2lnblVwIGFuZCBzaWduSW5XaXRoKlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2Vzc2lvbiwgcmVkaXJlY3RUeXBlIH0gPSBkYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdkZXRlY3RlZCBzZXNzaW9uIGluIFVSTCcsIHNlc3Npb24sICdyZWRpcmVjdCB0eXBlJywgcmVkaXJlY3RUeXBlKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZGlyZWN0VHlwZSA9PT0gJ3JlY292ZXJ5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1BBU1NXT1JEX1JFQ09WRVJZJywgc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm8gbG9naW4gYXR0ZW1wdCB2aWEgY2FsbGJhY2sgdXJsIHRyeSB0byByZWNvdmVyIHNlc3Npb24gZnJvbSBzdG9yYWdlXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhVbmtub3duRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgZHVyaW5nIGluaXRpYWxpemF0aW9uJywgZXJyb3IpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2hhbmRsZVZpc2liaWxpdHlDaGFuZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2luaXRpYWxpemUoKScsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGFub255bW91cyB1c2VyLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzZXNzaW9uIHdoZXJlIHRoZSBpc19hbm9ueW1vdXMgY2xhaW0gaW4gdGhlIGFjY2VzcyB0b2tlbiBKV1Qgc2V0IHRvIHRydWVcbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5Bbm9ueW1vdXNseShjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2IgPSAoX2EgPSBjcmVkZW50aWFscyA9PT0gbnVsbCB8fCBjcmVkZW50aWFscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9LFxuICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiAoX2MgPSBjcmVkZW50aWFscyA9PT0gbnVsbCB8fCBjcmVkZW50aWFscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSBkYXRhLnNlc3Npb247XG4gICAgICAgICAgICBjb25zdCB1c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHVzZXIuXG4gICAgICpcbiAgICAgKiBCZSBhd2FyZSB0aGF0IGlmIGEgdXNlciBhY2NvdW50IGV4aXN0cyBpbiB0aGUgc3lzdGVtIHlvdSBtYXkgZ2V0IGJhY2sgYW5cbiAgICAgKiBlcnJvciBtZXNzYWdlIHRoYXQgYXR0ZW1wdHMgdG8gaGlkZSB0aGlzIGluZm9ybWF0aW9uIGZyb20gdGhlIHVzZXIuXG4gICAgICogVGhpcyBtZXRob2QgaGFzIHN1cHBvcnQgZm9yIFBLQ0UgdmlhIGVtYWlsIHNpZ251cHMuIFRoZSBQS0NFIGZsb3cgY2Fubm90IGJlIHVzZWQgd2hlbiBhdXRvY29uZmlybSBpcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBsb2dnZWQtaW4gc2Vzc2lvbiBpZiB0aGUgc2VydmVyIGhhcyBcImF1dG9jb25maXJtXCIgT05cbiAgICAgKiBAcmV0dXJucyBBIHVzZXIgaWYgdGhlIHNlcnZlciBoYXMgXCJhdXRvY29uZmlybVwiIE9GRlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25VcChjcmVkZW50aWFscykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXM7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dUeXBlID09PSAncGtjZScpIHtcbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vc2lnbnVwYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5lbWFpbFJlZGlyZWN0VG8sXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwaG9uZSwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3NpZ251cGAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwaG9uZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3N3b3JkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNoYW5uZWwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICdzbXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSBwYXNzd29yZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzO1xuICAgICAgICAgICAgaWYgKGVycm9yIHx8ICFkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGRhdGEuc2Vzc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXIsIHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhbiBleGlzdGluZyB1c2VyIHdpdGggYW4gZW1haWwgYW5kIHBhc3N3b3JkIG9yIHBob25lIGFuZCBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEJlIGF3YXJlIHRoYXQgeW91IG1heSBnZXQgYmFjayBhbiBlcnJvciBtZXNzYWdlIHRoYXQgd2lsbCBub3QgZGlzdGluZ3Vpc2hcbiAgICAgKiBiZXR3ZWVuIHRoZSBjYXNlcyB3aGVyZSB0aGUgYWNjb3VudCBkb2VzIG5vdCBleGlzdCBvciB0aGF0IHRoZVxuICAgICAqIGVtYWlsL3Bob25lIGFuZCBwYXNzd29yZCBjb21iaW5hdGlvbiBpcyB3cm9uZyBvciB0aGF0IHRoZSBhY2NvdW50IGNhbiBvbmx5XG4gICAgICogYmUgYWNjZXNzZWQgdmlhIHNvY2lhbCBsb2dpbi5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoUGFzc3dvcmQoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCByZXM7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIHBhc3N3b3JkLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPXBhc3N3b3JkYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlUGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwaG9uZSwgcGFzc3dvcmQsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIHJlcyA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cGFzc3dvcmRgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgZWl0aGVyIGFuIGVtYWlsIG9yIHBob25lIG51bWJlciBhbmQgYSBwYXNzd29yZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZGF0YSB8fCAhZGF0YS5zZXNzaW9uIHx8ICFkYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3I6IG5ldyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvcigpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHVzZXI6IGRhdGEudXNlciwgc2Vzc2lvbjogZGF0YS5zZXNzaW9uIH0sIChkYXRhLndlYWtfcGFzc3dvcmQgPyB7IHdlYWtQYXNzd29yZDogZGF0YS53ZWFrX3Bhc3N3b3JkIH0gOiBudWxsKSksXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nIGluIGFuIGV4aXN0aW5nIHVzZXIgdmlhIGEgdGhpcmQtcGFydHkgcHJvdmlkZXIuXG4gICAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgdGhlIFBLQ0UgZmxvdy5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoT0F1dGgoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5faGFuZGxlUHJvdmlkZXJTaWduSW4oY3JlZGVudGlhbHMucHJvdmlkZXIsIHtcbiAgICAgICAgICAgIHJlZGlyZWN0VG86IChfYSA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgc2NvcGVzOiAoX2IgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2NvcGVzLFxuICAgICAgICAgICAgcXVlcnlQYXJhbXM6IChfYyA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5xdWVyeVBhcmFtcyxcbiAgICAgICAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q6IChfZCA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5za2lwQnJvd3NlclJlZGlyZWN0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nIGluIGFuIGV4aXN0aW5nIHVzZXIgYnkgZXhjaGFuZ2luZyBhbiBBdXRoIENvZGUgaXNzdWVkIGR1cmluZyB0aGUgUEtDRSBmbG93LlxuICAgICAqL1xuICAgIGFzeW5jIGV4Y2hhbmdlQ29kZUZvclNlc3Npb24oYXV0aENvZGUpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihhdXRoQ29kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyBpbiBhIHVzZXIgYnkgdmVyaWZ5aW5nIGEgbWVzc2FnZSBzaWduZWQgYnkgdGhlIHVzZXIncyBwcml2YXRlIGtleS5cbiAgICAgKiBTdXBwb3J0cyBFdGhlcmV1bSAodmlhIFNpZ24tSW4tV2l0aC1FdGhlcmV1bSkgJiBTb2xhbmEgKFNpZ24tSW4tV2l0aC1Tb2xhbmEpIHN0YW5kYXJkcyxcbiAgICAgKiBib3RoIG9mIHdoaWNoIGRlcml2ZSBmcm9tIHRoZSBFSVAtNDM2MSBzdGFuZGFyZFxuICAgICAqIFdpdGggc2xpZ2h0IHZhcmlhdGlvbiBvbiBTb2xhbmEncyBzaWRlLlxuICAgICAqIEByZWZlcmVuY2UgaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC00MzYxXG4gICAgICovXG4gICAgYXN5bmMgc2lnbkluV2l0aFdlYjMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgeyBjaGFpbiB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgIHN3aXRjaCAoY2hhaW4pIHtcbiAgICAgICAgICAgIGNhc2UgJ2V0aGVyZXVtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zaWduSW5XaXRoRXRoZXJldW0oY3JlZGVudGlhbHMpO1xuICAgICAgICAgICAgY2FzZSAnc29sYW5hJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5zaWduSW5XaXRoU29sYW5hKGNyZWRlbnRpYWxzKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogVW5zdXBwb3J0ZWQgY2hhaW4gXCIke2NoYWlufVwiYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2lnbkluV2l0aEV0aGVyZXVtKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaywgX2w7XG4gICAgICAgIC8vIFRPRE86IGZsYXR0ZW4gdHlwZVxuICAgICAgICBsZXQgbWVzc2FnZTtcbiAgICAgICAgbGV0IHNpZ25hdHVyZTtcbiAgICAgICAgaWYgKCdtZXNzYWdlJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGNyZWRlbnRpYWxzLm1lc3NhZ2U7XG4gICAgICAgICAgICBzaWduYXR1cmUgPSBjcmVkZW50aWFscy5zaWduYXR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IGNoYWluLCB3YWxsZXQsIHN0YXRlbWVudCwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRXYWxsZXQ7XG4gICAgICAgICAgICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3YWxsZXQgIT09ICdvYmplY3QnIHx8ICEob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVybCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAc3VwYWJhc2UvYXV0aC1qczogQm90aCB3YWxsZXQgYW5kIHVybCBtdXN0IGJlIHNwZWNpZmllZCBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmVkV2FsbGV0ID0gd2FsbGV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdhbGxldCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFdhbGxldCA9IHdhbGxldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpbmRvd0FueSA9IHdpbmRvdztcbiAgICAgICAgICAgICAgICBpZiAoJ2V0aGVyZXVtJyBpbiB3aW5kb3dBbnkgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvd0FueS5ldGhlcmV1bSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICAgICAgJ3JlcXVlc3QnIGluIHdpbmRvd0FueS5ldGhlcmV1bSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygd2luZG93QW55LmV0aGVyZXVtLnJlcXVlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3aW5kb3dBbnkuZXRoZXJldW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBObyBjb21wYXRpYmxlIEV0aGVyZXVtIHdhbGxldCBpbnRlcmZhY2Ugb24gdGhlIHdpbmRvdyBvYmplY3QgKHdpbmRvdy5ldGhlcmV1bSkgZGV0ZWN0ZWQuIE1ha2Ugc3VyZSB0aGUgdXNlciBhbHJlYWR5IGhhcyBhIHdhbGxldCBpbnN0YWxsZWQgYW5kIGNvbm5lY3RlZCBmb3IgdGhpcyBhcHAuIFByZWZlciBwYXNzaW5nIHRoZSB3YWxsZXQgaW50ZXJmYWNlIG9iamVjdCBkaXJlY3RseSB0byBzaWduSW5XaXRoV2ViMyh7IGNoYWluOiAnZXRoZXJldW0nLCB3YWxsZXQ6IHJlc29sdmVkVXNlcldhbGxldCB9KSBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSBhd2FpdCByZXNvbHZlZFdhbGxldFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfcmVxdWVzdEFjY291bnRzJyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGFjY3MpID0+IGFjY3MpXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBXYWxsZXQgbWV0aG9kIGV0aF9yZXF1ZXN0QWNjb3VudHMgaXMgbWlzc2luZyBvciBpbnZhbGlkYCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghYWNjb3VudHMgfHwgYWNjb3VudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogTm8gYWNjb3VudHMgYXZhaWxhYmxlLiBQbGVhc2UgZW5zdXJlIHRoZSB3YWxsZXQgaXMgY29ubmVjdGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IGdldEFkZHJlc3MoYWNjb3VudHNbMF0pO1xuICAgICAgICAgICAgbGV0IGNoYWluSWQgPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aEV0aGVyZXVtKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2hhaW5JZDtcbiAgICAgICAgICAgIGlmICghY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluSWRIZXggPSBhd2FpdCByZXNvbHZlZFdhbGxldC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2NoYWluSWQnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBmcm9tSGV4KGNoYWluSWRIZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2l3ZU1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgZG9tYWluOiB1cmwuaG9zdCxcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN0YXRlbWVudDogc3RhdGVtZW50LFxuICAgICAgICAgICAgICAgIHVyaTogdXJsLmhyZWYsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogJzEnLFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IGNoYWluSWQsXG4gICAgICAgICAgICAgICAgbm9uY2U6IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoRXRoZXJldW0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5ub25jZSxcbiAgICAgICAgICAgICAgICBpc3N1ZWRBdDogKF9lID0gKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmlzc3VlZEF0KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgICAgICAgIGV4cGlyYXRpb25UaW1lOiAoX2YgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aEV0aGVyZXVtKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuZXhwaXJhdGlvblRpbWUsXG4gICAgICAgICAgICAgICAgbm90QmVmb3JlOiAoX2cgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aEV0aGVyZXVtKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cubm90QmVmb3JlLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogKF9oID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhFdGhlcmV1bSkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLnJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICByZXNvdXJjZXM6IChfaiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoRXRoZXJldW0pID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5yZXNvdXJjZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWVzc2FnZSA9IGNyZWF0ZVNpd2VNZXNzYWdlKHNpd2VNZXNzYWdlKTtcbiAgICAgICAgICAgIC8vIFNpZ24gbWVzc2FnZVxuICAgICAgICAgICAgc2lnbmF0dXJlID0gKGF3YWl0IHJlc29sdmVkV2FsbGV0LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ3BlcnNvbmFsX3NpZ24nLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW3RvSGV4KG1lc3NhZ2UpLCBhZGRyZXNzXSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT13ZWIzYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiBPYmplY3QuYXNzaWduKHsgY2hhaW46ICdldGhlcmV1bScsIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSB9LCAoKChfayA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5jYXB0Y2hhVG9rZW4pXG4gICAgICAgICAgICAgICAgICAgID8geyBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiAoX2wgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wuY2FwdGNoYVRva2VuIH0gfVxuICAgICAgICAgICAgICAgICAgICA6IG51bGwpKSxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGEgfHwgIWRhdGEuc2Vzc2lvbiB8fCAhZGF0YS51c2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNpZ25JbldpdGhTb2xhbmEoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX207XG4gICAgICAgIGxldCBtZXNzYWdlO1xuICAgICAgICBsZXQgc2lnbmF0dXJlO1xuICAgICAgICBpZiAoJ21lc3NhZ2UnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gY3JlZGVudGlhbHMubWVzc2FnZTtcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IGNyZWRlbnRpYWxzLnNpZ25hdHVyZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW4sIHdhbGxldCwgc3RhdGVtZW50LCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgIGxldCByZXNvbHZlZFdhbGxldDtcbiAgICAgICAgICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdhbGxldCAhPT0gJ29iamVjdCcgfHwgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudXJsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0BzdXBhYmFzZS9hdXRoLWpzOiBCb3RoIHdhbGxldCBhbmQgdXJsIG11c3QgYmUgc3BlY2lmaWVkIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQgPSB3YWxsZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2FsbGV0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkV2FsbGV0ID0gd2FsbGV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2luZG93QW55ID0gd2luZG93O1xuICAgICAgICAgICAgICAgIGlmICgnc29sYW5hJyBpbiB3aW5kb3dBbnkgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvd0FueS5zb2xhbmEgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICgoJ3NpZ25JbicgaW4gd2luZG93QW55LnNvbGFuYSAmJiB0eXBlb2Ygd2luZG93QW55LnNvbGFuYS5zaWduSW4gPT09ICdmdW5jdGlvbicpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoJ3NpZ25NZXNzYWdlJyBpbiB3aW5kb3dBbnkuc29sYW5hICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHdpbmRvd0FueS5zb2xhbmEuc2lnbk1lc3NhZ2UgPT09ICdmdW5jdGlvbicpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFdhbGxldCA9IHdpbmRvd0FueS5zb2xhbmE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBObyBjb21wYXRpYmxlIFNvbGFuYSB3YWxsZXQgaW50ZXJmYWNlIG9uIHRoZSB3aW5kb3cgb2JqZWN0ICh3aW5kb3cuc29sYW5hKSBkZXRlY3RlZC4gTWFrZSBzdXJlIHRoZSB1c2VyIGFscmVhZHkgaGFzIGEgd2FsbGV0IGluc3RhbGxlZCBhbmQgY29ubmVjdGVkIGZvciB0aGlzIGFwcC4gUHJlZmVyIHBhc3NpbmcgdGhlIHdhbGxldCBpbnRlcmZhY2Ugb2JqZWN0IGRpcmVjdGx5IHRvIHNpZ25JbldpdGhXZWIzKHsgY2hhaW46ICdzb2xhbmEnLCB3YWxsZXQ6IHJlc29sdmVkVXNlcldhbGxldCB9KSBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICAgICAgICAgICAgaWYgKCdzaWduSW4nIGluIHJlc29sdmVkV2FsbGV0ICYmIHJlc29sdmVkV2FsbGV0LnNpZ25Jbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJlc29sdmVkV2FsbGV0LnNpZ25JbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGlzc3VlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpLCB7IFxuICAgICAgICAgICAgICAgICAgICAvLyBub24tb3ZlcnJpZGFibGUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMScsIGRvbWFpbjogdXJsLmhvc3QsIHVyaTogdXJsLmhyZWYgfSksIChzdGF0ZW1lbnQgPyB7IHN0YXRlbWVudCB9IDogbnVsbCkpKTtcbiAgICAgICAgICAgICAgICBsZXQgb3V0cHV0VG9Qcm9jZXNzO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG91dHB1dCkgJiYgb3V0cHV0WzBdICYmIHR5cGVvZiBvdXRwdXRbMF0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFRvUHJvY2VzcyA9IG91dHB1dFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAob3V0cHV0ICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvdXRwdXQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgICdzaWduZWRNZXNzYWdlJyBpbiBvdXRwdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgJ3NpZ25hdHVyZScgaW4gb3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFRvUHJvY2VzcyA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQHN1cGFiYXNlL2F1dGgtanM6IFdhbGxldCBtZXRob2Qgc2lnbkluKCkgcmV0dXJuZWQgdW5yZWNvZ25pemVkIHZhbHVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnc2lnbmVkTWVzc2FnZScgaW4gb3V0cHV0VG9Qcm9jZXNzICYmXG4gICAgICAgICAgICAgICAgICAgICdzaWduYXR1cmUnIGluIG91dHB1dFRvUHJvY2VzcyAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIG91dHB1dFRvUHJvY2Vzcy5zaWduZWRNZXNzYWdlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0VG9Qcm9jZXNzLnNpZ25lZE1lc3NhZ2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSAmJlxuICAgICAgICAgICAgICAgICAgICBvdXRwdXRUb1Byb2Nlc3Muc2lnbmF0dXJlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBvdXRwdXRUb1Byb2Nlc3Muc2lnbmVkTWVzc2FnZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG91dHB1dFRvUHJvY2Vzcy5zaWduZWRNZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUob3V0cHV0VG9Qcm9jZXNzLnNpZ25lZE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUgPSBvdXRwdXRUb1Byb2Nlc3Muc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IG1ldGhvZCBzaWduSW4oKSBBUEkgcmV0dXJuZWQgb2JqZWN0IHdpdGhvdXQgc2lnbmVkTWVzc2FnZSBhbmQgc2lnbmF0dXJlIGZpZWxkcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghKCdzaWduTWVzc2FnZScgaW4gcmVzb2x2ZWRXYWxsZXQpIHx8XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiByZXNvbHZlZFdhbGxldC5zaWduTWVzc2FnZSAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgICAgICAgICAhKCdwdWJsaWNLZXknIGluIHJlc29sdmVkV2FsbGV0KSB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcmVzb2x2ZWRXYWxsZXQgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgICFyZXNvbHZlZFdhbGxldC5wdWJsaWNLZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgISgndG9CYXNlNTgnIGluIHJlc29sdmVkV2FsbGV0LnB1YmxpY0tleSkgfHxcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlc29sdmVkV2FsbGV0LnB1YmxpY0tleS50b0Jhc2U1OCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0BzdXBhYmFzZS9hdXRoLWpzOiBXYWxsZXQgZG9lcyBub3QgaGF2ZSBhIGNvbXBhdGlibGUgc2lnbk1lc3NhZ2UoKSBhbmQgcHVibGljS2V5LnRvQmFzZTU4KCkgQVBJJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBbXG4gICAgICAgICAgICAgICAgICAgIGAke3VybC5ob3N0fSB3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgU29sYW5hIGFjY291bnQ6YCxcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWRXYWxsZXQucHVibGljS2V5LnRvQmFzZTU4KCksXG4gICAgICAgICAgICAgICAgICAgIC4uLihzdGF0ZW1lbnQgPyBbJycsIHN0YXRlbWVudCwgJyddIDogWycnXSksXG4gICAgICAgICAgICAgICAgICAgICdWZXJzaW9uOiAxJyxcbiAgICAgICAgICAgICAgICAgICAgYFVSSTogJHt1cmwuaHJlZn1gLFxuICAgICAgICAgICAgICAgICAgICBgSXNzdWVkIEF0OiAkeyhfYyA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaXNzdWVkQXQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1gLFxuICAgICAgICAgICAgICAgICAgICAuLi4oKChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Qubm90QmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbYE5vdCBCZWZvcmU6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLm5vdEJlZm9yZX1gXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLigoKF9lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5leHBpcmF0aW9uVGltZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW2BFeHBpcmF0aW9uIFRpbWU6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLmV4cGlyYXRpb25UaW1lfWBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKCgoX2YgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNoYWluSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtgQ2hhaW4gSUQ6ICR7b3B0aW9ucy5zaWduSW5XaXRoU29sYW5hLmNoYWluSWR9YF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgICAgICAgICAuLi4oKChfZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaWduSW5XaXRoU29sYW5hKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cubm9uY2UpID8gW2BOb25jZTogJHtvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEubm9uY2V9YF0gOiBbXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLigoKF9oID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEpID09PSBudWxsIHx8IF9oID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaC5yZXF1ZXN0SWQpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtgUmVxdWVzdCBJRDogJHtvcHRpb25zLnNpZ25JbldpdGhTb2xhbmEucmVxdWVzdElkfWBdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKCgoX2sgPSAoX2ogPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLnJlc291cmNlcykgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdSZXNvdXJjZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuc2lnbkluV2l0aFNvbGFuYS5yZXNvdXJjZXMubWFwKChyZXNvdXJjZSkgPT4gYC0gJHtyZXNvdXJjZX1gKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogW10pLFxuICAgICAgICAgICAgICAgIF0uam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF5YmVTaWduYXR1cmUgPSBhd2FpdCByZXNvbHZlZFdhbGxldC5zaWduTWVzc2FnZShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobWVzc2FnZSksICd1dGY4Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXliZVNpZ25hdHVyZSB8fCAhKG1heWJlU2lnbmF0dXJlIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdAc3VwYWJhc2UvYXV0aC1qczogV2FsbGV0IHNpZ25NZXNzYWdlKCkgQVBJIHJldHVybmVkIGFuIHJlY29nbml6ZWQgdmFsdWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlID0gbWF5YmVTaWduYXR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9d2ViM2AsIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbih7IGNoYWluOiAnc29sYW5hJywgbWVzc2FnZSwgc2lnbmF0dXJlOiBieXRlc1RvQmFzZTY0VVJMKHNpZ25hdHVyZSkgfSwgKCgoX2wgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2wuY2FwdGNoYVRva2VuKVxuICAgICAgICAgICAgICAgICAgICA/IHsgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogKF9tID0gY3JlZGVudGlhbHMub3B0aW9ucykgPT09IG51bGwgfHwgX20gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9tLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKSksXG4gICAgICAgICAgICAgICAgeGZvcm06IF9zZXNzaW9uUmVzcG9uc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZGF0YSksIGVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihhdXRoQ29kZSkge1xuICAgICAgICBjb25zdCBzdG9yYWdlSXRlbSA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICBjb25zdCBbY29kZVZlcmlmaWVyLCByZWRpcmVjdFR5cGVdID0gKHN0b3JhZ2VJdGVtICE9PSBudWxsICYmIHN0b3JhZ2VJdGVtICE9PSB2b2lkIDAgPyBzdG9yYWdlSXRlbSA6ICcnKS5zcGxpdCgnLycpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1wa2NlYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIGF1dGhfY29kZTogYXV0aENvZGUsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVfdmVyaWZpZXI6IGNvZGVWZXJpZmllcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCBgJHt0aGlzLnN0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgKTtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgcmVkaXJlY3RUeXBlOiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aEludmFsaWRUb2tlblJlc3BvbnNlRXJyb3IoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IHJlZGlyZWN0VHlwZTogcmVkaXJlY3RUeXBlICE9PSBudWxsICYmIHJlZGlyZWN0VHlwZSAhPT0gdm9pZCAwID8gcmVkaXJlY3RUeXBlIDogbnVsbCB9KSwgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHNpZ25pbmcgaW4gd2l0aCBhbiBPSURDIElEIHRva2VuLiBUaGUgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgdXNlZFxuICAgICAqIHNob3VsZCBiZSBlbmFibGVkIGFuZCBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25JbldpdGhJZFRva2VuKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMsIHByb3ZpZGVyLCB0b2tlbiwgYWNjZXNzX3Rva2VuLCBub25jZSB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS90b2tlbj9ncmFudF90eXBlPWlkX3Rva2VuYCwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICBpZF90b2tlbjogdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXM7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdTSUdORURfSU4nLCBkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyBpbiBhIHVzZXIgdXNpbmcgbWFnaWNsaW5rIG9yIGEgb25lLXRpbWUgcGFzc3dvcmQgKE9UUCkuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYHt7IC5Db25maXJtYXRpb25VUkwgfX1gIHZhcmlhYmxlIGlzIHNwZWNpZmllZCBpbiB0aGUgZW1haWwgdGVtcGxhdGUsIGEgbWFnaWNsaW5rIHdpbGwgYmUgc2VudC5cbiAgICAgKiBJZiB0aGUgYHt7IC5Ub2tlbiB9fWAgdmFyaWFibGUgaXMgc3BlY2lmaWVkIGluIHRoZSBlbWFpbCB0ZW1wbGF0ZSwgYW4gT1RQIHdpbGwgYmUgc2VudC5cbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgcGhvbmUgc2lnbi1pbnMsIG9ubHkgYW4gT1RQIHdpbGwgYmUgc2VudC4gWW91IHdvbid0IGJlIGFibGUgdG8gc2VuZCBhIG1hZ2ljbGluayBmb3IgcGhvbmUgc2lnbi1pbnMuXG4gICAgICpcbiAgICAgKiBCZSBhd2FyZSB0aGF0IHlvdSBtYXkgZ2V0IGJhY2sgYW4gZXJyb3IgbWVzc2FnZSB0aGF0IHdpbGwgbm90IGRpc3Rpbmd1aXNoXG4gICAgICogYmV0d2VlbiB0aGUgY2FzZXMgd2hlcmUgdGhlIGFjY291bnQgZG9lcyBub3QgZXhpc3Qgb3IsIHRoYXQgdGhlIGFjY291bnRcbiAgICAgKiBjYW4gb25seSBiZSBhY2Nlc3NlZCB2aWEgc29jaWFsIGxvZ2luLlxuICAgICAqXG4gICAgICogRG8gbm90ZSB0aGF0IHlvdSB3aWxsIG5lZWQgdG8gY29uZmlndXJlIGEgV2hhdHNhcHAgc2VuZGVyIG9uIFR3aWxpb1xuICAgICAqIGlmIHlvdSBhcmUgdXNpbmcgcGhvbmUgc2lnbiBpbiB3aXRoIHRoZSAnd2hhdHNhcHAnIGNoYW5uZWwuIFRoZSB3aGF0c2FwcFxuICAgICAqIGNoYW5uZWwgaXMgbm90IHN1cHBvcnRlZCBvbiBvdGhlciBwcm92aWRlcnNcbiAgICAgKiBhdCB0aGlzIHRpbWUuXG4gICAgICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgUEtDRSB3aGVuIGFuIGVtYWlsIGlzIHBhc3NlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzaWduSW5XaXRoT3RwKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoJ2VtYWlsJyBpbiBjcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1haWwsIG9wdGlvbnMgfSA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgY29kZUNoYWxsZW5nZU1ldGhvZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9vdHBgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1haWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBjcmVhdGVfdXNlcjogKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNob3VsZENyZWF0ZVVzZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgncGhvbmUnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwaG9uZSwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vb3RwYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBob25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlX3VzZXI6IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaG91bGRDcmVhdGVVc2VyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbDogKF9lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNoYW5uZWwpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6ICdzbXMnLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgbWVzc2FnZUlkOiBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubWVzc2FnZV9pZCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcignWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nIGluIGEgdXNlciBnaXZlbiBhIFVzZXIgc3VwcGxpZWQgT1RQIG9yIFRva2VuSGFzaCByZWNlaXZlZCB0aHJvdWdoIG1vYmlsZSBvciBlbWFpbC5cbiAgICAgKi9cbiAgICBhc3luYyB2ZXJpZnlPdHAocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcmVkaXJlY3RUbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBjYXB0Y2hhVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoJ29wdGlvbnMnIGluIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIHJlZGlyZWN0VG8gPSAoX2EgPSBwYXJhbXMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG87XG4gICAgICAgICAgICAgICAgY2FwdGNoYVRva2VuID0gKF9iID0gcGFyYW1zLm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYXB0Y2hhVG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS92ZXJpZnlgLCB7XG4gICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgeyBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBjYXB0Y2hhVG9rZW4gfSB9KSxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgb24gdG9rZW4gdmVyaWZpY2F0aW9uLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IGRhdGEuc2Vzc2lvbjtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICBpZiAoc2Vzc2lvbiA9PT0gbnVsbCB8fCBzZXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uLmFjY2Vzc190b2tlbikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKHBhcmFtcy50eXBlID09ICdyZWNvdmVyeScgPyAnUEFTU1dPUkRfUkVDT1ZFUlknIDogJ1NJR05FRF9JTicsIHNlc3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyBhIHNpbmdsZS1zaWduIG9uIHVzaW5nIGFuIGVudGVycHJpc2UgSWRlbnRpdHkgUHJvdmlkZXIuIEFcbiAgICAgKiBzdWNjZXNzZnVsIFNTTyBhdHRlbXB0IHdpbGwgcmVkaXJlY3QgdGhlIGN1cnJlbnQgcGFnZSB0byB0aGUgaWRlbnRpdHlcbiAgICAgKiBwcm92aWRlciBhdXRob3JpemF0aW9uIHBhZ2UuIFRoZSByZWRpcmVjdCBVUkwgaXMgaW1wbGVtZW50YXRpb24gYW5kIFNTT1xuICAgICAqIHByb3RvY29sIHNwZWNpZmljLlxuICAgICAqXG4gICAgICogWW91IGNhbiB1c2UgaXQgYnkgcHJvdmlkaW5nIGEgU1NPIGRvbWFpbi4gVHlwaWNhbGx5IHlvdSBjYW4gZXh0cmFjdCB0aGlzXG4gICAgICogZG9tYWluIGJ5IGFza2luZyB1c2VycyBmb3IgdGhlaXIgZW1haWwgYWRkcmVzcy4gSWYgdGhpcyBkb21haW4gaXNcbiAgICAgKiByZWdpc3RlcmVkIG9uIHRoZSBBdXRoIGluc3RhbmNlIHRoZSByZWRpcmVjdCB3aWxsIHVzZSB0aGF0IG9yZ2FuaXphdGlvbidzXG4gICAgICogY3VycmVudGx5IGFjdGl2ZSBTU08gSWRlbnRpdHkgUHJvdmlkZXIgZm9yIHRoZSBsb2dpbi5cbiAgICAgKlxuICAgICAqIElmIHlvdSBoYXZlIGJ1aWx0IGFuIG9yZ2FuaXphdGlvbi1zcGVjaWZpYyBsb2dpbiBwYWdlLCB5b3UgY2FuIHVzZSB0aGVcbiAgICAgKiBvcmdhbml6YXRpb24ncyBTU08gSWRlbnRpdHkgUHJvdmlkZXIgVVVJRCBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGFzeW5jIHNpZ25JbldpdGhTU08ocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9zc29gLCB7XG4gICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoJ3Byb3ZpZGVySWQnIGluIHBhcmFtcyA/IHsgcHJvdmlkZXJfaWQ6IHBhcmFtcy5wcm92aWRlcklkIH0gOiBudWxsKSksICgnZG9tYWluJyBpbiBwYXJhbXMgPyB7IGRvbWFpbjogcGFyYW1zLmRvbWFpbiB9IDogbnVsbCkpLCB7IHJlZGlyZWN0X3RvOiAoX2IgPSAoX2EgPSBwYXJhbXMub3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlZGlyZWN0VG8pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZCB9KSwgKCgoX2MgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhcHRjaGFUb2tlbilcbiAgICAgICAgICAgICAgICAgICAgPyB7IGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IHBhcmFtcy5vcHRpb25zLmNhcHRjaGFUb2tlbiB9IH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsKSksIHsgc2tpcF9odHRwX3JlZGlyZWN0OiB0cnVlLCBjb2RlX2NoYWxsZW5nZTogY29kZUNoYWxsZW5nZSwgY29kZV9jaGFsbGVuZ2VfbWV0aG9kOiBjb2RlQ2hhbGxlbmdlTWV0aG9kIH0pLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB4Zm9ybTogX3Nzb1Jlc3BvbnNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgcmVhdXRoZW50aWNhdGlvbiBPVFAgdG8gdGhlIHVzZXIncyBlbWFpbCBvciBwaG9uZSBudW1iZXIuXG4gICAgICogUmVxdWlyZXMgdGhlIHVzZXIgdG8gYmUgc2lnbmVkLWluLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYXV0aGVudGljYXRlKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9yZWF1dGhlbnRpY2F0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3JlYXV0aGVudGljYXRlKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yOiBzZXNzaW9uRXJyb3IsIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgc2Vzc2lvbkVycm9yO1xuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS9yZWF1dGhlbnRpY2F0ZWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNlbmRzIGFuIGV4aXN0aW5nIHNpZ251cCBjb25maXJtYXRpb24gZW1haWwsIGVtYWlsIGNoYW5nZSBlbWFpbCwgU01TIE9UUCBvciBwaG9uZSBjaGFuZ2UgT1RQLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc2VuZChjcmVkZW50aWFscykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZW5kcG9pbnQgPSBgJHt0aGlzLnVybH0vcmVzZW5kYDtcbiAgICAgICAgICAgIGlmICgnZW1haWwnIGluIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbWFpbCwgdHlwZSwgb3B0aW9ucyB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBlbmRwb2ludCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdHJ1ZV9tZXRhX3NlY3VyaXR5OiB7IGNhcHRjaGFfdG9rZW46IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RUbzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVtYWlsUmVkaXJlY3RUbyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCdwaG9uZScgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBob25lLCB0eXBlLCBvcHRpb25zIH0gPSBjcmVkZW50aWFscztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGVuZHBvaW50LCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGhvbmUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhcHRjaGFUb2tlbiB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCwgbWVzc2FnZUlkOiBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEubWVzc2FnZV9pZCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcignWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gZW1haWwgb3IgcGhvbmUgbnVtYmVyIGFuZCBhIHR5cGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNlc3Npb24sIHJlZnJlc2hpbmcgaXQgaWYgbmVjZXNzYXJ5LlxuICAgICAqXG4gICAgICogVGhlIHNlc3Npb24gcmV0dXJuZWQgY2FuIGJlIG51bGwgaWYgdGhlIHNlc3Npb24gaXMgbm90IGRldGVjdGVkIHdoaWNoIGNhbiBoYXBwZW4gaW4gdGhlIGV2ZW50IGEgdXNlciBpcyBub3Qgc2lnbmVkLWluIG9yIGhhcyBsb2dnZWQgb3V0LlxuICAgICAqXG4gICAgICogKipJTVBPUlRBTlQ6KiogVGhpcyBtZXRob2QgbG9hZHMgdmFsdWVzIGRpcmVjdGx5IGZyb20gdGhlIHN0b3JhZ2UgYXR0YWNoZWRcbiAgICAgKiB0byB0aGUgY2xpZW50LiBJZiB0aGF0IHN0b3JhZ2UgaXMgYmFzZWQgb24gcmVxdWVzdCBjb29raWVzIGZvciBleGFtcGxlLFxuICAgICAqIHRoZSB2YWx1ZXMgaW4gaXQgbWF5IG5vdCBiZSBhdXRoZW50aWMgYW5kIHRoZXJlZm9yZSBpdCdzIHN0cm9uZ2x5IGFkdmlzZWRcbiAgICAgKiBhZ2FpbnN0IHVzaW5nIHRoaXMgbWV0aG9kIGFuZCBpdHMgcmVzdWx0cyBpbiBzdWNoIGNpcmN1bXN0YW5jZXMuIEEgd2FybmluZ1xuICAgICAqIHdpbGwgYmUgZW1pdHRlZCBpZiB0aGlzIGlzIGRldGVjdGVkLiBVc2Uge0BsaW5rICNnZXRVc2VyKCl9IGluc3RlYWQuXG4gICAgICovXG4gICAgYXN5bmMgZ2V0U2Vzc2lvbigpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3F1aXJlcyBhIGdsb2JhbCBsb2NrIGJhc2VkIG9uIHRoZSBzdG9yYWdlIGtleS5cbiAgICAgKi9cbiAgICBhc3luYyBfYWNxdWlyZUxvY2soYWNxdWlyZVRpbWVvdXQsIGZuKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2JlZ2luJywgYWNxdWlyZVRpbWVvdXQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMubG9ja0FjcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IHRoaXMucGVuZGluZ0luTG9jay5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnBlbmRpbmdJbkxvY2tbdGhpcy5wZW5kaW5nSW5Mb2NrLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbGFzdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdJbkxvY2sucHVzaCgoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGNhcmUgaWYgaXQgZmluaXNoZWRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5sb2NrKGBsb2NrOiR7dGhpcy5zdG9yYWdlS2V5fWAsIGFjcXVpcmVUaW1lb3V0LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYWNxdWlyZUxvY2snLCAnbG9jayBhY3F1aXJlZCBmb3Igc3RvcmFnZSBrZXknLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9ja0FjcXVpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nSW5Mb2NrLnB1c2goKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBqdXN0IGNhcmUgaWYgaXQgZmluaXNoZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCBkcmFpbmluZyB0aGUgcXVldWUgdW50aWwgdGhlcmUncyBub3RoaW5nIHRvIHdhaXQgb25cbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMucGVuZGluZ0luTG9jay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhaXRPbiA9IFsuLi50aGlzLnBlbmRpbmdJbkxvY2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwod2FpdE9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0luTG9jay5zcGxpY2UoMCwgd2FpdE9uLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2xvY2sgcmVsZWFzZWQgZm9yIHN0b3JhZ2Uga2V5JywgdGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NrQWNxdWlyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2FjcXVpcmVMb2NrJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSBpbnN0ZWFkIG9mIHtAbGluayAjZ2V0U2Vzc2lvbn0gaW5zaWRlIHRoZSBsaWJyYXJ5LiBJdCBpc1xuICAgICAqIHNlbWFudGljYWxseSB1c3VhbGx5IHdoYXQgeW91IHdhbnQsIGFzIGdldHRpbmcgYSBzZXNzaW9uIGludm9sdmVzIHNvbWVcbiAgICAgKiBwcm9jZXNzaW5nIGFmdGVyd2FyZHMgdGhhdCByZXF1aXJlcyBvbmx5IG9uZSBjbGllbnQgb3BlcmF0aW5nIG9uIHRoZVxuICAgICAqIHNlc3Npb24gYXQgb25jZSBhY3Jvc3MgbXVsdGlwbGUgdGFicyBvciBwcm9jZXNzZXMuXG4gICAgICovXG4gICAgYXN5bmMgX3VzZVNlc3Npb24oZm4pIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfdXNlU2Vzc2lvbicsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gdGhlIHVzZSBvZiBfX2xvYWRTZXNzaW9uIGhlcmUgaXMgdGhlIG9ubHkgY29ycmVjdCB1c2Ugb2YgdGhlIGZ1bmN0aW9uIVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fX2xvYWRTZXNzaW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4ocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX3VzZVNlc3Npb24nLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTkVWRVIgVVNFIERJUkVDVExZIVxuICAgICAqXG4gICAgICogQWx3YXlzIHVzZSB7QGxpbmsgI191c2VTZXNzaW9ufS5cbiAgICAgKi9cbiAgICBhc3luYyBfX2xvYWRTZXNzaW9uKCkge1xuICAgICAgICB0aGlzLl9kZWJ1ZygnI19fbG9hZFNlc3Npb24oKScsICdiZWdpbicpO1xuICAgICAgICBpZiAoIXRoaXMubG9ja0FjcXVpcmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19fbG9hZFNlc3Npb24oKScsICd1c2VkIG91dHNpZGUgb2YgYW4gYWNxdWlyZWQgbG9jayEnLCBuZXcgRXJyb3IoKS5zdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50U2Vzc2lvbiA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBtYXliZVNlc3Npb24gPSBhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNnZXRTZXNzaW9uKCknLCAnc2Vzc2lvbiBmcm9tIHN0b3JhZ2UnLCBtYXliZVNlc3Npb24pO1xuICAgICAgICAgICAgaWYgKG1heWJlU2Vzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pc1ZhbGlkU2Vzc2lvbihtYXliZVNlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gbWF5YmVTZXNzaW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNnZXRTZXNzaW9uKCknLCAnc2Vzc2lvbiBmcm9tIHN0b3JhZ2UgaXMgbm90IHZhbGlkJyk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JlbW92ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBIHNlc3Npb24gaXMgY29uc2lkZXJlZCBleHBpcmVkIGJlZm9yZSB0aGUgYWNjZXNzIHRva2VuIF9hY3R1YWxseV9cbiAgICAgICAgICAgIC8vIGV4cGlyZXMuIFdoZW4gdGhlIGF1dG9SZWZyZXNoVG9rZW4gb3B0aW9uIGlzIG9mZiAob3Igd2hlbiB0aGUgdGFiIGlzXG4gICAgICAgICAgICAvLyBpbiB0aGUgYmFja2dyb3VuZCksIHZlcnkgZWFnZXIgdXNlcnMgb2YgZ2V0U2Vzc2lvbigpIC0tIGxpa2VcbiAgICAgICAgICAgIC8vIHJlYWx0aW1lLWpzIC0tIG1pZ2h0IHNlbmQgYSB2YWxpZCBKV1Qgd2hpY2ggd2lsbCBleHBpcmUgYnkgdGhlIHRpbWUgaXRcbiAgICAgICAgICAgIC8vIHJlYWNoZXMgdGhlIHNlcnZlci5cbiAgICAgICAgICAgIGNvbnN0IGhhc0V4cGlyZWQgPSBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0XG4gICAgICAgICAgICAgICAgPyBjdXJyZW50U2Vzc2lvbi5leHBpcmVzX2F0ICogMTAwMCAtIERhdGUubm93KCkgPCBFWFBJUllfTUFSR0lOX01TXG4gICAgICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgYHNlc3Npb24gaGFzJHtoYXNFeHBpcmVkID8gJycgOiAnIG5vdCd9IGV4cGlyZWRgLCAnZXhwaXJlc19hdCcsIGN1cnJlbnRTZXNzaW9uLmV4cGlyZXNfYXQpO1xuICAgICAgICAgICAgaWYgKCFoYXNFeHBpcmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlclN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF5YmVVc2VyID0gKGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnVzZXJTdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZVVzZXIgPT09IG51bGwgfHwgbWF5YmVVc2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXliZVVzZXIudXNlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciA9IG1heWJlVXNlci51c2VyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciA9IHVzZXJOb3RBdmFpbGFibGVQcm94eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdyYXAgdGhlIHVzZXIgb2JqZWN0IHdpdGggYSB3YXJuaW5nIHByb3h5IG9uIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdhcm5zIHdoZW4gcHJvcGVydGllcyBvZiB0aGUgdXNlciBhcmUgYWNjZXNzZWQsIG5vdCB3aGVuIHNlc3Npb24udXNlciBpdHNlbGYgaXMgYWNjZXNzZWRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdG9yYWdlLmlzU2VydmVyICYmXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgIWN1cnJlbnRTZXNzaW9uLnVzZXIuX19pc1VzZXJOb3RBdmFpbGFibGVQcm94eSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdXBwcmVzc1dhcm5pbmdSZWYgPSB7IHZhbHVlOiB0aGlzLnN1cHByZXNzR2V0U2Vzc2lvbldhcm5pbmcgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciA9IGluc2VjdXJlVXNlcldhcm5pbmdQcm94eShjdXJyZW50U2Vzc2lvbi51c2VyLCBzdXBwcmVzc1dhcm5pbmdSZWYpO1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGNsaWVudC1sZXZlbCBzdXBwcmVzc2lvbiBmbGFnIHdoZW4gdGhlIHByb3h5IHN1cHByZXNzZXMgdGhlIHdhcm5pbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1cHByZXNzV2FybmluZ1JlZi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdXBwcmVzc0dldFNlc3Npb25XYXJuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IGN1cnJlbnRTZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb24sIGVycm9yIH0gPSBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX19sb2FkU2Vzc2lvbigpJywgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdXNlciBkZXRhaWxzIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIHNlc3Npb24uIFRoaXMgbWV0aG9kXG4gICAgICogcGVyZm9ybXMgYSBuZXR3b3JrIHJlcXVlc3QgdG8gdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLCBzbyB0aGUgcmV0dXJuZWRcbiAgICAgKiB2YWx1ZSBpcyBhdXRoZW50aWMgYW5kIGNhbiBiZSB1c2VkIHRvIGJhc2UgYXV0aG9yaXphdGlvbiBydWxlcyBvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBqd3QgVGFrZXMgaW4gYW4gb3B0aW9uYWwgYWNjZXNzIHRva2VuIEpXVC4gSWYgbm8gSldUIGlzIHByb3ZpZGVkLCB0aGUgSldUIGZyb20gdGhlIGN1cnJlbnQgc2Vzc2lvbiBpcyB1c2VkLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFVzZXIoand0KSB7XG4gICAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKGp3dCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9nZXRVc2VyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBhc3luYyBfZ2V0VXNlcihqd3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChqd3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogand0LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3VzZXJSZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZXR1cm5zIGFuIGVycm9yIGlmIHRoZXJlIGlzIG5vIGFjY2Vzc190b2tlbiBvciBjdXN0b20gYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgICAgICAgICAgICBpZiAoISgoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4pICYmICF0aGlzLmhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsIH0sIGVycm9yOiBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0dFVCcsIGAke3RoaXMudXJsfS91c2VyYCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9jID0gKF9iID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEpXVCBjb250YWlucyBhIGBzZXNzaW9uX2lkYCB3aGljaCBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIGFuIGFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICAvLyBzZXNzaW9uIGluIHRoZSBkYXRhYmFzZSwgaW5kaWNhdGluZyB0aGUgdXNlciBpcyBzaWduZWQgb3V0LlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZUl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdXNlciBkYXRhIGZvciBhIGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqL1xuICAgIGFzeW5jIHVwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VwZGF0ZVVzZXIoYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBfdXBkYXRlVXNlcihhdHRyaWJ1dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBzZXNzaW9uRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc2Vzc2lvbkRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc2Vzc2lvbiA9IHNlc3Npb25EYXRhLnNlc3Npb247XG4gICAgICAgICAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnICYmIGF0dHJpYnV0ZXMuZW1haWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIFtjb2RlQ2hhbGxlbmdlLCBjb2RlQ2hhbGxlbmdlTWV0aG9kXSA9IGF3YWl0IGdldENvZGVDaGFsbGVuZ2VBbmRNZXRob2QodGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiB1c2VyRXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQVVQnLCBgJHt0aGlzLnVybH0vdXNlcmAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW1haWxSZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICBib2R5OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpLCB7IGNvZGVfY2hhbGxlbmdlOiBjb2RlQ2hhbGxlbmdlLCBjb2RlX2NoYWxsZW5nZV9tZXRob2Q6IGNvZGVDaGFsbGVuZ2VNZXRob2QgfSksXG4gICAgICAgICAgICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfdXNlclJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh1c2VyRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHVzZXJFcnJvcjtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLnVzZXIgPSBkYXRhLnVzZXI7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1VTRVJfVVBEQVRFRCcsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNlc3Npb24gZGF0YSBmcm9tIHRoZSBjdXJyZW50IHNlc3Npb24uIElmIHRoZSBjdXJyZW50IHNlc3Npb24gaXMgZXhwaXJlZCwgc2V0U2Vzc2lvbiB3aWxsIHRha2UgY2FyZSBvZiByZWZyZXNoaW5nIGl0IHRvIG9idGFpbiBhIG5ldyBzZXNzaW9uLlxuICAgICAqIElmIHRoZSByZWZyZXNoIHRva2VuIG9yIGFjY2VzcyB0b2tlbiBpbiB0aGUgY3VycmVudCBzZXNzaW9uIGlzIGludmFsaWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqIEBwYXJhbSBjdXJyZW50U2Vzc2lvbiBUaGUgY3VycmVudCBzZXNzaW9uIHRoYXQgbWluaW1hbGx5IGNvbnRhaW5zIGFuIGFjY2VzcyB0b2tlbiBhbmQgcmVmcmVzaCB0b2tlbi5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3NldFNlc3Npb24oY3VycmVudFNlc3Npb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3NldFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuIHx8ICFjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0aW1lTm93ID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICAgICAgICBsZXQgZXhwaXJlc0F0ID0gdGltZU5vdztcbiAgICAgICAgICAgIGxldCBoYXNFeHBpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBzZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHsgcGF5bG9hZCB9ID0gZGVjb2RlSldUKGN1cnJlbnRTZXNzaW9uLmFjY2Vzc190b2tlbik7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5leHApIHtcbiAgICAgICAgICAgICAgICBleHBpcmVzQXQgPSBwYXlsb2FkLmV4cDtcbiAgICAgICAgICAgICAgICBoYXNFeHBpcmVkID0gZXhwaXJlc0F0IDw9IHRpbWVOb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogcmVmcmVzaGVkU2Vzc2lvbiwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2NhbGxSZWZyZXNoVG9rZW4oY3VycmVudFNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZyZXNoZWRTZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXNzaW9uID0gcmVmcmVzaGVkU2Vzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc190b2tlbjogY3VycmVudFNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuOiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB1c2VyOiBkYXRhLnVzZXIsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuX3R5cGU6ICdiZWFyZXInLFxuICAgICAgICAgICAgICAgICAgICBleHBpcmVzX2luOiBleHBpcmVzQXQgLSB0aW1lTm93LFxuICAgICAgICAgICAgICAgICAgICBleHBpcmVzX2F0OiBleHBpcmVzQXQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9ub3RpZnlBbGxTdWJzY3JpYmVycygnU0lHTkVEX0lOJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IHNlc3Npb24udXNlciwgc2Vzc2lvbiB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBzZXNzaW9uLCByZWdhcmRsZXNzIG9mIGV4cGlyeSBzdGF0dXMuXG4gICAgICogVGFrZXMgaW4gYW4gb3B0aW9uYWwgY3VycmVudCBzZXNzaW9uLiBJZiBub3QgcGFzc2VkIGluLCB0aGVuIHJlZnJlc2hTZXNzaW9uKCkgd2lsbCBhdHRlbXB0IHRvIHJldHJpZXZlIGl0IGZyb20gZ2V0U2Vzc2lvbigpLlxuICAgICAqIElmIHRoZSBjdXJyZW50IHNlc3Npb24ncyByZWZyZXNoIHRva2VuIGlzIGludmFsaWQsIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duLlxuICAgICAqIEBwYXJhbSBjdXJyZW50U2Vzc2lvbiBUaGUgY3VycmVudCBzZXNzaW9uLiBJZiBwYXNzZWQgaW4sIGl0IG11c3QgY29udGFpbiBhIHJlZnJlc2ggdG9rZW4uXG4gICAgICovXG4gICAgYXN5bmMgcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fcmVmcmVzaFNlc3Npb24oY3VycmVudFNlc3Npb24pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3JlZnJlc2hTZXNzaW9uKGN1cnJlbnRTZXNzaW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudFNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uID0gKF9hID0gZGF0YS5zZXNzaW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGN1cnJlbnRTZXNzaW9uID09PSBudWxsIHx8IGN1cnJlbnRTZXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogc2Vzc2lvbi51c2VyLCBzZXNzaW9uIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNlc3Npb24gZGF0YSBmcm9tIGEgVVJMIHN0cmluZ1xuICAgICAqL1xuICAgIGFzeW5jIF9nZXRTZXNzaW9uRnJvbVVSTChwYXJhbXMsIGNhbGxiYWNrVXJsVHlwZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFpc0Jyb3dzZXIoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yKCdObyBicm93c2VyIGRldGVjdGVkLicpO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhbiBlcnJvciBpbiB0aGUgVVJMLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IGZsb3cgaXQgaXMsIHdlIGp1c3QgcmV0dXJuIHRoZSBlcnJvci5cbiAgICAgICAgICAgIGlmIChwYXJhbXMuZXJyb3IgfHwgcGFyYW1zLmVycm9yX2Rlc2NyaXB0aW9uIHx8IHBhcmFtcy5lcnJvcl9jb2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGVycm9yIGNsYXNzIHJldHVybmVkIGltcGxpZXMgdGhhdCB0aGUgcmVkaXJlY3QgaXMgZnJvbSBhbiBpbXBsaWNpdCBncmFudCBmbG93XG4gICAgICAgICAgICAgICAgLy8gYnV0IGl0IGNvdWxkIGFsc28gYmUgZnJvbSBhIHJlZGlyZWN0IGVycm9yIGZyb20gYSBQS0NFIGZsb3cuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihwYXJhbXMuZXJyb3JfZGVzY3JpcHRpb24gfHwgJ0Vycm9yIGluIFVSTCB3aXRoIHVuc3BlY2lmaWVkIGVycm9yX2Rlc2NyaXB0aW9uJywge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogcGFyYW1zLmVycm9yIHx8ICd1bnNwZWNpZmllZF9lcnJvcicsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHBhcmFtcy5lcnJvcl9jb2RlIHx8ICd1bnNwZWNpZmllZF9jb2RlJyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrcyBmb3IgbWlzbWF0Y2hlcyBiZXR3ZWVuIHRoZSBmbG93VHlwZSBpbml0aWFsaXNlZCBpbiB0aGUgY2xpZW50IGFuZCB0aGUgVVJMIHBhcmFtZXRlcnNcbiAgICAgICAgICAgIHN3aXRjaCAoY2FsbGJhY2tVcmxUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW1wbGljaXQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yKCdOb3QgYSB2YWxpZCBQS0NFIGZsb3cgdXJsLicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BrY2UnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ2ltcGxpY2l0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcignTm90IGEgdmFsaWQgaW1wbGljaXQgZ3JhbnQgZmxvdyB1cmwuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSdzIG5vIG1pc21hdGNoIHNvIHdlIGNvbnRpbnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaW5jZSB0aGlzIGlzIGEgcmVkaXJlY3QgZm9yIFBLQ0UsIHdlIGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlIGNvZGUgZnJvbSB0aGUgVVJMIGZvciB0aGUgY29kZSBleGNoYW5nZVxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrVXJsVHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfaW5pdGlhbGl6ZSgpJywgJ2JlZ2luJywgJ2lzIFBLQ0UgZmxvdycsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyYW1zLmNvZGUpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoUEtDRUdyYW50Q29kZUV4Y2hhbmdlRXJyb3IoJ05vIGNvZGUgZGV0ZWN0ZWQuJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbihwYXJhbXMuY29kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZSgnY29kZScpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh3aW5kb3cuaGlzdG9yeS5zdGF0ZSwgJycsIHVybC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IGRhdGEuc2Vzc2lvbiwgcmVkaXJlY3RUeXBlOiBudWxsIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHByb3ZpZGVyX3Rva2VuLCBwcm92aWRlcl9yZWZyZXNoX3Rva2VuLCBhY2Nlc3NfdG9rZW4sIHJlZnJlc2hfdG9rZW4sIGV4cGlyZXNfaW4sIGV4cGlyZXNfYXQsIHRva2VuX3R5cGUsIH0gPSBwYXJhbXM7XG4gICAgICAgICAgICBpZiAoIWFjY2Vzc190b2tlbiB8fCAhZXhwaXJlc19pbiB8fCAhcmVmcmVzaF90b2tlbiB8fCAhdG9rZW5fdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBBdXRoSW1wbGljaXRHcmFudFJlZGlyZWN0RXJyb3IoJ05vIHNlc3Npb24gZGVmaW5lZCBpbiBVUkwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpbWVOb3cgPSBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGlyZXNJbiA9IHBhcnNlSW50KGV4cGlyZXNfaW4pO1xuICAgICAgICAgICAgbGV0IGV4cGlyZXNBdCA9IHRpbWVOb3cgKyBleHBpcmVzSW47XG4gICAgICAgICAgICBpZiAoZXhwaXJlc19hdCkge1xuICAgICAgICAgICAgICAgIGV4cGlyZXNBdCA9IHBhcnNlSW50KGV4cGlyZXNfYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWN0dWFsbHlFeHBpcmVzSW4gPSBleHBpcmVzQXQgLSB0aW1lTm93O1xuICAgICAgICAgICAgaWYgKGFjdHVhbGx5RXhwaXJlc0luICogMTAwMCA8PSBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQHN1cGFiYXNlL2dvdHJ1ZS1qczogU2Vzc2lvbiBhcyByZXRyaWV2ZWQgZnJvbSBVUkwgZXhwaXJlcyBpbiAke2FjdHVhbGx5RXhwaXJlc0lufXMsIHNob3VsZCBoYXZlIGJlZW4gY2xvc2VyIHRvICR7ZXhwaXJlc0lufXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlzc3VlZEF0ID0gZXhwaXJlc0F0IC0gZXhwaXJlc0luO1xuICAgICAgICAgICAgaWYgKHRpbWVOb3cgLSBpc3N1ZWRBdCA+PSAxMjApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0BzdXBhYmFzZS9nb3RydWUtanM6IFNlc3Npb24gYXMgcmV0cmlldmVkIGZyb20gVVJMIHdhcyBpc3N1ZWQgb3ZlciAxMjBzIGFnbywgVVJMIGNvdWxkIGJlIHN0YWxlJywgaXNzdWVkQXQsIGV4cGlyZXNBdCwgdGltZU5vdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aW1lTm93IC0gaXNzdWVkQXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBTZXNzaW9uIGFzIHJldHJpZXZlZCBmcm9tIFVSTCB3YXMgaXNzdWVkIGluIHRoZSBmdXR1cmU/IENoZWNrIHRoZSBkZXZpY2UgY2xvY2sgZm9yIHNrZXcnLCBpc3N1ZWRBdCwgZXhwaXJlc0F0LCB0aW1lTm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX2dldFVzZXIoYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb24gPSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJfdG9rZW4sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJfcmVmcmVzaF90b2tlbixcbiAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgZXhwaXJlc19pbjogZXhwaXJlc0luLFxuICAgICAgICAgICAgICAgIGV4cGlyZXNfYXQ6IGV4cGlyZXNBdCxcbiAgICAgICAgICAgICAgICByZWZyZXNoX3Rva2VuLFxuICAgICAgICAgICAgICAgIHRva2VuX3R5cGU6IHRva2VuX3R5cGUsXG4gICAgICAgICAgICAgICAgdXNlcjogZGF0YS51c2VyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0b2tlbnMgZnJvbSBVUkxcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyc7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19nZXRTZXNzaW9uRnJvbVVSTCgpJywgJ2NsZWFyaW5nIHdpbmRvdy5sb2NhdGlvbi5oYXNoJyk7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb24sIHJlZGlyZWN0VHlwZTogcGFyYW1zLnR5cGUgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNlc3Npb246IG51bGwsIHJlZGlyZWN0VHlwZTogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IFVSTCBjb250YWlucyBwYXJhbWV0ZXJzIGdpdmVuIGJ5IGFuIGltcGxpY2l0IG9hdXRoIGdyYW50IGZsb3cgKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM2NzQ5Lmh0bWwjc2VjdGlvbi00LjIpXG4gICAgICovXG4gICAgX2lzSW1wbGljaXRHcmFudENhbGxiYWNrKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihwYXJhbXMuYWNjZXNzX3Rva2VuIHx8IHBhcmFtcy5lcnJvcl9kZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBVUkwgYW5kIGJhY2tpbmcgc3RvcmFnZSBjb250YWluIHBhcmFtZXRlcnMgZ2l2ZW4gYnkgYSBQS0NFIGZsb3dcbiAgICAgKi9cbiAgICBhc3luYyBfaXNQS0NFQ2FsbGJhY2socGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTdG9yYWdlQ29udGVudCA9IGF3YWl0IGdldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIGAke3RoaXMuc3RvcmFnZUtleX0tY29kZS12ZXJpZmllcmApO1xuICAgICAgICByZXR1cm4gISEocGFyYW1zLmNvZGUgJiYgY3VycmVudFN0b3JhZ2VDb250ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zaWRlIGEgYnJvd3NlciBjb250ZXh0LCBgc2lnbk91dCgpYCB3aWxsIHJlbW92ZSB0aGUgbG9nZ2VkIGluIHVzZXIgZnJvbSB0aGUgYnJvd3NlciBzZXNzaW9uIGFuZCBsb2cgdGhlbSBvdXQgLSByZW1vdmluZyBhbGwgaXRlbXMgZnJvbSBsb2NhbHN0b3JhZ2UgYW5kIHRoZW4gdHJpZ2dlciBhIGBcIlNJR05FRF9PVVRcImAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBGb3Igc2VydmVyLXNpZGUgbWFuYWdlbWVudCwgeW91IGNhbiByZXZva2UgYWxsIHJlZnJlc2ggdG9rZW5zIGZvciBhIHVzZXIgYnkgcGFzc2luZyBhIHVzZXIncyBKV1QgdGhyb3VnaCB0byBgYXV0aC5hcGkuc2lnbk91dChKV1Q6IHN0cmluZylgLlxuICAgICAqIFRoZXJlIGlzIG5vIHdheSB0byByZXZva2UgYSB1c2VyJ3MgYWNjZXNzIHRva2VuIGp3dCB1bnRpbCBpdCBleHBpcmVzLiBJdCBpcyByZWNvbW1lbmRlZCB0byBzZXQgYSBzaG9ydGVyIGV4cGlyeSBvbiB0aGUgand0IGZvciB0aGlzIHJlYXNvbi5cbiAgICAgKlxuICAgICAqIElmIHVzaW5nIGBvdGhlcnNgIHNjb3BlLCBubyBgU0lHTkVEX09VVGAgZXZlbnQgaXMgZmlyZWQhXG4gICAgICovXG4gICAgYXN5bmMgc2lnbk91dChvcHRpb25zID0geyBzY29wZTogJ2dsb2JhbCcgfSkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcm9taXNlO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl9zaWduT3V0KG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX3NpZ25PdXQoeyBzY29wZSB9ID0geyBzY29wZTogJ2dsb2JhbCcgfSkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcjogc2Vzc2lvbkVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IChfYSA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbjtcbiAgICAgICAgICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuYWRtaW4uc2lnbk91dChhY2Nlc3NUb2tlbiwgc2NvcGUpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmUgNDA0cyBzaW5jZSB1c2VyIG1pZ2h0IG5vdCBleGlzdCBhbnltb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSA0MDFzIHNpbmNlIGFuIGludmFsaWQgb3IgZXhwaXJlZCBKV1Qgc2hvdWxkIHNpZ24gb3V0IHRoZSBjdXJyZW50IHNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaXNBdXRoQXBpRXJyb3IoZXJyb3IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZXJyb3Iuc3RhdHVzID09PSA0MDQgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDEgfHwgZXJyb3Iuc3RhdHVzID09PSA0MDMpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY29wZSAhPT0gJ290aGVycycpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgYCR7dGhpcy5zdG9yYWdlS2V5fS1jb2RlLXZlcmlmaWVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb25BdXRoU3RhdGVDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgaWQgPSB1dWlkKCk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjdW5zdWJzY3JpYmUoKScsICdzdGF0ZSBjaGFuZ2UgY2FsbGJhY2sgd2l0aCBpZCByZW1vdmVkJywgaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNvbkF1dGhTdGF0ZUNoYW5nZSgpJywgJ3JlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCBpZCcsIGlkKTtcbiAgICAgICAgdGhpcy5zdGF0ZUNoYW5nZUVtaXR0ZXJzLnNldChpZCwgc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXRJbml0aWFsU2Vzc2lvbihpZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzdWJzY3JpcHRpb24gfSB9O1xuICAgIH1cbiAgICBhc3luYyBfZW1pdEluaXRpYWxTZXNzaW9uKGlkKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogeyBzZXNzaW9uIH0sIGVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfYSA9IHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIHNlc3Npb24pKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdzZXNzaW9uJywgc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfYiA9IHRoaXMuc3RhdGVDaGFuZ2VFbWl0dGVycy5nZXQoaWQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbGJhY2soJ0lOSVRJQUxfU0VTU0lPTicsIG51bGwpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnSU5JVElBTF9TRVNTSU9OJywgJ2NhbGxiYWNrIGlkJywgaWQsICdlcnJvcicsIGVycik7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBwYXNzd29yZCByZXNldCByZXF1ZXN0IHRvIGFuIGVtYWlsIGFkZHJlc3MuIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHRoZSBQS0NFIGZsb3cuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVkaXJlY3RUbyBUaGUgVVJMIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBjbGljayB0aGUgcGFzc3dvcmQgcmVzZXQgbGluay5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jYXB0Y2hhVG9rZW4gVmVyaWZpY2F0aW9uIHRva2VuIHJlY2VpdmVkIHdoZW4gdGhlIHVzZXIgY29tcGxldGVzIHRoZSBjYXB0Y2hhIG9uIHRoZSBzaXRlLlxuICAgICAqL1xuICAgIGFzeW5jIHJlc2V0UGFzc3dvcmRGb3JFbWFpbChlbWFpbCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb2RlQ2hhbGxlbmdlID0gbnVsbDtcbiAgICAgICAgbGV0IGNvZGVDaGFsbGVuZ2VNZXRob2QgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5mbG93VHlwZSA9PT0gJ3BrY2UnKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgICAgICBbY29kZUNoYWxsZW5nZSwgY29kZUNoYWxsZW5nZU1ldGhvZF0gPSBhd2FpdCBnZXRDb2RlQ2hhbGxlbmdlQW5kTWV0aG9kKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5LCB0cnVlIC8vIGlzUGFzc3dvcmRSZWNvdmVyeVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3JlY292ZXJgLCB7XG4gICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICBlbWFpbCxcbiAgICAgICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGNvZGVDaGFsbGVuZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogY29kZUNoYWxsZW5nZU1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgZ290cnVlX21ldGFfc2VjdXJpdHk6IHsgY2FwdGNoYV90b2tlbjogb3B0aW9ucy5jYXB0Y2hhVG9rZW4gfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICByZWRpcmVjdFRvOiBvcHRpb25zLnJlZGlyZWN0VG8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgdGhlIGlkZW50aXRpZXMgbGlua2VkIHRvIGEgdXNlci5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRVc2VySWRlbnRpdGllcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKCk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IGlkZW50aXRpZXM6IChfYSA9IGRhdGEudXNlci5pZGVudGl0aWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaW5rSWRlbnRpdHkoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgaWYgKCd0b2tlbicgaW4gY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxpbmtJZGVudGl0eUlkVG9rZW4oY3JlZGVudGlhbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmtJZGVudGl0eU9BdXRoKGNyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgYXN5bmMgbGlua0lkZW50aXR5T0F1dGgoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl9nZXRVcmxGb3JQcm92aWRlcihgJHt0aGlzLnVybH0vdXNlci9pZGVudGl0aWVzL2F1dGhvcml6ZWAsIGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VG86IChfYSA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRpcmVjdFRvLFxuICAgICAgICAgICAgICAgICAgICBzY29wZXM6IChfYiA9IGNyZWRlbnRpYWxzLm9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zY29wZXMsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiAoX2MgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgIHNraXBCcm93c2VyUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdHRVQnLCB1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfZSA9IChfZCA9IGRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFjY2Vzc190b2tlbikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgISgoX2EgPSBjcmVkZW50aWFscy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2tpcEJyb3dzZXJSZWRpcmVjdCkpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS51cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBwcm92aWRlcjogY3JlZGVudGlhbHMucHJvdmlkZXIsIHVybDogZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnVybCB9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgcHJvdmlkZXI6IGNyZWRlbnRpYWxzLnByb3ZpZGVyLCB1cmw6IG51bGwgfSwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpbmtJZGVudGl0eUlkVG9rZW4oY3JlZGVudGlhbHMpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9yOiBzZXNzaW9uRXJyb3IsIGRhdGE6IHsgc2Vzc2lvbiB9LCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IHNlc3Npb25FcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMsIHByb3ZpZGVyLCB0b2tlbiwgYWNjZXNzX3Rva2VuLCBub25jZSB9ID0gY3JlZGVudGlhbHM7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vdG9rZW4/Z3JhbnRfdHlwZT1pZF90b2tlbmAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb24gPT09IG51bGwgfHwgc2Vzc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZF90b2tlbjogdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmtfaWRlbnRpdHk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBnb3RydWVfbWV0YV9zZWN1cml0eTogeyBjYXB0Y2hhX3Rva2VuOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2FwdGNoYVRva2VuIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHhmb3JtOiBfc2Vzc2lvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IHJlcztcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFkYXRhIHx8ICFkYXRhLnNlc3Npb24gfHwgIWRhdGEudXNlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB1c2VyOiBudWxsLCBzZXNzaW9uOiBudWxsIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yKCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oZGF0YS5zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1VTRVJfVVBEQVRFRCcsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgdXNlcjogbnVsbCwgc2Vzc2lvbjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVubGlua3MgYW4gaWRlbnRpdHkgZnJvbSBhIHVzZXIgYnkgZGVsZXRpbmcgaXQuIFRoZSB1c2VyIHdpbGwgbm8gbG9uZ2VyIGJlIGFibGUgdG8gc2lnbiBpbiB3aXRoIHRoYXQgaWRlbnRpdHkgb25jZSBpdCdzIHVubGlua2VkLlxuICAgICAqL1xuICAgIGFzeW5jIHVubGlua0lkZW50aXR5KGlkZW50aXR5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ0RFTEVURScsIGAke3RoaXMudXJsfS91c2VyL2lkZW50aXRpZXMvJHtpZGVudGl0eS5pZGVudGl0eV9pZH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2IgPSAoX2EgPSBkYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgSldULlxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gQSB2YWxpZCByZWZyZXNoIHRva2VuIHRoYXQgd2FzIHJldHVybmVkIG9uIGxvZ2luLlxuICAgICAqL1xuICAgIGFzeW5jIF9yZWZyZXNoQWNjZXNzVG9rZW4ocmVmcmVzaFRva2VuKSB7XG4gICAgICAgIGNvbnN0IGRlYnVnTmFtZSA9IGAjX3JlZnJlc2hBY2Nlc3NUb2tlbigke3JlZnJlc2hUb2tlbi5zdWJzdHJpbmcoMCwgNSl9Li4uKWA7XG4gICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydGVkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgLy8gd2lsbCBhdHRlbXB0IHRvIHJlZnJlc2ggdGhlIHRva2VuIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJldHJ5YWJsZShhc3luYyAoYXR0ZW1wdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhdHRlbXB0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcCgyMDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0IC0gMSkpOyAvLyAyMDAsIDQwMCwgODAwLCAuLi5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAncmVmcmVzaGluZyBhdHRlbXB0JywgYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L3Rva2VuP2dyYW50X3R5cGU9cmVmcmVzaF90b2tlbmAsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogeyByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4gfSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogX3Nlc3Npb25SZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIChhdHRlbXB0LCBlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRCYWNrT2ZmSW50ZXJ2YWwgPSAyMDAgKiBNYXRoLnBvdygyLCBhdHRlbXB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIGlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IoZXJyb3IpICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHJ5YWJsZSBvbmx5IGlmIHRoZSByZXF1ZXN0IGNhbiBiZSBzZW50IGJlZm9yZSB0aGUgYmFja29mZiBvdmVyZmxvd3MgdGhlIHRpY2sgZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgRGF0ZS5ub3coKSArIG5leHRCYWNrT2ZmSW50ZXJ2YWwgLSBzdGFydGVkQXQgPCBBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbjogbnVsbCwgdXNlcjogbnVsbCB9LCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaXNWYWxpZFNlc3Npb24obWF5YmVTZXNzaW9uKSB7XG4gICAgICAgIGNvbnN0IGlzVmFsaWRTZXNzaW9uID0gdHlwZW9mIG1heWJlU2Vzc2lvbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIG1heWJlU2Vzc2lvbiAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgJ2FjY2Vzc190b2tlbicgaW4gbWF5YmVTZXNzaW9uICYmXG4gICAgICAgICAgICAncmVmcmVzaF90b2tlbicgaW4gbWF5YmVTZXNzaW9uICYmXG4gICAgICAgICAgICAnZXhwaXJlc19hdCcgaW4gbWF5YmVTZXNzaW9uO1xuICAgICAgICByZXR1cm4gaXNWYWxpZFNlc3Npb247XG4gICAgfVxuICAgIGFzeW5jIF9oYW5kbGVQcm92aWRlclNpZ25Jbihwcm92aWRlciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLl9nZXRVcmxGb3JQcm92aWRlcihgJHt0aGlzLnVybH0vYXV0aG9yaXplYCwgcHJvdmlkZXIsIHtcbiAgICAgICAgICAgIHJlZGlyZWN0VG86IG9wdGlvbnMucmVkaXJlY3RUbyxcbiAgICAgICAgICAgIHNjb3Blczogb3B0aW9ucy5zY29wZXMsXG4gICAgICAgICAgICBxdWVyeVBhcmFtczogb3B0aW9ucy5xdWVyeVBhcmFtcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX2hhbmRsZVByb3ZpZGVyU2lnbkluKCknLCAncHJvdmlkZXInLCBwcm92aWRlciwgJ29wdGlvbnMnLCBvcHRpb25zLCAndXJsJywgdXJsKTtcbiAgICAgICAgLy8gdHJ5IHRvIG9wZW4gb24gdGhlIGJyb3dzZXJcbiAgICAgICAgaWYgKGlzQnJvd3NlcigpICYmICFvcHRpb25zLnNraXBCcm93c2VyUmVkaXJlY3QpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhOiB7IHByb3ZpZGVyLCB1cmwgfSwgZXJyb3I6IG51bGwgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3ZlcnMgdGhlIHNlc3Npb24gZnJvbSBMb2NhbFN0b3JhZ2UgYW5kIHJlZnJlc2hlcyB0aGUgdG9rZW5cbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBpcyBhc3luYyB0byBhY2NvbW1vZGF0ZSBmb3IgQXN5bmNTdG9yYWdlIGUuZy4gaW4gUmVhY3QgbmF0aXZlLlxuICAgICAqL1xuICAgIGFzeW5jIF9yZWNvdmVyQW5kUmVmcmVzaCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgZGVidWdOYW1lID0gJyNfcmVjb3ZlckFuZFJlZnJlc2goKSc7XG4gICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2JlZ2luJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U2Vzc2lvbiA9IChhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50U2Vzc2lvbiAmJiB0aGlzLnVzZXJTdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1heWJlVXNlciA9IChhd2FpdCBnZXRJdGVtQXN5bmModGhpcy51c2VyU3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJykpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdG9yYWdlLmlzU2VydmVyICYmIE9iamVjdC5pcyh0aGlzLnN0b3JhZ2UsIHRoaXMudXNlclN0b3JhZ2UpICYmICFtYXliZVVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmFnZSBhbmQgdXNlclN0b3JhZ2UgYXJlIHRoZSBzYW1lIHN0b3JhZ2UgbWVkaXVtLCBmb3IgZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3cubG9jYWxTdG9yYWdlIGlmIHVzZXJTdG9yYWdlIGRvZXMgbm90IGhhdmUgdGhlIHVzZXIgZnJvbVxuICAgICAgICAgICAgICAgICAgICAvLyBzdG9yYWdlIHN0b3JlZCwgc3RvcmUgaXQgZmlyc3QgdGhlcmVieSBtaWdyYXRpbmcgdGhlIHVzZXIgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGZyb20gc3RvcmFnZSAtPiB1c2VyU3RvcmFnZVxuICAgICAgICAgICAgICAgICAgICBtYXliZVVzZXIgPSB7IHVzZXI6IGN1cnJlbnRTZXNzaW9uLnVzZXIgfTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc2V0SXRlbUFzeW5jKHRoaXMudXNlclN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSArICctdXNlcicsIG1heWJlVXNlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSAoX2EgPSBtYXliZVVzZXIgPT09IG51bGwgfHwgbWF5YmVVc2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXliZVVzZXIudXNlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdXNlck5vdEF2YWlsYWJsZVByb3h5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50U2Vzc2lvbiAmJiAhY3VycmVudFNlc3Npb24udXNlcikge1xuICAgICAgICAgICAgICAgIC8vIHVzZXIgc3RvcmFnZSBpcyBub3Qgc2V0LCBsZXQncyBjaGVjayBpZiBpdCB3YXMgcHJldmlvdXNseSBlbmFibGVkIHNvXG4gICAgICAgICAgICAgICAgLy8gd2UgYnJpbmcgYmFjayB0aGUgc3RvcmFnZSBhcyBpdCBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRTZXNzaW9uLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGVzdCBpZiB1c2VyU3RvcmFnZSB3YXMgcHJldmlvdXNseSBlbmFibGVkIGFuZCB0aGUgc3RvcmFnZSBtZWRpdW0gd2FzIHRoZSBzYW1lLCB0byBtb3ZlIHRoZSB1c2VyIGJhY2sgdW5kZXIgdGhlIHNhbWUga2V5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRlVXNlciA9IChhd2FpdCBnZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0ZVVzZXIgJiYgKHNlcGFyYXRlVXNlciA9PT0gbnVsbCB8fCBzZXBhcmF0ZVVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcGFyYXRlVXNlci51c2VyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNlc3Npb24udXNlciA9IHNlcGFyYXRlVXNlci51c2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXksIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIgPSB1c2VyTm90QXZhaWxhYmxlUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ3Nlc3Npb24gZnJvbSBzdG9yYWdlJywgY3VycmVudFNlc3Npb24pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pc1ZhbGlkU2Vzc2lvbihjdXJyZW50U2Vzc2lvbikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdzZXNzaW9uIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2Vzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4cGlyZXNXaXRoTWFyZ2luID0gKChfYiA9IGN1cnJlbnRTZXNzaW9uLmV4cGlyZXNfYXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IEluZmluaXR5KSAqIDEwMDAgLSBEYXRlLm5vdygpIDwgRVhQSVJZX01BUkdJTl9NUztcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgYHNlc3Npb24gaGFzJHtleHBpcmVzV2l0aE1hcmdpbiA/ICcnIDogJyBub3QnfSBleHBpcmVkIHdpdGggbWFyZ2luIG9mICR7RVhQSVJZX01BUkdJTl9NU31zYCk7XG4gICAgICAgICAgICBpZiAoZXhwaXJlc1dpdGhNYXJnaW4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdXRvUmVmcmVzaFRva2VuICYmIGN1cnJlbnRTZXNzaW9uLnJlZnJlc2hfdG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgdGhpcy5fY2FsbFJlZnJlc2hUb2tlbihjdXJyZW50U2Vzc2lvbi5yZWZyZXNoX3Rva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdyZWZyZXNoIGZhaWxlZCB3aXRoIGEgbm9uLXJldHJ5YWJsZSBlcnJvciwgcmVtb3ZpbmcgdGhlIHNlc3Npb24nLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fcmVtb3ZlU2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudFNlc3Npb24udXNlciAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnVzZXIuX19pc1VzZXJOb3RBdmFpbGFibGVQcm94eSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwcm94eSB1c2VyLCB0cnkgdG8gZ2V0IHRoZSByZWFsIHVzZXIgZGF0YVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3I6IHVzZXJFcnJvciB9ID0gYXdhaXQgdGhpcy5fZ2V0VXNlcihjdXJyZW50U2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXVzZXJFcnJvciAmJiAoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnVzZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2Vzc2lvbi51c2VyID0gZGF0YS51c2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2F2ZVNlc3Npb24oY3VycmVudFNlc3Npb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2NvdWxkIG5vdCBnZXQgdXNlciBkYXRhLCBza2lwcGluZyBTSUdORURfSU4gbm90aWZpY2F0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGdldFVzZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHVzZXIgZGF0YTonLCBnZXRVc2VyRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvciBnZXR0aW5nIHVzZXIgZGF0YSwgc2tpcHBpbmcgU0lHTkVEX0lOIG5vdGlmaWNhdGlvbicsIGdldFVzZXJFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBwZXJzaXN0IGN1cnJlbnRTZXNzaW9uIGFnYWluLCBhcyB3ZSBqdXN0IGxvYWRlZCBpdCBmcm9tXG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgc3RvcmFnZTsgcGVyc2lzdGluZyBpdCBhZ2FpbiBtYXkgb3ZlcndyaXRlIGEgdmFsdWUgc2F2ZWQgYnlcbiAgICAgICAgICAgICAgICAvLyBhbm90aGVyIGNsaWVudCB3aXRoIGFjY2VzcyB0byB0aGUgc2FtZSBsb2NhbCBzdG9yYWdlXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9JTicsIGN1cnJlbnRTZXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfY2FsbFJlZnJlc2hUb2tlbihyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFyZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlZnJlc2hpbmcgaXMgYWxyZWFkeSBpbiBwcm9ncmVzc1xuICAgICAgICBpZiAodGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlYnVnTmFtZSA9IGAjX2NhbGxSZWZyZXNoVG9rZW4oJHtyZWZyZXNoVG9rZW4uc3Vic3RyaW5nKDAsIDUpfS4uLilgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoaW5nRGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IHRoaXMuX3JlZnJlc2hBY2Nlc3NUb2tlbihyZWZyZXNoVG9rZW4pO1xuICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgaWYgKCFkYXRhLnNlc3Npb24pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yKCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zYXZlU2Vzc2lvbihkYXRhLnNlc3Npb24pO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1RPS0VOX1JFRlJFU0hFRCcsIGRhdGEuc2Vzc2lvbik7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IGRhdGE6IGRhdGEuc2Vzc2lvbiwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgaWYgKCFpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZW1vdmVTZXNzaW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucmVmcmVzaGluZ0RlZmVycmVkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSB0aGlzLnJlZnJlc2hpbmdEZWZlcnJlZCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaGluZ0RlZmVycmVkID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnKGRlYnVnTmFtZSwgJ2VuZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF9ub3RpZnlBbGxTdWJzY3JpYmVycyhldmVudCwgc2Vzc2lvbiwgYnJvYWRjYXN0ID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBkZWJ1Z05hbWUgPSBgI19ub3RpZnlBbGxTdWJzY3JpYmVycygke2V2ZW50fSlgO1xuICAgICAgICB0aGlzLl9kZWJ1ZyhkZWJ1Z05hbWUsICdiZWdpbicsIHNlc3Npb24sIGBicm9hZGNhc3QgPSAke2Jyb2FkY2FzdH1gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJyb2FkY2FzdENoYW5uZWwgJiYgYnJvYWRjYXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RDaGFubmVsLnBvc3RNZXNzYWdlKHsgZXZlbnQsIHNlc3Npb24gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gQXJyYXkuZnJvbSh0aGlzLnN0YXRlQ2hhbmdlRW1pdHRlcnMudmFsdWVzKCkpLm1hcChhc3luYyAoeCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHguY2FsbGJhY2soZXZlbnQsIHNlc3Npb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fZGVidWcoZGVidWdOYW1lLCAnZW5kJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0IGN1cnJlbnRTZXNzaW9uIGFuZCBjdXJyZW50VXNlclxuICAgICAqIHByb2Nlc3MgdG8gX3N0YXJ0QXV0b1JlZnJlc2hUb2tlbiBpZiBwb3NzaWJsZVxuICAgICAqL1xuICAgIGFzeW5jIF9zYXZlU2Vzc2lvbihzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3NhdmVTZXNzaW9uKCknLCBzZXNzaW9uKTtcbiAgICAgICAgLy8gX3NhdmVTZXNzaW9uIGlzIGFsd2F5cyBjYWxsZWQgd2hlbmV2ZXIgYSBuZXcgc2Vzc2lvbiBoYXMgYmVlbiBhY3F1aXJlZFxuICAgICAgICAvLyBzbyB3ZSBjYW4gc2FmZWx5IHN1cHByZXNzIHRoZSB3YXJuaW5nIHJldHVybmVkIGJ5IGZ1dHVyZSBnZXRTZXNzaW9uIGNhbGxzXG4gICAgICAgIHRoaXMuc3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyA9IHRydWU7XG4gICAgICAgIC8vIENyZWF0ZSBhIHNoYWxsb3cgY29weSB0byB3b3JrIHdpdGgsIHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbCBzZXNzaW9uIG9iamVjdCBpZiBpdCdzIHVzZWQgZWxzZXdoZXJlXG4gICAgICAgIGNvbnN0IHNlc3Npb25Ub1Byb2Nlc3MgPSBPYmplY3QuYXNzaWduKHt9LCBzZXNzaW9uKTtcbiAgICAgICAgY29uc3QgdXNlcklzUHJveHkgPSBzZXNzaW9uVG9Qcm9jZXNzLnVzZXIgJiYgc2Vzc2lvblRvUHJvY2Vzcy51c2VyLl9faXNVc2VyTm90QXZhaWxhYmxlUHJveHkgPT09IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnVzZXJTdG9yYWdlKSB7XG4gICAgICAgICAgICBpZiAoIXVzZXJJc1Byb3h5ICYmIHNlc3Npb25Ub1Byb2Nlc3MudXNlcikge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYSByZWFsIHVzZXIgb2JqZWN0LCBzYXZlIGl0IHRvIHVzZXJTdG9yYWdlLlxuICAgICAgICAgICAgICAgIGF3YWl0IHNldEl0ZW1Bc3luYyh0aGlzLnVzZXJTdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLXVzZXInLCB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXI6IHNlc3Npb25Ub1Byb2Nlc3MudXNlcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVzZXJJc1Byb3h5KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyB0aGUgcHJveHksIGl0IG1lYW5zIHVzZXIgd2FzIG5vdCBmb3VuZCBpbiB1c2VyU3RvcmFnZS5cbiAgICAgICAgICAgICAgICAvLyBXZSBzaG91bGQgZW5zdXJlIG5vIHN0YWxlIHVzZXIgZGF0YSBmb3IgdGhpcyBrZXkgZXhpc3RzIGluIHVzZXJTdG9yYWdlIGlmIHdlIHdlcmUgdG8gc2F2ZSBudWxsLFxuICAgICAgICAgICAgICAgIC8vIG9yIHNpbXBseSBub3Qgc2F2ZSB0aGUgcHJveHkuIEZvciBub3csIHdlIGRvbid0IHNhdmUgdGhlIHByb3h5IGhlcmUuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIG5lZWQgdG8gY2xlYXIgdXNlclN0b3JhZ2UgaWYgdXNlciBiZWNvbWVzIHByb3h5LCB0aGF0IGxvZ2ljIHdvdWxkIGdvIGhlcmUuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcmVwYXJlIHRoZSBtYWluIHNlc3Npb24gZGF0YSBmb3IgcHJpbWFyeSBzdG9yYWdlOiByZW1vdmUgdGhlIHVzZXIgcHJvcGVydHkgYmVmb3JlIGNsb25pbmdcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgdGhlIG9yaWdpbmFsIHNlc3Npb24udXNlciBtaWdodCBiZSB0aGUgcHJveHlcbiAgICAgICAgICAgIGNvbnN0IG1haW5TZXNzaW9uRGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIHNlc3Npb25Ub1Byb2Nlc3MpO1xuICAgICAgICAgICAgZGVsZXRlIG1haW5TZXNzaW9uRGF0YS51c2VyOyAvLyBSZW1vdmUgdXNlciAocmVhbCBvciBwcm94eSkgYmVmb3JlIGNsb25pbmcgZm9yIG1haW4gc3RvcmFnZVxuICAgICAgICAgICAgY29uc3QgY2xvbmVkTWFpblNlc3Npb25EYXRhID0gZGVlcENsb25lKG1haW5TZXNzaW9uRGF0YSk7XG4gICAgICAgICAgICBhd2FpdCBzZXRJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXksIGNsb25lZE1haW5TZXNzaW9uRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyB1c2VyU3RvcmFnZSBpcyBjb25maWd1cmVkLlxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlLCBzZXNzaW9uLnVzZXIgc2hvdWxkIGlkZWFsbHkgbm90IGJlIGEgcHJveHkuXG4gICAgICAgICAgICAvLyBJZiBpdCB3ZXJlLCBzdHJ1Y3R1cmVkQ2xvbmUgd291bGQgZmFpbC4gVGhpcyBpbXBsaWVzIGFuIGlzc3VlIGVsc2V3aGVyZSBpZiB1c2VyIGlzIGEgcHJveHkgaGVyZVxuICAgICAgICAgICAgY29uc3QgY2xvbmVkU2Vzc2lvbiA9IGRlZXBDbG9uZShzZXNzaW9uVG9Qcm9jZXNzKTsgLy8gc2Vzc2lvblRvUHJvY2VzcyBzdGlsbCBoYXMgaXRzIG9yaWdpbmFsIHVzZXIgcHJvcGVydHlcbiAgICAgICAgICAgIGF3YWl0IHNldEl0ZW1Bc3luYyh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSwgY2xvbmVkU2Vzc2lvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgX3JlbW92ZVNlc3Npb24oKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3JlbW92ZVNlc3Npb24oKScpO1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy5zdG9yYWdlLCB0aGlzLnN0b3JhZ2VLZXkgKyAnLWNvZGUtdmVyaWZpZXInKTtcbiAgICAgICAgYXdhaXQgcmVtb3ZlSXRlbUFzeW5jKHRoaXMuc3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJyk7XG4gICAgICAgIGlmICh0aGlzLnVzZXJTdG9yYWdlKSB7XG4gICAgICAgICAgICBhd2FpdCByZW1vdmVJdGVtQXN5bmModGhpcy51c2VyU3RvcmFnZSwgdGhpcy5zdG9yYWdlS2V5ICsgJy11c2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5fbm90aWZ5QWxsU3Vic2NyaWJlcnMoJ1NJR05FRF9PVVQnLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbnkgcmVnaXN0ZXJlZCB2aXNpYmlsaXR5Y2hhbmdlIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICoge0BzZWUgI3N0YXJ0QXV0b1JlZnJlc2h9XG4gICAgICoge0BzZWUgI3N0b3BBdXRvUmVmcmVzaH1cbiAgICAgKi9cbiAgICBfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfcmVtb3ZlVmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjaygpJyk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy52aXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrO1xuICAgICAgICB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICYmIGlzQnJvd3NlcigpICYmICh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcigncmVtb3ZpbmcgdmlzaWJpbGl0eWNoYW5nZSBjYWxsYmFjayBmYWlsZWQnLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIHRoZSBwcml2YXRlIGltcGxlbWVudGF0aW9uIG9mIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0uIFVzZSB0aGlzXG4gICAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGFzeW5jIF9zdGFydEF1dG9SZWZyZXNoKCkge1xuICAgICAgICBhd2FpdCB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfc3RhcnRBdXRvUmVmcmVzaCgpJyk7XG4gICAgICAgIGNvbnN0IHRpY2tlciA9IHNldEludGVydmFsKCgpID0+IHRoaXMuX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCksIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TKTtcbiAgICAgICAgdGhpcy5hdXRvUmVmcmVzaFRpY2tlciA9IHRpY2tlcjtcbiAgICAgICAgaWYgKHRpY2tlciAmJiB0eXBlb2YgdGlja2VyID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGlja2VyLnVucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyB0aWNrZXIgaXMgYSBOb2RlSlMgVGltZW91dCBvYmplY3QgdGhhdCBoYXMgYW4gYHVucmVmYCBtZXRob2RcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvdGltZXJzLmh0bWwjdGltZW91dHVucmVmXG4gICAgICAgICAgICAvLyBXaGVuIGF1dG8gcmVmcmVzaCBpcyB1c2VkIGluIE5vZGVKUyAobGlrZSBmb3IgdGVzdGluZykgdGhlXG4gICAgICAgICAgICAvLyBgc2V0SW50ZXJ2YWxgIGlzIHByZXZlbnRpbmcgdGhlIHByb2Nlc3MgZnJvbSBiZWluZyBtYXJrZWQgYXNcbiAgICAgICAgICAgIC8vIGZpbmlzaGVkIGFuZCB0ZXN0cyBydW4gZW5kbGVzc2x5LiBUaGlzIGNhbiBiZSBwcmV2ZW50ZWQgYnkgY2FsbGluZ1xuICAgICAgICAgICAgLy8gYHVucmVmKClgIG9uIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gICAgICAgICAgICB0aWNrZXIudW5yZWYoKTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMgaGFzIG5vIGNvbnRleHQgb2YgRGVub1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgRGVuby51bnJlZlRpbWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBzaW1pbGFyIGxpa2UgZm9yIE5vZGVKUywgYnV0IHdpdGggdGhlIERlbm8gQVBJXG4gICAgICAgICAgICAvLyBodHRwczovL2Rlbm8ubGFuZC9hcGlAbGF0ZXN0P3Vuc3RhYmxlJnM9RGVuby51bnJlZlRpbWVyXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTIGhhcyBubyBjb250ZXh0IG9mIERlbm9cbiAgICAgICAgICAgIERlbm8udW5yZWZUaW1lcih0aWNrZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJ1biB0aGUgdGljayBpbW1lZGlhdGVseSwgYnV0IGluIHRoZSBuZXh0IHBhc3Mgb2YgdGhlIGV2ZW50IGxvb3Agc28gdGhhdFxuICAgICAgICAvLyAjX2luaXRpYWxpemUgY2FuIGJlIGFsbG93ZWQgdG8gY29tcGxldGUgd2l0aG91dCByZWN1cnNpdmVseSB3YWl0aW5nIG9uXG4gICAgICAgIC8vIGl0c2VsZlxuICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hdXRvUmVmcmVzaFRva2VuVGljaygpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgcHJpdmF0ZSBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgI3N0b3BBdXRvUmVmcmVzaH0uIFVzZSB0aGlzXG4gICAgICogd2l0aGluIHRoZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIGFzeW5jIF9zdG9wQXV0b1JlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuX2RlYnVnKCcjX3N0b3BBdXRvUmVmcmVzaCgpJyk7XG4gICAgICAgIGNvbnN0IHRpY2tlciA9IHRoaXMuYXV0b1JlZnJlc2hUaWNrZXI7XG4gICAgICAgIHRoaXMuYXV0b1JlZnJlc2hUaWNrZXIgPSBudWxsO1xuICAgICAgICBpZiAodGlja2VyKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRpY2tlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGFuIGF1dG8tcmVmcmVzaCBwcm9jZXNzIGluIHRoZSBiYWNrZ3JvdW5kLiBUaGUgc2Vzc2lvbiBpcyBjaGVja2VkXG4gICAgICogZXZlcnkgZmV3IHNlY29uZHMuIENsb3NlIHRvIHRoZSB0aW1lIG9mIGV4cGlyYXRpb24gYSBwcm9jZXNzIGlzIHN0YXJ0ZWQgdG9cbiAgICAgKiByZWZyZXNoIHRoZSBzZXNzaW9uLiBJZiByZWZyZXNoaW5nIGZhaWxzIGl0IHdpbGwgYmUgcmV0cmllZCBmb3IgYXMgbG9uZyBhc1xuICAgICAqIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBzZXQgdGhlIHtAbGluayBHb1RydWVDbGllbnRPcHRpb25zI2F1dG9SZWZyZXNoVG9rZW59IHlvdSBkb24ndCBuZWVkXG4gICAgICogdG8gY2FsbCB0aGlzIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCBmb3IgeW91LlxuICAgICAqXG4gICAgICogT24gYnJvd3NlcnMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyBvbmx5IHdoZW4gdGhlIHRhYi93aW5kb3cgaXMgaW4gdGhlXG4gICAgICogZm9yZWdyb3VuZCB0byBjb25zZXJ2ZSByZXNvdXJjZXMgYXMgd2VsbCBhcyBwcmV2ZW50IHJhY2UgY29uZGl0aW9ucyBhbmRcbiAgICAgKiBmbG9vZGluZyBhdXRoIHdpdGggcmVxdWVzdHMuIElmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIGFueSBtYW5hZ2VkXG4gICAgICogdmlzaWJpbGl0eSBjaGFuZ2UgY2FsbGJhY2sgd2lsbCBiZSByZW1vdmVkIGFuZCB5b3UgbXVzdCBtYW5hZ2UgdmlzaWJpbGl0eVxuICAgICAqIGNoYW5nZXMgb24geW91ciBvd24uXG4gICAgICpcbiAgICAgKiBPbiBub24tYnJvd3NlciBwbGF0Zm9ybXMgdGhlIHJlZnJlc2ggcHJvY2VzcyB3b3JrcyAqY29udGludW91c2x5KiBpbiB0aGVcbiAgICAgKiBiYWNrZ3JvdW5kLCB3aGljaCBtYXkgbm90IGJlIGRlc2lyYWJsZS4gWW91IHNob3VsZCBob29rIGludG8geW91clxuICAgICAqIHBsYXRmb3JtJ3MgZm9yZWdyb3VuZCBpbmRpY2F0aW9uIG1lY2hhbmlzbSBhbmQgY2FsbCB0aGVzZSBtZXRob2RzXG4gICAgICogYXBwcm9wcmlhdGVseSB0byBjb25zZXJ2ZSByZXNvdXJjZXMuXG4gICAgICpcbiAgICAgKiB7QHNlZSAjc3RvcEF1dG9SZWZyZXNofVxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0QXV0b1JlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RhcnRBdXRvUmVmcmVzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wcyBhbiBhY3RpdmUgYXV0byByZWZyZXNoIHByb2Nlc3MgcnVubmluZyBpbiB0aGUgYmFja2dyb3VuZCAoaWYgYW55KS5cbiAgICAgKlxuICAgICAqIElmIHlvdSBjYWxsIHRoaXMgbWV0aG9kIGFueSBtYW5hZ2VkIHZpc2liaWxpdHkgY2hhbmdlIGNhbGxiYWNrIHdpbGwgYmVcbiAgICAgKiByZW1vdmVkIGFuZCB5b3UgbXVzdCBtYW5hZ2UgdmlzaWJpbGl0eSBjaGFuZ2VzIG9uIHlvdXIgb3duLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayAjc3RhcnRBdXRvUmVmcmVzaH0gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKi9cbiAgICBhc3luYyBzdG9wQXV0b1JlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2soKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fc3RvcEF1dG9SZWZyZXNoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIGF1dG8gcmVmcmVzaCB0b2tlbiB0aWNrLlxuICAgICAqL1xuICAgIGFzeW5jIF9hdXRvUmVmcmVzaFRva2VuVGljaygpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdiZWdpbicpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soMCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24gfHwgIXNlc3Npb24ucmVmcmVzaF90b2tlbiB8fCAhc2Vzc2lvbi5leHBpcmVzX2F0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlYnVnKCcjX2F1dG9SZWZyZXNoVG9rZW5UaWNrKCknLCAnbm8gc2Vzc2lvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlc3Npb24gd2lsbCBleHBpcmUgaW4gdGhpcyBtYW55IHRpY2tzIChvciBoYXMgYWxyZWFkeSBleHBpcmVkIGlmIDw9IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luVGlja3MgPSBNYXRoLmZsb29yKChzZXNzaW9uLmV4cGlyZXNfYXQgKiAxMDAwIC0gbm93KSAvIEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnI19hdXRvUmVmcmVzaFRva2VuVGljaygpJywgYGFjY2VzcyB0b2tlbiBleHBpcmVzIGluICR7ZXhwaXJlc0luVGlja3N9IHRpY2tzLCBhIHRpY2sgbGFzdHMgJHtBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NU31tcywgcmVmcmVzaCB0aHJlc2hvbGQgaXMgJHtBVVRPX1JFRlJFU0hfVElDS19USFJFU0hPTER9IHRpY2tzYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGlyZXNJblRpY2tzIDw9IEFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9jYWxsUmVmcmVzaFRva2VuKHNlc3Npb24ucmVmcmVzaF90b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F1dG8gcmVmcmVzaCB0aWNrIGZhaWxlZCB3aXRoIGVycm9yLiBUaGlzIGlzIGxpa2VseSBhIHRyYW5zaWVudCBlcnJvci4nLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVidWcoJyNfYXV0b1JlZnJlc2hUb2tlblRpY2soKScsICdlbmQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUuaXNBY3F1aXJlVGltZW91dCB8fCBlIGluc3RhbmNlb2YgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZygnYXV0byByZWZyZXNoIHRva2VuIHRpY2sgbG9jayBub3QgYXZhaWxhYmxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBjYWxsYmFja3Mgb24gdGhlIGJyb3dzZXIgLyBwbGF0Zm9ybSwgd2hpY2ggaW4tdHVybiBydW5cbiAgICAgKiBhbGdvcml0aG1zIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93L3RhYiBhcmUgaW4gZm9yZWdyb3VuZC4gT24gbm9uLWJyb3dzZXJcbiAgICAgKiBwbGF0Zm9ybXMgaXQgYXNzdW1lcyBhbHdheXMgZm9yZWdyb3VuZC5cbiAgICAgKi9cbiAgICBhc3luYyBfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5fZGVidWcoJyNfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZSgpJyk7XG4gICAgICAgIGlmICghaXNCcm93c2VyKCkgfHwgISh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBub24tYnJvd3NlciBlbnZpcm9ubWVudHMgdGhlIHJlZnJlc2ggdG9rZW4gdGlja2VyIHJ1bnMgYWx3YXlzXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEF1dG9SZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayA9IGFzeW5jICgpID0+IGF3YWl0IHRoaXMuX29uVmlzaWJpbGl0eUNoYW5nZWQoZmFsc2UpO1xuICAgICAgICAgICAgd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLnZpc2liaWxpdHlDaGFuZ2VkQ2FsbGJhY2spO1xuICAgICAgICAgICAgLy8gbm93IGltbWVkaWF0ZWx5IGNhbGwgdGhlIHZpc2JpbGl0eSBjaGFuZ2VkIGNhbGxiYWNrIHRvIHNldHVwIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IHZpc2JpbGl0eSBzdGF0ZVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlZCh0cnVlKTsgLy8gaW5pdGlhbCBjYWxsXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdfaGFuZGxlVmlzaWJpbGl0eUNoYW5nZScsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayByZWdpc3RlcmVkIHdpdGggYHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJylgLlxuICAgICAqL1xuICAgIGFzeW5jIF9vblZpc2liaWxpdHlDaGFuZ2VkKGNhbGxlZEZyb21Jbml0aWFsaXplKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZE5hbWUgPSBgI19vblZpc2liaWxpdHlDaGFuZ2VkKCR7Y2FsbGVkRnJvbUluaXRpYWxpemV9KWA7XG4gICAgICAgIHRoaXMuX2RlYnVnKG1ldGhvZE5hbWUsICd2aXNpYmlsaXR5U3RhdGUnLCBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUpO1xuICAgICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAndmlzaWJsZScpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBicm93c2VyIGVudmlyb25tZW50cyB0aGUgcmVmcmVzaCB0b2tlbiB0aWNrZXIgcnVucyBvbmx5IG9uIGZvY3VzZWQgdGFic1xuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHByZXZlbnRzIHJhY2UgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0QXV0b1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2FsbGVkRnJvbUluaXRpYWxpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGUgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCwgaS5lLiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIC8vIHRyYW5zaXRpb25lZCBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlIHNvIHdlIG5lZWQgdG8gc2VlIGlmIHRoZSBzZXNzaW9uXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIHJlY292ZXJlZCBpbW1lZGlhdGVseS4uLiBidXQgdG8gZG8gdGhhdCB3ZSBuZWVkIHRvIGFjcXVpcmVcbiAgICAgICAgICAgICAgICAvLyB0aGUgbG9jayBmaXJzdCBhc3luY2hyb25vdXNseVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZVByb21pc2U7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fYWNxdWlyZUxvY2soLTEsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSAhPT0gJ3Zpc2libGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWJ1ZyhtZXRob2ROYW1lLCAnYWNxdWlyZWQgdGhlIGxvY2sgdG8gcmVjb3ZlciB0aGUgc2Vzc2lvbiwgYnV0IHRoZSBicm93c2VyIHZpc2liaWxpdHlTdGF0ZSBpcyBubyBsb25nZXIgdmlzaWJsZSwgYWJvcnRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQgd2hpbGUgd2FpdGluZyBmb3IgdGhlIGxvY2ssIGFib3J0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVjb3ZlciB0aGUgc2Vzc2lvblxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9yZWNvdmVyQW5kUmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9SZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdG9wQXV0b1JlZnJlc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgdGhlIHJlbGV2YW50IGxvZ2luIFVSTCBmb3IgYSB0aGlyZC1wYXJ0eSBwcm92aWRlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFRvIEEgVVJMIG9yIG1vYmlsZSBhZGRyZXNzIHRvIHNlbmQgdGhlIHVzZXIgdG8gYWZ0ZXIgdGhleSBhcmUgY29uZmlybWVkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNjb3BlcyBBIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHNjb3BlcyBncmFudGVkIHRvIHRoZSBPQXV0aCBhcHBsaWNhdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5xdWVyeVBhcmFtcyBBbiBvYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIGNvbnRhaW5pbmcgcXVlcnkgcGFyYW1ldGVycyBncmFudGVkIHRvIHRoZSBPQXV0aCBhcHBsaWNhdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0VXJsRm9yUHJvdmlkZXIodXJsLCBwcm92aWRlciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBbYHByb3ZpZGVyPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHByb3ZpZGVyKX1gXTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZWRpcmVjdFRvKSB7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChgcmVkaXJlY3RfdG89JHtlbmNvZGVVUklDb21wb25lbnQob3B0aW9ucy5yZWRpcmVjdFRvKX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjb3Blcykge1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2goYHNjb3Blcz0ke2VuY29kZVVSSUNvbXBvbmVudChvcHRpb25zLnNjb3Blcyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmxvd1R5cGUgPT09ICdwa2NlJykge1xuICAgICAgICAgICAgY29uc3QgW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdID0gYXdhaXQgZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCh0aGlzLnN0b3JhZ2UsIHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgICAgICBjb25zdCBmbG93UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgY29kZV9jaGFsbGVuZ2U6IGAke2VuY29kZVVSSUNvbXBvbmVudChjb2RlQ2hhbGxlbmdlKX1gLFxuICAgICAgICAgICAgICAgIGNvZGVfY2hhbGxlbmdlX21ldGhvZDogYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvZGVDaGFsbGVuZ2VNZXRob2QpfWAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVybFBhcmFtcy5wdXNoKGZsb3dQYXJhbXMudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5xdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdGlvbnMucXVlcnlQYXJhbXMpO1xuICAgICAgICAgICAgdXJsUGFyYW1zLnB1c2gocXVlcnkudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSB7XG4gICAgICAgICAgICB1cmxQYXJhbXMucHVzaChgc2tpcF9odHRwX3JlZGlyZWN0PSR7b3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt1cmx9PyR7dXJsUGFyYW1zLmpvaW4oJyYnKX1gO1xuICAgIH1cbiAgICBhc3luYyBfdW5lbnJvbGwocGFyYW1zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogc2Vzc2lvbkRhdGEsIGVycm9yOiBzZXNzaW9uRXJyb3IgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdERUxFVEUnLCBgJHt0aGlzLnVybH0vZmFjdG9ycy8ke3BhcmFtcy5mYWN0b3JJZH1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiAoX2EgPSBzZXNzaW9uRGF0YSA9PT0gbnVsbCB8fCBzZXNzaW9uRGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2Vzc2lvbkRhdGEuc2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBfZW5yb2xsKHBhcmFtcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VzZVNlc3Npb24oYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gT2JqZWN0LmFzc2lnbih7IGZyaWVuZGx5X25hbWU6IHBhcmFtcy5mcmllbmRseU5hbWUsIGZhY3Rvcl90eXBlOiBwYXJhbXMuZmFjdG9yVHlwZSB9LCAocGFyYW1zLmZhY3RvclR5cGUgPT09ICdwaG9uZSdcbiAgICAgICAgICAgICAgICAgICAgPyB7IHBob25lOiBwYXJhbXMucGhvbmUgfVxuICAgICAgICAgICAgICAgICAgICA6IHBhcmFtcy5mYWN0b3JUeXBlID09PSAndG90cCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBpc3N1ZXI6IHBhcmFtcy5pc3N1ZXIgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IChhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9mYWN0b3JzYCwge1xuICAgICAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogKF9hID0gc2Vzc2lvbkRhdGEgPT09IG51bGwgfHwgc2Vzc2lvbkRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb25EYXRhLnNlc3Npb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZhY3RvclR5cGUgPT09ICd0b3RwJyAmJiBkYXRhLnR5cGUgPT09ICd0b3RwJyAmJiAoKF9iID0gZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnRvdHApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5xcl9jb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnRvdHAucXJfY29kZSA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7dXRmLTgsJHtkYXRhLnRvdHAucXJfY29kZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIF92ZXJpZnkocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3F1aXJlTG9jaygtMSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBzZXNzaW9uRGF0YSwgZXJyb3I6IHNlc3Npb25FcnJvciB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogc2Vzc2lvbkVycm9yIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IE9iamVjdC5hc3NpZ24oeyBjaGFsbGVuZ2VfaWQ6IHBhcmFtcy5jaGFsbGVuZ2VJZCB9LCAoJ3dlYmF1dGhuJyBpbiBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlYmF1dGhuOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcy53ZWJhdXRobiksIHsgY3JlZGVudGlhbF9yZXNwb25zZTogcGFyYW1zLndlYmF1dGhuLnR5cGUgPT09ICdjcmVhdGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlcmlhbGl6ZUNyZWRlbnRpYWxDcmVhdGlvblJlc3BvbnNlKHBhcmFtcy53ZWJhdXRobi5jcmVkZW50aWFsX3Jlc3BvbnNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdFJlc3BvbnNlKHBhcmFtcy53ZWJhdXRobi5jcmVkZW50aWFsX3Jlc3BvbnNlKSB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogeyBjb2RlOiBwYXJhbXMuY29kZSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L2ZhY3RvcnMvJHtwYXJhbXMuZmFjdG9ySWR9L3ZlcmlmeWAsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NhdmVTZXNzaW9uKE9iamVjdC5hc3NpZ24oeyBleHBpcmVzX2F0OiBNYXRoLnJvdW5kKERhdGUubm93KCkgLyAxMDAwKSArIGRhdGEuZXhwaXJlc19pbiB9LCBkYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX25vdGlmeUFsbFN1YnNjcmliZXJzKCdNRkFfQ0hBTExFTkdFX1ZFUklGSUVEJywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgX2NoYWxsZW5nZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjcXVpcmVMb2NrKC0xLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHNlc3Npb25EYXRhLCBlcnJvcjogc2Vzc2lvbkVycm9yIH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IChhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnUE9TVCcsIGAke3RoaXMudXJsfS9mYWN0b3JzLyR7cGFyYW1zLmZhY3RvcklkfS9jaGFsbGVuZ2VgLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBqd3Q6IChfYSA9IHNlc3Npb25EYXRhID09PSBudWxsIHx8IHNlc3Npb25EYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXNzaW9uRGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgIT09ICd3ZWJhdXRobicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChkYXRhLndlYmF1dGhuLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NyZWF0ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhKSwgeyB3ZWJhdXRobjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhLndlYmF1dGhuKSwgeyBjcmVkZW50aWFsX29wdGlvbnM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGF0YS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMpLCB7IHB1YmxpY0tleTogZGVzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zKGRhdGEud2ViYXV0aG4uY3JlZGVudGlhbF9vcHRpb25zLnB1YmxpY0tleSkgfSkgfSkgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyZXF1ZXN0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEpLCB7IHdlYmF1dGhuOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRhdGEud2ViYXV0aG4pLCB7IGNyZWRlbnRpYWxfb3B0aW9uczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXRhLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucyksIHsgcHVibGljS2V5OiBkZXNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyhkYXRhLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucy5wdWJsaWNLZXkpIH0pIH0pIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BzZWUgR29UcnVlTUZBQXBpI2NoYWxsZW5nZUFuZFZlcmlmeX1cbiAgICAgKi9cbiAgICBhc3luYyBfY2hhbGxlbmdlQW5kVmVyaWZ5KHBhcmFtcykge1xuICAgICAgICAvLyBib3RoIF9jaGFsbGVuZ2UgYW5kIF92ZXJpZnkgaW5kZXBlbmRlbnRseSBhY3F1aXJlIHRoZSBsb2NrLCBzbyBubyBuZWVkXG4gICAgICAgIC8vIHRvIGFjcXVpcmUgaXQgaGVyZVxuICAgICAgICBjb25zdCB7IGRhdGE6IGNoYWxsZW5nZURhdGEsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9ID0gYXdhaXQgdGhpcy5fY2hhbGxlbmdlKHtcbiAgICAgICAgICAgIGZhY3RvcklkOiBwYXJhbXMuZmFjdG9ySWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2hhbGxlbmdlRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl92ZXJpZnkoe1xuICAgICAgICAgICAgZmFjdG9ySWQ6IHBhcmFtcy5mYWN0b3JJZCxcbiAgICAgICAgICAgIGNoYWxsZW5nZUlkOiBjaGFsbGVuZ2VEYXRhLmlkLFxuICAgICAgICAgICAgY29kZTogcGFyYW1zLmNvZGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QHNlZSBHb1RydWVNRkFBcGkjbGlzdEZhY3RvcnN9XG4gICAgICovXG4gICAgYXN5bmMgX2xpc3RGYWN0b3JzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIHVzZSAjZ2V0VXNlciBpbnN0ZWFkIG9mICNfZ2V0VXNlciBhcyB0aGUgZm9ybWVyIGFjcXVpcmVzIGEgbG9ja1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogdXNlckVycm9yLCB9ID0gYXdhaXQgdGhpcy5nZXRVc2VyKCk7XG4gICAgICAgIGlmICh1c2VyRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiB1c2VyRXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgYWxsOiBbXSxcbiAgICAgICAgICAgIHBob25lOiBbXSxcbiAgICAgICAgICAgIHRvdHA6IFtdLFxuICAgICAgICAgICAgd2ViYXV0aG46IFtdLFxuICAgICAgICB9O1xuICAgICAgICAvLyBsb29wIG92ZXIgdGhlIGZhY3RvcnMgT05DRVxuICAgICAgICBmb3IgKGNvbnN0IGZhY3RvciBvZiAoX2EgPSB1c2VyID09PSBudWxsIHx8IHVzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVzZXIuZmFjdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pIHtcbiAgICAgICAgICAgIGRhdGEuYWxsLnB1c2goZmFjdG9yKTtcbiAgICAgICAgICAgIGlmIChmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnKSB7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGRhdGFbZmFjdG9yLmZhY3Rvcl90eXBlXS5wdXNoKGZhY3Rvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICoge0BzZWUgR29UcnVlTUZBQXBpI2dldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbH1cbiAgICAgKi9cbiAgICBhc3luYyBfZ2V0QXV0aGVudGljYXRvckFzc3VyYW5jZUxldmVsKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogc2Vzc2lvbkVycm9yLCB9ID0gYXdhaXQgdGhpcy5nZXRTZXNzaW9uKCk7XG4gICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogeyBjdXJyZW50TGV2ZWw6IG51bGwsIG5leHRMZXZlbDogbnVsbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kczogW10gfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwYXlsb2FkIH0gPSBkZWNvZGVKV1Qoc2Vzc2lvbi5hY2Nlc3NfdG9rZW4pO1xuICAgICAgICBsZXQgY3VycmVudExldmVsID0gbnVsbDtcbiAgICAgICAgaWYgKHBheWxvYWQuYWFsKSB7XG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBwYXlsb2FkLmFhbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dExldmVsID0gY3VycmVudExldmVsO1xuICAgICAgICBjb25zdCB2ZXJpZmllZEZhY3RvcnMgPSAoX2IgPSAoX2EgPSBzZXNzaW9uLnVzZXIuZmFjdG9ycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcigoZmFjdG9yKSA9PiBmYWN0b3Iuc3RhdHVzID09PSAndmVyaWZpZWQnKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW107XG4gICAgICAgIGlmICh2ZXJpZmllZEZhY3RvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbmV4dExldmVsID0gJ2FhbDInO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBdXRoZW50aWNhdGlvbk1ldGhvZHMgPSBwYXlsb2FkLmFtciB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBjdXJyZW50TGV2ZWwsIG5leHRMZXZlbCwgY3VycmVudEF1dGhlbnRpY2F0aW9uTWV0aG9kcyB9LCBlcnJvcjogbnVsbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgZGV0YWlscyBhYm91dCBhbiBPQXV0aCBhdXRob3JpemF0aW9uIHJlcXVlc3QuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYXV0aG9yaXphdGlvbiBkZXRhaWxzIGluY2x1ZGluZyBjbGllbnQgaW5mbywgc2NvcGVzLCBhbmQgdXNlciBpbmZvcm1hdGlvbi5cbiAgICAgKiBJZiB0aGUgQVBJIHJldHVybnMgYSByZWRpcmVjdF91cmksIGl0IG1lYW5zIGNvbnNlbnQgd2FzIGFscmVhZHkgZ2l2ZW4gLSB0aGUgY2FsbGVyXG4gICAgICogc2hvdWxkIGhhbmRsZSB0aGUgcmVkaXJlY3QgbWFudWFsbHkgaWYgbmVlZGVkLlxuICAgICAqL1xuICAgIGFzeW5jIF9nZXRBdXRob3JpemF0aW9uRGV0YWlscyhhdXRob3JpemF0aW9uSWQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogc2Vzc2lvbkVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9L29hdXRoL2F1dGhvcml6YXRpb25zLyR7YXV0aG9yaXphdGlvbklkfWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBqd3Q6IHNlc3Npb24uYWNjZXNzX3Rva2VuLFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogKGRhdGEpID0+ICh7IGRhdGEsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcHJvdmVzIGFuIE9BdXRoIGF1dGhvcml6YXRpb24gcmVxdWVzdC5cbiAgICAgKiBPbmx5IHJlbGV2YW50IHdoZW4gdGhlIE9BdXRoIDIuMSBzZXJ2ZXIgaXMgZW5hYmxlZCBpbiBTdXBhYmFzZSBBdXRoLlxuICAgICAqL1xuICAgIGFzeW5jIF9hcHByb3ZlQXV0aG9yaXphdGlvbihhdXRob3JpemF0aW9uSWQsIG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl91c2VTZXNzaW9uKGFzeW5jIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGE6IHsgc2Vzc2lvbiB9LCBlcnJvcjogc2Vzc2lvbkVycm9yLCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChzZXNzaW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IHNlc3Npb25FcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX3JlcXVlc3QodGhpcy5mZXRjaCwgJ1BPU1QnLCBgJHt0aGlzLnVybH0vb2F1dGgvYXV0aG9yaXphdGlvbnMvJHthdXRob3JpemF0aW9uSWR9L2NvbnNlbnRgLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgand0OiBzZXNzaW9uLmFjY2Vzc190b2tlbixcbiAgICAgICAgICAgICAgICAgICAgYm9keTogeyBhY3Rpb246ICdhcHByb3ZlJyB9LFxuICAgICAgICAgICAgICAgICAgICB4Zm9ybTogKGRhdGEpID0+ICh7IGRhdGEsIGVycm9yOiBudWxsIH0pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5kYXRhICYmIHJlc3BvbnNlLmRhdGEucmVkaXJlY3RfdXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgcmVkaXJlY3QgaW4gYnJvd3NlciB1bmxlc3Mgc2tpcEJyb3dzZXJSZWRpcmVjdCBpcyB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jyb3dzZXIoKSAmJiAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5za2lwQnJvd3NlclJlZGlyZWN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbihyZXNwb25zZS5kYXRhLnJlZGlyZWN0X3VybCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbmllcyBhbiBPQXV0aCBhdXRob3JpemF0aW9uIHJlcXVlc3QuXG4gICAgICogT25seSByZWxldmFudCB3aGVuIHRoZSBPQXV0aCAyLjEgc2VydmVyIGlzIGVuYWJsZWQgaW4gU3VwYWJhc2UgQXV0aC5cbiAgICAgKi9cbiAgICBhc3luYyBfZGVueUF1dGhvcml6YXRpb24oYXV0aG9yaXphdGlvbklkLCBvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXNlU2Vzc2lvbihhc3luYyAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhOiB7IHNlc3Npb24gfSwgZXJyb3I6IHNlc3Npb25FcnJvciwgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Vzc2lvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBzZXNzaW9uRXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yOiBuZXcgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IoKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IF9yZXF1ZXN0KHRoaXMuZmV0Y2gsICdQT1NUJywgYCR7dGhpcy51cmx9L29hdXRoL2F1dGhvcml6YXRpb25zLyR7YXV0aG9yaXphdGlvbklkfS9jb25zZW50YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGp3dDogc2Vzc2lvbi5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHsgYWN0aW9uOiAnZGVueScgfSxcbiAgICAgICAgICAgICAgICAgICAgeGZvcm06IChkYXRhKSA9PiAoeyBkYXRhLCBlcnJvcjogbnVsbCB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLnJlZGlyZWN0X3VybCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IHJlZGlyZWN0IGluIGJyb3dzZXIgdW5sZXNzIHNraXBCcm93c2VyUmVkaXJlY3QgaXMgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNCcm93c2VyKCkgJiYgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2tpcEJyb3dzZXJSZWRpcmVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24ocmVzcG9uc2UuZGF0YS5yZWRpcmVjdF91cmwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGlzQXV0aEVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmZXRjaEp3ayhraWQsIGp3a3MgPSB7IGtleXM6IFtdIH0pIHtcbiAgICAgICAgLy8gdHJ5IGZldGNoaW5nIGZyb20gdGhlIHN1cHBsaWVkIGp3a3NcbiAgICAgICAgbGV0IGp3ayA9IGp3a3Mua2V5cy5maW5kKChrZXkpID0+IGtleS5raWQgPT09IGtpZCk7XG4gICAgICAgIGlmIChqd2spIHtcbiAgICAgICAgICAgIHJldHVybiBqd2s7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgLy8gdHJ5IGZldGNoaW5nIGZyb20gY2FjaGVcbiAgICAgICAgandrID0gdGhpcy5qd2tzLmtleXMuZmluZCgoa2V5KSA9PiBrZXkua2lkID09PSBraWQpO1xuICAgICAgICAvLyBqd2sgZXhpc3RzIGFuZCBqd2tzIGlzbid0IHN0YWxlXG4gICAgICAgIGlmIChqd2sgJiYgdGhpcy5qd2tzX2NhY2hlZF9hdCArIEpXS1NfVFRMID4gbm93KSB7XG4gICAgICAgICAgICByZXR1cm4gandrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGp3ayBpc24ndCBjYWNoZWQgaW4gbWVtb3J5IHNvIHdlIG5lZWQgdG8gZmV0Y2ggaXQgZnJvbSB0aGUgd2VsbC1rbm93biBlbmRwb2ludFxuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBfcmVxdWVzdCh0aGlzLmZldGNoLCAnR0VUJywgYCR7dGhpcy51cmx9Ly53ZWxsLWtub3duL2p3a3MuanNvbmAsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhLmtleXMgfHwgZGF0YS5rZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5qd2tzID0gZGF0YTtcbiAgICAgICAgdGhpcy5qd2tzX2NhY2hlZF9hdCA9IG5vdztcbiAgICAgICAgLy8gRmluZCB0aGUgc2lnbmluZyBrZXlcbiAgICAgICAgandrID0gZGF0YS5rZXlzLmZpbmQoKGtleSkgPT4ga2V5LmtpZCA9PT0ga2lkKTtcbiAgICAgICAgaWYgKCFqd2spIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqd2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBKV1QgY2xhaW1zIHByZXNlbnQgaW4gdGhlIGFjY2VzcyB0b2tlbiBieSBmaXJzdCB2ZXJpZnlpbmcgdGhlXG4gICAgICogSldUIGFnYWluc3QgdGhlIHNlcnZlcidzIEpTT04gV2ViIEtleSBTZXQgZW5kcG9pbnRcbiAgICAgKiBgLy53ZWxsLWtub3duL2p3a3MuanNvbmAgd2hpY2ggaXMgb2Z0ZW4gY2FjaGVkLCByZXN1bHRpbmcgaW4gc2lnbmlmaWNhbnRseVxuICAgICAqIGZhc3RlciByZXNwb25zZXMuIFByZWZlciB0aGlzIG1ldGhvZCBvdmVyIHtAbGluayAjZ2V0VXNlcn0gd2hpY2ggYWx3YXlzXG4gICAgICogc2VuZHMgYSByZXF1ZXN0IHRvIHRoZSBBdXRoIHNlcnZlciBmb3IgZWFjaCBKV1QuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgcHJvamVjdCBpcyBub3QgdXNpbmcgYW4gYXN5bW1ldHJpYyBKV1Qgc2lnbmluZyBrZXkgKGxpa2UgRUNDIG9yXG4gICAgICogUlNBKSBpdCBhbHdheXMgc2VuZHMgYSByZXF1ZXN0IHRvIHRoZSBBdXRoIHNlcnZlciAoc2ltaWxhciB0byB7QGxpbmtcbiAgICAgKiAjZ2V0VXNlcn0pIHRvIHZlcmlmeSB0aGUgSldULlxuICAgICAqXG4gICAgICogQHBhcmFtIGp3dCBBbiBvcHRpb25hbCBzcGVjaWZpYyBKV1QgeW91IHdpc2ggdG8gdmVyaWZ5LCBub3QgdGhlIG9uZSB5b3VcbiAgICAgKiAgICAgICAgICAgIGNhbiBvYnRhaW4gZnJvbSB7QGxpbmsgI2dldFNlc3Npb259LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFZhcmlvdXMgYWRkaXRpb25hbCBvcHRpb25zIHRoYXQgYWxsb3cgeW91IHRvIGN1c3RvbWl6ZSB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICBiZWhhdmlvciBvZiB0aGlzIG1ldGhvZC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRDbGFpbXMoand0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxldCB0b2tlbiA9IGp3dDtcbiAgICAgICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCB0aGlzLmdldFNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgfHwgIWRhdGEuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbiA9IGRhdGEuc2Vzc2lvbi5hY2Nlc3NfdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGhlYWRlciwgcGF5bG9hZCwgc2lnbmF0dXJlLCByYXc6IHsgaGVhZGVyOiByYXdIZWFkZXIsIHBheWxvYWQ6IHJhd1BheWxvYWQgfSwgfSA9IGRlY29kZUpXVCh0b2tlbik7XG4gICAgICAgICAgICBpZiAoIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWxsb3dFeHBpcmVkKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlamVjdCBleHBpcmVkIEpXVHMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIGp3dCBhcmd1bWVudCB3YXMgcGFzc2VkXG4gICAgICAgICAgICAgICAgdmFsaWRhdGVFeHAocGF5bG9hZC5leHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2lnbmluZ0tleSA9ICFoZWFkZXIuYWxnIHx8XG4gICAgICAgICAgICAgICAgaGVhZGVyLmFsZy5zdGFydHNXaXRoKCdIUycpIHx8XG4gICAgICAgICAgICAgICAgIWhlYWRlci5raWQgfHxcbiAgICAgICAgICAgICAgICAhKCdjcnlwdG8nIGluIGdsb2JhbFRoaXMgJiYgJ3N1YnRsZScgaW4gZ2xvYmFsVGhpcy5jcnlwdG8pXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiBhd2FpdCB0aGlzLmZldGNoSndrKGhlYWRlci5raWQsIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMua2V5cykgPyB7IGtleXM6IG9wdGlvbnMua2V5cyB9IDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmp3a3MpO1xuICAgICAgICAgICAgLy8gSWYgc3ltbWV0cmljIGFsZ29yaXRobSBvciBXZWJDcnlwdG8gQVBJIGlzIHVuYXZhaWxhYmxlLCBmYWxsYmFjayB0byBnZXRVc2VyKClcbiAgICAgICAgICAgIGlmICghc2lnbmluZ0tleSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHRoaXMuZ2V0VXNlcih0b2tlbik7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBnZXRVc2VyIHN1Y2NlZWRzIHNvIHRoZSBjbGFpbXMgaW4gdGhlIEpXVCBjYW4gYmUgdHJ1c3RlZFxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYWltczogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFsZ29yaXRobSA9IGdldEFsZ29yaXRobShoZWFkZXIuYWxnKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgSldLIHRvIENyeXB0b0tleVxuICAgICAgICAgICAgY29uc3QgcHVibGljS2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ2p3aycsIHNpZ25pbmdLZXksIGFsZ29yaXRobSwgdHJ1ZSwgW1xuICAgICAgICAgICAgICAgICd2ZXJpZnknLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAvLyBWZXJpZnkgdGhlIHNpZ25hdHVyZVxuICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUudmVyaWZ5KGFsZ29yaXRobSwgcHVibGljS2V5LCBzaWduYXR1cmUsIHN0cmluZ1RvVWludDhBcnJheShgJHtyYXdIZWFkZXJ9LiR7cmF3UGF5bG9hZH1gKSk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXV0aEludmFsaWRKd3RFcnJvcignSW52YWxpZCBKV1Qgc2lnbmF0dXJlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB2ZXJpZmljYXRpb24gc3VjY2VlZHMsIGRlY29kZSBhbmQgcmV0dXJuIGNsYWltc1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYWltczogcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxufVxuR29UcnVlQ2xpZW50Lm5leHRJbnN0YW5jZUlEID0gMDtcbmV4cG9ydCBkZWZhdWx0IEdvVHJ1ZUNsaWVudDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdvVHJ1ZUNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiR29UcnVlQWRtaW5BcGkiLCJBVVRPX1JFRlJFU0hfVElDS19EVVJBVElPTl9NUyIsIkFVVE9fUkVGUkVTSF9USUNLX1RIUkVTSE9MRCIsIkRFRkFVTFRfSEVBREVSUyIsIkVYUElSWV9NQVJHSU5fTVMiLCJHT1RSVUVfVVJMIiwiSldLU19UVEwiLCJTVE9SQUdFX0tFWSIsIkF1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciIsIkF1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvciIsIkF1dGhJbnZhbGlkSnd0RXJyb3IiLCJBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciIsIkF1dGhQS0NFR3JhbnRDb2RlRXhjaGFuZ2VFcnJvciIsIkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIiwiQXV0aFVua25vd25FcnJvciIsImlzQXV0aEFwaUVycm9yIiwiaXNBdXRoRXJyb3IiLCJpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvciIsImlzQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IiLCJpc0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIiwiX3JlcXVlc3QiLCJfc2Vzc2lvblJlc3BvbnNlIiwiX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkIiwiX3Nzb1Jlc3BvbnNlIiwiX3VzZXJSZXNwb25zZSIsImRlY29kZUpXVCIsImRlZXBDbG9uZSIsIkRlZmVycmVkIiwiZ2V0QWxnb3JpdGhtIiwiZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCIsImdldEl0ZW1Bc3luYyIsImluc2VjdXJlVXNlcldhcm5pbmdQcm94eSIsImlzQnJvd3NlciIsInBhcnNlUGFyYW1ldGVyc0Zyb21VUkwiLCJyZW1vdmVJdGVtQXN5bmMiLCJyZXNvbHZlRmV0Y2giLCJyZXRyeWFibGUiLCJzZXRJdGVtQXN5bmMiLCJzbGVlcCIsInN1cHBvcnRzTG9jYWxTdG9yYWdlIiwidXNlck5vdEF2YWlsYWJsZVByb3h5IiwidXVpZCIsInZhbGlkYXRlRXhwIiwibWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlciIsIkxvY2tBY3F1aXJlVGltZW91dEVycm9yIiwibmF2aWdhdG9yTG9jayIsInBvbHlmaWxsR2xvYmFsVGhpcyIsInZlcnNpb24iLCJieXRlc1RvQmFzZTY0VVJMIiwic3RyaW5nVG9VaW50OEFycmF5IiwiY3JlYXRlU2l3ZU1lc3NhZ2UiLCJmcm9tSGV4IiwiZ2V0QWRkcmVzcyIsInRvSGV4IiwiZGVzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zIiwiZGVzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMiLCJzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25SZXNwb25zZSIsInNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0UmVzcG9uc2UiLCJXZWJBdXRobkFwaSIsIkRFRkFVTFRfT1BUSU9OUyIsInVybCIsInN0b3JhZ2VLZXkiLCJhdXRvUmVmcmVzaFRva2VuIiwicGVyc2lzdFNlc3Npb24iLCJkZXRlY3RTZXNzaW9uSW5VcmwiLCJoZWFkZXJzIiwiZmxvd1R5cGUiLCJkZWJ1ZyIsImhhc0N1c3RvbUF1dGhvcml6YXRpb25IZWFkZXIiLCJsb2NrTm9PcCIsIm5hbWUiLCJhY3F1aXJlVGltZW91dCIsImZuIiwiR0xPQkFMX0pXS1MiLCJHb1RydWVDbGllbnQiLCJqd2tzIiwiX2EiLCJfYiIsImtleXMiLCJ2YWx1ZSIsIk9iamVjdCIsImFzc2lnbiIsImp3a3NfY2FjaGVkX2F0IiwiY2FjaGVkQXQiLCJOdW1iZXIiLCJNSU5fU0FGRV9JTlRFR0VSIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwidXNlclN0b3JhZ2UiLCJtZW1vcnlTdG9yYWdlIiwic3RhdGVDaGFuZ2VFbWl0dGVycyIsIk1hcCIsImF1dG9SZWZyZXNoVGlja2VyIiwidmlzaWJpbGl0eUNoYW5nZWRDYWxsYmFjayIsInJlZnJlc2hpbmdEZWZlcnJlZCIsImluaXRpYWxpemVQcm9taXNlIiwic3VwcHJlc3NHZXRTZXNzaW9uV2FybmluZyIsImxvY2tBY3F1aXJlZCIsInBlbmRpbmdJbkxvY2siLCJicm9hZGNhc3RDaGFubmVsIiwibG9nZ2VyIiwiY29uc29sZSIsImxvZyIsImluc3RhbmNlSUQiLCJuZXh0SW5zdGFuY2VJRCIsIndhcm4iLCJzZXR0aW5ncyIsImxvZ0RlYnVnTWVzc2FnZXMiLCJhZG1pbiIsImZldGNoIiwibG9jayIsImdsb2JhbFRoaXMiLCJuYXZpZ2F0b3IiLCJsb2NrcyIsIm1mYSIsInZlcmlmeSIsIl92ZXJpZnkiLCJiaW5kIiwiZW5yb2xsIiwiX2Vucm9sbCIsInVuZW5yb2xsIiwiX3VuZW5yb2xsIiwiY2hhbGxlbmdlIiwiX2NoYWxsZW5nZSIsImxpc3RGYWN0b3JzIiwiX2xpc3RGYWN0b3JzIiwiY2hhbGxlbmdlQW5kVmVyaWZ5IiwiX2NoYWxsZW5nZUFuZFZlcmlmeSIsImdldEF1dGhlbnRpY2F0b3JBc3N1cmFuY2VMZXZlbCIsIl9nZXRBdXRoZW50aWNhdG9yQXNzdXJhbmNlTGV2ZWwiLCJ3ZWJhdXRobiIsIm9hdXRoIiwiZ2V0QXV0aG9yaXphdGlvbkRldGFpbHMiLCJfZ2V0QXV0aG9yaXphdGlvbkRldGFpbHMiLCJhcHByb3ZlQXV0aG9yaXphdGlvbiIsIl9hcHByb3ZlQXV0aG9yaXphdGlvbiIsImRlbnlBdXRob3JpemF0aW9uIiwiX2RlbnlBdXRob3JpemF0aW9uIiwic3RvcmFnZSIsImxvY2FsU3RvcmFnZSIsIkJyb2FkY2FzdENoYW5uZWwiLCJlIiwiZXJyb3IiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJfZGVidWciLCJfbm90aWZ5QWxsU3Vic2NyaWJlcnMiLCJkYXRhIiwic2Vzc2lvbiIsImluaXRpYWxpemUiLCJhcmdzIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiX2FjcXVpcmVMb2NrIiwiX2luaXRpYWxpemUiLCJwYXJhbXMiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsImhyZWYiLCJjYWxsYmFja1VybFR5cGUiLCJfaXNJbXBsaWNpdEdyYW50Q2FsbGJhY2siLCJfaXNQS0NFQ2FsbGJhY2siLCJfZ2V0U2Vzc2lvbkZyb21VUkwiLCJlcnJvckNvZGUiLCJkZXRhaWxzIiwiY29kZSIsIl9yZW1vdmVTZXNzaW9uIiwicmVkaXJlY3RUeXBlIiwiX3NhdmVTZXNzaW9uIiwic2V0VGltZW91dCIsIl9yZWNvdmVyQW5kUmVmcmVzaCIsIl9oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlIiwic2lnbkluQW5vbnltb3VzbHkiLCJjcmVkZW50aWFscyIsIl9jIiwicmVzIiwiYm9keSIsImdvdHJ1ZV9tZXRhX3NlY3VyaXR5IiwiY2FwdGNoYV90b2tlbiIsImNhcHRjaGFUb2tlbiIsInhmb3JtIiwidXNlciIsInNpZ25VcCIsImVtYWlsIiwicGFzc3dvcmQiLCJjb2RlQ2hhbGxlbmdlIiwiY29kZUNoYWxsZW5nZU1ldGhvZCIsInJlZGlyZWN0VG8iLCJlbWFpbFJlZGlyZWN0VG8iLCJjb2RlX2NoYWxsZW5nZSIsImNvZGVfY2hhbGxlbmdlX21ldGhvZCIsInBob25lIiwiY2hhbm5lbCIsInNpZ25JbldpdGhQYXNzd29yZCIsIndlYWtfcGFzc3dvcmQiLCJ3ZWFrUGFzc3dvcmQiLCJzaWduSW5XaXRoT0F1dGgiLCJfZCIsIl9oYW5kbGVQcm92aWRlclNpZ25JbiIsInByb3ZpZGVyIiwic2NvcGVzIiwicXVlcnlQYXJhbXMiLCJza2lwQnJvd3NlclJlZGlyZWN0IiwiZXhjaGFuZ2VDb2RlRm9yU2Vzc2lvbiIsImF1dGhDb2RlIiwiX2V4Y2hhbmdlQ29kZUZvclNlc3Npb24iLCJzaWduSW5XaXRoV2ViMyIsImNoYWluIiwic2lnbkluV2l0aEV0aGVyZXVtIiwic2lnbkluV2l0aFNvbGFuYSIsIkVycm9yIiwiX2UiLCJfZiIsIl9nIiwiX2giLCJfaiIsIl9rIiwiX2wiLCJtZXNzYWdlIiwic2lnbmF0dXJlIiwid2FsbGV0Iiwic3RhdGVtZW50IiwicmVzb2x2ZWRXYWxsZXQiLCJ3aW5kb3dBbnkiLCJldGhlcmV1bSIsInJlcXVlc3QiLCJVUkwiLCJhY2NvdW50cyIsIm1ldGhvZCIsInRoZW4iLCJhY2NzIiwiY2F0Y2giLCJsZW5ndGgiLCJhZGRyZXNzIiwiY2hhaW5JZCIsImNoYWluSWRIZXgiLCJzaXdlTWVzc2FnZSIsImRvbWFpbiIsImhvc3QiLCJ1cmkiLCJub25jZSIsImlzc3VlZEF0IiwiZXhwaXJhdGlvblRpbWUiLCJub3RCZWZvcmUiLCJyZXF1ZXN0SWQiLCJyZXNvdXJjZXMiLCJfbSIsInNvbGFuYSIsInNpZ25JbiIsInNpZ25NZXNzYWdlIiwib3V0cHV0Iiwib3V0cHV0VG9Qcm9jZXNzIiwiQXJyYXkiLCJpc0FycmF5Iiwic2lnbmVkTWVzc2FnZSIsIlVpbnQ4QXJyYXkiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsInB1YmxpY0tleSIsInRvQmFzZTU4IiwibWFwIiwicmVzb3VyY2UiLCJqb2luIiwibWF5YmVTaWduYXR1cmUiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsInN0b3JhZ2VJdGVtIiwiY29kZVZlcmlmaWVyIiwic3BsaXQiLCJhdXRoX2NvZGUiLCJjb2RlX3ZlcmlmaWVyIiwic2lnbkluV2l0aElkVG9rZW4iLCJ0b2tlbiIsImFjY2Vzc190b2tlbiIsImlkX3Rva2VuIiwic2lnbkluV2l0aE90cCIsImNyZWF0ZV91c2VyIiwic2hvdWxkQ3JlYXRlVXNlciIsIm1lc3NhZ2VJZCIsIm1lc3NhZ2VfaWQiLCJ2ZXJpZnlPdHAiLCJ1bmRlZmluZWQiLCJ0eXBlIiwic2lnbkluV2l0aFNTTyIsInByb3ZpZGVyX2lkIiwicHJvdmlkZXJJZCIsInJlZGlyZWN0X3RvIiwic2tpcF9odHRwX3JlZGlyZWN0IiwicmVhdXRoZW50aWNhdGUiLCJfcmVhdXRoZW50aWNhdGUiLCJfdXNlU2Vzc2lvbiIsInJlc3VsdCIsInNlc3Npb25FcnJvciIsImp3dCIsInJlc2VuZCIsImVuZHBvaW50IiwiZ2V0U2Vzc2lvbiIsImxhc3QiLCJQcm9taXNlIiwicmVzb2x2ZSIsInB1c2giLCJ3YWl0T24iLCJhbGwiLCJzcGxpY2UiLCJfX2xvYWRTZXNzaW9uIiwic3RhY2siLCJjdXJyZW50U2Vzc2lvbiIsIm1heWJlU2Vzc2lvbiIsIl9pc1ZhbGlkU2Vzc2lvbiIsImhhc0V4cGlyZWQiLCJleHBpcmVzX2F0Iiwibm93IiwibWF5YmVVc2VyIiwiaXNTZXJ2ZXIiLCJfX2lzVXNlck5vdEF2YWlsYWJsZVByb3h5Iiwic3VwcHJlc3NXYXJuaW5nUmVmIiwiX2NhbGxSZWZyZXNoVG9rZW4iLCJyZWZyZXNoX3Rva2VuIiwiZ2V0VXNlciIsIl9nZXRVc2VyIiwidXBkYXRlVXNlciIsImF0dHJpYnV0ZXMiLCJfdXBkYXRlVXNlciIsInNlc3Npb25EYXRhIiwidXNlckVycm9yIiwic2V0U2Vzc2lvbiIsIl9zZXRTZXNzaW9uIiwidGltZU5vdyIsImV4cGlyZXNBdCIsInBheWxvYWQiLCJleHAiLCJyZWZyZXNoZWRTZXNzaW9uIiwidG9rZW5fdHlwZSIsImV4cGlyZXNfaW4iLCJyZWZyZXNoU2Vzc2lvbiIsIl9yZWZyZXNoU2Vzc2lvbiIsImVycm9yX2Rlc2NyaXB0aW9uIiwiZXJyb3JfY29kZSIsInNlYXJjaFBhcmFtcyIsImRlbGV0ZSIsImhpc3RvcnkiLCJyZXBsYWNlU3RhdGUiLCJzdGF0ZSIsInRvU3RyaW5nIiwicHJvdmlkZXJfdG9rZW4iLCJwcm92aWRlcl9yZWZyZXNoX3Rva2VuIiwiTWF0aCIsInJvdW5kIiwiZXhwaXJlc0luIiwicGFyc2VJbnQiLCJhY3R1YWxseUV4cGlyZXNJbiIsImhhc2giLCJCb29sZWFuIiwiY3VycmVudFN0b3JhZ2VDb250ZW50Iiwic2lnbk91dCIsInNjb3BlIiwiX3NpZ25PdXQiLCJhY2Nlc3NUb2tlbiIsInN0YXR1cyIsIm9uQXV0aFN0YXRlQ2hhbmdlIiwiY2FsbGJhY2siLCJpZCIsInN1YnNjcmlwdGlvbiIsInVuc3Vic2NyaWJlIiwic2V0IiwiX2VtaXRJbml0aWFsU2Vzc2lvbiIsImdldCIsImVyciIsInJlc2V0UGFzc3dvcmRGb3JFbWFpbCIsImdldFVzZXJJZGVudGl0aWVzIiwiaWRlbnRpdGllcyIsImxpbmtJZGVudGl0eSIsImxpbmtJZGVudGl0eUlkVG9rZW4iLCJsaW5rSWRlbnRpdHlPQXV0aCIsIl9nZXRVcmxGb3JQcm92aWRlciIsImxpbmtfaWRlbnRpdHkiLCJ1bmxpbmtJZGVudGl0eSIsImlkZW50aXR5IiwiaWRlbnRpdHlfaWQiLCJfcmVmcmVzaEFjY2Vzc1Rva2VuIiwicmVmcmVzaFRva2VuIiwiZGVidWdOYW1lIiwic3Vic3RyaW5nIiwic3RhcnRlZEF0IiwiYXR0ZW1wdCIsInBvdyIsIm5leHRCYWNrT2ZmSW50ZXJ2YWwiLCJpc1ZhbGlkU2Vzc2lvbiIsImlzIiwic2VwYXJhdGVVc2VyIiwiZXhwaXJlc1dpdGhNYXJnaW4iLCJJbmZpbml0eSIsImdldFVzZXJFcnJvciIsInByb21pc2UiLCJyZWplY3QiLCJicm9hZGNhc3QiLCJwb3N0TWVzc2FnZSIsImVycm9ycyIsInByb21pc2VzIiwiZnJvbSIsInZhbHVlcyIsIngiLCJpIiwic2Vzc2lvblRvUHJvY2VzcyIsInVzZXJJc1Byb3h5IiwibWFpblNlc3Npb25EYXRhIiwiY2xvbmVkTWFpblNlc3Npb25EYXRhIiwiY2xvbmVkU2Vzc2lvbiIsIl9yZW1vdmVWaXNpYmlsaXR5Q2hhbmdlZENhbGxiYWNrIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl9zdGFydEF1dG9SZWZyZXNoIiwiX3N0b3BBdXRvUmVmcmVzaCIsInRpY2tlciIsInNldEludGVydmFsIiwiX2F1dG9SZWZyZXNoVG9rZW5UaWNrIiwidW5yZWYiLCJEZW5vIiwidW5yZWZUaW1lciIsImNsZWFySW50ZXJ2YWwiLCJzdGFydEF1dG9SZWZyZXNoIiwic3RvcEF1dG9SZWZyZXNoIiwiZXhwaXJlc0luVGlja3MiLCJmbG9vciIsImlzQWNxdWlyZVRpbWVvdXQiLCJfb25WaXNpYmlsaXR5Q2hhbmdlZCIsImNhbGxlZEZyb21Jbml0aWFsaXplIiwibWV0aG9kTmFtZSIsImRvY3VtZW50IiwidmlzaWJpbGl0eVN0YXRlIiwidXJsUGFyYW1zIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZmxvd1BhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInF1ZXJ5IiwiZmFjdG9ySWQiLCJmcmllbmRseV9uYW1lIiwiZnJpZW5kbHlOYW1lIiwiZmFjdG9yX3R5cGUiLCJmYWN0b3JUeXBlIiwiaXNzdWVyIiwidG90cCIsInFyX2NvZGUiLCJjaGFsbGVuZ2VfaWQiLCJjaGFsbGVuZ2VJZCIsImNyZWRlbnRpYWxfcmVzcG9uc2UiLCJyZXNwb25zZSIsImNyZWRlbnRpYWxfb3B0aW9ucyIsImNoYWxsZW5nZURhdGEiLCJjaGFsbGVuZ2VFcnJvciIsImZhY3RvciIsImZhY3RvcnMiLCJjdXJyZW50TGV2ZWwiLCJuZXh0TGV2ZWwiLCJjdXJyZW50QXV0aGVudGljYXRpb25NZXRob2RzIiwiYWFsIiwidmVyaWZpZWRGYWN0b3JzIiwiZmlsdGVyIiwiYW1yIiwiYXV0aG9yaXphdGlvbklkIiwiYWN0aW9uIiwicmVkaXJlY3RfdXJsIiwiZmV0Y2hKd2siLCJraWQiLCJqd2siLCJmaW5kIiwia2V5IiwiZ2V0Q2xhaW1zIiwiaGVhZGVyIiwicmF3IiwicmF3SGVhZGVyIiwicmF3UGF5bG9hZCIsImFsbG93RXhwaXJlZCIsInNpZ25pbmdLZXkiLCJhbGciLCJzdGFydHNXaXRoIiwiY3J5cHRvIiwiY2xhaW1zIiwiYWxnb3JpdGhtIiwic3VidGxlIiwiaW1wb3J0S2V5IiwiaXNWYWxpZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAdminApi: () => (/* reexport safe */ _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   AuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthApiError),\n/* harmony export */   AuthClient: () => (/* reexport safe */ _AuthClient__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   AuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidJwtError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidJwtError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.CustomAuthError),\n/* harmony export */   GoTrueAdminApi: () => (/* reexport safe */ _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   GoTrueClient: () => (/* reexport safe */ _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.NavigatorLockAcquireTimeoutError),\n/* harmony export */   SIGN_OUT_SCOPES: () => (/* reexport safe */ _lib_types__WEBPACK_IMPORTED_MODULE_4__.SIGN_OUT_SCOPES),\n/* harmony export */   isAuthApiError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthApiError),\n/* harmony export */   isAuthError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* reexport safe */ _lib_errors__WEBPACK_IMPORTED_MODULE_5__.isAuthWeakPasswordError),\n/* harmony export */   lockInternals: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.internals),\n/* harmony export */   navigatorLock: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.navigatorLock),\n/* harmony export */   processLock: () => (/* reexport safe */ _lib_locks__WEBPACK_IMPORTED_MODULE_6__.processLock)\n/* harmony export */ });\n/* harmony import */ var _GoTrueAdminApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GoTrueAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueAdminApi.js\");\n/* harmony import */ var _GoTrueClient__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GoTrueClient */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/GoTrueClient.js\");\n/* harmony import */ var _AuthAdminApi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AuthAdminApi */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthAdminApi.js\");\n/* harmony import */ var _AuthClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthClient */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/AuthClient.js\");\n/* harmony import */ var _lib_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/types */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_locks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/locks */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\");\n\n\n\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE4QztBQUNKO0FBQ0E7QUFDSjtBQUM0QjtBQUN0QztBQUNDO0FBQzJGLENBQ3hILGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2luZGV4LmpzPzU1MDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEdvVHJ1ZUFkbWluQXBpIGZyb20gJy4vR29UcnVlQWRtaW5BcGknO1xuaW1wb3J0IEdvVHJ1ZUNsaWVudCBmcm9tICcuL0dvVHJ1ZUNsaWVudCc7XG5pbXBvcnQgQXV0aEFkbWluQXBpIGZyb20gJy4vQXV0aEFkbWluQXBpJztcbmltcG9ydCBBdXRoQ2xpZW50IGZyb20gJy4vQXV0aENsaWVudCc7XG5leHBvcnQgeyBHb1RydWVBZG1pbkFwaSwgR29UcnVlQ2xpZW50LCBBdXRoQWRtaW5BcGksIEF1dGhDbGllbnQgfTtcbmV4cG9ydCAqIGZyb20gJy4vbGliL3R5cGVzJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL2Vycm9ycyc7XG5leHBvcnQgeyBuYXZpZ2F0b3JMb2NrLCBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciwgaW50ZXJuYWxzIGFzIGxvY2tJbnRlcm5hbHMsIHByb2Nlc3NMb2NrLCB9IGZyb20gJy4vbGliL2xvY2tzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJHb1RydWVBZG1pbkFwaSIsIkdvVHJ1ZUNsaWVudCIsIkF1dGhBZG1pbkFwaSIsIkF1dGhDbGllbnQiLCJuYXZpZ2F0b3JMb2NrIiwiTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IiLCJpbnRlcm5hbHMiLCJsb2NrSW50ZXJuYWxzIiwicHJvY2Vzc0xvY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/base64url.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base64UrlToUint8Array: () => (/* binding */ base64UrlToUint8Array),\n/* harmony export */   byteFromBase64URL: () => (/* binding */ byteFromBase64URL),\n/* harmony export */   byteToBase64URL: () => (/* binding */ byteToBase64URL),\n/* harmony export */   bytesToBase64URL: () => (/* binding */ bytesToBase64URL),\n/* harmony export */   codepointToUTF8: () => (/* binding */ codepointToUTF8),\n/* harmony export */   stringFromBase64URL: () => (/* binding */ stringFromBase64URL),\n/* harmony export */   stringFromUTF8: () => (/* binding */ stringFromUTF8),\n/* harmony export */   stringToBase64URL: () => (/* binding */ stringToBase64URL),\n/* harmony export */   stringToUTF8: () => (/* binding */ stringToUTF8),\n/* harmony export */   stringToUint8Array: () => (/* binding */ stringToUint8Array)\n/* harmony export */ });\n/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */ /**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */ const TO_BASE64URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".split(\"\");\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */ const IGNORE_BASE64URL = \" \t\\n\\r=\".split(\"\");\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */ const FROM_BASE64URL = (()=>{\n    const charMap = new Array(128);\n    for(let i = 0; i < charMap.length; i += 1){\n        charMap[i] = -1;\n    }\n    for(let i = 0; i < IGNORE_BASE64URL.length; i += 1){\n        charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n    }\n    for(let i = 0; i < TO_BASE64URL.length; i += 1){\n        charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n    }\n    return charMap;\n})();\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */ function byteToBase64URL(byte, state, emit) {\n    if (byte !== null) {\n        state.queue = state.queue << 8 | byte;\n        state.queuedBits += 8;\n        while(state.queuedBits >= 6){\n            const pos = state.queue >> state.queuedBits - 6 & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    } else if (state.queuedBits > 0) {\n        state.queue = state.queue << 6 - state.queuedBits;\n        state.queuedBits = 6;\n        while(state.queuedBits >= 6){\n            const pos = state.queue >> state.queuedBits - 6 & 63;\n            emit(TO_BASE64URL[pos]);\n            state.queuedBits -= 6;\n        }\n    }\n}\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */ function byteFromBase64URL(charCode, state, emit) {\n    const bits = FROM_BASE64URL[charCode];\n    if (bits > -1) {\n        // valid Base64-URL character\n        state.queue = state.queue << 6 | bits;\n        state.queuedBits += 6;\n        while(state.queuedBits >= 8){\n            emit(state.queue >> state.queuedBits - 8 & 0xff);\n            state.queuedBits -= 8;\n        }\n    } else if (bits === -2) {\n        // ignore spaces, tabs, newlines, =\n        return;\n    } else {\n        throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`);\n    }\n}\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */ function stringToBase64URL(str) {\n    const base64 = [];\n    const emitter = (char)=>{\n        base64.push(char);\n    };\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    stringToUTF8(str, (byte)=>{\n        byteToBase64URL(byte, state, emitter);\n    });\n    byteToBase64URL(null, state, emitter);\n    return base64.join(\"\");\n}\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */ function stringFromBase64URL(str) {\n    const conv = [];\n    const utf8Emit = (codepoint)=>{\n        conv.push(String.fromCodePoint(codepoint));\n    };\n    const utf8State = {\n        utf8seq: 0,\n        codepoint: 0\n    };\n    const b64State = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const byteEmit = (byte)=>{\n        stringFromUTF8(byte, utf8State, utf8Emit);\n    };\n    for(let i = 0; i < str.length; i += 1){\n        byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\n    }\n    return conv.join(\"\");\n}\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */ function codepointToUTF8(codepoint, emit) {\n    if (codepoint <= 0x7f) {\n        emit(codepoint);\n        return;\n    } else if (codepoint <= 0x7ff) {\n        emit(0xc0 | codepoint >> 6);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0xffff) {\n        emit(0xe0 | codepoint >> 12);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    } else if (codepoint <= 0x10ffff) {\n        emit(0xf0 | codepoint >> 18);\n        emit(0x80 | codepoint >> 12 & 0x3f);\n        emit(0x80 | codepoint >> 6 & 0x3f);\n        emit(0x80 | codepoint & 0x3f);\n        return;\n    }\n    throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`);\n}\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */ function stringToUTF8(str, emit) {\n    for(let i = 0; i < str.length; i += 1){\n        let codepoint = str.charCodeAt(i);\n        if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n            // most UTF-16 codepoints are Unicode codepoints, except values in this\n            // range where the next UTF-16 codepoint needs to be combined with the\n            // current one to get the Unicode codepoint\n            const highSurrogate = (codepoint - 0xd800) * 0x400 & 0xffff;\n            const lowSurrogate = str.charCodeAt(i + 1) - 0xdc00 & 0xffff;\n            codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n            i += 1;\n        }\n        codepointToUTF8(codepoint, emit);\n    }\n}\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */ function stringFromUTF8(byte, state, emit) {\n    if (state.utf8seq === 0) {\n        if (byte <= 0x7f) {\n            emit(byte);\n            return;\n        }\n        // count the number of 1 leading bits until you reach 0\n        for(let leadingBit = 1; leadingBit < 6; leadingBit += 1){\n            if ((byte >> 7 - leadingBit & 1) === 0) {\n                state.utf8seq = leadingBit;\n                break;\n            }\n        }\n        if (state.utf8seq === 2) {\n            state.codepoint = byte & 31;\n        } else if (state.utf8seq === 3) {\n            state.codepoint = byte & 15;\n        } else if (state.utf8seq === 4) {\n            state.codepoint = byte & 7;\n        } else {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.utf8seq -= 1;\n    } else if (state.utf8seq > 0) {\n        if (byte <= 0x7f) {\n            throw new Error(\"Invalid UTF-8 sequence\");\n        }\n        state.codepoint = state.codepoint << 6 | byte & 63;\n        state.utf8seq -= 1;\n        if (state.utf8seq === 0) {\n            emit(state.codepoint);\n        }\n    }\n}\n/**\n * Helper functions to convert different types of strings to Uint8Array\n */ function base64UrlToUint8Array(str) {\n    const result = [];\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const onByte = (byte)=>{\n        result.push(byte);\n    };\n    for(let i = 0; i < str.length; i += 1){\n        byteFromBase64URL(str.charCodeAt(i), state, onByte);\n    }\n    return new Uint8Array(result);\n}\nfunction stringToUint8Array(str) {\n    const result = [];\n    stringToUTF8(str, (byte)=>result.push(byte));\n    return new Uint8Array(result);\n}\nfunction bytesToBase64URL(bytes) {\n    const result = [];\n    const state = {\n        queue: 0,\n        queuedBits: 0\n    };\n    const onChar = (char)=>{\n        result.push(char);\n    };\n    bytes.forEach((byte)=>byteToBase64URL(byte, state, onChar));\n    // always call with `null` after processing all bytes\n    byteToBase64URL(null, state, onChar);\n    return result.join(\"\");\n} //# sourceMappingURL=base64url.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2Jhc2U2NHVybC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNEOzs7Q0FHQyxHQUNELE1BQU1BLGVBQWUsbUVBQW1FQyxLQUFLLENBQUM7QUFDOUY7OztDQUdDLEdBQ0QsTUFBTUMsbUJBQW1CLFVBQVdELEtBQUssQ0FBQztBQUMxQzs7O0NBR0MsR0FDRCxNQUFNRSxpQkFBaUIsQ0FBQztJQUNwQixNQUFNQyxVQUFVLElBQUlDLE1BQU07SUFDMUIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFFBQVFHLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQ3hDRixPQUFPLENBQUNFLEVBQUUsR0FBRyxDQUFDO0lBQ2xCO0lBQ0EsSUFBSyxJQUFJQSxJQUFJLEdBQUdBLElBQUlKLGlCQUFpQkssTUFBTSxFQUFFRCxLQUFLLEVBQUc7UUFDakRGLE9BQU8sQ0FBQ0YsZ0JBQWdCLENBQUNJLEVBQUUsQ0FBQ0UsVUFBVSxDQUFDLEdBQUcsR0FBRyxDQUFDO0lBQ2xEO0lBQ0EsSUFBSyxJQUFJRixJQUFJLEdBQUdBLElBQUlOLGFBQWFPLE1BQU0sRUFBRUQsS0FBSyxFQUFHO1FBQzdDRixPQUFPLENBQUNKLFlBQVksQ0FBQ00sRUFBRSxDQUFDRSxVQUFVLENBQUMsR0FBRyxHQUFHRjtJQUM3QztJQUNBLE9BQU9GO0FBQ1g7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTSyxnQkFBZ0JDLElBQUksRUFBRUMsS0FBSyxFQUFFQyxJQUFJO0lBQzdDLElBQUlGLFNBQVMsTUFBTTtRQUNmQyxNQUFNRSxLQUFLLEdBQUcsTUFBT0EsS0FBSyxJQUFJLElBQUtIO1FBQ25DQyxNQUFNRyxVQUFVLElBQUk7UUFDcEIsTUFBT0gsTUFBTUcsVUFBVSxJQUFJLEVBQUc7WUFDMUIsTUFBTUMsTUFBTSxNQUFPRixLQUFLLElBQUtGLE1BQU1HLFVBQVUsR0FBRyxJQUFN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O0FBQzFCO0FBQ08sU0FBU0ksaUJBQWlCQyxLQUFLO0lBQ2xDLE1BQU1MLFNBQVMsRUFBRTtJQUNqQixNQUFNbkMsUUFBUTtRQUFFRSxPQUFPO1FBQUdDLFlBQVk7SUFBRTtJQUN4QyxNQUFNc0MsU0FBUyxDQUFDMUI7UUFDWm9CLE9BQU9uQixJQUFJLENBQUNEO0lBQ2hCO0lBQ0F5QixNQUFNRSxPQUFPLENBQUMsQ0FBQzNDLE9BQVNELGdCQUFnQkMsTUFBTUMsT0FBT3lDO0lBQ3JELHFEQUFxRDtJQUNyRDNDLGdCQUFnQixNQUFNRSxPQUFPeUM7SUFDN0IsT0FBT04sT0FBT2pCLElBQUksQ0FBQztBQUN2QixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9iYXNlNjR1cmwuanM/MTVkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEF2b2lkIG1vZGlmeWluZyB0aGlzIGZpbGUuIEl0J3MgcGFydCBvZlxuICogaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlLWNvbW11bml0eS9iYXNlNjR1cmwtanMuICBTdWJtaXQgYWxsIGZpeGVzIG9uXG4gKiB0aGF0IHJlcG8hXG4gKi9cbi8qKlxuICogQW4gYXJyYXkgb2YgY2hhcmFjdGVycyB0aGF0IGVuY29kZSA2IGJpdHMgaW50byBhIEJhc2U2NC1VUkwgYWxwaGFiZXRcbiAqIGNoYXJhY3Rlci5cbiAqL1xuY29uc3QgVE9fQkFTRTY0VVJMID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV8nLnNwbGl0KCcnKTtcbi8qKlxuICogQW4gYXJyYXkgb2YgY2hhcmFjdGVycyB0aGF0IGNhbiBhcHBlYXIgaW4gYSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nIGJ1dFxuICogc2hvdWxkIGJlIGlnbm9yZWQuXG4gKi9cbmNvbnN0IElHTk9SRV9CQVNFNjRVUkwgPSAnIFxcdFxcblxccj0nLnNwbGl0KCcnKTtcbi8qKlxuICogQW4gYXJyYXkgb2YgMTI4IG51bWJlcnMgdGhhdCBtYXAgYSBCYXNlNjQtVVJMIGNoYXJhY3RlciB0byA2IGJpdHMsIG9yIGlmIC0yXG4gKiB1c2VkIHRvIHNraXAgdGhlIGNoYXJhY3Rlciwgb3IgaWYgLTEgdXNlZCB0byBlcnJvciBvdXQuXG4gKi9cbmNvbnN0IEZST01fQkFTRTY0VVJMID0gKCgpID0+IHtcbiAgICBjb25zdCBjaGFyTWFwID0gbmV3IEFycmF5KDEyOCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFyTWFwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNoYXJNYXBbaV0gPSAtMTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBJR05PUkVfQkFTRTY0VVJMLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNoYXJNYXBbSUdOT1JFX0JBU0U2NFVSTFtpXS5jaGFyQ29kZUF0KDApXSA9IC0yO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFRPX0JBU0U2NFVSTC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjaGFyTWFwW1RPX0JBU0U2NFVSTFtpXS5jaGFyQ29kZUF0KDApXSA9IGk7XG4gICAgfVxuICAgIHJldHVybiBjaGFyTWFwO1xufSkoKTtcbi8qKlxuICogQ29udmVydHMgYSBieXRlIHRvIGEgQmFzZTY0LVVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGJ5dGUgVGhlIGJ5dGUgdG8gY29udmVydCwgb3IgbnVsbCB0byBmbHVzaCBhdCB0aGUgZW5kIG9mIHRoZSBieXRlIHNlcXVlbmNlLlxuICogQHBhcmFtIHN0YXRlIFRoZSBCYXNlNjQgY29udmVyc2lvbiBzdGF0ZS4gUGFzcyBhbiBpbml0aWFsIHZhbHVlIG9mIGB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH1gLlxuICogQHBhcmFtIGVtaXQgQSBmdW5jdGlvbiBjYWxsZWQgd2l0aCB0aGUgbmV4dCBCYXNlNjQgY2hhcmFjdGVyIHdoZW4gcmVhZHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlVG9CYXNlNjRVUkwoYnl0ZSwgc3RhdGUsIGVtaXQpIHtcbiAgICBpZiAoYnl0ZSAhPT0gbnVsbCkge1xuICAgICAgICBzdGF0ZS5xdWV1ZSA9IChzdGF0ZS5xdWV1ZSA8PCA4KSB8IGJ5dGU7XG4gICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgKz0gODtcbiAgICAgICAgd2hpbGUgKHN0YXRlLnF1ZXVlZEJpdHMgPj0gNikge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gKHN0YXRlLnF1ZXVlID4+IChzdGF0ZS5xdWV1ZWRCaXRzIC0gNikpICYgNjM7XG4gICAgICAgICAgICBlbWl0KFRPX0JBU0U2NFVSTFtwb3NdKTtcbiAgICAgICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgLT0gNjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZS5xdWV1ZWRCaXRzID4gMCkge1xuICAgICAgICBzdGF0ZS5xdWV1ZSA9IHN0YXRlLnF1ZXVlIDw8ICg2IC0gc3RhdGUucXVldWVkQml0cyk7XG4gICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgPSA2O1xuICAgICAgICB3aGlsZSAoc3RhdGUucXVldWVkQml0cyA+PSA2KSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSAoc3RhdGUucXVldWUgPj4gKHN0YXRlLnF1ZXVlZEJpdHMgLSA2KSkgJiA2MztcbiAgICAgICAgICAgIGVtaXQoVE9fQkFTRTY0VVJMW3Bvc10pO1xuICAgICAgICAgICAgc3RhdGUucXVldWVkQml0cyAtPSA2O1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFN0cmluZyBjaGFyIGNvZGUgKGV4dHJhY3RlZCB1c2luZyBgc3RyaW5nLmNoYXJDb2RlQXQocG9zaXRpb24pYCkgdG8gYSBzZXF1ZW5jZSBvZiBCYXNlNjQtVVJMIGNoYXJhY3RlcnMuXG4gKlxuICogQHBhcmFtIGNoYXJDb2RlIFRoZSBjaGFyIGNvZGUgb2YgdGhlIEphdmFTY3JpcHQgc3RyaW5nLlxuICogQHBhcmFtIHN0YXRlIFRoZSBCYXNlNjQgc3RhdGUuIFBhc3MgYW4gaW5pdGlhbCB2YWx1ZSBvZiBgeyBxdWV1ZTogMCwgcXVldWVkQml0czogMCB9YC5cbiAqIEBwYXJhbSBlbWl0IEEgZnVuY3Rpb24gY2FsbGVkIHdpdGggdGhlIG5leHQgYnl0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVGcm9tQmFzZTY0VVJMKGNoYXJDb2RlLCBzdGF0ZSwgZW1pdCkge1xuICAgIGNvbnN0IGJpdHMgPSBGUk9NX0JBU0U2NFVSTFtjaGFyQ29kZV07XG4gICAgaWYgKGJpdHMgPiAtMSkge1xuICAgICAgICAvLyB2YWxpZCBCYXNlNjQtVVJMIGNoYXJhY3RlclxuICAgICAgICBzdGF0ZS5xdWV1ZSA9IChzdGF0ZS5xdWV1ZSA8PCA2KSB8IGJpdHM7XG4gICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgKz0gNjtcbiAgICAgICAgd2hpbGUgKHN0YXRlLnF1ZXVlZEJpdHMgPj0gOCkge1xuICAgICAgICAgICAgZW1pdCgoc3RhdGUucXVldWUgPj4gKHN0YXRlLnF1ZXVlZEJpdHMgLSA4KSkgJiAweGZmKTtcbiAgICAgICAgICAgIHN0YXRlLnF1ZXVlZEJpdHMgLT0gODtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChiaXRzID09PSAtMikge1xuICAgICAgICAvLyBpZ25vcmUgc3BhY2VzLCB0YWJzLCBuZXdsaW5lcywgPVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQmFzZTY0LVVSTCBjaGFyYWN0ZXIgXCIke1N0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpfVwiYCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEphdmFTY3JpcHQgc3RyaW5nICh3aGljaCBtYXkgaW5jbHVkZSBhbnkgdmFsaWQgY2hhcmFjdGVyKSBpbnRvIGFcbiAqIEJhc2U2NC1VUkwgZW5jb2RlZCBzdHJpbmcuIFRoZSBzdHJpbmcgaXMgZmlyc3QgZW5jb2RlZCBpbiBVVEYtOCB3aGljaCBpc1xuICogdGhlbiBlbmNvZGVkIGFzIEJhc2U2NC1VUkwuXG4gKlxuICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb0Jhc2U2NFVSTChzdHIpIHtcbiAgICBjb25zdCBiYXNlNjQgPSBbXTtcbiAgICBjb25zdCBlbWl0dGVyID0gKGNoYXIpID0+IHtcbiAgICAgICAgYmFzZTY0LnB1c2goY2hhcik7XG4gICAgfTtcbiAgICBjb25zdCBzdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfTtcbiAgICBzdHJpbmdUb1VURjgoc3RyLCAoYnl0ZSkgPT4ge1xuICAgICAgICBieXRlVG9CYXNlNjRVUkwoYnl0ZSwgc3RhdGUsIGVtaXR0ZXIpO1xuICAgIH0pO1xuICAgIGJ5dGVUb0Jhc2U2NFVSTChudWxsLCBzdGF0ZSwgZW1pdHRlcik7XG4gICAgcmV0dXJuIGJhc2U2NC5qb2luKCcnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nIGludG8gYSBKYXZhU2NyaXB0IHN0cmluZy4gSXQgaXMgYXNzdW1lZFxuICogdGhhdCB0aGUgdW5kZXJseWluZyBzdHJpbmcgaGFzIGJlZW4gZW5jb2RlZCBhcyBVVEYtOC5cbiAqXG4gKiBAcGFyYW0gc3RyIFRoZSBCYXNlNjQtVVJMIGVuY29kZWQgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRnJvbUJhc2U2NFVSTChzdHIpIHtcbiAgICBjb25zdCBjb252ID0gW107XG4gICAgY29uc3QgdXRmOEVtaXQgPSAoY29kZXBvaW50KSA9PiB7XG4gICAgICAgIGNvbnYucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlcG9pbnQpKTtcbiAgICB9O1xuICAgIGNvbnN0IHV0ZjhTdGF0ZSA9IHtcbiAgICAgICAgdXRmOHNlcTogMCxcbiAgICAgICAgY29kZXBvaW50OiAwLFxuICAgIH07XG4gICAgY29uc3QgYjY0U3RhdGUgPSB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH07XG4gICAgY29uc3QgYnl0ZUVtaXQgPSAoYnl0ZSkgPT4ge1xuICAgICAgICBzdHJpbmdGcm9tVVRGOChieXRlLCB1dGY4U3RhdGUsIHV0ZjhFbWl0KTtcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGJ5dGVGcm9tQmFzZTY0VVJMKHN0ci5jaGFyQ29kZUF0KGkpLCBiNjRTdGF0ZSwgYnl0ZUVtaXQpO1xuICAgIH1cbiAgICByZXR1cm4gY29udi5qb2luKCcnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIGNvZGVwb2ludCB0byBhIG11bHRpLWJ5dGUgVVRGLTggc2VxdWVuY2UuXG4gKlxuICogQHBhcmFtIGNvZGVwb2ludCBUaGUgVW5pY29kZSBjb2RlcG9pbnQuXG4gKiBAcGFyYW0gZW1pdCAgICAgIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIFVURi04IGJ5dGUgdGhhdCByZXByZXNlbnRzIHRoZSBjb2RlcG9pbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2RlcG9pbnRUb1VURjgoY29kZXBvaW50LCBlbWl0KSB7XG4gICAgaWYgKGNvZGVwb2ludCA8PSAweDdmKSB7XG4gICAgICAgIGVtaXQoY29kZXBvaW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlcG9pbnQgPD0gMHg3ZmYpIHtcbiAgICAgICAgZW1pdCgweGMwIHwgKGNvZGVwb2ludCA+PiA2KSk7XG4gICAgICAgIGVtaXQoMHg4MCB8IChjb2RlcG9pbnQgJiAweDNmKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZXBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICBlbWl0KDB4ZTAgfCAoY29kZXBvaW50ID4+IDEyKSk7XG4gICAgICAgIGVtaXQoMHg4MCB8ICgoY29kZXBvaW50ID4+IDYpICYgMHgzZikpO1xuICAgICAgICBlbWl0KDB4ODAgfCAoY29kZXBvaW50ICYgMHgzZikpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGVwb2ludCA8PSAweDEwZmZmZikge1xuICAgICAgICBlbWl0KDB4ZjAgfCAoY29kZXBvaW50ID4+IDE4KSk7XG4gICAgICAgIGVtaXQoMHg4MCB8ICgoY29kZXBvaW50ID4+IDEyKSAmIDB4M2YpKTtcbiAgICAgICAgZW1pdCgweDgwIHwgKChjb2RlcG9pbnQgPj4gNikgJiAweDNmKSk7XG4gICAgICAgIGVtaXQoMHg4MCB8IChjb2RlcG9pbnQgJiAweDNmKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgVW5pY29kZSBjb2RlcG9pbnQ6ICR7Y29kZXBvaW50LnRvU3RyaW5nKDE2KX1gKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBKYXZhU2NyaXB0IHN0cmluZyB0byBhIHNlcXVlbmNlIG9mIFVURi04IGJ5dGVzLlxuICpcbiAqIEBwYXJhbSBzdHIgIFRoZSBzdHJpbmcgdG8gY29udmVydCB0byBVVEYtOC5cbiAqIEBwYXJhbSBlbWl0IEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIFVURi04IGJ5dGUgb2YgdGhlIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvVVRGOChzdHIsIGVtaXQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBsZXQgY29kZXBvaW50ID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlcG9pbnQgPiAweGQ3ZmYgJiYgY29kZXBvaW50IDw9IDB4ZGJmZikge1xuICAgICAgICAgICAgLy8gbW9zdCBVVEYtMTYgY29kZXBvaW50cyBhcmUgVW5pY29kZSBjb2RlcG9pbnRzLCBleGNlcHQgdmFsdWVzIGluIHRoaXNcbiAgICAgICAgICAgIC8vIHJhbmdlIHdoZXJlIHRoZSBuZXh0IFVURi0xNiBjb2RlcG9pbnQgbmVlZHMgdG8gYmUgY29tYmluZWQgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgb25lIHRvIGdldCB0aGUgVW5pY29kZSBjb2RlcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hTdXJyb2dhdGUgPSAoKGNvZGVwb2ludCAtIDB4ZDgwMCkgKiAweDQwMCkgJiAweGZmZmY7XG4gICAgICAgICAgICBjb25zdCBsb3dTdXJyb2dhdGUgPSAoc3RyLmNoYXJDb2RlQXQoaSArIDEpIC0gMHhkYzAwKSAmIDB4ZmZmZjtcbiAgICAgICAgICAgIGNvZGVwb2ludCA9IChsb3dTdXJyb2dhdGUgfCBoaWdoU3Vycm9nYXRlKSArIDB4MTAwMDA7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29kZXBvaW50VG9VVEY4KGNvZGVwb2ludCwgZW1pdCk7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIFVURi04IGJ5dGUgdG8gYSBVbmljb2RlIGNvZGVwb2ludC5cbiAqXG4gKiBAcGFyYW0gYnl0ZSAgVGhlIFVURi04IGJ5dGUgbmV4dCBpbiB0aGUgc2VxdWVuY2UuXG4gKiBAcGFyYW0gc3RhdGUgVGhlIHNoYXJlZCBzdGF0ZSBiZXR3ZWVuIGNvbnNlY3V0aXZlIFVURi04IGJ5dGVzIGluIHRoZVxuICogICAgICAgICAgICAgIHNlcXVlbmNlLCBhbiBvYmplY3Qgd2l0aCB0aGUgc2hhcGUgYHsgdXRmOHNlcTogMCwgY29kZXBvaW50OiAwIH1gLlxuICogQHBhcmFtIGVtaXQgIEZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGNvZGVwb2ludC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ0Zyb21VVEY4KGJ5dGUsIHN0YXRlLCBlbWl0KSB7XG4gICAgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDApIHtcbiAgICAgICAgaWYgKGJ5dGUgPD0gMHg3Zikge1xuICAgICAgICAgICAgZW1pdChieXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3VudCB0aGUgbnVtYmVyIG9mIDEgbGVhZGluZyBiaXRzIHVudGlsIHlvdSByZWFjaCAwXG4gICAgICAgIGZvciAobGV0IGxlYWRpbmdCaXQgPSAxOyBsZWFkaW5nQml0IDwgNjsgbGVhZGluZ0JpdCArPSAxKSB7XG4gICAgICAgICAgICBpZiAoKChieXRlID4+ICg3IC0gbGVhZGluZ0JpdCkpICYgMSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS51dGY4c2VxID0gbGVhZGluZ0JpdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUudXRmOHNlcSA9PT0gMikge1xuICAgICAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gYnl0ZSAmIDMxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLnV0ZjhzZXEgPT09IDMpIHtcbiAgICAgICAgICAgIHN0YXRlLmNvZGVwb2ludCA9IGJ5dGUgJiAxNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS51dGY4c2VxID09PSA0KSB7XG4gICAgICAgICAgICBzdGF0ZS5jb2RlcG9pbnQgPSBieXRlICYgNztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBVVEYtOCBzZXF1ZW5jZScpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnV0ZjhzZXEgLT0gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGUudXRmOHNlcSA+IDApIHtcbiAgICAgICAgaWYgKGJ5dGUgPD0gMHg3Zikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFVURi04IHNlcXVlbmNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuY29kZXBvaW50ID0gKHN0YXRlLmNvZGVwb2ludCA8PCA2KSB8IChieXRlICYgNjMpO1xuICAgICAgICBzdGF0ZS51dGY4c2VxIC09IDE7XG4gICAgICAgIGlmIChzdGF0ZS51dGY4c2VxID09PSAwKSB7XG4gICAgICAgICAgICBlbWl0KHN0YXRlLmNvZGVwb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbnMgdG8gY29udmVydCBkaWZmZXJlbnQgdHlwZXMgb2Ygc3RyaW5ncyB0byBVaW50OEFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkoc3RyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3Qgc3RhdGUgPSB7IHF1ZXVlOiAwLCBxdWV1ZWRCaXRzOiAwIH07XG4gICAgY29uc3Qgb25CeXRlID0gKGJ5dGUpID0+IHtcbiAgICAgICAgcmVzdWx0LnB1c2goYnl0ZSk7XG4gICAgfTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBieXRlRnJvbUJhc2U2NFVSTChzdHIuY2hhckNvZGVBdChpKSwgc3RhdGUsIG9uQnl0ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvVWludDhBcnJheShzdHIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBzdHJpbmdUb1VURjgoc3RyLCAoYnl0ZSkgPT4gcmVzdWx0LnB1c2goYnl0ZSkpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXN1bHQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9CYXNlNjRVUkwoYnl0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBzdGF0ZSA9IHsgcXVldWU6IDAsIHF1ZXVlZEJpdHM6IDAgfTtcbiAgICBjb25zdCBvbkNoYXIgPSAoY2hhcikgPT4ge1xuICAgICAgICByZXN1bHQucHVzaChjaGFyKTtcbiAgICB9O1xuICAgIGJ5dGVzLmZvckVhY2goKGJ5dGUpID0+IGJ5dGVUb0Jhc2U2NFVSTChieXRlLCBzdGF0ZSwgb25DaGFyKSk7XG4gICAgLy8gYWx3YXlzIGNhbGwgd2l0aCBgbnVsbGAgYWZ0ZXIgcHJvY2Vzc2luZyBhbGwgYnl0ZXNcbiAgICBieXRlVG9CYXNlNjRVUkwobnVsbCwgc3RhdGUsIG9uQ2hhcik7XG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2U2NHVybC5qcy5tYXAiXSwibmFtZXMiOlsiVE9fQkFTRTY0VVJMIiwic3BsaXQiLCJJR05PUkVfQkFTRTY0VVJMIiwiRlJPTV9CQVNFNjRVUkwiLCJjaGFyTWFwIiwiQXJyYXkiLCJpIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsImJ5dGVUb0Jhc2U2NFVSTCIsImJ5dGUiLCJzdGF0ZSIsImVtaXQiLCJxdWV1ZSIsInF1ZXVlZEJpdHMiLCJwb3MiLCJieXRlRnJvbUJhc2U2NFVSTCIsImNoYXJDb2RlIiwiYml0cyIsIkVycm9yIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwic3RyaW5nVG9CYXNlNjRVUkwiLCJzdHIiLCJiYXNlNjQiLCJlbWl0dGVyIiwiY2hhciIsInB1c2giLCJzdHJpbmdUb1VURjgiLCJqb2luIiwic3RyaW5nRnJvbUJhc2U2NFVSTCIsImNvbnYiLCJ1dGY4RW1pdCIsImNvZGVwb2ludCIsImZyb21Db2RlUG9pbnQiLCJ1dGY4U3RhdGUiLCJ1dGY4c2VxIiwiYjY0U3RhdGUiLCJieXRlRW1pdCIsInN0cmluZ0Zyb21VVEY4IiwiY29kZXBvaW50VG9VVEY4IiwidG9TdHJpbmciLCJoaWdoU3Vycm9nYXRlIiwibG93U3Vycm9nYXRlIiwibGVhZGluZ0JpdCIsImJhc2U2NFVybFRvVWludDhBcnJheSIsInJlc3VsdCIsIm9uQnl0ZSIsIlVpbnQ4QXJyYXkiLCJzdHJpbmdUb1VpbnQ4QXJyYXkiLCJieXRlc1RvQmFzZTY0VVJMIiwiYnl0ZXMiLCJvbkNoYXIiLCJmb3JFYWNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/constants.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_VERSIONS: () => (/* binding */ API_VERSIONS),\n/* harmony export */   API_VERSION_HEADER_NAME: () => (/* binding */ API_VERSION_HEADER_NAME),\n/* harmony export */   AUDIENCE: () => (/* binding */ AUDIENCE),\n/* harmony export */   AUTO_REFRESH_TICK_DURATION_MS: () => (/* binding */ AUTO_REFRESH_TICK_DURATION_MS),\n/* harmony export */   AUTO_REFRESH_TICK_THRESHOLD: () => (/* binding */ AUTO_REFRESH_TICK_THRESHOLD),\n/* harmony export */   BASE64URL_REGEX: () => (/* binding */ BASE64URL_REGEX),\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),\n/* harmony export */   EXPIRY_MARGIN_MS: () => (/* binding */ EXPIRY_MARGIN_MS),\n/* harmony export */   GOTRUE_URL: () => (/* binding */ GOTRUE_URL),\n/* harmony export */   JWKS_TTL: () => (/* binding */ JWKS_TTL),\n/* harmony export */   NETWORK_FAILURE: () => (/* binding */ NETWORK_FAILURE),\n/* harmony export */   STORAGE_KEY: () => (/* binding */ STORAGE_KEY)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\");\n\n/** Current session will be checked for refresh at this interval. */ const AUTO_REFRESH_TICK_DURATION_MS = 30 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */ const AUTO_REFRESH_TICK_THRESHOLD = 3;\n/*\n * Earliest time before an access token expires that the session should be refreshed.\n */ const EXPIRY_MARGIN_MS = AUTO_REFRESH_TICK_THRESHOLD * AUTO_REFRESH_TICK_DURATION_MS;\nconst GOTRUE_URL = \"http://localhost:9999\";\nconst STORAGE_KEY = \"supabase.auth.token\";\nconst AUDIENCE = \"\";\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `gotrue-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`\n};\nconst NETWORK_FAILURE = {\n    MAX_RETRIES: 10,\n    RETRY_INTERVAL: 2\n};\nconst API_VERSION_HEADER_NAME = \"X-Supabase-Api-Version\";\nconst API_VERSIONS = {\n    \"2024-01-01\": {\n        timestamp: Date.parse(\"2024-01-01T00:00:00.0Z\"),\n        name: \"2024-01-01\"\n    }\n};\nconst BASE64URL_REGEX = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i;\nconst JWKS_TTL = 10 * 60 * 1000; // 10 minutes\n //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ3BDLGtFQUFrRSxHQUMzRCxNQUFNQyxnQ0FBZ0MsS0FBSyxLQUFLO0FBQ3ZEO3lGQUN5RixHQUNsRixNQUFNQyw4QkFBOEIsRUFBRTtBQUM3Qzs7Q0FFQyxHQUNNLE1BQU1DLG1CQUFtQkQsOEJBQThCRCw4QkFBOEI7QUFDckYsTUFBTUcsYUFBYSx3QkFBd0I7QUFDM0MsTUFBTUMsY0FBYyxzQkFBc0I7QUFDMUMsTUFBTUMsV0FBVyxHQUFHO0FBQ3BCLE1BQU1DLGtCQUFrQjtJQUFFLGlCQUFpQixDQUFDLFVBQVUsRUFBRVAsNkNBQU9BLENBQUMsQ0FBQztBQUFDLEVBQUU7QUFDcEUsTUFBTVEsa0JBQWtCO0lBQzNCQyxhQUFhO0lBQ2JDLGdCQUFnQjtBQUNwQixFQUFFO0FBQ0ssTUFBTUMsMEJBQTBCLHlCQUF5QjtBQUN6RCxNQUFNQyxlQUFlO0lBQ3hCLGNBQWM7UUFDVkMsV0FBV0MsS0FBS0MsS0FBSyxDQUFDO1FBQ3RCQyxNQUFNO0lBQ1Y7QUFDSixFQUFFO0FBQ0ssTUFBTUMsa0JBQWtCLHVEQUF1RDtBQUMvRSxNQUFNQyxXQUFXLEtBQUssS0FBSyxLQUFLLENBQUMsYUFBYTtDQUNyRCxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvY29uc3RhbnRzLmpzP2YwNDgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7XG4vKiogQ3VycmVudCBzZXNzaW9uIHdpbGwgYmUgY2hlY2tlZCBmb3IgcmVmcmVzaCBhdCB0aGlzIGludGVydmFsLiAqL1xuZXhwb3J0IGNvbnN0IEFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TID0gMzAgKiAxMDAwO1xuLyoqXG4gKiBBIHRva2VuIHJlZnJlc2ggd2lsbCBiZSBhdHRlbXB0ZWQgdGhpcyBtYW55IHRpY2tzIGJlZm9yZSB0aGUgY3VycmVudCBzZXNzaW9uIGV4cGlyZXMuICovXG5leHBvcnQgY29uc3QgQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEID0gMztcbi8qXG4gKiBFYXJsaWVzdCB0aW1lIGJlZm9yZSBhbiBhY2Nlc3MgdG9rZW4gZXhwaXJlcyB0aGF0IHRoZSBzZXNzaW9uIHNob3VsZCBiZSByZWZyZXNoZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBFWFBJUllfTUFSR0lOX01TID0gQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEICogQVVUT19SRUZSRVNIX1RJQ0tfRFVSQVRJT05fTVM7XG5leHBvcnQgY29uc3QgR09UUlVFX1VSTCA9ICdodHRwOi8vbG9jYWxob3N0Ojk5OTknO1xuZXhwb3J0IGNvbnN0IFNUT1JBR0VfS0VZID0gJ3N1cGFiYXNlLmF1dGgudG9rZW4nO1xuZXhwb3J0IGNvbnN0IEFVRElFTkNFID0gJyc7XG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0geyAnWC1DbGllbnQtSW5mbyc6IGBnb3RydWUtanMvJHt2ZXJzaW9ufWAgfTtcbmV4cG9ydCBjb25zdCBORVRXT1JLX0ZBSUxVUkUgPSB7XG4gICAgTUFYX1JFVFJJRVM6IDEwLFxuICAgIFJFVFJZX0lOVEVSVkFMOiAyLCAvLyBpbiBkZWNpc2Vjb25kc1xufTtcbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTl9IRUFERVJfTkFNRSA9ICdYLVN1cGFiYXNlLUFwaS1WZXJzaW9uJztcbmV4cG9ydCBjb25zdCBBUElfVkVSU0lPTlMgPSB7XG4gICAgJzIwMjQtMDEtMDEnOiB7XG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5wYXJzZSgnMjAyNC0wMS0wMVQwMDowMDowMC4wWicpLFxuICAgICAgICBuYW1lOiAnMjAyNC0wMS0wMScsXG4gICAgfSxcbn07XG5leHBvcnQgY29uc3QgQkFTRTY0VVJMX1JFR0VYID0gL14oW2EtejAtOV8tXXs0fSkqKCR8W2EtejAtOV8tXXszfSR8W2EtejAtOV8tXXsyfSQpJC9pO1xuZXhwb3J0IGNvbnN0IEpXS1NfVFRMID0gMTAgKiA2MCAqIDEwMDA7IC8vIDEwIG1pbnV0ZXNcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiIsIkFVVE9fUkVGUkVTSF9USUNLX0RVUkFUSU9OX01TIiwiQVVUT19SRUZSRVNIX1RJQ0tfVEhSRVNIT0xEIiwiRVhQSVJZX01BUkdJTl9NUyIsIkdPVFJVRV9VUkwiLCJTVE9SQUdFX0tFWSIsIkFVRElFTkNFIiwiREVGQVVMVF9IRUFERVJTIiwiTkVUV09SS19GQUlMVVJFIiwiTUFYX1JFVFJJRVMiLCJSRVRSWV9JTlRFUlZBTCIsIkFQSV9WRVJTSU9OX0hFQURFUl9OQU1FIiwiQVBJX1ZFUlNJT05TIiwidGltZXN0YW1wIiwiRGF0ZSIsInBhcnNlIiwibmFtZSIsIkJBU0U2NFVSTF9SRUdFWCIsIkpXS1NfVFRMIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/errors.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthApiError: () => (/* binding */ AuthApiError),\n/* harmony export */   AuthError: () => (/* binding */ AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* binding */ AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* binding */ AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidJwtError: () => (/* binding */ AuthInvalidJwtError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* binding */ AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* binding */ AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* binding */ AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* binding */ AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* binding */ AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* binding */ AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* binding */ CustomAuthError),\n/* harmony export */   isAuthApiError: () => (/* binding */ isAuthApiError),\n/* harmony export */   isAuthError: () => (/* binding */ isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* binding */ isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* binding */ isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* binding */ isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* binding */ isAuthWeakPasswordError)\n/* harmony export */ });\nclass AuthError extends Error {\n    constructor(message, status, code){\n        super(message);\n        this.__isAuthError = true;\n        this.name = \"AuthError\";\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthError(error) {\n    return typeof error === \"object\" && error !== null && \"__isAuthError\" in error;\n}\nclass AuthApiError extends AuthError {\n    constructor(message, status, code){\n        super(message, status, code);\n        this.name = \"AuthApiError\";\n        this.status = status;\n        this.code = code;\n    }\n}\nfunction isAuthApiError(error) {\n    return isAuthError(error) && error.name === \"AuthApiError\";\n}\nclass AuthUnknownError extends AuthError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"AuthUnknownError\";\n        this.originalError = originalError;\n    }\n}\nclass CustomAuthError extends AuthError {\n    constructor(message, name, status, code){\n        super(message, status, code);\n        this.name = name;\n        this.status = status;\n    }\n}\nclass AuthSessionMissingError extends CustomAuthError {\n    constructor(){\n        super(\"Auth session missing!\", \"AuthSessionMissingError\", 400, undefined);\n    }\n}\nfunction isAuthSessionMissingError(error) {\n    return isAuthError(error) && error.name === \"AuthSessionMissingError\";\n}\nclass AuthInvalidTokenResponseError extends CustomAuthError {\n    constructor(){\n        super(\"Auth session or user missing\", \"AuthInvalidTokenResponseError\", 500, undefined);\n    }\n}\nclass AuthInvalidCredentialsError extends CustomAuthError {\n    constructor(message){\n        super(message, \"AuthInvalidCredentialsError\", 400, undefined);\n    }\n}\nclass AuthImplicitGrantRedirectError extends CustomAuthError {\n    constructor(message, details = null){\n        super(message, \"AuthImplicitGrantRedirectError\", 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details\n        };\n    }\n}\nfunction isAuthImplicitGrantRedirectError(error) {\n    return isAuthError(error) && error.name === \"AuthImplicitGrantRedirectError\";\n}\nclass AuthPKCEGrantCodeExchangeError extends CustomAuthError {\n    constructor(message, details = null){\n        super(message, \"AuthPKCEGrantCodeExchangeError\", 500, undefined);\n        this.details = null;\n        this.details = details;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            details: this.details\n        };\n    }\n}\nclass AuthRetryableFetchError extends CustomAuthError {\n    constructor(message, status){\n        super(message, \"AuthRetryableFetchError\", status, undefined);\n    }\n}\nfunction isAuthRetryableFetchError(error) {\n    return isAuthError(error) && error.name === \"AuthRetryableFetchError\";\n}\n/**\n * This error is thrown on certain methods when the password used is deemed\n * weak. Inspect the reasons to identify what password strength rules are\n * inadequate.\n */ class AuthWeakPasswordError extends CustomAuthError {\n    constructor(message, status, reasons){\n        super(message, \"AuthWeakPasswordError\", status, \"weak_password\");\n        this.reasons = reasons;\n    }\n}\nfunction isAuthWeakPasswordError(error) {\n    return isAuthError(error) && error.name === \"AuthWeakPasswordError\";\n}\nclass AuthInvalidJwtError extends CustomAuthError {\n    constructor(message){\n        super(message, \"AuthInvalidJwtError\", 400, \"invalid_jwt\");\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTyxNQUFNQSxrQkFBa0JDO0lBQzNCQyxZQUFZQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxDQUFFO1FBQy9CLEtBQUssQ0FBQ0Y7UUFDTixJQUFJLENBQUNHLGFBQWEsR0FBRztRQUNyQixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0gsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0MsSUFBSSxHQUFHQTtJQUNoQjtBQUNKO0FBQ08sU0FBU0csWUFBWUMsS0FBSztJQUM3QixPQUFPLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxRQUFRLG1CQUFtQkE7QUFDN0U7QUFDTyxNQUFNQyxxQkFBcUJWO0lBQzlCRSxZQUFZQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsSUFBSSxDQUFFO1FBQy9CLEtBQUssQ0FBQ0YsU0FBU0MsUUFBUUM7UUFDdkIsSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNILE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLElBQUksR0FBR0E7SUFDaEI7QUFDSjtBQUNPLFNBQVNNLGVBQWVGLEtBQUs7SUFDaEMsT0FBT0QsWUFBWUMsVUFBVUEsTUFBTUYsSUFBSSxLQUFLO0FBQ2hEO0FBQ08sTUFBTUsseUJBQXlCWjtJQUNsQ0UsWUFBWUMsT0FBTyxFQUFFVSxhQUFhLENBQUU7UUFDaEMsS0FBSyxDQUFDVjtRQUNOLElBQUksQ0FBQ0ksSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDTSxhQUFhLEdBQUdBO0lBQ3pCO0FBQ0o7QUFDTyxNQUFNQyx3QkFBd0JkO0lBQ2pDRSxZQUFZQyxPQUFPLEVBQUVJLElBQUksRUFBRUgsTUFBTSxFQUFFQyxJQUFJLENBQUU7UUFDckMsS0FBSyxDQUFDRixTQUFTQyxRQUFRQztRQUN2QixJQUFJLENBQUNFLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNILE1BQU0sR0FBR0E7SUFDbEI7QUFDSjtBQUNPLE1BQU1XLGdDQUFnQ0Q7SUFDekNaLGFBQWM7UUFDVixLQUFLLENBQUMseUJBQXlCLDJCQUEyQixLQUFLYztJQUNuRTtBQUNKO0FBQ08sU0FBU0MsMEJBQTBCUixLQUFLO0lBQzNDLE9BQU9ELFlBQVlDLFVBQVVBLE1BQU1GLElBQUksS0FBSztBQUNoRDtBQUNPLE1BQU1XLHNDQUFzQ0o7SUFDL0NaLGFBQWM7UUFDVixLQUFLLENBQUMsZ0NBQWdDLGlDQUFpQyxLQUFLYztJQUNoRjtBQUNKO0FBQ08sTUFBTUcsb0NBQW9DTDtJQUM3Q1osWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0EsU0FBUywrQkFBK0IsS0FBS2E7SUFDdkQ7QUFDSjtBQUNPLE1BQU1JLHVDQUF1Q047SUFDaERaLFlBQVlDLE9BQU8sRUFBRWtCLFVBQVUsSUFBSSxDQUFFO1FBQ2pDLEtBQUssQ0FBQ2xCLFNBQVMsa0NBQWtDLEtBQUthO1FBQ3RELElBQUksQ0FBQ0ssT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0FDLFNBQVM7UUFDTCxPQUFPO1lBQ0hmLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZKLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCQyxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQmlCLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1FBQ3pCO0lBQ0o7QUFDSjtBQUNPLFNBQVNFLGlDQUFpQ2QsS0FBSztJQUNsRCxPQUFPRCxZQUFZQyxVQUFVQSxNQUFNRixJQUFJLEtBQUs7QUFDaEQ7QUFDTyxNQUFNaUIsdUNBQXVDVjtJQUNoRFosWUFBWUMsT0FBTyxFQUFFa0IsVUFBVSxJQUFJLENBQUU7UUFDakMsS0FBSyxDQUFDbEIsU0FBUyxrQ0FBa0MsS0FBS2E7UUFDdEQsSUFBSSxDQUFDSyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDbkI7SUFDQUMsU0FBUztRQUNMLE9BQU87WUFDSGYsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkosU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJDLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CaUIsU0FBUyxJQUFJLENBQUNBLE9BQU87UUFDekI7SUFDSjtBQUNKO0FBQ08sTUFBTUksZ0NBQWdDWDtJQUN6Q1osWUFBWUMsT0FBTyxFQUFFQyxNQUFNLENBQUU7UUFDekIsS0FBSyxDQUFDRCxTQUFTLDJCQUEyQkMsUUFBUVk7SUFDdEQ7QUFDSjtBQUNPLFNBQVNVLDBCQUEwQmpCLEtBQUs7SUFDM0MsT0FBT0QsWUFBWUMsVUFBVUEsTUFBTUYsSUFBSSxLQUFLO0FBQ2hEO0FBQ0E7Ozs7Q0FJQyxHQUNNLE1BQU1vQiw4QkFBOEJiO0lBQ3ZDWixZQUFZQyxPQUFPLEVBQUVDLE1BQU0sRUFBRXdCLE9BQU8sQ0FBRTtRQUNsQyxLQUFLLENBQUN6QixTQUFTLHlCQUF5QkMsUUFBUTtRQUNoRCxJQUFJLENBQUN3QixPQUFPLEdBQUdBO0lBQ25CO0FBQ0o7QUFDTyxTQUFTQyx3QkFBd0JwQixLQUFLO0lBQ3pDLE9BQU9ELFlBQVlDLFVBQVVBLE1BQU1GLElBQUksS0FBSztBQUNoRDtBQUNPLE1BQU11Qiw0QkFBNEJoQjtJQUNyQ1osWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0EsU0FBUyx1QkFBdUIsS0FBSztJQUMvQztBQUNKLEVBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2Vycm9ycy5qcz9kZGVkIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBBdXRoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9faXNBdXRoRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXV0aEVycm9yJztcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQXV0aEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNBdXRoRXJyb3InIGluIGVycm9yO1xufVxuZXhwb3J0IGNsYXNzIEF1dGhBcGlFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBjb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIHN0YXR1cywgY29kZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBdXRoQXBpRXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoQXBpRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoQXBpRXJyb3InO1xufVxuZXhwb3J0IGNsYXNzIEF1dGhVbmtub3duRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdBdXRoVW5rbm93bkVycm9yJztcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ3VzdG9tQXV0aEVycm9yIGV4dGVuZHMgQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBuYW1lLCBzdGF0dXMsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgc3RhdHVzLCBjb2RlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0F1dGggc2Vzc2lvbiBtaXNzaW5nIScsICdBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcicsIDQwMCwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhTZXNzaW9uTWlzc2luZ0Vycm9yJztcbn1cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZFRva2VuUmVzcG9uc2VFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdBdXRoIHNlc3Npb24gb3IgdXNlciBtaXNzaW5nJywgJ0F1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yJywgNTAwLCB1bmRlZmluZWQpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBdXRoSW52YWxpZENyZWRlbnRpYWxzRXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbnZhbGlkQ3JlZGVudGlhbHNFcnJvcicsIDQwMCwgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkZXRhaWxzID0gbnVsbCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yJywgNTAwLCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgZGV0YWlsczogdGhpcy5kZXRhaWxzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhJbXBsaWNpdEdyYW50UmVkaXJlY3RFcnJvcic7XG59XG5leHBvcnQgY2xhc3MgQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkZXRhaWxzID0gbnVsbCkge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCAnQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yJywgNTAwLCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBudWxsO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgZGV0YWlsczogdGhpcy5kZXRhaWxzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciBleHRlbmRzIEN1c3RvbUF1dGhFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsICdBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcicsIHN0YXR1cywgdW5kZWZpbmVkKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBpc0F1dGhFcnJvcihlcnJvcikgJiYgZXJyb3IubmFtZSA9PT0gJ0F1dGhSZXRyeWFibGVGZXRjaEVycm9yJztcbn1cbi8qKlxuICogVGhpcyBlcnJvciBpcyB0aHJvd24gb24gY2VydGFpbiBtZXRob2RzIHdoZW4gdGhlIHBhc3N3b3JkIHVzZWQgaXMgZGVlbWVkXG4gKiB3ZWFrLiBJbnNwZWN0IHRoZSByZWFzb25zIHRvIGlkZW50aWZ5IHdoYXQgcGFzc3dvcmQgc3RyZW5ndGggcnVsZXMgYXJlXG4gKiBpbmFkZXF1YXRlLlxuICovXG5leHBvcnQgY2xhc3MgQXV0aFdlYWtQYXNzd29yZEVycm9yIGV4dGVuZHMgQ3VzdG9tQXV0aEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIHJlYXNvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhXZWFrUGFzc3dvcmRFcnJvcicsIHN0YXR1cywgJ3dlYWtfcGFzc3dvcmQnKTtcbiAgICAgICAgdGhpcy5yZWFzb25zID0gcmVhc29ucztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gaXNBdXRoRXJyb3IoZXJyb3IpICYmIGVycm9yLm5hbWUgPT09ICdBdXRoV2Vha1Bhc3N3b3JkRXJyb3InO1xufVxuZXhwb3J0IGNsYXNzIEF1dGhJbnZhbGlkSnd0RXJyb3IgZXh0ZW5kcyBDdXN0b21BdXRoRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgJ0F1dGhJbnZhbGlkSnd0RXJyb3InLCA0MDAsICdpbnZhbGlkX2p3dCcpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOlsiQXV0aEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJjb2RlIiwiX19pc0F1dGhFcnJvciIsIm5hbWUiLCJpc0F1dGhFcnJvciIsImVycm9yIiwiQXV0aEFwaUVycm9yIiwiaXNBdXRoQXBpRXJyb3IiLCJBdXRoVW5rbm93bkVycm9yIiwib3JpZ2luYWxFcnJvciIsIkN1c3RvbUF1dGhFcnJvciIsIkF1dGhTZXNzaW9uTWlzc2luZ0Vycm9yIiwidW5kZWZpbmVkIiwiaXNBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciIsIkF1dGhJbnZhbGlkVG9rZW5SZXNwb25zZUVycm9yIiwiQXV0aEludmFsaWRDcmVkZW50aWFsc0Vycm9yIiwiQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIiwiZGV0YWlscyIsInRvSlNPTiIsImlzQXV0aEltcGxpY2l0R3JhbnRSZWRpcmVjdEVycm9yIiwiQXV0aFBLQ0VHcmFudENvZGVFeGNoYW5nZUVycm9yIiwiQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IiLCJpc0F1dGhSZXRyeWFibGVGZXRjaEVycm9yIiwiQXV0aFdlYWtQYXNzd29yZEVycm9yIiwicmVhc29ucyIsImlzQXV0aFdlYWtQYXNzd29yZEVycm9yIiwiQXV0aEludmFsaWRKd3RFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/fetch.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _generateLinkResponse: () => (/* binding */ _generateLinkResponse),\n/* harmony export */   _noResolveJsonResponse: () => (/* binding */ _noResolveJsonResponse),\n/* harmony export */   _request: () => (/* binding */ _request),\n/* harmony export */   _sessionResponse: () => (/* binding */ _sessionResponse),\n/* harmony export */   _sessionResponsePassword: () => (/* binding */ _sessionResponsePassword),\n/* harmony export */   _ssoResponse: () => (/* binding */ _ssoResponse),\n/* harmony export */   _userResponse: () => (/* binding */ _userResponse),\n/* harmony export */   handleError: () => (/* binding */ handleError)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n\n\n\n\nconst _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\nconst NETWORK_ERROR_CODES = [\n    502,\n    503,\n    504\n];\nasync function handleError(error) {\n    var _a;\n    if (!(0,_helpers__WEBPACK_IMPORTED_MODULE_1__.looksLikeFetchResponse)(error)) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), 0);\n    }\n    if (NETWORK_ERROR_CODES.includes(error.status)) {\n        // status in 500...599 range - server had an error, request might be retryed.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(error), error.status);\n    }\n    let data;\n    try {\n        data = await error.json();\n    } catch (e) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthUnknownError(_getErrorMessage(e), e);\n    }\n    let errorCode = undefined;\n    const responseAPIVersion = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.parseResponseAPIVersion)(error);\n    if (responseAPIVersion && responseAPIVersion.getTime() >= _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS[\"2024-01-01\"].timestamp && typeof data === \"object\" && data && typeof data.code === \"string\") {\n        errorCode = data.code;\n    } else if (typeof data === \"object\" && data && typeof data.error_code === \"string\") {\n        errorCode = data.error_code;\n    }\n    if (!errorCode) {\n        // Legacy support for weak password errors, when there were no error codes\n        if (typeof data === \"object\" && data && typeof data.weak_password === \"object\" && data.weak_password && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.reasons.reduce((a, i)=>a && typeof i === \"string\", true)) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, data.weak_password.reasons);\n        }\n    } else if (errorCode === \"weak_password\") {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthWeakPasswordError(_getErrorMessage(data), error.status, ((_a = data.weak_password) === null || _a === void 0 ? void 0 : _a.reasons) || []);\n    } else if (errorCode === \"session_not_found\") {\n        // The `session_id` inside the JWT does not correspond to a row in the\n        // `sessions` table. This usually means the user has signed out, has been\n        // deleted, or their session has somehow been terminated.\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthSessionMissingError();\n    }\n    throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthApiError(_getErrorMessage(data), error.status || 500, errorCode);\n}\nconst _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\") {\n        return params;\n    }\n    params.headers = Object.assign({\n        \"Content-Type\": \"application/json;charset=UTF-8\"\n    }, options === null || options === void 0 ? void 0 : options.headers);\n    params.body = JSON.stringify(body);\n    return Object.assign(Object.assign({}, params), parameters);\n};\nasync function _request(fetcher, method, url, options) {\n    var _a;\n    const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers);\n    if (!headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME]) {\n        headers[_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME] = _constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSIONS[\"2024-01-01\"].name;\n    }\n    if (options === null || options === void 0 ? void 0 : options.jwt) {\n        headers[\"Authorization\"] = `Bearer ${options.jwt}`;\n    }\n    const qs = (_a = options === null || options === void 0 ? void 0 : options.query) !== null && _a !== void 0 ? _a : {};\n    if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n        qs[\"redirect_to\"] = options.redirectTo;\n    }\n    const queryString = Object.keys(qs).length ? \"?\" + new URLSearchParams(qs).toString() : \"\";\n    const data = await _handleRequest(fetcher, method, url + queryString, {\n        headers,\n        noResolveJson: options === null || options === void 0 ? void 0 : options.noResolveJson\n    }, {}, options === null || options === void 0 ? void 0 : options.body);\n    return (options === null || options === void 0 ? void 0 : options.xform) ? options === null || options === void 0 ? void 0 : options.xform(data) : {\n        data: Object.assign({}, data),\n        error: null\n    };\n}\nasync function _handleRequest(fetcher, method, url, options, parameters, body) {\n    const requestParams = _getRequestParams(method, options, parameters, body);\n    let result;\n    try {\n        result = await fetcher(url, Object.assign({}, requestParams));\n    } catch (e) {\n        console.error(e);\n        // fetch failed, likely due to a network or CORS error\n        throw new _errors__WEBPACK_IMPORTED_MODULE_2__.AuthRetryableFetchError(_getErrorMessage(e), 0);\n    }\n    if (!result.ok) {\n        await handleError(result);\n    }\n    if (options === null || options === void 0 ? void 0 : options.noResolveJson) {\n        return result;\n    }\n    try {\n        return await result.json();\n    } catch (e) {\n        await handleError(e);\n    }\n}\nfunction _sessionResponse(data) {\n    var _a;\n    let session = null;\n    if (hasSession(data)) {\n        session = Object.assign({}, data);\n        if (!data.expires_at) {\n            session.expires_at = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.expiresAt)(data.expires_in);\n        }\n    }\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return {\n        data: {\n            session,\n            user\n        },\n        error: null\n    };\n}\nfunction _sessionResponsePassword(data) {\n    const response = _sessionResponse(data);\n    if (!response.error && data.weak_password && typeof data.weak_password === \"object\" && Array.isArray(data.weak_password.reasons) && data.weak_password.reasons.length && data.weak_password.message && typeof data.weak_password.message === \"string\" && data.weak_password.reasons.reduce((a, i)=>a && typeof i === \"string\", true)) {\n        response.data.weak_password = data.weak_password;\n    }\n    return response;\n}\nfunction _userResponse(data) {\n    var _a;\n    const user = (_a = data.user) !== null && _a !== void 0 ? _a : data;\n    return {\n        data: {\n            user\n        },\n        error: null\n    };\n}\nfunction _ssoResponse(data) {\n    return {\n        data,\n        error: null\n    };\n}\nfunction _generateLinkResponse(data) {\n    const { action_link, email_otp, hashed_token, redirect_to, verification_type } = data, rest = (0,tslib__WEBPACK_IMPORTED_MODULE_3__.__rest)(data, [\n        \"action_link\",\n        \"email_otp\",\n        \"hashed_token\",\n        \"redirect_to\",\n        \"verification_type\"\n    ]);\n    const properties = {\n        action_link,\n        email_otp,\n        hashed_token,\n        redirect_to,\n        verification_type\n    };\n    const user = Object.assign({}, rest);\n    return {\n        data: {\n            properties,\n            user\n        },\n        error: null\n    };\n}\nfunction _noResolveJsonResponse(data) {\n    return data;\n}\n/**\n * hasSession checks if the response object contains a valid session\n * @param data A response object\n * @returns true if a session is in the response\n */ function hasSession(data) {\n    return data.access_token && data.refresh_token && data.expires_in;\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2ZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNxQztBQUNtQjtBQUM2QztBQUNwSSxNQUFNVyxtQkFBbUIsQ0FBQ0MsTUFBUUEsSUFBSUMsR0FBRyxJQUFJRCxJQUFJRSxPQUFPLElBQUlGLElBQUlHLGlCQUFpQixJQUFJSCxJQUFJSSxLQUFLLElBQUlDLEtBQUtDLFNBQVMsQ0FBQ047QUFDakgsTUFBTU8sc0JBQXNCO0lBQUM7SUFBSztJQUFLO0NBQUk7QUFDcEMsZUFBZUMsWUFBWUosS0FBSztJQUNuQyxJQUFJSztJQUNKLElBQUksQ0FBQ2pCLGdFQUFzQkEsQ0FBQ1ksUUFBUTtRQUNoQyxNQUFNLElBQUlULDREQUF1QkEsQ0FBQ0ksaUJBQWlCSyxRQUFRO0lBQy9EO0lBQ0EsSUFBSUcsb0JBQW9CRyxRQUFRLENBQUNOLE1BQU1PLE1BQU0sR0FBRztRQUM1Qyw2RUFBNkU7UUFDN0UsTUFBTSxJQUFJaEIsNERBQXVCQSxDQUFDSSxpQkFBaUJLLFFBQVFBLE1BQU1PLE1BQU07SUFDM0U7SUFDQSxJQUFJQztJQUNKLElBQUk7UUFDQUEsT0FBTyxNQUFNUixNQUFNUyxJQUFJO0lBQzNCLEVBQ0EsT0FBT0MsR0FBRztRQUNOLE1BQU0sSUFBSWpCLHFEQUFnQkEsQ0FBQ0UsaUJBQWlCZSxJQUFJQTtJQUNwRDtJQUNBLElBQUlDLFlBQVlDO0lBQ2hCLE1BQU1DLHFCQUFxQnhCLGlFQUF1QkEsQ0FBQ1c7SUFDbkQsSUFBSWEsc0JBQ0FBLG1CQUFtQkMsT0FBTyxNQUFNN0Isb0RBQVksQ0FBQyxhQUFhLENBQUM4QixTQUFTLElBQ3BFLE9BQU9QLFNBQVMsWUFDaEJBLFFBQ0EsT0FBT0EsS0FBS1EsSUFBSSxLQUFLLFVBQVU7UUFDL0JMLFlBQVlILEtBQUtRLElBQUk7SUFDekIsT0FDSyxJQUFJLE9BQU9SLFNBQVMsWUFBWUEsUUFBUSxPQUFP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QUNVLGFBQWEsR0FBR1YsS0FBS1UsYUFBYTtJQUNwRDtJQUNBLE9BQU8yQztBQUNYO0FBQ08sU0FBU0MsY0FBY3RELElBQUk7SUFDOUIsSUFBSUg7SUFDSixNQUFNc0QsT0FBTyxDQUFDdEQsS0FBS0csS0FBS21ELElBQUksTUFBTSxRQUFRdEQsT0FBTyxLQUFLLElBQUlBLEtBQUtHO0lBQy9ELE9BQU87UUFBRUEsTUFBTTtZQUFFbUQ7UUFBSztRQUFHM0QsT0FBTztJQUFLO0FBQ3pDO0FBQ08sU0FBUytELGFBQWF2RCxJQUFJO0lBQzdCLE9BQU87UUFBRUE7UUFBTVIsT0FBTztJQUFLO0FBQy9CO0FBQ08sU0FBU2dFLHNCQUFzQnhELElBQUk7SUFDdEMsTUFBTSxFQUFFeUQsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxpQkFBaUIsRUFBRSxHQUFHN0QsTUFBTThELE9BQU90Riw2Q0FBTUEsQ0FBQ3dCLE1BQU07UUFBQztRQUFlO1FBQWE7UUFBZ0I7UUFBZTtLQUFvQjtJQUMzTCxNQUFNK0QsYUFBYTtRQUNmTjtRQUNBQztRQUNBQztRQUNBQztRQUNBQztJQUNKO0lBQ0EsTUFBTVYsT0FBTzFCLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdvQztJQUMvQixPQUFPO1FBQ0g5RCxNQUFNO1lBQ0YrRDtZQUNBWjtRQUNKO1FBQ0EzRCxPQUFPO0lBQ1g7QUFDSjtBQUNPLFNBQVN3RSx1QkFBdUJoRSxJQUFJO0lBQ3ZDLE9BQU9BO0FBQ1g7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU2dELFdBQVdoRCxJQUFJO0lBQ3BCLE9BQU9BLEtBQUtpRSxZQUFZLElBQUlqRSxLQUFLa0UsYUFBYSxJQUFJbEUsS0FBS2tELFVBQVU7QUFDckUsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvZmV0Y2guanM/MDIzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEFQSV9WRVJTSU9OUywgQVBJX1ZFUlNJT05fSEVBREVSX05BTUUgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBleHBpcmVzQXQsIGxvb2tzTGlrZUZldGNoUmVzcG9uc2UsIHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uIH0gZnJvbSAnLi9oZWxwZXJzJztcbmltcG9ydCB7IEF1dGhBcGlFcnJvciwgQXV0aFJldHJ5YWJsZUZldGNoRXJyb3IsIEF1dGhXZWFrUGFzc3dvcmRFcnJvciwgQXV0aFVua25vd25FcnJvciwgQXV0aFNlc3Npb25NaXNzaW5nRXJyb3IsIH0gZnJvbSAnLi9lcnJvcnMnO1xuY29uc3QgX2dldEVycm9yTWVzc2FnZSA9IChlcnIpID0+IGVyci5tc2cgfHwgZXJyLm1lc3NhZ2UgfHwgZXJyLmVycm9yX2Rlc2NyaXB0aW9uIHx8IGVyci5lcnJvciB8fCBKU09OLnN0cmluZ2lmeShlcnIpO1xuY29uc3QgTkVUV09SS19FUlJPUl9DT0RFUyA9IFs1MDIsIDUwMywgNTA0XTtcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcikge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIWxvb2tzTGlrZUZldGNoUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVycm9yKSwgMCk7XG4gICAgfVxuICAgIGlmIChORVRXT1JLX0VSUk9SX0NPREVTLmluY2x1ZGVzKGVycm9yLnN0YXR1cykpIHtcbiAgICAgICAgLy8gc3RhdHVzIGluIDUwMC4uLjU5OSByYW5nZSAtIHNlcnZlciBoYWQgYW4gZXJyb3IsIHJlcXVlc3QgbWlnaHQgYmUgcmV0cnllZC5cbiAgICAgICAgdGhyb3cgbmV3IEF1dGhSZXRyeWFibGVGZXRjaEVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCBlcnJvci5zdGF0dXMpO1xuICAgIH1cbiAgICBsZXQgZGF0YTtcbiAgICB0cnkge1xuICAgICAgICBkYXRhID0gYXdhaXQgZXJyb3IuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgQXV0aFVua25vd25FcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGUpLCBlKTtcbiAgICB9XG4gICAgbGV0IGVycm9yQ29kZSA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCByZXNwb25zZUFQSVZlcnNpb24gPSBwYXJzZVJlc3BvbnNlQVBJVmVyc2lvbihlcnJvcik7XG4gICAgaWYgKHJlc3BvbnNlQVBJVmVyc2lvbiAmJlxuICAgICAgICByZXNwb25zZUFQSVZlcnNpb24uZ2V0VGltZSgpID49IEFQSV9WRVJTSU9OU1snMjAyNC0wMS0wMSddLnRpbWVzdGFtcCAmJlxuICAgICAgICB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgZGF0YSAmJlxuICAgICAgICB0eXBlb2YgZGF0YS5jb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICBlcnJvckNvZGUgPSBkYXRhLmNvZGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBkYXRhICYmIHR5cGVvZiBkYXRhLmVycm9yX2NvZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGVycm9yQ29kZSA9IGRhdGEuZXJyb3JfY29kZTtcbiAgICB9XG4gICAgaWYgKCFlcnJvckNvZGUpIHtcbiAgICAgICAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHdlYWsgcGFzc3dvcmQgZXJyb3JzLCB3aGVuIHRoZXJlIHdlcmUgbm8gZXJyb3IgY29kZXNcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgZGF0YSAmJlxuICAgICAgICAgICAgdHlwZW9mIGRhdGEud2Vha19wYXNzd29yZCA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIGRhdGEud2Vha19wYXNzd29yZCAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucykgJiZcbiAgICAgICAgICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLmxlbmd0aCAmJlxuICAgICAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMucmVkdWNlKChhLCBpKSA9PiBhICYmIHR5cGVvZiBpID09PSAnc3RyaW5nJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBdXRoV2Vha1Bhc3N3b3JkRXJyb3IoX2dldEVycm9yTWVzc2FnZShkYXRhKSwgZXJyb3Iuc3RhdHVzLCBkYXRhLndlYWtfcGFzc3dvcmQucmVhc29ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3JDb2RlID09PSAnd2Vha19wYXNzd29yZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF1dGhXZWFrUGFzc3dvcmRFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGRhdGEpLCBlcnJvci5zdGF0dXMsICgoX2EgPSBkYXRhLndlYWtfcGFzc3dvcmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFzb25zKSB8fCBbXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yQ29kZSA9PT0gJ3Nlc3Npb25fbm90X2ZvdW5kJykge1xuICAgICAgICAvLyBUaGUgYHNlc3Npb25faWRgIGluc2lkZSB0aGUgSldUIGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gYSByb3cgaW4gdGhlXG4gICAgICAgIC8vIGBzZXNzaW9uc2AgdGFibGUuIFRoaXMgdXN1YWxseSBtZWFucyB0aGUgdXNlciBoYXMgc2lnbmVkIG91dCwgaGFzIGJlZW5cbiAgICAgICAgLy8gZGVsZXRlZCwgb3IgdGhlaXIgc2Vzc2lvbiBoYXMgc29tZWhvdyBiZWVuIHRlcm1pbmF0ZWQuXG4gICAgICAgIHRocm93IG5ldyBBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvcigpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQXV0aEFwaUVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZGF0YSksIGVycm9yLnN0YXR1cyB8fCA1MDAsIGVycm9yQ29kZSk7XG59XG5jb25zdCBfZ2V0UmVxdWVzdFBhcmFtcyA9IChtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IG1ldGhvZCwgaGVhZGVyczogKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKSB8fCB7fSB9O1xuICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIHBhcmFtcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PVVURi04JyB9LCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyk7XG4gICAgcGFyYW1zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShib2R5KTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCBwYXJhbWV0ZXJzKTtcbn07XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gX3JlcXVlc3QoZmV0Y2hlciwgbWV0aG9kLCB1cmwsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKTtcbiAgICBpZiAoIWhlYWRlcnNbQVBJX1ZFUlNJT05fSEVBREVSX05BTUVdKSB7XG4gICAgICAgIGhlYWRlcnNbQVBJX1ZFUlNJT05fSEVBREVSX05BTUVdID0gQVBJX1ZFUlNJT05TWycyMDI0LTAxLTAxJ10ubmFtZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5qd3QpIHtcbiAgICAgICAgaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke29wdGlvbnMuand0fWA7XG4gICAgfVxuICAgIGNvbnN0IHFzID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnF1ZXJ5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlZGlyZWN0VG8pIHtcbiAgICAgICAgcXNbJ3JlZGlyZWN0X3RvJ10gPSBvcHRpb25zLnJlZGlyZWN0VG87XG4gICAgfVxuICAgIGNvbnN0IHF1ZXJ5U3RyaW5nID0gT2JqZWN0LmtleXMocXMpLmxlbmd0aCA/ICc/JyArIG5ldyBVUkxTZWFyY2hQYXJhbXMocXMpLnRvU3RyaW5nKCkgOiAnJztcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgbWV0aG9kLCB1cmwgKyBxdWVyeVN0cmluZywge1xuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBub1Jlc29sdmVKc29uOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbixcbiAgICB9LCB7fSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmJvZHkpO1xuICAgIHJldHVybiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnhmb3JtKSA/IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy54Zm9ybShkYXRhKSA6IHsgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZGF0YSksIGVycm9yOiBudWxsIH07XG59XG5hc3luYyBmdW5jdGlvbiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCBtZXRob2QsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSkge1xuICAgIGNvbnN0IHJlcXVlc3RQYXJhbXMgPSBfZ2V0UmVxdWVzdFBhcmFtcyhtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgZmV0Y2hlcih1cmwsIE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3RQYXJhbXMpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgLy8gZmV0Y2ggZmFpbGVkLCBsaWtlbHkgZHVlIHRvIGEgbmV0d29yayBvciBDT1JTIGVycm9yXG4gICAgICAgIHRocm93IG5ldyBBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGUpLCAwKTtcbiAgICB9XG4gICAgaWYgKCFyZXN1bHQub2spIHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IocmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gX3Nlc3Npb25SZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBzZXNzaW9uID0gbnVsbDtcbiAgICBpZiAoaGFzU2Vzc2lvbihkYXRhKSkge1xuICAgICAgICBzZXNzaW9uID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YSk7XG4gICAgICAgIGlmICghZGF0YS5leHBpcmVzX2F0KSB7XG4gICAgICAgICAgICBzZXNzaW9uLmV4cGlyZXNfYXQgPSBleHBpcmVzQXQoZGF0YS5leHBpcmVzX2luKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1c2VyID0gKF9hID0gZGF0YS51c2VyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRhO1xuICAgIHJldHVybiB7IGRhdGE6IHsgc2Vzc2lvbiwgdXNlciB9LCBlcnJvcjogbnVsbCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9zZXNzaW9uUmVzcG9uc2VQYXNzd29yZChkYXRhKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBfc2Vzc2lvblJlc3BvbnNlKGRhdGEpO1xuICAgIGlmICghcmVzcG9uc2UuZXJyb3IgJiZcbiAgICAgICAgZGF0YS53ZWFrX3Bhc3N3b3JkICYmXG4gICAgICAgIHR5cGVvZiBkYXRhLndlYWtfcGFzc3dvcmQgPT09ICdvYmplY3QnICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkoZGF0YS53ZWFrX3Bhc3N3b3JkLnJlYXNvbnMpICYmXG4gICAgICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLmxlbmd0aCAmJlxuICAgICAgICBkYXRhLndlYWtfcGFzc3dvcmQubWVzc2FnZSAmJlxuICAgICAgICB0eXBlb2YgZGF0YS53ZWFrX3Bhc3N3b3JkLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIGRhdGEud2Vha19wYXNzd29yZC5yZWFzb25zLnJlZHVjZSgoYSwgaSkgPT4gYSAmJiB0eXBlb2YgaSA9PT0gJ3N0cmluZycsIHRydWUpKSB7XG4gICAgICAgIHJlc3BvbnNlLmRhdGEud2Vha19wYXNzd29yZCA9IGRhdGEud2Vha19wYXNzd29yZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF91c2VyUmVzcG9uc2UoZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB1c2VyID0gKF9hID0gZGF0YS51c2VyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkYXRhO1xuICAgIHJldHVybiB7IGRhdGE6IHsgdXNlciB9LCBlcnJvcjogbnVsbCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9zc29SZXNwb25zZShkYXRhKSB7XG4gICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfZ2VuZXJhdGVMaW5rUmVzcG9uc2UoZGF0YSkge1xuICAgIGNvbnN0IHsgYWN0aW9uX2xpbmssIGVtYWlsX290cCwgaGFzaGVkX3Rva2VuLCByZWRpcmVjdF90bywgdmVyaWZpY2F0aW9uX3R5cGUgfSA9IGRhdGEsIHJlc3QgPSBfX3Jlc3QoZGF0YSwgW1wiYWN0aW9uX2xpbmtcIiwgXCJlbWFpbF9vdHBcIiwgXCJoYXNoZWRfdG9rZW5cIiwgXCJyZWRpcmVjdF90b1wiLCBcInZlcmlmaWNhdGlvbl90eXBlXCJdKTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBhY3Rpb25fbGluayxcbiAgICAgICAgZW1haWxfb3RwLFxuICAgICAgICBoYXNoZWRfdG9rZW4sXG4gICAgICAgIHJlZGlyZWN0X3RvLFxuICAgICAgICB2ZXJpZmljYXRpb25fdHlwZSxcbiAgICB9O1xuICAgIGNvbnN0IHVzZXIgPSBPYmplY3QuYXNzaWduKHt9LCByZXN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgdXNlcixcbiAgICAgICAgfSxcbiAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfbm9SZXNvbHZlSnNvblJlc3BvbnNlKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogaGFzU2Vzc2lvbiBjaGVja3MgaWYgdGhlIHJlc3BvbnNlIG9iamVjdCBjb250YWlucyBhIHZhbGlkIHNlc3Npb25cbiAqIEBwYXJhbSBkYXRhIEEgcmVzcG9uc2Ugb2JqZWN0XG4gKiBAcmV0dXJucyB0cnVlIGlmIGEgc2Vzc2lvbiBpcyBpbiB0aGUgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gaGFzU2Vzc2lvbihkYXRhKSB7XG4gICAgcmV0dXJuIGRhdGEuYWNjZXNzX3Rva2VuICYmIGRhdGEucmVmcmVzaF90b2tlbiAmJiBkYXRhLmV4cGlyZXNfaW47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiXSwibmFtZXMiOlsiX19yZXN0IiwiQVBJX1ZFUlNJT05TIiwiQVBJX1ZFUlNJT05fSEVBREVSX05BTUUiLCJleHBpcmVzQXQiLCJsb29rc0xpa2VGZXRjaFJlc3BvbnNlIiwicGFyc2VSZXNwb25zZUFQSVZlcnNpb24iLCJBdXRoQXBpRXJyb3IiLCJBdXRoUmV0cnlhYmxlRmV0Y2hFcnJvciIsIkF1dGhXZWFrUGFzc3dvcmRFcnJvciIsIkF1dGhVbmtub3duRXJyb3IiLCJBdXRoU2Vzc2lvbk1pc3NpbmdFcnJvciIsIl9nZXRFcnJvck1lc3NhZ2UiLCJlcnIiLCJtc2ciLCJtZXNzYWdlIiwiZXJyb3JfZGVzY3JpcHRpb24iLCJlcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJORVRXT1JLX0VSUk9SX0NPREVTIiwiaGFuZGxlRXJyb3IiLCJfYSIsImluY2x1ZGVzIiwic3RhdHVzIiwiZGF0YSIsImpzb24iLCJlIiwiZXJyb3JDb2RlIiwidW5kZWZpbmVkIiwicmVzcG9uc2VBUElWZXJzaW9uIiwiZ2V0VGltZSIsInRpbWVzdGFtcCIsImNvZGUiLCJlcnJvcl9jb2RlIiwid2Vha19wYXNzd29yZCIsIkFycmF5IiwiaXNBcnJheSIsInJlYXNvbnMiLCJsZW5ndGgiLCJyZWR1Y2UiLCJhIiwiaSIsIl9nZXRSZXF1ZXN0UGFyYW1zIiwibWV0aG9kIiwib3B0aW9ucyIsInBhcmFtZXRlcnMiLCJib2R5IiwicGFyYW1zIiwiaGVhZGVycyIsIk9iamVjdCIsImFzc2lnbiIsIl9yZXF1ZXN0IiwiZmV0Y2hlciIsInVybCIsIm5hbWUiLCJqd3QiLCJxcyIsInF1ZXJ5IiwicmVkaXJlY3RUbyIsInF1ZXJ5U3RyaW5nIiwia2V5cyIsIlVSTFNlYXJjaFBhcmFtcyIsInRvU3RyaW5nIiwiX2hhbmRsZVJlcXVlc3QiLCJub1Jlc29sdmVKc29uIiwieGZvcm0iLCJyZXF1ZXN0UGFyYW1zIiwicmVzdWx0IiwiY29uc29sZSIsIm9rIiwiX3Nlc3Npb25SZXNwb25zZSIsInNlc3Npb24iLCJoYXNTZXNzaW9uIiwiZXhwaXJlc19hdCIsImV4cGlyZXNfaW4iLCJ1c2VyIiwiX3Nlc3Npb25SZXNwb25zZVBhc3N3b3JkIiwicmVzcG9uc2UiLCJfdXNlclJlc3BvbnNlIiwiX3Nzb1Jlc3BvbnNlIiwiX2dlbmVyYXRlTGlua1Jlc3BvbnNlIiwiYWN0aW9uX2xpbmsiLCJlbWFpbF9vdHAiLCJoYXNoZWRfdG9rZW4iLCJyZWRpcmVjdF90byIsInZlcmlmaWNhdGlvbl90eXBlIiwicmVzdCIsInByb3BlcnRpZXMiLCJfbm9SZXNvbHZlSnNvblJlc3BvbnNlIiwiYWNjZXNzX3Rva2VuIiwicmVmcmVzaF90b2tlbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/helpers.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Deferred: () => (/* binding */ Deferred),\n/* harmony export */   decodeJWT: () => (/* binding */ decodeJWT),\n/* harmony export */   deepClone: () => (/* binding */ deepClone),\n/* harmony export */   expiresAt: () => (/* binding */ expiresAt),\n/* harmony export */   generatePKCEChallenge: () => (/* binding */ generatePKCEChallenge),\n/* harmony export */   generatePKCEVerifier: () => (/* binding */ generatePKCEVerifier),\n/* harmony export */   getAlgorithm: () => (/* binding */ getAlgorithm),\n/* harmony export */   getCodeChallengeAndMethod: () => (/* binding */ getCodeChallengeAndMethod),\n/* harmony export */   getItemAsync: () => (/* binding */ getItemAsync),\n/* harmony export */   insecureUserWarningProxy: () => (/* binding */ insecureUserWarningProxy),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   looksLikeFetchResponse: () => (/* binding */ looksLikeFetchResponse),\n/* harmony export */   parseParametersFromURL: () => (/* binding */ parseParametersFromURL),\n/* harmony export */   parseResponseAPIVersion: () => (/* binding */ parseResponseAPIVersion),\n/* harmony export */   removeItemAsync: () => (/* binding */ removeItemAsync),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   retryable: () => (/* binding */ retryable),\n/* harmony export */   setItemAsync: () => (/* binding */ setItemAsync),\n/* harmony export */   sleep: () => (/* binding */ sleep),\n/* harmony export */   supportsLocalStorage: () => (/* binding */ supportsLocalStorage),\n/* harmony export */   userNotAvailableProxy: () => (/* binding */ userNotAvailableProxy),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   validateExp: () => (/* binding */ validateExp),\n/* harmony export */   validateUUID: () => (/* binding */ validateUUID)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/constants.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _base64url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base64url */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n\n\n\nfunction expiresAt(expiresIn) {\n    const timeNow = Math.round(Date.now() / 1000);\n    return timeNow + expiresIn;\n}\nfunction uuid() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n        const r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n}\nconst isBrowser = ()=> false && 0;\nconst localStorageWriteTests = {\n    tested: false,\n    writable: false\n};\n/**\n * Checks whether localStorage is supported on this browser.\n */ const supportsLocalStorage = ()=>{\n    if (!isBrowser()) {\n        return false;\n    }\n    try {\n        if (typeof globalThis.localStorage !== \"object\") {\n            return false;\n        }\n    } catch (e) {\n        // DOM exception when accessing `localStorage`\n        return false;\n    }\n    if (localStorageWriteTests.tested) {\n        return localStorageWriteTests.writable;\n    }\n    const randomKey = `lswt-${Math.random()}${Math.random()}`;\n    try {\n        globalThis.localStorage.setItem(randomKey, randomKey);\n        globalThis.localStorage.removeItem(randomKey);\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = true;\n    } catch (e) {\n        // localStorage can't be written to\n        // https://www.chromium.org/for-testers/bug-reporting-guidelines/uncaught-securityerror-failed-to-read-the-localstorage-property-from-window-access-is-denied-for-this-document\n        localStorageWriteTests.tested = true;\n        localStorageWriteTests.writable = false;\n    }\n    return localStorageWriteTests.writable;\n};\n/**\n * Extracts parameters encoded in the URL both in the query and fragment.\n */ function parseParametersFromURL(href) {\n    const result = {};\n    const url = new URL(href);\n    if (url.hash && url.hash[0] === \"#\") {\n        try {\n            const hashSearchParams = new URLSearchParams(url.hash.substring(1));\n            hashSearchParams.forEach((value, key)=>{\n                result[key] = value;\n            });\n        } catch (e) {\n        // hash is not a query string\n        }\n    }\n    // search parameters take precedence over hash parameters\n    url.searchParams.forEach((value, key)=>{\n        result[key] = value;\n    });\n    return result;\n}\nconst resolveFetch = (customFetch)=>{\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    } else if (typeof fetch === \"undefined\") {\n        _fetch = (...args)=>Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\", 23)).then(({ default: fetch1 })=>fetch1(...args));\n    } else {\n        _fetch = fetch;\n    }\n    return (...args)=>_fetch(...args);\n};\nconst looksLikeFetchResponse = (maybeResponse)=>{\n    return typeof maybeResponse === \"object\" && maybeResponse !== null && \"status\" in maybeResponse && \"ok\" in maybeResponse && \"json\" in maybeResponse && typeof maybeResponse.json === \"function\";\n};\n// Storage helpers\nconst setItemAsync = async (storage, key, data)=>{\n    await storage.setItem(key, JSON.stringify(data));\n};\nconst getItemAsync = async (storage, key)=>{\n    const value = await storage.getItem(key);\n    if (!value) {\n        return null;\n    }\n    try {\n        return JSON.parse(value);\n    } catch (_a) {\n        return value;\n    }\n};\nconst removeItemAsync = async (storage, key)=>{\n    await storage.removeItem(key);\n};\n/**\n * A deferred represents some asynchronous work that is not yet finished, which\n * may or may not culminate in a value.\n * Taken from: https://github.com/mike-north/types/blob/master/src/async.ts\n */ class Deferred {\n    constructor(){\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        this.promise = new Deferred.promiseConstructor((res, rej)=>{\n            // eslint-disable-next-line @typescript-eslint/no-extra-semi\n            ;\n            this.resolve = res;\n            this.reject = rej;\n        });\n    }\n}\nDeferred.promiseConstructor = Promise;\nfunction decodeJWT(token) {\n    const parts = token.split(\".\");\n    if (parts.length !== 3) {\n        throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthInvalidJwtError(\"Invalid JWT structure\");\n    }\n    // Regex checks for base64url format\n    for(let i = 0; i < parts.length; i++){\n        if (!_constants__WEBPACK_IMPORTED_MODULE_0__.BASE64URL_REGEX.test(parts[i])) {\n            throw new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthInvalidJwtError(\"JWT not in base64url format\");\n        }\n    }\n    const data = {\n        // using base64url lib\n        header: JSON.parse((0,_base64url__WEBPACK_IMPORTED_MODULE_2__.stringFromBase64URL)(parts[0])),\n        payload: JSON.parse((0,_base64url__WEBPACK_IMPORTED_MODULE_2__.stringFromBase64URL)(parts[1])),\n        signature: (0,_base64url__WEBPACK_IMPORTED_MODULE_2__.base64UrlToUint8Array)(parts[2]),\n        raw: {\n            header: parts[0],\n            payload: parts[1]\n        }\n    };\n    return data;\n}\n/**\n * Creates a promise that resolves to null after some time.\n */ async function sleep(time) {\n    return await new Promise((accept)=>{\n        setTimeout(()=>accept(null), time);\n    });\n}\n/**\n * Converts the provided async function into a retryable function. Each result\n * or thrown error is sent to the isRetryable function which should return true\n * if the function should run again.\n */ function retryable(fn, isRetryable) {\n    const promise = new Promise((accept, reject)=>{\n        // eslint-disable-next-line @typescript-eslint/no-extra-semi\n        ;\n        (async ()=>{\n            for(let attempt = 0; attempt < Infinity; attempt++){\n                try {\n                    const result = await fn(attempt);\n                    if (!isRetryable(attempt, null, result)) {\n                        accept(result);\n                        return;\n                    }\n                } catch (e) {\n                    if (!isRetryable(attempt, e)) {\n                        reject(e);\n                        return;\n                    }\n                }\n            }\n        })();\n    });\n    return promise;\n}\nfunction dec2hex(dec) {\n    return (\"0\" + dec.toString(16)).substr(-2);\n}\n// Functions below taken from: https://stackoverflow.com/questions/63309409/creating-a-code-verifier-and-challenge-for-pkce-auth-on-spotify-api-in-reactjs\nfunction generatePKCEVerifier() {\n    const verifierLength = 56;\n    const array = new Uint32Array(verifierLength);\n    if (typeof crypto === \"undefined\") {\n        const charSet = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\";\n        const charSetLen = charSet.length;\n        let verifier = \"\";\n        for(let i = 0; i < verifierLength; i++){\n            verifier += charSet.charAt(Math.floor(Math.random() * charSetLen));\n        }\n        return verifier;\n    }\n    crypto.getRandomValues(array);\n    return Array.from(array, dec2hex).join(\"\");\n}\nasync function sha256(randomString) {\n    const encoder = new TextEncoder();\n    const encodedData = encoder.encode(randomString);\n    const hash = await crypto.subtle.digest(\"SHA-256\", encodedData);\n    const bytes = new Uint8Array(hash);\n    return Array.from(bytes).map((c)=>String.fromCharCode(c)).join(\"\");\n}\nasync function generatePKCEChallenge(verifier) {\n    const hasCryptoSupport = typeof crypto !== \"undefined\" && typeof crypto.subtle !== \"undefined\" && typeof TextEncoder !== \"undefined\";\n    if (!hasCryptoSupport) {\n        console.warn(\"WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256.\");\n        return verifier;\n    }\n    const hashed = await sha256(verifier);\n    return btoa(hashed).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\nasync function getCodeChallengeAndMethod(storage, storageKey, isPasswordRecovery = false) {\n    const codeVerifier = generatePKCEVerifier();\n    let storedCodeVerifier = codeVerifier;\n    if (isPasswordRecovery) {\n        storedCodeVerifier += \"/PASSWORD_RECOVERY\";\n    }\n    await setItemAsync(storage, `${storageKey}-code-verifier`, storedCodeVerifier);\n    const codeChallenge = await generatePKCEChallenge(codeVerifier);\n    const codeChallengeMethod = codeVerifier === codeChallenge ? \"plain\" : \"s256\";\n    return [\n        codeChallenge,\n        codeChallengeMethod\n    ];\n}\n/** Parses the API version which is 2YYY-MM-DD. */ const API_VERSION_REGEX = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;\nfunction parseResponseAPIVersion(response) {\n    const apiVersion = response.headers.get(_constants__WEBPACK_IMPORTED_MODULE_0__.API_VERSION_HEADER_NAME);\n    if (!apiVersion) {\n        return null;\n    }\n    if (!apiVersion.match(API_VERSION_REGEX)) {\n        return null;\n    }\n    try {\n        const date = new Date(`${apiVersion}T00:00:00.0Z`);\n        return date;\n    } catch (e) {\n        return null;\n    }\n}\nfunction validateExp(exp) {\n    if (!exp) {\n        throw new Error(\"Missing exp claim\");\n    }\n    const timeNow = Math.floor(Date.now() / 1000);\n    if (exp <= timeNow) {\n        throw new Error(\"JWT has expired\");\n    }\n}\nfunction getAlgorithm(alg) {\n    switch(alg){\n        case \"RS256\":\n            return {\n                name: \"RSASSA-PKCS1-v1_5\",\n                hash: {\n                    name: \"SHA-256\"\n                }\n            };\n        case \"ES256\":\n            return {\n                name: \"ECDSA\",\n                namedCurve: \"P-256\",\n                hash: {\n                    name: \"SHA-256\"\n                }\n            };\n        default:\n            throw new Error(\"Invalid alg claim\");\n    }\n}\nconst UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;\nfunction validateUUID(str) {\n    if (!UUID_REGEX.test(str)) {\n        throw new Error(\"@supabase/auth-js: Expected parameter to be UUID but is not\");\n    }\n}\nfunction userNotAvailableProxy() {\n    const proxyTarget = {};\n    return new Proxy(proxyTarget, {\n        get: (target, prop)=>{\n            if (prop === \"__isUserNotAvailableProxy\") {\n                return true;\n            }\n            // Preventative check for common problematic symbols during cloning/inspection\n            // These symbols might be accessed by structuredClone or other internal mechanisms.\n            if (typeof prop === \"symbol\") {\n                const sProp = prop.toString();\n                if (sProp === \"Symbol(Symbol.toPrimitive)\" || sProp === \"Symbol(Symbol.toStringTag)\" || sProp === \"Symbol(util.inspect.custom)\") {\n                    // Node.js util.inspect\n                    return undefined;\n                }\n            }\n            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the \"${prop}\" property of the session object is not supported. Please use getUser() instead.`);\n        },\n        set: (_target, prop)=>{\n            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the \"${prop}\" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);\n        },\n        deleteProperty: (_target, prop)=>{\n            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the \"${prop}\" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`);\n        }\n    });\n}\n/**\n * Creates a proxy around a user object that warns when properties are accessed on the server.\n * This is used to alert developers that using user data from getSession() on the server is insecure.\n *\n * @param user The actual user object to wrap\n * @param suppressWarningRef An object with a 'value' property that controls warning suppression\n * @returns A proxied user object that warns on property access\n */ function insecureUserWarningProxy(user, suppressWarningRef) {\n    return new Proxy(user, {\n        get: (target, prop, receiver)=>{\n            // Allow internal checks without warning\n            if (prop === \"__isInsecureUserWarningProxy\") {\n                return true;\n            }\n            // Preventative check for common problematic symbols during cloning/inspection\n            // These symbols might be accessed by structuredClone or other internal mechanisms\n            if (typeof prop === \"symbol\") {\n                const sProp = prop.toString();\n                if (sProp === \"Symbol(Symbol.toPrimitive)\" || sProp === \"Symbol(Symbol.toStringTag)\" || sProp === \"Symbol(util.inspect.custom)\" || sProp === \"Symbol(nodejs.util.inspect.custom)\") {\n                    // Return the actual value for these symbols to allow proper inspection\n                    return Reflect.get(target, prop, receiver);\n                }\n            }\n            // Emit warning on first property access\n            if (!suppressWarningRef.value && typeof prop === \"string\") {\n                console.warn(\"Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server.\");\n                suppressWarningRef.value = true;\n            }\n            return Reflect.get(target, prop, receiver);\n        }\n    });\n}\n/**\n * Deep clones a JSON-serializable object using JSON.parse(JSON.stringify(obj)).\n * Note: Only works for JSON-safe data.\n */ function deepClone(obj) {\n    return JSON.parse(JSON.stringify(obj));\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVFO0FBQ3hCO0FBQzBCO0FBQ2xFLFNBQVNLLFVBQVVDLFNBQVM7SUFDL0IsTUFBTUMsVUFBVUMsS0FBS0MsS0FBSyxDQUFDQyxLQUFLQyxHQUFHLEtBQUs7SUFDeEMsT0FBT0osVUFBVUQ7QUFDckI7QUFDTyxTQUFTTTtJQUNaLE9BQU8sdUNBQXVDQyxPQUFPLENBQUMsU0FBUyxTQUFVQyxDQUFDO1FBQ3RFLE1BQU1DLElBQUksS0FBTUMsTUFBTSxLQUFLLEtBQU0sR0FBR0MsSUFBSUgsS0FBSyxNQUFNQyxJQUFJLElBQUssTUFBTztRQUNuRSxPQUFPRSxFQUFFQyxRQUFRLENBQUM7SUFDdEI7QUFDSjtBQUNPLE1BQU1DLFlBQVksSUFBTSxNQUFrQixJQUFlLENBQW9CLENBQVk7QUFDaEcsTUFBTUUseUJBQXlCO0lBQzNCQyxRQUFRO0lBQ1JDLFVBQVU7QUFDZDtBQUNBOztDQUVDLEdBQ00sTUFBTUMsdUJBQXVCO0lBQ2hDLElBQUksQ0FBQ0wsYUFBYTtRQUNkLE9BQU87SUFDWDtJQUNBLElBQUk7UUFDQSxJQUFJLE9BQU9NLFdBQVdDLFlBQVksS0FBSyxVQUFVO1lBQzdDLE9BQU87UUFDWDtJQUNKLEVBQ0EsT0FBT0MsR0FBRztRQUNOLDhDQUE4QztRQUM5QyxPQUFPO0lBQ1g7SUFDQSxJQUFJTix1QkFBdUJDLE1BQU0sRUFBRTtRQUMvQixPQUFPRCx1QkFBdUJFLFFBQVE7SUFDMUM7SUFDQSxNQUFNSyxZQUFZLENBQUMsS0FBSyxFQUFFcEIsS0FBS1EsTUFBTSxHQUFHLEVBQUVSLEtBQUtRLE1BQU0sR0FBRyxDQUFDO0lBQ3pELElBQUk7UUFDQVMsV0FBV0MsWUFBWSxDQUFDRyxPQUFPLENBQUNELFdBQVdBO1FBQzNDSCxXQUFXQyxZQUFZLENBQUNJLFVBQVUs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QUFFWSxLQUFLLGtIQUFrSCxDQUFDO1FBQzdRO0lBQ0o7QUFDSjtBQUNBOzs7Ozs7O0NBT0MsR0FDTSxTQUFTTSx5QkFBeUJDLElBQUksRUFBRUMsa0JBQWtCO0lBQzdELE9BQU8sSUFBSVYsTUFBTVMsTUFBTTtRQUNuQnhCLEtBQUssQ0FBQ2dCLFFBQVFDLE1BQU1TO1lBQ2hCLHdDQUF3QztZQUN4QyxJQUFJVCxTQUFTLGdDQUFnQztnQkFDekMsT0FBTztZQUNYO1lBQ0EsOEVBQThFO1lBQzlFLGtGQUFrRjtZQUNsRixJQUFJLE9BQU9BLFNBQVMsVUFBVTtnQkFDMUIsTUFBTUMsUUFBUUQsS0FBSzVJLFFBQVE7Z0JBQzNCLElBQUk2SSxVQUFVLGdDQUNWQSxVQUFVLGdDQUNWQSxVQUFVLGlDQUNWQSxVQUFVLHNDQUFzQztvQkFDaEQsdUVBQXVFO29CQUN2RSxPQUFPUyxRQUFRM0IsR0FBRyxDQUFDZ0IsUUFBUUMsTUFBTVM7Z0JBQ3JDO1lBQ0o7WUFDQSx3Q0FBd0M7WUFDeEMsSUFBSSxDQUFDRCxtQkFBbUI3SCxLQUFLLElBQUksT0FBT3FILFNBQVMsVUFBVTtnQkFDdkRqQyxRQUFRQyxJQUFJLENBQUM7Z0JBQ2J3QyxtQkFBbUI3SCxLQUFLLEdBQUc7WUFDL0I7WUFDQSxPQUFPK0gsUUFBUTNCLEdBQUcsQ0FBQ2dCLFFBQVFDLE1BQU1TO1FBQ3JDO0lBQ0o7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNFLFVBQVVDLEdBQUc7SUFDekIsT0FBT2pILEtBQUtJLEtBQUssQ0FBQ0osS0FBS0MsU0FBUyxDQUFDZ0g7QUFDckMsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvaGVscGVycy5qcz81YTY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FLCBCQVNFNjRVUkxfUkVHRVggfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBBdXRoSW52YWxpZEp3dEVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgYmFzZTY0VXJsVG9VaW50OEFycmF5LCBzdHJpbmdGcm9tQmFzZTY0VVJMIH0gZnJvbSAnLi9iYXNlNjR1cmwnO1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGlyZXNBdChleHBpcmVzSW4pIHtcbiAgICBjb25zdCB0aW1lTm93ID0gTWF0aC5yb3VuZChEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgcmV0dXJuIHRpbWVOb3cgKyBleHBpcmVzSW47XG59XG5leHBvcnQgZnVuY3Rpb24gdXVpZCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLCB2ID0gYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4O1xuICAgICAgICByZXR1cm4gdi50b1N0cmluZygxNik7XG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMgPSB7XG4gICAgdGVzdGVkOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG59O1xuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBsb2NhbFN0b3JhZ2UgaXMgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHN1cHBvcnRzTG9jYWxTdG9yYWdlID0gKCkgPT4ge1xuICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMubG9jYWxTdG9yYWdlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIERPTSBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmcgYGxvY2FsU3RvcmFnZWBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobG9jYWxTdG9yYWdlV3JpdGVUZXN0cy50ZXN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGU7XG4gICAgfVxuICAgIGNvbnN0IHJhbmRvbUtleSA9IGBsc3d0LSR7TWF0aC5yYW5kb20oKX0ke01hdGgucmFuZG9tKCl9YDtcbiAgICB0cnkge1xuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHJhbmRvbUtleSwgcmFuZG9tS2V5KTtcbiAgICAgICAgZ2xvYmFsVGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShyYW5kb21LZXkpO1xuICAgICAgICBsb2NhbFN0b3JhZ2VXcml0ZVRlc3RzLnRlc3RlZCA9IHRydWU7XG4gICAgICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMud3JpdGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBsb2NhbFN0b3JhZ2UgY2FuJ3QgYmUgd3JpdHRlbiB0b1xuICAgICAgICAvLyBodHRwczovL3d3dy5jaHJvbWl1bS5vcmcvZm9yLXRlc3RlcnMvYnVnLXJlcG9ydGluZy1ndWlkZWxpbmVzL3VuY2F1Z2h0LXNlY3VyaXR5ZXJyb3ItZmFpbGVkLXRvLXJlYWQtdGhlLWxvY2Fsc3RvcmFnZS1wcm9wZXJ0eS1mcm9tLXdpbmRvdy1hY2Nlc3MtaXMtZGVuaWVkLWZvci10aGlzLWRvY3VtZW50XG4gICAgICAgIGxvY2FsU3RvcmFnZVdyaXRlVGVzdHMudGVzdGVkID0gdHJ1ZTtcbiAgICAgICAgbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlV3JpdGVUZXN0cy53cml0YWJsZTtcbn07XG4vKipcbiAqIEV4dHJhY3RzIHBhcmFtZXRlcnMgZW5jb2RlZCBpbiB0aGUgVVJMIGJvdGggaW4gdGhlIHF1ZXJ5IGFuZCBmcmFnbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyc0Zyb21VUkwoaHJlZikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoaHJlZik7XG4gICAgaWYgKHVybC5oYXNoICYmIHVybC5oYXNoWzBdID09PSAnIycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhhc2hTZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHVybC5oYXNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgICAgICBoYXNoU2VhcmNoUGFyYW1zLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGhhc2ggaXMgbm90IGEgcXVlcnkgc3RyaW5nXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2VhcmNoIHBhcmFtZXRlcnMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgaGFzaCBwYXJhbWV0ZXJzXG4gICAgdXJsLnNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICBsZXQgX2ZldGNoO1xuICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT4gaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgX2ZldGNoID0gZmV0Y2g7XG4gICAgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpO1xufTtcbmV4cG9ydCBjb25zdCBsb29rc0xpa2VGZXRjaFJlc3BvbnNlID0gKG1heWJlUmVzcG9uc2UpID0+IHtcbiAgICByZXR1cm4gKHR5cGVvZiBtYXliZVJlc3BvbnNlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICBtYXliZVJlc3BvbnNlICE9PSBudWxsICYmXG4gICAgICAgICdzdGF0dXMnIGluIG1heWJlUmVzcG9uc2UgJiZcbiAgICAgICAgJ29rJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgICAgICdqc29uJyBpbiBtYXliZVJlc3BvbnNlICYmXG4gICAgICAgIHR5cGVvZiBtYXliZVJlc3BvbnNlLmpzb24gPT09ICdmdW5jdGlvbicpO1xufTtcbi8vIFN0b3JhZ2UgaGVscGVyc1xuZXhwb3J0IGNvbnN0IHNldEl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXksIGRhdGEpID0+IHtcbiAgICBhd2FpdCBzdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG59O1xuZXhwb3J0IGNvbnN0IGdldEl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHJlbW92ZUl0ZW1Bc3luYyA9IGFzeW5jIChzdG9yYWdlLCBrZXkpID0+IHtcbiAgICBhd2FpdCBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbn07XG4vKipcbiAqIEEgZGVmZXJyZWQgcmVwcmVzZW50cyBzb21lIGFzeW5jaHJvbm91cyB3b3JrIHRoYXQgaXMgbm90IHlldCBmaW5pc2hlZCwgd2hpY2hcbiAqIG1heSBvciBtYXkgbm90IGN1bG1pbmF0ZSBpbiBhIHZhbHVlLlxuICogVGFrZW4gZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL21pa2Utbm9ydGgvdHlwZXMvYmxvYi9tYXN0ZXIvc3JjL2FzeW5jLnRzXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZlcnJlZCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmEtc2VtaVxuICAgICAgICA7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBEZWZlcnJlZC5wcm9taXNlQ29uc3RydWN0b3IoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5EZWZlcnJlZC5wcm9taXNlQ29uc3RydWN0b3IgPSBQcm9taXNlO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUpXVCh0b2tlbikge1xuICAgIGNvbnN0IHBhcnRzID0gdG9rZW4uc3BsaXQoJy4nKTtcbiAgICBpZiAocGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoSW52YWxpZEp3dEVycm9yKCdJbnZhbGlkIEpXVCBzdHJ1Y3R1cmUnKTtcbiAgICB9XG4gICAgLy8gUmVnZXggY2hlY2tzIGZvciBiYXNlNjR1cmwgZm9ybWF0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIUJBU0U2NFVSTF9SRUdFWC50ZXN0KHBhcnRzW2ldKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhJbnZhbGlkSnd0RXJyb3IoJ0pXVCBub3QgaW4gYmFzZTY0dXJsIGZvcm1hdCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIC8vIHVzaW5nIGJhc2U2NHVybCBsaWJcbiAgICAgICAgaGVhZGVyOiBKU09OLnBhcnNlKHN0cmluZ0Zyb21CYXNlNjRVUkwocGFydHNbMF0pKSxcbiAgICAgICAgcGF5bG9hZDogSlNPTi5wYXJzZShzdHJpbmdGcm9tQmFzZTY0VVJMKHBhcnRzWzFdKSksXG4gICAgICAgIHNpZ25hdHVyZTogYmFzZTY0VXJsVG9VaW50OEFycmF5KHBhcnRzWzJdKSxcbiAgICAgICAgcmF3OiB7XG4gICAgICAgICAgICBoZWFkZXI6IHBhcnRzWzBdLFxuICAgICAgICAgICAgcGF5bG9hZDogcGFydHNbMV0sXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBudWxsIGFmdGVyIHNvbWUgdGltZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNsZWVwKHRpbWUpIHtcbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKGFjY2VwdCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGFjY2VwdChudWxsKSwgdGltZSk7XG4gICAgfSk7XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBwcm92aWRlZCBhc3luYyBmdW5jdGlvbiBpbnRvIGEgcmV0cnlhYmxlIGZ1bmN0aW9uLiBFYWNoIHJlc3VsdFxuICogb3IgdGhyb3duIGVycm9yIGlzIHNlbnQgdG8gdGhlIGlzUmV0cnlhYmxlIGZ1bmN0aW9uIHdoaWNoIHNob3VsZCByZXR1cm4gdHJ1ZVxuICogaWYgdGhlIGZ1bmN0aW9uIHNob3VsZCBydW4gYWdhaW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXRyeWFibGUoZm4sIGlzUmV0cnlhYmxlKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhLXNlbWlcbiAgICAgICAgO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBJbmZpbml0eTsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4oYXR0ZW1wdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNSZXRyeWFibGUoYXR0ZW1wdCwgbnVsbCwgcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXB0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1JldHJ5YWJsZShhdHRlbXB0LCBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gZGVjMmhleChkZWMpIHtcbiAgICByZXR1cm4gKCcwJyArIGRlYy50b1N0cmluZygxNikpLnN1YnN0cigtMik7XG59XG4vLyBGdW5jdGlvbnMgYmVsb3cgdGFrZW4gZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjMzMDk0MDkvY3JlYXRpbmctYS1jb2RlLXZlcmlmaWVyLWFuZC1jaGFsbGVuZ2UtZm9yLXBrY2UtYXV0aC1vbi1zcG90aWZ5LWFwaS1pbi1yZWFjdGpzXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVQS0NFVmVyaWZpZXIoKSB7XG4gICAgY29uc3QgdmVyaWZpZXJMZW5ndGggPSA1NjtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50MzJBcnJheSh2ZXJpZmllckxlbmd0aCk7XG4gICAgaWYgKHR5cGVvZiBjcnlwdG8gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IGNoYXJTZXQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktLl9+JztcbiAgICAgICAgY29uc3QgY2hhclNldExlbiA9IGNoYXJTZXQubGVuZ3RoO1xuICAgICAgICBsZXQgdmVyaWZpZXIgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZXJpZmllckxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2ZXJpZmllciArPSBjaGFyU2V0LmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyU2V0TGVuKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZlcmlmaWVyO1xuICAgIH1cbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycmF5KTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShhcnJheSwgZGVjMmhleCkuam9pbignJyk7XG59XG5hc3luYyBmdW5jdGlvbiBzaGEyNTYocmFuZG9tU3RyaW5nKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IGVuY29kZWREYXRhID0gZW5jb2Rlci5lbmNvZGUocmFuZG9tU3RyaW5nKTtcbiAgICBjb25zdCBoYXNoID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCBlbmNvZGVkRGF0YSk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoYXNoKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShieXRlcylcbiAgICAgICAgLm1hcCgoYykgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShjKSlcbiAgICAgICAgLmpvaW4oJycpO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlUEtDRUNoYWxsZW5nZSh2ZXJpZmllcikge1xuICAgIGNvbnN0IGhhc0NyeXB0b1N1cHBvcnQgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB0eXBlb2YgY3J5cHRvLnN1YnRsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgdHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJztcbiAgICBpZiAoIWhhc0NyeXB0b1N1cHBvcnQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXZWJDcnlwdG8gQVBJIGlzIG5vdCBzdXBwb3J0ZWQuIENvZGUgY2hhbGxlbmdlIG1ldGhvZCB3aWxsIGRlZmF1bHQgdG8gdXNlIHBsYWluIGluc3RlYWQgb2Ygc2hhMjU2LicpO1xuICAgICAgICByZXR1cm4gdmVyaWZpZXI7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZCA9IGF3YWl0IHNoYTI1Nih2ZXJpZmllcik7XG4gICAgcmV0dXJuIGJ0b2EoaGFzaGVkKS5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC89KyQvLCAnJyk7XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZChzdG9yYWdlLCBzdG9yYWdlS2V5LCBpc1Bhc3N3b3JkUmVjb3ZlcnkgPSBmYWxzZSkge1xuICAgIGNvbnN0IGNvZGVWZXJpZmllciA9IGdlbmVyYXRlUEtDRVZlcmlmaWVyKCk7XG4gICAgbGV0IHN0b3JlZENvZGVWZXJpZmllciA9IGNvZGVWZXJpZmllcjtcbiAgICBpZiAoaXNQYXNzd29yZFJlY292ZXJ5KSB7XG4gICAgICAgIHN0b3JlZENvZGVWZXJpZmllciArPSAnL1BBU1NXT1JEX1JFQ09WRVJZJztcbiAgICB9XG4gICAgYXdhaXQgc2V0SXRlbUFzeW5jKHN0b3JhZ2UsIGAke3N0b3JhZ2VLZXl9LWNvZGUtdmVyaWZpZXJgLCBzdG9yZWRDb2RlVmVyaWZpZXIpO1xuICAgIGNvbnN0IGNvZGVDaGFsbGVuZ2UgPSBhd2FpdCBnZW5lcmF0ZVBLQ0VDaGFsbGVuZ2UoY29kZVZlcmlmaWVyKTtcbiAgICBjb25zdCBjb2RlQ2hhbGxlbmdlTWV0aG9kID0gY29kZVZlcmlmaWVyID09PSBjb2RlQ2hhbGxlbmdlID8gJ3BsYWluJyA6ICdzMjU2JztcbiAgICByZXR1cm4gW2NvZGVDaGFsbGVuZ2UsIGNvZGVDaGFsbGVuZ2VNZXRob2RdO1xufVxuLyoqIFBhcnNlcyB0aGUgQVBJIHZlcnNpb24gd2hpY2ggaXMgMllZWS1NTS1ERC4gKi9cbmNvbnN0IEFQSV9WRVJTSU9OX1JFR0VYID0gL14yWzAtOV17M30tKDBbMS05XXwxWzAtMl0pLSgwWzEtOV18MVswLTldfDJbMC05XXwzWzAtMV0pJC9pO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVzcG9uc2VBUElWZXJzaW9uKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgYXBpVmVyc2lvbiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KEFQSV9WRVJTSU9OX0hFQURFUl9OQU1FKTtcbiAgICBpZiAoIWFwaVZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICghYXBpVmVyc2lvbi5tYXRjaChBUElfVkVSU0lPTl9SRUdFWCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShgJHthcGlWZXJzaW9ufVQwMDowMDowMC4wWmApO1xuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRXhwKGV4cCkge1xuICAgIGlmICghZXhwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBleHAgY2xhaW0nKTtcbiAgICB9XG4gICAgY29uc3QgdGltZU5vdyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgIGlmIChleHAgPD0gdGltZU5vdykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pXVCBoYXMgZXhwaXJlZCcpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGdvcml0aG0oYWxnKSB7XG4gICAgc3dpdGNoIChhbGcpIHtcbiAgICAgICAgY2FzZSAnUlMyNTYnOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICAgICAgICAgICAgICAgIGhhc2g6IHsgbmFtZTogJ1NIQS0yNTYnIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdFUzI1Nic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6ICdFQ0RTQScsXG4gICAgICAgICAgICAgICAgbmFtZWRDdXJ2ZTogJ1AtMjU2JyxcbiAgICAgICAgICAgICAgICBoYXNoOiB7IG5hbWU6ICdTSEEtMjU2JyB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhbGcgY2xhaW0nKTtcbiAgICB9XG59XG5jb25zdCBVVUlEX1JFR0VYID0gL15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXsxMn0kLztcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVVVSUQoc3RyKSB7XG4gICAgaWYgKCFVVUlEX1JFR0VYLnRlc3Qoc3RyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0BzdXBhYmFzZS9hdXRoLWpzOiBFeHBlY3RlZCBwYXJhbWV0ZXIgdG8gYmUgVVVJRCBidXQgaXMgbm90Jyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZXJOb3RBdmFpbGFibGVQcm94eSgpIHtcbiAgICBjb25zdCBwcm94eVRhcmdldCA9IHt9O1xuICAgIHJldHVybiBuZXcgUHJveHkocHJveHlUYXJnZXQsIHtcbiAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gJ19faXNVc2VyTm90QXZhaWxhYmxlUHJveHknKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcmV2ZW50YXRpdmUgY2hlY2sgZm9yIGNvbW1vbiBwcm9ibGVtYXRpYyBzeW1ib2xzIGR1cmluZyBjbG9uaW5nL2luc3BlY3Rpb25cbiAgICAgICAgICAgIC8vIFRoZXNlIHN5bWJvbHMgbWlnaHQgYmUgYWNjZXNzZWQgYnkgc3RydWN0dXJlZENsb25lIG9yIG90aGVyIGludGVybmFsIG1lY2hhbmlzbXMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc1Byb3AgPSBwcm9wLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNQcm9wID09PSAnU3ltYm9sKFN5bWJvbC50b1ByaW1pdGl2ZSknIHx8XG4gICAgICAgICAgICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKFN5bWJvbC50b1N0cmluZ1RhZyknIHx8XG4gICAgICAgICAgICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKHV0aWwuaW5zcGVjdC5jdXN0b20pJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb2RlLmpzIHV0aWwuaW5zcGVjdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IGNsaWVudCB3YXMgY3JlYXRlZCB3aXRoIHVzZXJTdG9yYWdlIG9wdGlvbiBhbmQgdGhlcmUgd2FzIG5vIHVzZXIgc3RvcmVkIGluIHRoZSB1c2VyIHN0b3JhZ2UuIEFjY2Vzc2luZyB0aGUgXCIke3Byb3B9XCIgcHJvcGVydHkgb2YgdGhlIHNlc3Npb24gb2JqZWN0IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgZ2V0VXNlcigpIGluc3RlYWQuYCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogKF90YXJnZXQsIHByb3ApID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IGNsaWVudCB3YXMgY3JlYXRlZCB3aXRoIHVzZXJTdG9yYWdlIG9wdGlvbiBhbmQgdGhlcmUgd2FzIG5vIHVzZXIgc3RvcmVkIGluIHRoZSB1c2VyIHN0b3JhZ2UuIFNldHRpbmcgdGhlIFwiJHtwcm9wfVwiIHByb3BlcnR5IG9mIHRoZSBzZXNzaW9uIG9iamVjdCBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlIGdldFVzZXIoKSB0byBmZXRjaCBhIHVzZXIgb2JqZWN0IHlvdSBjYW4gbWFuaXB1bGF0ZS5gKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZXRlUHJvcGVydHk6IChfdGFyZ2V0LCBwcm9wKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBjbGllbnQgd2FzIGNyZWF0ZWQgd2l0aCB1c2VyU3RvcmFnZSBvcHRpb24gYW5kIHRoZXJlIHdhcyBubyB1c2VyIHN0b3JlZCBpbiB0aGUgdXNlciBzdG9yYWdlLiBEZWxldGluZyB0aGUgXCIke3Byb3B9XCIgcHJvcGVydHkgb2YgdGhlIHNlc3Npb24gb2JqZWN0IGlzIG5vdCBzdXBwb3J0ZWQuIFBsZWFzZSB1c2UgZ2V0VXNlcigpIHRvIGZldGNoIGEgdXNlciBvYmplY3QgeW91IGNhbiBtYW5pcHVsYXRlLmApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgcHJveHkgYXJvdW5kIGEgdXNlciBvYmplY3QgdGhhdCB3YXJucyB3aGVuIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkIG9uIHRoZSBzZXJ2ZXIuXG4gKiBUaGlzIGlzIHVzZWQgdG8gYWxlcnQgZGV2ZWxvcGVycyB0aGF0IHVzaW5nIHVzZXIgZGF0YSBmcm9tIGdldFNlc3Npb24oKSBvbiB0aGUgc2VydmVyIGlzIGluc2VjdXJlLlxuICpcbiAqIEBwYXJhbSB1c2VyIFRoZSBhY3R1YWwgdXNlciBvYmplY3QgdG8gd3JhcFxuICogQHBhcmFtIHN1cHByZXNzV2FybmluZ1JlZiBBbiBvYmplY3Qgd2l0aCBhICd2YWx1ZScgcHJvcGVydHkgdGhhdCBjb250cm9scyB3YXJuaW5nIHN1cHByZXNzaW9uXG4gKiBAcmV0dXJucyBBIHByb3hpZWQgdXNlciBvYmplY3QgdGhhdCB3YXJucyBvbiBwcm9wZXJ0eSBhY2Nlc3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VjdXJlVXNlcldhcm5pbmdQcm94eSh1c2VyLCBzdXBwcmVzc1dhcm5pbmdSZWYpIHtcbiAgICByZXR1cm4gbmV3IFByb3h5KHVzZXIsIHtcbiAgICAgICAgZ2V0OiAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikgPT4ge1xuICAgICAgICAgICAgLy8gQWxsb3cgaW50ZXJuYWwgY2hlY2tzIHdpdGhvdXQgd2FybmluZ1xuICAgICAgICAgICAgaWYgKHByb3AgPT09ICdfX2lzSW5zZWN1cmVVc2VyV2FybmluZ1Byb3h5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJldmVudGF0aXZlIGNoZWNrIGZvciBjb21tb24gcHJvYmxlbWF0aWMgc3ltYm9scyBkdXJpbmcgY2xvbmluZy9pbnNwZWN0aW9uXG4gICAgICAgICAgICAvLyBUaGVzZSBzeW1ib2xzIG1pZ2h0IGJlIGFjY2Vzc2VkIGJ5IHN0cnVjdHVyZWRDbG9uZSBvciBvdGhlciBpbnRlcm5hbCBtZWNoYW5pc21zXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc1Byb3AgPSBwcm9wLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNQcm9wID09PSAnU3ltYm9sKFN5bWJvbC50b1ByaW1pdGl2ZSknIHx8XG4gICAgICAgICAgICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKFN5bWJvbC50b1N0cmluZ1RhZyknIHx8XG4gICAgICAgICAgICAgICAgICAgIHNQcm9wID09PSAnU3ltYm9sKHV0aWwuaW5zcGVjdC5jdXN0b20pJyB8fFxuICAgICAgICAgICAgICAgICAgICBzUHJvcCA9PT0gJ1N5bWJvbChub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbSknKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB0aGUgYWN0dWFsIHZhbHVlIGZvciB0aGVzZSBzeW1ib2xzIHRvIGFsbG93IHByb3BlciBpbnNwZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFbWl0IHdhcm5pbmcgb24gZmlyc3QgcHJvcGVydHkgYWNjZXNzXG4gICAgICAgICAgICBpZiAoIXN1cHByZXNzV2FybmluZ1JlZi52YWx1ZSAmJiB0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1VzaW5nIHRoZSB1c2VyIG9iamVjdCBhcyByZXR1cm5lZCBmcm9tIHN1cGFiYXNlLmF1dGguZ2V0U2Vzc2lvbigpIG9yIGZyb20gc29tZSBzdXBhYmFzZS5hdXRoLm9uQXV0aFN0YXRlQ2hhbmdlKCkgZXZlbnRzIGNvdWxkIGJlIGluc2VjdXJlISBUaGlzIHZhbHVlIGNvbWVzIGRpcmVjdGx5IGZyb20gdGhlIHN0b3JhZ2UgbWVkaXVtICh1c3VhbGx5IGNvb2tpZXMgb24gdGhlIHNlcnZlcikgYW5kIG1heSBub3QgYmUgYXV0aGVudGljLiBVc2Ugc3VwYWJhc2UuYXV0aC5nZXRVc2VyKCkgaW5zdGVhZCB3aGljaCBhdXRoZW50aWNhdGVzIHRoZSBkYXRhIGJ5IGNvbnRhY3RpbmcgdGhlIFN1cGFiYXNlIEF1dGggc2VydmVyLicpO1xuICAgICAgICAgICAgICAgIHN1cHByZXNzV2FybmluZ1JlZi52YWx1ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIERlZXAgY2xvbmVzIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IHVzaW5nIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSkuXG4gKiBOb3RlOiBPbmx5IHdvcmtzIGZvciBKU09OLXNhZmUgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZXBDbG9uZShvYmopIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlcnMuanMubWFwIl0sIm5hbWVzIjpbIkFQSV9WRVJTSU9OX0hFQURFUl9OQU1FIiwiQkFTRTY0VVJMX1JFR0VYIiwiQXV0aEludmFsaWRKd3RFcnJvciIsImJhc2U2NFVybFRvVWludDhBcnJheSIsInN0cmluZ0Zyb21CYXNlNjRVUkwiLCJleHBpcmVzQXQiLCJleHBpcmVzSW4iLCJ0aW1lTm93IiwiTWF0aCIsInJvdW5kIiwiRGF0ZSIsIm5vdyIsInV1aWQiLCJyZXBsYWNlIiwiYyIsInIiLCJyYW5kb20iLCJ2IiwidG9TdHJpbmciLCJpc0Jyb3dzZXIiLCJkb2N1bWVudCIsImxvY2FsU3RvcmFnZVdyaXRlVGVzdHMiLCJ0ZXN0ZWQiLCJ3cml0YWJsZSIsInN1cHBvcnRzTG9jYWxTdG9yYWdlIiwiZ2xvYmFsVGhpcyIsImxvY2FsU3RvcmFnZSIsImUiLCJyYW5kb21LZXkiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsInBhcnNlUGFyYW1ldGVyc0Zyb21VUkwiLCJocmVmIiwicmVzdWx0IiwidXJsIiwiVVJMIiwiaGFzaCIsImhhc2hTZWFyY2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJzdWJzdHJpbmciLCJmb3JFYWNoIiwidmFsdWUiLCJrZXkiLCJzZWFyY2hQYXJhbXMiLCJyZXNvbHZlRmV0Y2giLCJjdXN0b21GZXRjaCIsIl9mZXRjaCIsImZldGNoIiwiYXJncyIsInRoZW4iLCJkZWZhdWx0IiwibG9va3NMaWtlRmV0Y2hSZXNwb25zZSIsIm1heWJlUmVzcG9uc2UiLCJqc29uIiwic2V0SXRlbUFzeW5jIiwic3RvcmFnZSIsImRhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0SXRlbUFzeW5jIiwiZ2V0SXRlbSIsInBhcnNlIiwiX2EiLCJyZW1vdmVJdGVtQXN5bmMiLCJEZWZlcnJlZCIsImNvbnN0cnVjdG9yIiwicHJvbWlzZSIsInByb21pc2VDb25zdHJ1Y3RvciIsInJlcyIsInJlaiIsInJlc29sdmUiLCJyZWplY3QiLCJQcm9taXNlIiwiZGVjb2RlSldUIiwidG9rZW4iLCJwYXJ0cyIsInNwbGl0IiwibGVuZ3RoIiwiaSIsInRlc3QiLCJoZWFkZXIiLCJwYXlsb2FkIiwic2lnbmF0dXJlIiwicmF3Iiwic2xlZXAiLCJ0aW1lIiwiYWNjZXB0Iiwic2V0VGltZW91dCIsInJldHJ5YWJsZSIsImZuIiwiaXNSZXRyeWFibGUiLCJhdHRlbXB0IiwiSW5maW5pdHkiLCJkZWMyaGV4IiwiZGVjIiwic3Vic3RyIiwiZ2VuZXJhdGVQS0NFVmVyaWZpZXIiLCJ2ZXJpZmllckxlbmd0aCIsImFycmF5IiwiVWludDMyQXJyYXkiLCJjcnlwdG8iLCJjaGFyU2V0IiwiY2hhclNldExlbiIsInZlcmlmaWVyIiwiY2hhckF0IiwiZmxvb3IiLCJnZXRSYW5kb21WYWx1ZXMiLCJBcnJheSIsImZyb20iLCJqb2luIiwic2hhMjU2IiwicmFuZG9tU3RyaW5nIiwiZW5jb2RlciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlZERhdGEiLCJlbmNvZGUiLCJzdWJ0bGUiLCJkaWdlc3QiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJtYXAiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJnZW5lcmF0ZVBLQ0VDaGFsbGVuZ2UiLCJoYXNDcnlwdG9TdXBwb3J0IiwiY29uc29sZSIsIndhcm4iLCJoYXNoZWQiLCJidG9hIiwiZ2V0Q29kZUNoYWxsZW5nZUFuZE1ldGhvZCIsInN0b3JhZ2VLZXkiLCJpc1Bhc3N3b3JkUmVjb3ZlcnkiLCJjb2RlVmVyaWZpZXIiLCJzdG9yZWRDb2RlVmVyaWZpZXIiLCJjb2RlQ2hhbGxlbmdlIiwiY29kZUNoYWxsZW5nZU1ldGhvZCIsIkFQSV9WRVJTSU9OX1JFR0VYIiwicGFyc2VSZXNwb25zZUFQSVZlcnNpb24iLCJyZXNwb25zZSIsImFwaVZlcnNpb24iLCJoZWFkZXJzIiwiZ2V0IiwibWF0Y2giLCJkYXRlIiwidmFsaWRhdGVFeHAiLCJleHAiLCJFcnJvciIsImdldEFsZ29yaXRobSIsImFsZyIsIm5hbWUiLCJuYW1lZEN1cnZlIiwiVVVJRF9SRUdFWCIsInZhbGlkYXRlVVVJRCIsInN0ciIsInVzZXJOb3RBdmFpbGFibGVQcm94eSIsInByb3h5VGFyZ2V0IiwiUHJveHkiLCJ0YXJnZXQiLCJwcm9wIiwic1Byb3AiLCJ1bmRlZmluZWQiLCJzZXQiLCJfdGFyZ2V0IiwiZGVsZXRlUHJvcGVydHkiLCJpbnNlY3VyZVVzZXJXYXJuaW5nUHJveHkiLCJ1c2VyIiwic3VwcHJlc3NXYXJuaW5nUmVmIiwicmVjZWl2ZXIiLCJSZWZsZWN0IiwiZGVlcENsb25lIiwib2JqIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   memoryLocalStorageAdapter: () => (/* binding */ memoryLocalStorageAdapter)\n/* harmony export */ });\n/**\n * Returns a localStorage-like object that stores the key-value pairs in\n * memory.\n */ function memoryLocalStorageAdapter(store = {}) {\n    return {\n        getItem: (key)=>{\n            return store[key] || null;\n        },\n        setItem: (key, value)=>{\n            store[key] = value;\n        },\n        removeItem: (key)=>{\n            delete store[key];\n        }\n    };\n} //# sourceMappingURL=local-storage.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2xvY2FsLXN0b3JhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Q0FHQyxHQUNNLFNBQVNBLDBCQUEwQkMsUUFBUSxDQUFDLENBQUM7SUFDaEQsT0FBTztRQUNIQyxTQUFTLENBQUNDO1lBQ04sT0FBT0YsS0FBSyxDQUFDRSxJQUFJLElBQUk7UUFDekI7UUFDQUMsU0FBUyxDQUFDRCxLQUFLRTtZQUNYSixLQUFLLENBQUNFLElBQUksR0FBR0U7UUFDakI7UUFDQUMsWUFBWSxDQUFDSDtZQUNULE9BQU9GLEtBQUssQ0FBQ0UsSUFBSTtRQUNyQjtJQUNKO0FBQ0osRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvbG9jYWwtc3RvcmFnZS5qcz8yM2MyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUmV0dXJucyBhIGxvY2FsU3RvcmFnZS1saWtlIG9iamVjdCB0aGF0IHN0b3JlcyB0aGUga2V5LXZhbHVlIHBhaXJzIGluXG4gKiBtZW1vcnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vcnlMb2NhbFN0b3JhZ2VBZGFwdGVyKHN0b3JlID0ge30pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVba2V5XSB8fCBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZXRJdGVtOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgc3RvcmVba2V5XSA9IHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVJdGVtOiAoa2V5KSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgc3RvcmVba2V5XTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9jYWwtc3RvcmFnZS5qcy5tYXAiXSwibmFtZXMiOlsibWVtb3J5TG9jYWxTdG9yYWdlQWRhcHRlciIsInN0b3JlIiwiZ2V0SXRlbSIsImtleSIsInNldEl0ZW0iLCJ2YWx1ZSIsInJlbW92ZUl0ZW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/local-storage.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/locks.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LockAcquireTimeoutError: () => (/* binding */ LockAcquireTimeoutError),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* binding */ NavigatorLockAcquireTimeoutError),\n/* harmony export */   ProcessLockAcquireTimeoutError: () => (/* binding */ ProcessLockAcquireTimeoutError),\n/* harmony export */   internals: () => (/* binding */ internals),\n/* harmony export */   navigatorLock: () => (/* binding */ navigatorLock),\n/* harmony export */   processLock: () => (/* binding */ processLock)\n/* harmony export */ });\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n\n/**\n * @experimental\n */ const internals = {\n    /**\n     * @experimental\n     */ debug: !!(globalThis && (0,_helpers__WEBPACK_IMPORTED_MODULE_0__.supportsLocalStorage)() && globalThis.localStorage && globalThis.localStorage.getItem(\"supabase.gotrue-js.locks.debug\") === \"true\")\n};\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */ class LockAcquireTimeoutError extends Error {\n    constructor(message){\n        super(message);\n        this.isAcquireTimeout = true;\n    }\n}\nclass NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\nclass ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {\n}\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */ async function navigatorLock(name, acquireTimeout, fn) {\n    if (internals.debug) {\n        console.log(\"@supabase/gotrue-js: navigatorLock: acquire lock\", name, acquireTimeout);\n    }\n    const abortController = new globalThis.AbortController();\n    if (acquireTimeout > 0) {\n        setTimeout(()=>{\n            abortController.abort();\n            if (internals.debug) {\n                console.log(\"@supabase/gotrue-js: navigatorLock acquire timed out\", name);\n            }\n        }, acquireTimeout);\n    }\n    // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n    // Wrapping navigator.locks.request() with a plain Promise is done as some\n    // libraries like zone.js patch the Promise object to track the execution\n    // context. However, it appears that most browsers use an internal promise\n    // implementation when using the navigator.locks.request() API causing them\n    // to lose context and emit confusing log messages or break certain features.\n    // This wrapping is believed to help zone.js track the execution context\n    // better.\n    return await Promise.resolve().then(()=>globalThis.navigator.locks.request(name, acquireTimeout === 0 ? {\n            mode: \"exclusive\",\n            ifAvailable: true\n        } : {\n            mode: \"exclusive\",\n            signal: abortController.signal\n        }, async (lock)=>{\n            if (lock) {\n                if (internals.debug) {\n                    console.log(\"@supabase/gotrue-js: navigatorLock: acquired\", name, lock.name);\n                }\n                try {\n                    return await fn();\n                } finally{\n                    if (internals.debug) {\n                        console.log(\"@supabase/gotrue-js: navigatorLock: released\", name, lock.name);\n                    }\n                }\n            } else {\n                if (acquireTimeout === 0) {\n                    if (internals.debug) {\n                        console.log(\"@supabase/gotrue-js: navigatorLock: not immediately available\", name);\n                    }\n                    throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);\n                } else {\n                    if (internals.debug) {\n                        try {\n                            const result = await globalThis.navigator.locks.query();\n                            console.log(\"@supabase/gotrue-js: Navigator LockManager state\", JSON.stringify(result, null, \"  \"));\n                        } catch (e) {\n                            console.warn(\"@supabase/gotrue-js: Error when querying Navigator LockManager state\", e);\n                        }\n                    }\n                    // Browser is not following the Navigator LockManager spec, it\n                    // returned a null lock when we didn't use ifAvailable. So we can\n                    // pretend the lock is acquired in the name of backward compatibility\n                    // and user experience and just run the function.\n                    console.warn(\"@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\");\n                    return await fn();\n                }\n            }\n        }));\n}\nconst PROCESS_LOCKS = {};\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */ async function processLock(name, acquireTimeout, fn) {\n    var _a;\n    const previousOperation = (_a = PROCESS_LOCKS[name]) !== null && _a !== void 0 ? _a : Promise.resolve();\n    const currentOperation = Promise.race([\n        previousOperation.catch(()=>{\n            // ignore error of previous operation that we're waiting to finish\n            return null;\n        }),\n        acquireTimeout >= 0 ? new Promise((_, reject)=>{\n            setTimeout(()=>{\n                reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name \"${name}\" timed out`));\n            }, acquireTimeout);\n        }) : null\n    ].filter((x)=>x)).catch((e)=>{\n        if (e && e.isAcquireTimeout) {\n            throw e;\n        }\n        return null;\n    }).then(async ()=>{\n        // previous operations finished and we didn't get a race on the acquire\n        // timeout, so the current operation can finally start\n        return await fn();\n    });\n    PROCESS_LOCKS[name] = currentOperation.catch(async (e)=>{\n        if (e && e.isAcquireTimeout) {\n            // if the current operation timed out, it doesn't mean that the previous\n            // operation finished, so we need contnue waiting for it to finish\n            await previousOperation;\n            return null;\n        }\n        throw e;\n    });\n    // finally wait for the current operation to finish successfully, with an\n    // error or with an acquire timeout error\n    return await currentOperation;\n} //# sourceMappingURL=locks.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL2xvY2tzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBaUQ7QUFDakQ7O0NBRUMsR0FDTSxNQUFNQyxZQUFZO0lBQ3JCOztLQUVDLEdBQ0RDLE9BQU8sQ0FBQyxDQUFFQyxDQUFBQSxjQUNOSCw4REFBb0JBLE1BQ3BCRyxXQUFXQyxZQUFZLElBQ3ZCRCxXQUFXQyxZQUFZLENBQUNDLE9BQU8sQ0FBQyxzQ0FBc0MsTUFBSztBQUNuRixFQUFFO0FBQ0Y7Ozs7Q0FJQyxHQUNNLE1BQU1DLGdDQUFnQ0M7SUFDekNDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBO1FBQ04sSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztJQUM1QjtBQUNKO0FBQ08sTUFBTUMseUNBQXlDTDtBQUN0RDtBQUNPLE1BQU1NLHVDQUF1Q047QUFDcEQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBd0JDLEdBQ00sZUFBZU8sY0FBY0MsSUFBSSxFQUFFQyxjQUFjLEVBQUVDLEVBQUU7SUFDeEQsSUFBSWYsVUFBVUMsS0FBSyxFQUFFO1FBQ2pCZSxRQUFRQyxHQUFHLENBQUMsb0RBQW9ESixNQUFNQztJQUMxRTtJQUNBLE1BQU1JLGtCQUFrQixJQUFJaEIsV0FBV2lCLGVBQWU7SUFDdEQsSUFBSUwsaUJBQWlCLEdBQUc7UUFDcEJNLFdBQVc7WUFDUEYsZ0JBQWdCRyxLQUFLO1lBQ3JCLElBQUlyQixVQUFVQyxLQUFLLEVBQUU7Z0JBQ2pCZSxRQUFRQyxHQUFHLENBQUMsd0RBQXdESjtZQUN4RTtRQUNKLEdBQUdDO0lBQ1A7SUFDQSxvRkFBb0Y7SUFDcEYsMEVBQTBFO0lBQzFFLHlFQUF5RTtJQUN6RSwwRUFBMEU7SUFDMUUsMkVBQTJFO0lBQzNFLDZFQUE2RTtJQUM3RSx3RUFBd0U7SUFDeEUsVUFBVTtJQUNWLE9BQU8sTUFBTVEsUUFBUUMsT0FBTyxHQUFHQyxJQUFJLENBQUMs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bW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvbG9ja3MuanM/MDM4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzdXBwb3J0c0xvY2FsU3RvcmFnZSB9IGZyb20gJy4vaGVscGVycyc7XG4vKipcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZXhwb3J0IGNvbnN0IGludGVybmFscyA9IHtcbiAgICAvKipcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgZGVidWc6ICEhKGdsb2JhbFRoaXMgJiZcbiAgICAgICAgc3VwcG9ydHNMb2NhbFN0b3JhZ2UoKSAmJlxuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZSAmJlxuICAgICAgICBnbG9iYWxUaGlzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdzdXBhYmFzZS5nb3RydWUtanMubG9ja3MuZGVidWcnKSA9PT0gJ3RydWUnKSxcbn07XG4vKipcbiAqIEFuIGVycm9yIHRocm93biB3aGVuIGEgbG9jayBjYW5ub3QgYmUgYWNxdWlyZWQgYWZ0ZXIgc29tZSBhbW91bnQgb2YgdGltZS5cbiAqXG4gKiBVc2UgdGhlIHtAbGluayAjaXNBY3F1aXJlVGltZW91dH0gcHJvcGVydHkgaW5zdGVhZCBvZiBjaGVja2luZyB3aXRoIGBpbnN0YW5jZW9mYC5cbiAqL1xuZXhwb3J0IGNsYXNzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuaXNBY3F1aXJlVGltZW91dCA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRvckxvY2tBY3F1aXJlVGltZW91dEVycm9yIGV4dGVuZHMgTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3Ige1xufVxuZXhwb3J0IGNsYXNzIFByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvciBleHRlbmRzIExvY2tBY3F1aXJlVGltZW91dEVycm9yIHtcbn1cbi8qKlxuICogSW1wbGVtZW50cyBhIGdsb2JhbCBleGNsdXNpdmUgbG9jayB1c2luZyB0aGUgTmF2aWdhdG9yIExvY2tNYW5hZ2VyIEFQSS4gSXRcbiAqIGlzIGF2YWlsYWJsZSBvbiBhbGwgYnJvd3NlcnMgcmVsZWFzZWQgYWZ0ZXIgMjAyMi0wMy0xNSB3aXRoIFNhZmFyaSBiZWluZyB0aGVcbiAqIGxhc3Qgb25lIHRvIHJlbGVhc2Ugc3VwcG9ydC4gSWYgdGhlIEFQSSBpcyBub3QgYXZhaWxhYmxlLCB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAqIHRocm93LiBNYWtlIHN1cmUgeW91IGNoZWNrIGF2YWlsYWJsaWxpdHkgYmVmb3JlIGNvbmZpZ3VyaW5nIHtAbGlua1xuICogR29UcnVlQ2xpZW50fS5cbiAqXG4gKiBZb3UgY2FuIHR1cm4gb24gZGVidWdnaW5nIGJ5IHNldHRpbmcgdGhlIGBzdXBhYmFzZS5nb3RydWUtanMubG9ja3MuZGVidWdgXG4gKiBsb2NhbCBzdG9yYWdlIGl0ZW0gdG8gYHRydWVgLlxuICpcbiAqIEludGVybmFsczpcbiAqXG4gKiBTaW5jZSB0aGUgTG9ja01hbmFnZXIgQVBJIGRvZXMgbm90IHByZXNlcnZlIHN0YWNrIHRyYWNlcyBmb3IgdGhlIGFzeW5jXG4gKiBmdW5jdGlvbiBwYXNzZWQgaW4gdGhlIGByZXF1ZXN0YCBtZXRob2QsIGEgdHJpY2sgaXMgdXNlZCB3aGVyZSBhY3F1aXJpbmcgdGhlXG4gKiBsb2NrIHJlbGVhc2VzIGEgcHJldmlvdXNseSBzdGFydGVkIHByb21pc2UgdG8gcnVuIHRoZSBvcGVyYXRpb24gaW4gdGhlIGBmbmBcbiAqIGZ1bmN0aW9uLiBUaGUgbG9jayB3YWl0cyBmb3IgdGhhdCBwcm9taXNlIHRvIGZpbmlzaCAod2l0aCBvciB3aXRob3V0IGVycm9yKSxcbiAqIHdoaWxlIHRoZSBmdW5jdGlvbiB3aWxsIGZpbmFsbHkgd2FpdCBmb3IgdGhlIHJlc3VsdCBhbnl3YXkuXG4gKlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgbG9jayB0byBiZSBhY3F1aXJlZC5cbiAqIEBwYXJhbSBhY3F1aXJlVGltZW91dCBJZiBuZWdhdGl2ZSwgbm8gdGltZW91dC4gSWYgMCBhbiBlcnJvciBpcyB0aHJvd24gaWZcbiAqICAgICAgICAgICAgICAgICAgICAgICB0aGUgbG9jayBjYW4ndCBiZSBhY3F1aXJlZCB3aXRob3V0IHdhaXRpbmcuIElmIHBvc2l0aXZlLCB0aGUgbG9jayBhY3F1aXJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgd2lsbCB0aW1lIG91dCBhZnRlciBzbyBtYW55IG1pbGxpc2Vjb25kcy4gQW4gZXJyb3IgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICBhIHRpbWVvdXQgaWYgaXQgaGFzIGBpc0FjcXVpcmVUaW1lb3V0YCBzZXQgdG8gdHJ1ZS5cbiAqIEBwYXJhbSBmbiBUaGUgb3BlcmF0aW9uIHRvIHJ1biBvbmNlIHRoZSBsb2NrIGlzIGFjcXVpcmVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbmF2aWdhdG9yTG9jayhuYW1lLCBhY3F1aXJlVGltZW91dCwgZm4pIHtcbiAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBhY3F1aXJlIGxvY2snLCBuYW1lLCBhY3F1aXJlVGltZW91dCk7XG4gICAgfVxuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBnbG9iYWxUaGlzLkFib3J0Q29udHJvbGxlcigpO1xuICAgIGlmIChhY3F1aXJlVGltZW91dCA+IDApIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jayBhY3F1aXJlIHRpbWVkIG91dCcsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBhY3F1aXJlVGltZW91dCk7XG4gICAgfVxuICAgIC8vIE1ETiBhcnRpY2xlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTG9ja01hbmFnZXIvcmVxdWVzdFxuICAgIC8vIFdyYXBwaW5nIG5hdmlnYXRvci5sb2Nrcy5yZXF1ZXN0KCkgd2l0aCBhIHBsYWluIFByb21pc2UgaXMgZG9uZSBhcyBzb21lXG4gICAgLy8gbGlicmFyaWVzIGxpa2Ugem9uZS5qcyBwYXRjaCB0aGUgUHJvbWlzZSBvYmplY3QgdG8gdHJhY2sgdGhlIGV4ZWN1dGlvblxuICAgIC8vIGNvbnRleHQuIEhvd2V2ZXIsIGl0IGFwcGVhcnMgdGhhdCBtb3N0IGJyb3dzZXJzIHVzZSBhbiBpbnRlcm5hbCBwcm9taXNlXG4gICAgLy8gaW1wbGVtZW50YXRpb24gd2hlbiB1c2luZyB0aGUgbmF2aWdhdG9yLmxvY2tzLnJlcXVlc3QoKSBBUEkgY2F1c2luZyB0aGVtXG4gICAgLy8gdG8gbG9zZSBjb250ZXh0IGFuZCBlbWl0IGNvbmZ1c2luZyBsb2cgbWVzc2FnZXMgb3IgYnJlYWsgY2VydGFpbiBmZWF0dXJlcy5cbiAgICAvLyBUaGlzIHdyYXBwaW5nIGlzIGJlbGlldmVkIHRvIGhlbHAgem9uZS5qcyB0cmFjayB0aGUgZXhlY3V0aW9uIGNvbnRleHRcbiAgICAvLyBiZXR0ZXIuXG4gICAgcmV0dXJuIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gZ2xvYmFsVGhpcy5uYXZpZ2F0b3IubG9ja3MucmVxdWVzdChuYW1lLCBhY3F1aXJlVGltZW91dCA9PT0gMFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIG1vZGU6ICdleGNsdXNpdmUnLFxuICAgICAgICAgICAgaWZBdmFpbGFibGU6IHRydWUsXG4gICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBtb2RlOiAnZXhjbHVzaXZlJyxcbiAgICAgICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgfSwgYXN5bmMgKGxvY2spID0+IHtcbiAgICAgICAgaWYgKGxvY2spIHtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogbmF2aWdhdG9yTG9jazogYWNxdWlyZWQnLCBuYW1lLCBsb2NrLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0BzdXBhYmFzZS9nb3RydWUtanM6IG5hdmlnYXRvckxvY2s6IHJlbGVhc2VkJywgbmFtZSwgbG9jay5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYWNxdWlyZVRpbWVvdXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxzLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdAc3VwYWJhc2UvZ290cnVlLWpzOiBuYXZpZ2F0b3JMb2NrOiBub3QgaW1tZWRpYXRlbHkgYXZhaWxhYmxlJywgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBOYXZpZ2F0b3JMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcihgQWNxdWlyaW5nIGFuIGV4Y2x1c2l2ZSBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgbG9jayBcIiR7bmFtZX1cIiBpbW1lZGlhdGVseSBmYWlsZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdsb2JhbFRoaXMubmF2aWdhdG9yLmxvY2tzLnF1ZXJ5KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQHN1cGFiYXNlL2dvdHJ1ZS1qczogTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHN0YXRlJywgSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAnICAnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQHN1cGFiYXNlL2dvdHJ1ZS1qczogRXJyb3Igd2hlbiBxdWVyeWluZyBOYXZpZ2F0b3IgTG9ja01hbmFnZXIgc3RhdGUnLCBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCcm93c2VyIGlzIG5vdCBmb2xsb3dpbmcgdGhlIE5hdmlnYXRvciBMb2NrTWFuYWdlciBzcGVjLCBpdFxuICAgICAgICAgICAgICAgIC8vIHJldHVybmVkIGEgbnVsbCBsb2NrIHdoZW4gd2UgZGlkbid0IHVzZSBpZkF2YWlsYWJsZS4gU28gd2UgY2FuXG4gICAgICAgICAgICAgICAgLy8gcHJldGVuZCB0aGUgbG9jayBpcyBhY3F1aXJlZCBpbiB0aGUgbmFtZSBvZiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgLy8gYW5kIHVzZXIgZXhwZXJpZW5jZSBhbmQganVzdCBydW4gdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQHN1cGFiYXNlL2dvdHJ1ZS1qczogTmF2aWdhdG9yIExvY2tNYW5hZ2VyIHJldHVybmVkIGEgbnVsbCBsb2NrIHdoZW4gdXNpbmcgI3JlcXVlc3Qgd2l0aG91dCBpZkF2YWlsYWJsZSBzZXQgdG8gdHJ1ZSwgaXQgYXBwZWFycyB0aGlzIGJyb3dzZXIgaXMgbm90IGZvbGxvd2luZyB0aGUgTG9ja01hbmFnZXIgc3BlYyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTG9ja01hbmFnZXIvcmVxdWVzdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkpO1xufVxuY29uc3QgUFJPQ0VTU19MT0NLUyA9IHt9O1xuLyoqXG4gKiBJbXBsZW1lbnRzIGEgZ2xvYmFsIGV4Y2x1c2l2ZSBsb2NrIHRoYXQgd29ya3Mgb25seSBpbiB0aGUgY3VycmVudCBwcm9jZXNzLlxuICogVXNlZnVsIGZvciBlbnZpcm9ubWVudHMgbGlrZSBSZWFjdCBOYXRpdmUgb3Igb3RoZXIgbm9uLWJyb3dzZXJcbiAqIHNpbmdsZS1wcm9jZXNzIChpLmUuIG5vIGNvbmNlcHQgb2YgXCJ0YWJzXCIpIGVudmlyb25tZW50cy5cbiAqXG4gKiBVc2Uge0BsaW5rICNuYXZpZ2F0b3JMb2NrfSBpbiBicm93c2VyIGVudmlyb25tZW50cy5cbiAqXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSBsb2NrIHRvIGJlIGFjcXVpcmVkLlxuICogQHBhcmFtIGFjcXVpcmVUaW1lb3V0IElmIG5lZ2F0aXZlLCBubyB0aW1lb3V0LiBJZiAwIGFuIGVycm9yIGlzIHRocm93biBpZlxuICogICAgICAgICAgICAgICAgICAgICAgIHRoZSBsb2NrIGNhbid0IGJlIGFjcXVpcmVkIHdpdGhvdXQgd2FpdGluZy4gSWYgcG9zaXRpdmUsIHRoZSBsb2NrIGFjcXVpcmVcbiAqICAgICAgICAgICAgICAgICAgICAgICB3aWxsIHRpbWUgb3V0IGFmdGVyIHNvIG1hbnkgbWlsbGlzZWNvbmRzLiBBbiBlcnJvciBpc1xuICogICAgICAgICAgICAgICAgICAgICAgIGEgdGltZW91dCBpZiBpdCBoYXMgYGlzQWNxdWlyZVRpbWVvdXRgIHNldCB0byB0cnVlLlxuICogQHBhcmFtIGZuIFRoZSBvcGVyYXRpb24gdG8gcnVuIG9uY2UgdGhlIGxvY2sgaXMgYWNxdWlyZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzTG9jayhuYW1lLCBhY3F1aXJlVGltZW91dCwgZm4pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcHJldmlvdXNPcGVyYXRpb24gPSAoX2EgPSBQUk9DRVNTX0xPQ0tTW25hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBjb25zdCBjdXJyZW50T3BlcmF0aW9uID0gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgcHJldmlvdXNPcGVyYXRpb24uY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gaWdub3JlIGVycm9yIG9mIHByZXZpb3VzIG9wZXJhdGlvbiB0aGF0IHdlJ3JlIHdhaXRpbmcgdG8gZmluaXNoXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSksXG4gICAgICAgIGFjcXVpcmVUaW1lb3V0ID49IDBcbiAgICAgICAgICAgID8gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFByb2Nlc3NMb2NrQWNxdWlyZVRpbWVvdXRFcnJvcihgQWNxdXJpbmcgcHJvY2VzcyBsb2NrIHdpdGggbmFtZSBcIiR7bmFtZX1cIiB0aW1lZCBvdXRgKSk7XG4gICAgICAgICAgICAgICAgfSwgYWNxdWlyZVRpbWVvdXQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogbnVsbCxcbiAgICBdLmZpbHRlcigoeCkgPT4geCkpXG4gICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICBpZiAoZSAmJiBlLmlzQWNxdWlyZVRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSlcbiAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAvLyBwcmV2aW91cyBvcGVyYXRpb25zIGZpbmlzaGVkIGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmFjZSBvbiB0aGUgYWNxdWlyZVxuICAgICAgICAvLyB0aW1lb3V0LCBzbyB0aGUgY3VycmVudCBvcGVyYXRpb24gY2FuIGZpbmFsbHkgc3RhcnRcbiAgICAgICAgcmV0dXJuIGF3YWl0IGZuKCk7XG4gICAgfSk7XG4gICAgUFJPQ0VTU19MT0NLU1tuYW1lXSA9IGN1cnJlbnRPcGVyYXRpb24uY2F0Y2goYXN5bmMgKGUpID0+IHtcbiAgICAgICAgaWYgKGUgJiYgZS5pc0FjcXVpcmVUaW1lb3V0KSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBvcGVyYXRpb24gdGltZWQgb3V0LCBpdCBkb2Vzbid0IG1lYW4gdGhhdCB0aGUgcHJldmlvdXNcbiAgICAgICAgICAgIC8vIG9wZXJhdGlvbiBmaW5pc2hlZCwgc28gd2UgbmVlZCBjb250bnVlIHdhaXRpbmcgZm9yIGl0IHRvIGZpbmlzaFxuICAgICAgICAgICAgYXdhaXQgcHJldmlvdXNPcGVyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICAgIC8vIGZpbmFsbHkgd2FpdCBmb3IgdGhlIGN1cnJlbnQgb3BlcmF0aW9uIHRvIGZpbmlzaCBzdWNjZXNzZnVsbHksIHdpdGggYW5cbiAgICAvLyBlcnJvciBvciB3aXRoIGFuIGFjcXVpcmUgdGltZW91dCBlcnJvclxuICAgIHJldHVybiBhd2FpdCBjdXJyZW50T3BlcmF0aW9uO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9ja3MuanMubWFwIl0sIm5hbWVzIjpbInN1cHBvcnRzTG9jYWxTdG9yYWdlIiwiaW50ZXJuYWxzIiwiZGVidWciLCJnbG9iYWxUaGlzIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkxvY2tBY3F1aXJlVGltZW91dEVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJpc0FjcXVpcmVUaW1lb3V0IiwiTmF2aWdhdG9yTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IiLCJQcm9jZXNzTG9ja0FjcXVpcmVUaW1lb3V0RXJyb3IiLCJuYXZpZ2F0b3JMb2NrIiwibmFtZSIsImFjcXVpcmVUaW1lb3V0IiwiZm4iLCJjb25zb2xlIiwibG9nIiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwic2V0VGltZW91dCIsImFib3J0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwibmF2aWdhdG9yIiwibG9ja3MiLCJyZXF1ZXN0IiwibW9kZSIsImlmQXZhaWxhYmxlIiwic2lnbmFsIiwibG9jayIsInJlc3VsdCIsInF1ZXJ5IiwiSlNPTiIsInN0cmluZ2lmeSIsImUiLCJ3YXJuIiwiUFJPQ0VTU19MT0NLUyIsInByb2Nlc3NMb2NrIiwiX2EiLCJwcmV2aW91c09wZXJhdGlvbiIsImN1cnJlbnRPcGVyYXRpb24iLCJyYWNlIiwiY2F0Y2giLCJfIiwicmVqZWN0IiwiZmlsdGVyIiwieCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/locks.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   polyfillGlobalThis: () => (/* binding */ polyfillGlobalThis)\n/* harmony export */ });\n/**\n * https://mathiasbynens.be/notes/globalthis\n */ function polyfillGlobalThis() {\n    if (typeof globalThis === \"object\") return;\n    try {\n        Object.defineProperty(Object.prototype, \"__magic__\", {\n            get: function() {\n                return this;\n            },\n            configurable: true\n        });\n        // @ts-expect-error 'Allow access to magic'\n        __magic__.globalThis = __magic__;\n        // @ts-expect-error 'Allow access to magic'\n        delete Object.prototype.__magic__;\n    } catch (e) {\n        if (typeof self !== \"undefined\") {\n            // @ts-expect-error 'Allow access to globals'\n            self.globalThis = self;\n        }\n    }\n} //# sourceMappingURL=polyfills.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3BvbHlmaWxscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7O0NBRUMsR0FDTSxTQUFTQTtJQUNaLElBQUksT0FBT0MsZUFBZSxVQUN0QjtJQUNKLElBQUk7UUFDQUMsT0FBT0MsY0FBYyxDQUFDRCxPQUFPRSxTQUFTLEVBQUUsYUFBYTtZQUNqREMsS0FBSztnQkFDRCxPQUFPLElBQUk7WUFDZjtZQUNBQyxjQUFjO1FBQ2xCO1FBQ0EsMkNBQTJDO1FBQzNDQyxVQUFVTixVQUFVLEdBQUdNO1FBQ3ZCLDJDQUEyQztRQUMzQyxPQUFPTCxPQUFPRSxTQUFTLENBQUNHLFNBQVM7SUFDckMsRUFDQSxPQUFPQyxHQUFHO1FBQ04sSUFBSSxPQUFPQyxTQUFTLGFBQWE7WUFDN0IsNkNBQTZDO1lBQzdDQSxLQUFLUixVQUFVLEdBQUdRO1FBQ3RCO0lBQ0o7QUFDSixFQUNBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi9wb2x5ZmlsbHMuanM/NjNlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9nbG9iYWx0aGlzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb2x5ZmlsbEdsb2JhbFRoaXMoKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QucHJvdG90eXBlLCAnX19tYWdpY19fJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAnQWxsb3cgYWNjZXNzIHRvIG1hZ2ljJ1xuICAgICAgICBfX21hZ2ljX18uZ2xvYmFsVGhpcyA9IF9fbWFnaWNfXztcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAnQWxsb3cgYWNjZXNzIHRvIG1hZ2ljJ1xuICAgICAgICBkZWxldGUgT2JqZWN0LnByb3RvdHlwZS5fX21hZ2ljX187XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgJ0FsbG93IGFjY2VzcyB0byBnbG9iYWxzJ1xuICAgICAgICAgICAgc2VsZi5nbG9iYWxUaGlzID0gc2VsZjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlmaWxscy5qcy5tYXAiXSwibmFtZXMiOlsicG9seWZpbGxHbG9iYWxUaGlzIiwiZ2xvYmFsVGhpcyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiZ2V0IiwiY29uZmlndXJhYmxlIiwiX19tYWdpY19fIiwiZSIsInNlbGYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/polyfills.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/types.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/types.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SIGN_OUT_SCOPES: () => (/* binding */ SIGN_OUT_SCOPES)\n/* harmony export */ });\nconst WeakPasswordReasons = [\n    \"length\",\n    \"characters\",\n    \"pwned\"\n];\nconst AMRMethods = [\n    \"password\",\n    \"otp\",\n    \"oauth\",\n    \"totp\",\n    \"mfa/totp\",\n    \"mfa/phone\",\n    \"mfa/webauthn\",\n    \"anonymous\",\n    \"sso/saml\",\n    \"magiclink\",\n    \"web3\"\n];\nconst FactorTypes = [\n    \"totp\",\n    \"phone\",\n    \"webauthn\"\n];\nconst FactorVerificationStatuses = [\n    \"verified\",\n    \"unverified\"\n];\nconst MFATOTPChannels = [\n    \"sms\",\n    \"whatsapp\"\n];\nconst SIGN_OUT_SCOPES = [\n    \"global\",\n    \"local\",\n    \"others\"\n]; //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3R5cGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxzQkFBc0I7SUFBQztJQUFVO0lBQWM7Q0FBUTtBQUM3RCxNQUFNQyxhQUFhO0lBQ2Y7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsTUFBTUMsY0FBYztJQUFDO0lBQVE7SUFBUztDQUFXO0FBQ2pELE1BQU1DLDZCQUE2QjtJQUFDO0lBQVk7Q0FBYTtBQUM3RCxNQUFNQyxrQkFBa0I7SUFBQztJQUFPO0NBQVc7QUFDcEMsTUFBTUMsa0JBQWtCO0lBQUM7SUFBVTtJQUFTO0NBQVMsQ0FBQyxDQUM3RCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvdHlwZXMuanM/MWY2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBXZWFrUGFzc3dvcmRSZWFzb25zID0gWydsZW5ndGgnLCAnY2hhcmFjdGVycycsICdwd25lZCddO1xuY29uc3QgQU1STWV0aG9kcyA9IFtcbiAgICAncGFzc3dvcmQnLFxuICAgICdvdHAnLFxuICAgICdvYXV0aCcsXG4gICAgJ3RvdHAnLFxuICAgICdtZmEvdG90cCcsXG4gICAgJ21mYS9waG9uZScsXG4gICAgJ21mYS93ZWJhdXRobicsXG4gICAgJ2Fub255bW91cycsXG4gICAgJ3Nzby9zYW1sJyxcbiAgICAnbWFnaWNsaW5rJyxcbiAgICAnd2ViMycsXG5dO1xuY29uc3QgRmFjdG9yVHlwZXMgPSBbJ3RvdHAnLCAncGhvbmUnLCAnd2ViYXV0aG4nXTtcbmNvbnN0IEZhY3RvclZlcmlmaWNhdGlvblN0YXR1c2VzID0gWyd2ZXJpZmllZCcsICd1bnZlcmlmaWVkJ107XG5jb25zdCBNRkFUT1RQQ2hhbm5lbHMgPSBbJ3NtcycsICd3aGF0c2FwcCddO1xuZXhwb3J0IGNvbnN0IFNJR05fT1VUX1NDT1BFUyA9IFsnZ2xvYmFsJywgJ2xvY2FsJywgJ290aGVycyddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIldlYWtQYXNzd29yZFJlYXNvbnMiLCJBTVJNZXRob2RzIiwiRmFjdG9yVHlwZXMiLCJGYWN0b3JWZXJpZmljYXRpb25TdGF0dXNlcyIsIk1GQVRPVFBDaGFubmVscyIsIlNJR05fT1VUX1NDT1BFUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/version.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nconst version = \"2.78.0\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDZFQUE2RTtBQUM3RSxnRUFBZ0U7QUFDaEUsdUVBQXVFO0FBQ3ZFLGlFQUFpRTtBQUNqRSxrRUFBa0U7QUFDbEUsaUVBQWlFO0FBQzFELE1BQU1BLFVBQVUsU0FBUyxDQUNoQyxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvdmVyc2lvbi5qcz85NzdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IGR1cmluZyByZWxlYXNlcyBieSBzY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLWZpbGVzLnRzXG4vLyBUaGlzIGZpbGUgcHJvdmlkZXMgcnVudGltZSBhY2Nlc3MgdG8gdGhlIHBhY2thZ2UgdmVyc2lvbiBmb3I6XG4vLyAtIEhUVFAgcmVxdWVzdCBoZWFkZXJzIChlLmcuLCBYLUNsaWVudC1JbmZvIGhlYWRlciBmb3IgQVBJIHJlcXVlc3RzKVxuLy8gLSBEZWJ1Z2dpbmcgYW5kIHN1cHBvcnQgKGlkZW50aWZ5aW5nIHdoaWNoIHZlcnNpb24gaXMgcnVubmluZylcbi8vIC0gVGVsZW1ldHJ5IGFuZCBsb2dnaW5nICh2ZXJzaW9uIHJlcG9ydGluZyBpbiBlcnJvcnMvYW5hbHl0aWNzKVxuLy8gLSBFbnN1cmluZyBidWlsZCBhcnRpZmFjdHMgbWF0Y2ggdGhlIHB1Ymxpc2hlZCBwYWNrYWdlIHZlcnNpb25cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuNzguMCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSiweMessage: () => (/* binding */ createSiweMessage),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   getAddress: () => (/* binding */ getAddress),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n// types and functions copied over from viem so this library doesn't depend on it\nfunction getAddress(address) {\n    if (!/^0x[a-fA-F0-9]{40}$/.test(address)) {\n        throw new Error(`@supabase/auth-js: Address \"${address}\" is invalid.`);\n    }\n    return address.toLowerCase();\n}\nfunction fromHex(hex) {\n    return parseInt(hex, 16);\n}\nfunction toHex(value) {\n    const bytes = new TextEncoder().encode(value);\n    const hex = Array.from(bytes, (byte)=>byte.toString(16).padStart(2, \"0\")).join(\"\");\n    return \"0x\" + hex;\n}\n/**\n * Creates EIP-4361 formatted message.\n */ function createSiweMessage(parameters) {\n    var _a;\n    const { chainId, domain, expirationTime, issuedAt = new Date(), nonce, notBefore, requestId, resources, scheme, uri, version } = parameters;\n    // Validate fields\n    {\n        if (!Number.isInteger(chainId)) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"chainId\". Chain ID must be a EIP-155 chain ID. Provided value: ${chainId}`);\n        if (!domain) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"domain\". Domain must be provided.`);\n        if (nonce && nonce.length < 8) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"nonce\". Nonce must be at least 8 characters. Provided value: ${nonce}`);\n        if (!uri) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"uri\". URI must be provided.`);\n        if (version !== \"1\") throw new Error(`@supabase/auth-js: Invalid SIWE message field \"version\". Version must be '1'. Provided value: ${version}`);\n        if ((_a = parameters.statement) === null || _a === void 0 ? void 0 : _a.includes(\"\\n\")) throw new Error(`@supabase/auth-js: Invalid SIWE message field \"statement\". Statement must not include '\\\\n'. Provided value: ${parameters.statement}`);\n    }\n    // Construct message\n    const address = getAddress(parameters.address);\n    const origin = scheme ? `${scheme}://${domain}` : domain;\n    const statement = parameters.statement ? `${parameters.statement}\\n` : \"\";\n    const prefix = `${origin} wants you to sign in with your Ethereum account:\\n${address}\\n\\n${statement}`;\n    let suffix = `URI: ${uri}\\nVersion: ${version}\\nChain ID: ${chainId}${nonce ? `\\nNonce: ${nonce}` : \"\"}\\nIssued At: ${issuedAt.toISOString()}`;\n    if (expirationTime) suffix += `\\nExpiration Time: ${expirationTime.toISOString()}`;\n    if (notBefore) suffix += `\\nNot Before: ${notBefore.toISOString()}`;\n    if (requestId) suffix += `\\nRequest ID: ${requestId}`;\n    if (resources) {\n        let content = \"\\nResources:\";\n        for (const resource of resources){\n            if (!resource || typeof resource !== \"string\") throw new Error(`@supabase/auth-js: Invalid SIWE message field \"resources\". Every resource must be a valid string. Provided value: ${resource}`);\n            content += `\\n- ${resource}`;\n        }\n        suffix += content;\n    }\n    return `${prefix}\\n${suffix}`;\n} //# sourceMappingURL=ethereum.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3dlYjMvZXRoZXJldW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGlGQUFpRjtBQUMxRSxTQUFTQSxXQUFXQyxPQUFPO0lBQzlCLElBQUksQ0FBQyxzQkFBc0JDLElBQUksQ0FBQ0QsVUFBVTtRQUN0QyxNQUFNLElBQUlFLE1BQU0sQ0FBQyw0QkFBNEIsRUFBRUYsUUFBUSxhQUFhLENBQUM7SUFDekU7SUFDQSxPQUFPQSxRQUFRRyxXQUFXO0FBQzlCO0FBQ08sU0FBU0MsUUFBUUMsR0FBRztJQUN2QixPQUFPQyxTQUFTRCxLQUFLO0FBQ3pCO0FBQ08sU0FBU0UsTUFBTUMsS0FBSztJQUN2QixNQUFNQyxRQUFRLElBQUlDLGNBQWNDLE1BQU0sQ0FBQ0g7SUFDdkMsTUFBTUgsTUFBTU8sTUFBTUMsSUFBSSxDQUFDSixPQUFPLENBQUNLLE9BQVNBLEtBQUtDLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRyxNQUFNQyxJQUFJLENBQUM7SUFDakYsT0FBUSxPQUFPWjtBQUNuQjtBQUNBOztDQUVDLEdBQ00sU0FBU2Esa0JBQWtCQyxVQUFVO0lBQ3hDLElBQUlDO0lBQ0osTUFBTSxFQUFFQyxPQUFPLEVBQUVDLE1BQU0sRUFBRUMsY0FBYyxFQUFFQyxXQUFXLElBQUlDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsU0FBUyxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsT0FBTyxFQUFHLEdBQUdiO0lBQ2xJLGtCQUFrQjtJQUNsQjtRQUNJLElBQUksQ0FBQ2MsT0FBT0MsU0FBUyxDQUFDYixVQUNsQixNQUFNLElBQUluQixNQUFNLENBQUMsOEdBQThHLEVBQUVtQixRQUFRLENBQUM7UUFDOUksSUFBSSxDQUFDQyxRQUNELE1BQU0sSUFBSXBCLE1BQU0sQ0FBQyxnRkFBZ0YsQ0FBQztRQUN0RyxJQUFJd0IsU0FBU0EsTUFBTVMsTUFBTSxHQUFHLEdBQ3hCLE1BQU0sSUFBSWpDLE1BQU0sQ0FBQyw0R0FBNEcsRUFBRXdCLE1BQU0sQ0FBQztRQUMxSSxJQUFJLENBQUNLLEtBQ0QsTUFBTSxJQUFJN0IsTUFBTSxDQUFDLDBFQUEwRSxDQUFDO1FBQ2hHLElBQUk4QixZQUFZLEtBQ1osTUFBTSxJQUFJOUIsTUFBTSxDQUFDLDhGQUE4RixFQUFFOEIsUUFBUSxDQUFDO1FBQzlILElBQUksQ0FBQ1osS0FBS0QsV0FBV2lCLFNBQVMsTUFBTSxRQUFRaEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHaUIsUUFBUSxDQUFDLE9BQzdFLE1BQU0sSUFBSW5DLE1BQU0sQ0FBQyw2R0FBNkcsRUFBRWlCLFdBQVdpQixTQUFTLENBQUMsQ0FBQztJQUM5SjtJQUNBLG9CQUFvQjtJQUNwQixNQUFNcEMsVUFBVUQsV0FBV29CLFdBQVduQixPQUFPO0lBQzdDLE1BQU1zQyxTQUFTUixTQUFTLENBQUMsRUFBRUEsT0FBTyxHQUFHLEVBQUVSLE9BQU8sQ0FBQyxHQUFHQTtJQUNsRCxNQUFNYyxZQUFZakIsV0FBV2lCLFNBQVMsR0FBRyxDQUFDLEVBQUVqQixXQUFXaUIsU0FBUyxDQUFDLEVBQUUsQ0FBQyxHQUFHO0lBQ3ZFLE1BQU1HLFNBQVMsQ0FBQyxFQUFFRCxPQUFPLG1EQUFtRCxFQUFFdEMsUUFBUSxJQUFJLEVBQUVvQyxVQUFVLENBQUM7SUFDdkcsSUFBSUksU0FBUyxDQUFDLEtBQUssRUFBRVQsSUFBSSxXQUFXLEVBQUVDLFFBQVEsWUFBWSxFQUFFWCxRQUFRLEVBQUVLLFFBQVEsQ0FBQyxTQUFTLEVBQUVBLE1BQU0sQ0FBQyxHQUFHLEdBQUcsYUFBYSxFQUFFRixTQUFTaUIsV0FBVyxHQUFHLENBQUM7SUFDOUksSUFBSWxCLGdCQUNBaUIsVUFBVSxDQUFDLG1CQUFtQixFQUFFakIsZUFBZWtCLFdBQVcsR0FBRyxDQUFDO0lBQ2xFLElBQUlkLFdBQ0FhLFVBQVUsQ0FBQyxjQUFjLEVBQUViLFVBQVVjLFdBQVcsR0FBRyxDQUFDO0lBQ3hELElBQUliLFdBQ0FZLFVBQVUsQ0FBQyxjQUFjLEVBQUVaLFVBQVUsQ0FBQztJQUMxQyxJQUFJQyxXQUFXO1FBQ1gsSUFBSWEsVUFBVTtRQUNkLEtBQUssTUFBTUMsWUFBWWQsVUFBVztZQUM5QixJQUFJLENBQUNjLFlBQVksT0FBT0EsYUFBYSxVQUNqQyxNQUFNLElBQUl6QyxNQUFNLENBQUMsa0hBQWtILEVBQUV5QyxTQUFTLENBQUM7WUFDbkpELFdBQVcsQ0FBQyxJQUFJLEVBQUVDLFNBQVMsQ0FBQztRQUNoQztRQUNBSCxVQUFVRTtJQUNkO0lBQ0EsT0FBTyxDQUFDLEVBQUVILE9BQU8sRUFBRSxFQUFFQyxPQUFPLENBQUM7QUFDakMsRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvd2ViMy9ldGhlcmV1bS5qcz8yMGQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHR5cGVzIGFuZCBmdW5jdGlvbnMgY29waWVkIG92ZXIgZnJvbSB2aWVtIHNvIHRoaXMgbGlicmFyeSBkb2Vzbid0IGRlcGVuZCBvbiBpdFxuZXhwb3J0IGZ1bmN0aW9uIGdldEFkZHJlc3MoYWRkcmVzcykge1xuICAgIGlmICghL14weFthLWZBLUYwLTldezQwfSQvLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogQWRkcmVzcyBcIiR7YWRkcmVzc31cIiBpcyBpbnZhbGlkLmApO1xuICAgIH1cbiAgICByZXR1cm4gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgoaGV4KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KGhleCwgMTYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KHZhbHVlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpO1xuICAgIGNvbnN0IGhleCA9IEFycmF5LmZyb20oYnl0ZXMsIChieXRlKSA9PiBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbiAgICByZXR1cm4gKCcweCcgKyBoZXgpO1xufVxuLyoqXG4gKiBDcmVhdGVzIEVJUC00MzYxIGZvcm1hdHRlZCBtZXNzYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2l3ZU1lc3NhZ2UocGFyYW1ldGVycykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGNoYWluSWQsIGRvbWFpbiwgZXhwaXJhdGlvblRpbWUsIGlzc3VlZEF0ID0gbmV3IERhdGUoKSwgbm9uY2UsIG5vdEJlZm9yZSwgcmVxdWVzdElkLCByZXNvdXJjZXMsIHNjaGVtZSwgdXJpLCB2ZXJzaW9uLCB9ID0gcGFyYW1ldGVycztcbiAgICAvLyBWYWxpZGF0ZSBmaWVsZHNcbiAgICB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjaGFpbklkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEludmFsaWQgU0lXRSBtZXNzYWdlIGZpZWxkIFwiY2hhaW5JZFwiLiBDaGFpbiBJRCBtdXN0IGJlIGEgRUlQLTE1NSBjaGFpbiBJRC4gUHJvdmlkZWQgdmFsdWU6ICR7Y2hhaW5JZH1gKTtcbiAgICAgICAgaWYgKCFkb21haW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcImRvbWFpblwiLiBEb21haW4gbXVzdCBiZSBwcm92aWRlZC5gKTtcbiAgICAgICAgaWYgKG5vbmNlICYmIG5vbmNlLmxlbmd0aCA8IDgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcIm5vbmNlXCIuIE5vbmNlIG11c3QgYmUgYXQgbGVhc3QgOCBjaGFyYWN0ZXJzLiBQcm92aWRlZCB2YWx1ZTogJHtub25jZX1gKTtcbiAgICAgICAgaWYgKCF1cmkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcInVyaVwiLiBVUkkgbXVzdCBiZSBwcm92aWRlZC5gKTtcbiAgICAgICAgaWYgKHZlcnNpb24gIT09ICcxJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQHN1cGFiYXNlL2F1dGgtanM6IEludmFsaWQgU0lXRSBtZXNzYWdlIGZpZWxkIFwidmVyc2lvblwiLiBWZXJzaW9uIG11c3QgYmUgJzEnLiBQcm92aWRlZCB2YWx1ZTogJHt2ZXJzaW9ufWApO1xuICAgICAgICBpZiAoKF9hID0gcGFyYW1ldGVycy5zdGF0ZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcygnXFxuJykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEBzdXBhYmFzZS9hdXRoLWpzOiBJbnZhbGlkIFNJV0UgbWVzc2FnZSBmaWVsZCBcInN0YXRlbWVudFwiLiBTdGF0ZW1lbnQgbXVzdCBub3QgaW5jbHVkZSAnXFxcXG4nLiBQcm92aWRlZCB2YWx1ZTogJHtwYXJhbWV0ZXJzLnN0YXRlbWVudH1gKTtcbiAgICB9XG4gICAgLy8gQ29uc3RydWN0IG1lc3NhZ2VcbiAgICBjb25zdCBhZGRyZXNzID0gZ2V0QWRkcmVzcyhwYXJhbWV0ZXJzLmFkZHJlc3MpO1xuICAgIGNvbnN0IG9yaWdpbiA9IHNjaGVtZSA/IGAke3NjaGVtZX06Ly8ke2RvbWFpbn1gIDogZG9tYWluO1xuICAgIGNvbnN0IHN0YXRlbWVudCA9IHBhcmFtZXRlcnMuc3RhdGVtZW50ID8gYCR7cGFyYW1ldGVycy5zdGF0ZW1lbnR9XFxuYCA6ICcnO1xuICAgIGNvbnN0IHByZWZpeCA9IGAke29yaWdpbn0gd2FudHMgeW91IHRvIHNpZ24gaW4gd2l0aCB5b3VyIEV0aGVyZXVtIGFjY291bnQ6XFxuJHthZGRyZXNzfVxcblxcbiR7c3RhdGVtZW50fWA7XG4gICAgbGV0IHN1ZmZpeCA9IGBVUkk6ICR7dXJpfVxcblZlcnNpb246ICR7dmVyc2lvbn1cXG5DaGFpbiBJRDogJHtjaGFpbklkfSR7bm9uY2UgPyBgXFxuTm9uY2U6ICR7bm9uY2V9YCA6ICcnfVxcbklzc3VlZCBBdDogJHtpc3N1ZWRBdC50b0lTT1N0cmluZygpfWA7XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lKVxuICAgICAgICBzdWZmaXggKz0gYFxcbkV4cGlyYXRpb24gVGltZTogJHtleHBpcmF0aW9uVGltZS50b0lTT1N0cmluZygpfWA7XG4gICAgaWYgKG5vdEJlZm9yZSlcbiAgICAgICAgc3VmZml4ICs9IGBcXG5Ob3QgQmVmb3JlOiAke25vdEJlZm9yZS50b0lTT1N0cmluZygpfWA7XG4gICAgaWYgKHJlcXVlc3RJZClcbiAgICAgICAgc3VmZml4ICs9IGBcXG5SZXF1ZXN0IElEOiAke3JlcXVlc3RJZH1gO1xuICAgIGlmIChyZXNvdXJjZXMpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSAnXFxuUmVzb3VyY2VzOic7XG4gICAgICAgIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgcmVzb3VyY2VzKSB7XG4gICAgICAgICAgICBpZiAoIXJlc291cmNlIHx8IHR5cGVvZiByZXNvdXJjZSAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2UvYXV0aC1qczogSW52YWxpZCBTSVdFIG1lc3NhZ2UgZmllbGQgXCJyZXNvdXJjZXNcIi4gRXZlcnkgcmVzb3VyY2UgbXVzdCBiZSBhIHZhbGlkIHN0cmluZy4gUHJvdmlkZWQgdmFsdWU6ICR7cmVzb3VyY2V9YCk7XG4gICAgICAgICAgICBjb250ZW50ICs9IGBcXG4tICR7cmVzb3VyY2V9YDtcbiAgICAgICAgfVxuICAgICAgICBzdWZmaXggKz0gY29udGVudDtcbiAgICB9XG4gICAgcmV0dXJuIGAke3ByZWZpeH1cXG4ke3N1ZmZpeH1gO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXRoZXJldW0uanMubWFwIl0sIm5hbWVzIjpbImdldEFkZHJlc3MiLCJhZGRyZXNzIiwidGVzdCIsIkVycm9yIiwidG9Mb3dlckNhc2UiLCJmcm9tSGV4IiwiaGV4IiwicGFyc2VJbnQiLCJ0b0hleCIsInZhbHVlIiwiYnl0ZXMiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsIkFycmF5IiwiZnJvbSIsImJ5dGUiLCJ0b1N0cmluZyIsInBhZFN0YXJ0Iiwiam9pbiIsImNyZWF0ZVNpd2VNZXNzYWdlIiwicGFyYW1ldGVycyIsIl9hIiwiY2hhaW5JZCIsImRvbWFpbiIsImV4cGlyYXRpb25UaW1lIiwiaXNzdWVkQXQiLCJEYXRlIiwibm9uY2UiLCJub3RCZWZvcmUiLCJyZXF1ZXN0SWQiLCJyZXNvdXJjZXMiLCJzY2hlbWUiLCJ1cmkiLCJ2ZXJzaW9uIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwibGVuZ3RoIiwic3RhdGVtZW50IiwiaW5jbHVkZXMiLCJvcmlnaW4iLCJwcmVmaXgiLCJzdWZmaXgiLCJ0b0lTT1N0cmluZyIsImNvbnRlbnQiLCJyZXNvdXJjZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/web3/ethereum.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebAuthnError: () => (/* binding */ WebAuthnError),\n/* harmony export */   WebAuthnUnknownError: () => (/* binding */ WebAuthnUnknownError),\n/* harmony export */   identifyAuthenticationError: () => (/* binding */ identifyAuthenticationError),\n/* harmony export */   identifyRegistrationError: () => (/* binding */ identifyRegistrationError),\n/* harmony export */   isWebAuthnError: () => (/* binding */ isWebAuthnError)\n/* harmony export */ });\n/* harmony import */ var _webauthn__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webauthn */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js\");\n/* eslint-disable @typescript-eslint/ban-ts-comment */ \n/**\n * A custom Error used to return a more nuanced error detailing _why_ one of the eight documented\n * errors in the spec was raised after calling `navigator.credentials.create()` or\n * `navigator.credentials.get()`:\n *\n * - `AbortError`\n * - `ConstraintError`\n * - `InvalidStateError`\n * - `NotAllowedError`\n * - `NotSupportedError`\n * - `SecurityError`\n * - `TypeError`\n * - `UnknownError`\n *\n * Error messages were determined through investigation of the spec to determine under which\n * scenarios a given error would be raised.\n */ class WebAuthnError extends Error {\n    constructor({ message, code, cause, name }){\n        var _a;\n        // @ts-ignore: help Rollup understand that `cause` is okay to set\n        super(message, {\n            cause\n        });\n        this.__isWebAuthnError = true;\n        this.name = (_a = name !== null && name !== void 0 ? name : cause instanceof Error ? cause.name : undefined) !== null && _a !== void 0 ? _a : \"Unknown Error\";\n        this.code = code;\n    }\n}\n/**\n * Error class for unknown WebAuthn errors.\n * Wraps unexpected errors that don't match known WebAuthn error conditions.\n */ class WebAuthnUnknownError extends WebAuthnError {\n    constructor(message, originalError){\n        super({\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: originalError,\n            message\n        });\n        this.name = \"WebAuthnUnknownError\";\n        this.originalError = originalError;\n    }\n}\n/**\n * Type guard to check if an error is a WebAuthnError.\n * @param {unknown} error - The error to check\n * @returns {boolean} True if the error is a WebAuthnError\n */ function isWebAuthnError(error) {\n    return typeof error === \"object\" && error !== null && \"__isWebAuthnError\" in error;\n}\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.create()`.\n * Maps browser errors to specific WebAuthn error codes for better debugging.\n * @param {Object} params - Error identification parameters\n * @param {Error} params.error - The error thrown by the browser\n * @param {CredentialCreationOptions} params.options - The options passed to credentials.create()\n * @returns {WebAuthnError} A WebAuthnError with a specific error code\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n */ function identifyRegistrationError({ error, options }) {\n    var _a, _b, _c;\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error(\"options was missing required publicKey property\");\n    }\n    if (error.name === \"AbortError\") {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: \"Registration ceremony was sent an abort signal\",\n                code: \"ERROR_CEREMONY_ABORTED\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"ConstraintError\") {\n        if (((_a = publicKey.authenticatorSelection) === null || _a === void 0 ? void 0 : _a.requireResidentKey) === true) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 4)\n            return new WebAuthnError({\n                message: \"Discoverable credentials were required but no available authenticator supported it\",\n                code: \"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT\",\n                cause: error\n            });\n        } else if (// @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024\n        options.mediation === \"conditional\" && ((_b = publicKey.authenticatorSelection) === null || _b === void 0 ? void 0 : _b.userVerification) === \"required\") {\n            // https://w3c.github.io/webauthn/#sctn-createCredential (Step 22.4)\n            return new WebAuthnError({\n                message: \"User verification was required during automatic registration but it could not be performed\",\n                code: \"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE\",\n                cause: error\n            });\n        } else if (((_c = publicKey.authenticatorSelection) === null || _c === void 0 ? void 0 : _c.userVerification) === \"required\") {\n            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 5)\n            return new WebAuthnError({\n                message: \"User verification was required but no available authenticator supported it\",\n                code: \"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"InvalidStateError\") {\n        // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 20)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 3)\n        return new WebAuthnError({\n            message: \"The authenticator was previously registered\",\n            code: \"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED\",\n            cause: error\n        });\n    } else if (error.name === \"NotAllowedError\") {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */ return new WebAuthnError({\n            message: error.message,\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: error\n        });\n    } else if (error.name === \"NotSupportedError\") {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param)=>param.type === \"public-key\");\n        if (validPubKeyCredParams.length === 0) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 10)\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: \"ERROR_MALFORMED_PUBKEYCREDPARAMS\",\n                cause: error\n            });\n        }\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 2)\n        return new WebAuthnError({\n            message: \"No available authenticator supported any of the specified pubKeyCredParams algorithms\",\n            code: \"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG\",\n            cause: error\n        });\n    } else if (error.name === \"SecurityError\") {\n        const effectiveDomain = window.location.hostname;\n        if (!(0,_webauthn__WEBPACK_IMPORTED_MODULE_0__.isValidDomain)(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 7)\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: \"ERROR_INVALID_DOMAIN\",\n                cause: error\n            });\n        } else if (publicKey.rp.id !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 8)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: \"ERROR_INVALID_RP_ID\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"TypeError\") {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 5)\n            return new WebAuthnError({\n                message: \"User ID was not between 1 and 64 characters\",\n                code: \"ERROR_INVALID_USER_ID_LENGTH\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"UnknownError\") {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 8)\n        return new WebAuthnError({\n            message: \"The authenticator was unable to process the specified options, or could not create a new credential\",\n            code: \"ERROR_AUTHENTICATOR_GENERAL_ERROR\",\n            cause: error\n        });\n    }\n    return new WebAuthnError({\n        message: \"a Non-Webauthn related error has occurred\",\n        code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n        cause: error\n    });\n}\n/**\n * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.get()`.\n * Maps browser errors to specific WebAuthn error codes for better debugging.\n * @param {Object} params - Error identification parameters\n * @param {Error} params.error - The error thrown by the browser\n * @param {CredentialRequestOptions} params.options - The options passed to credentials.get()\n * @returns {WebAuthnError} A WebAuthnError with a specific error code\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n */ function identifyAuthenticationError({ error, options }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error(\"options was missing required publicKey property\");\n    }\n    if (error.name === \"AbortError\") {\n        if (options.signal instanceof AbortSignal) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)\n            return new WebAuthnError({\n                message: \"Authentication ceremony was sent an abort signal\",\n                code: \"ERROR_CEREMONY_ABORTED\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"NotAllowedError\") {\n        /**\n         * Pass the error directly through. Platforms are overloading this error beyond what the spec\n         * defines and we don't want to overwrite potentially useful error messages.\n         */ return new WebAuthnError({\n            message: error.message,\n            code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n            cause: error\n        });\n    } else if (error.name === \"SecurityError\") {\n        const effectiveDomain = window.location.hostname;\n        if (!(0,_webauthn__WEBPACK_IMPORTED_MODULE_0__.isValidDomain)(effectiveDomain)) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 5)\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: \"ERROR_INVALID_DOMAIN\",\n                cause: error\n            });\n        } else if (publicKey.rpId !== effectiveDomain) {\n            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 6)\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: \"ERROR_INVALID_RP_ID\",\n                cause: error\n            });\n        }\n    } else if (error.name === \"UnknownError\") {\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 1)\n        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 12)\n        return new WebAuthnError({\n            message: \"The authenticator was unable to process the specified options, or could not create a new assertion signature\",\n            code: \"ERROR_AUTHENTICATOR_GENERAL_ERROR\",\n            cause: error\n        });\n    }\n    return new WebAuthnError({\n        message: \"a Non-Webauthn related error has occurred\",\n        code: \"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY\",\n        cause: error\n    });\n} //# sourceMappingURL=webauthn.errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3dlYmF1dGhuLmVycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxvREFBb0QsR0FDVDtBQUMzQzs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLE1BQU1DLHNCQUFzQkM7SUFDL0JDLFlBQVksRUFBRUMsT0FBTyxFQUFFQyxJQUFJLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFHLENBQUU7UUFDekMsSUFBSUM7UUFDSixpRUFBaUU7UUFDakUsS0FBSyxDQUFDSixTQUFTO1lBQUVFO1FBQU07UUFDdkIsSUFBSSxDQUFDRyxpQkFBaUIsR0FBRztRQUN6QixJQUFJLENBQUNGLElBQUksR0FBRyxDQUFDQyxLQUFLRCxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJQSxPQUFRRCxpQkFBaUJKLFFBQVFJLE1BQU1DLElBQUksR0FBR0csU0FBUyxNQUFPLFFBQVFGLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQ2hKLElBQUksQ0FBQ0gsSUFBSSxHQUFHQTtJQUNoQjtBQUNKO0FBQ0E7OztDQUdDLEdBQ00sTUFBTU0sNkJBQTZCVjtJQUN0Q0UsWUFBWUMsT0FBTyxFQUFFUSxhQUFhLENBQUU7UUFDaEMsS0FBSyxDQUFDO1lBQ0ZQLE1BQU07WUFDTkMsT0FBT007WUFDUFI7UUFDSjtRQUNBLElBQUksQ0FBQ0csSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDSyxhQUFhLEdBQUdBO0lBQ3pCO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ00sU0FBU0MsZ0JBQWdCQyxLQUFLO0lBQ2pDLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsdUJBQXVCQTtBQUNqRjtBQUNBOzs7Ozs7OztDQVFDLEdBQ00sU0FBU0MsMEJBQTBCLEVBQUVELEtBQUssRUFBRUUsT0FBTyxFQUFHO0lBQ3pELElBQUlSLElBQUlTLElBQUlDO0lBQ1osTUFBTSxFQUFFQyxTQUFTLEVBQUUsR0FBR0g7SUFDdEIsSUFBSSxDQUFDRyxXQUFXO1FBQ1osTUFBTWpCLE1BQU07SUFDaEI7SUFDQSxJQUFJWSxNQUFNUCxJQUFJLEtBQUssY0FBYztRQUM3QixJQUFJUyxRQUFRSSxNQUFNLFlBQVlDLGFBQWE7WUFDdkMsb0VBQW9FO1lBQ3BFLE9BQU8sSUFBSXBCLGNBQWM7Z0JBQ3JCRyxTQUFTO2dCQUNUQyxNQUFNO2dCQUNOQyxPQUFPUTtZQUNYO1FBQ0o7SUFDSixPQUNLLElBQUlBLE1BQU1QLElBQUksS0FBSyxtQkFBbUI7UUFDdkMsSUFBSSxDQUFDLENBQUNDLEtBQUtXLFVBQVVHLHNCQUFzQixNQUFNLFFBQVFkLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2Usa0JBQWtCLE1BQU0sTUFBTTtZQUMvRywrREFBK0Q7WUFDL0QsT0FBTyxJQUFJdEIsY0FBYztnQkFDckJHLFNBQVM7Z0JBQ1RDLE1BQU07Z0JBQ05DLE9BQU9RO1lBQ1g7UUFDSixPQUNLLElBQ0wsMkdBQTJHO1FBQzNHRSxRQUFRUSxTQUFTLEtBQUssaUJBQ2xCLENBQUMsQ0FBQ1AsS0FBS0UsVUFBVUcsc0JBQXNCLE1BQU0sUUFBUUwsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHUSxnQkFBZ0IsTUFBTSxZQUFZO1lBQ25ILG9FQUFvRTtZQUNwRSxPQUFPLElBQUl4QixjQUFjO2dCQUNyQkcsU0FBUztnQkFDVEMsTUFBTTtnQkFDTkMsT0FBT1E7WUFDWDtRQUNKLE9BQ0ssSUFBSSxDQUFDLENBQUNJLEtBQUtDLFVBQVVHLHNCQUFzQixNQUFNLFFBQVFKLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR08sZ0JBQWdCLE1BQU0sWUFBWTtZQUN4SCwrREFBK0Q7WUFDL0QsT0FBTyxJQUFJeEIsY0FBYztnQkFDckJHLFNBQVM7Z0JBQ1RDLE1BQU07Z0JBQ05DLE9BQU9RO1lBQ1g7UUFDSjtJQUNKLE9BQ0ssSUFBSUEsTUFBTVAsSUFBSSxLQUFLLHFCQUFxQjtRQUN6QyxvRUFBb0U7UUFDcEUsK0RBQStEO1FBQy9ELE9BQU8sSUFBSU4sY0FBYztZQUNyQkcsU0FBUztZQUNUQyxNQUFNO1lBQ05DLE9BQU9RO1FBQ1g7SUFDSixPQUNLLElBQUlBLE1BQU1QLElBQUksS0FBSyxtQkFBbUI7UUFDdkM7OztTQUdDLEdBQ0QsT0FBTyxJQUFJTixjQUFjO1lBQ3JCRyxTQUFTVSxNQUFNVixPQUFPO1lBQ3RCQyxNQUFNO1lBQ05DLE9BQU9RO1FBQ1g7SUFDSixPQUNLLElBQUlBLE1BQU1QLElBQUksS0FBSyxxQkFBcUI7UUFDekMsTUFBTW1CLHdCQUF3QlAsVUFBVVEsZ0JBQWdCLENBQUNDLE1BQU0sQ0FBQyxDQUFDQyxRQUFVQSxNQUFNQyxJQUFJLEtBQUs7UUFDMUYsSUFBSUosc0JBQXNCSyxNQUFNLEtBQUssR0FBRztZQUNwQyxvRUFBb0U7WUFDcEUsT0FBTyxJQUFJOUIsY0FBYztnQkFDckJHLFNBQVM7Z0JBQ1RDLE1BQU07Z0JBQ05DLE9BQU9RO1lBQ1g7UUFDSjtRQUNBLCtEQUErRDtRQUMvRCxPQUFPLElBQUliLGNBQWM7WUFDckJHLFNBQVM7WUFDVEMsTUFBTTtZQUNOQyxPQUFPUTtRQUNYO0lBQ0osT0FDSyxJQUFJQSxNQUFNUCxJQUFJLEtBQUssaUJBQWlCO1FBQ3JDLE1BQU15QixrQkFBa0JDLE9BQU9DLFFBQVEsQ0FBQ0MsUUFBUTtRQUNoRCxJQUFJLENBQUNuQyx3REFBYUEsQ0FBQ2dDLGtCQUFrQjtZQUNqQyxtRUFBbUU7WUFDbkUsT0FBTyxJQUFJL0IsY0FBYztnQkFDckJHLFNBQVMsQ0FBQyxFQUFFNkIsT0FBT0MsUUFBUSxDQUFDQyxRQUFRLENBQUMscUJBQXFCLENBQUM7Z0JBQzNEOUIsTUFBTTtnQkFDTkMsT0FBT1E7WUFDWDtRQUNKLE9BQ0ssSUFBSUssVUFBVWlCLEVBQUUsQ0FBQ0MsRUFBRSxLQUFLTCxpQkFBaUI7WUFDMUMsbUVBQW1FO1lBQ25FLE9BQU8sSUFBSS9CLGNBQWM7Z0JBQ3JCRyxTQUFTLENBQUMsV0FBVyxFQUFFZSxVQUFVaUIsRUFBRSxDQUFDQyxFQUFFLENBQUMsNEJBQTRCLENBQUM7Z0JBQ3BFaEMsTUFBTTtnQkFDTkMsT0FBT1E7WUFDWDtRQUNKO0lBQ0osT0FDSyxJQUFJQSxNQUFNUCxJQUFJLEtBQUssYUFBYTtRQUNqQyxJQUFJWSxVQUFVbUIsSUFBSSxDQUFDRCxFQUFFLENBQUNFLFVBQVUsR0FBRyxLQUFLcEIsVUFBVW1CLElBQUksQ0FBQ0QsRUFBRSxDQUFDRSxVQUFVLEdBQUcsSUFBSTtZQUN2RSxtRUFBbUU7WUFDbkUsT0FBTyxJQUFJdEMsY0FBYztnQkFDckJHLFNBQVM7Z0JBQ1RDLE1BQU07Z0JBQ05DLE9BQU9RO1lBQ1g7UUFDSjtJQUNKLE9BQ0ssSUFBSUEsTUFBTVAsSUFBSSxLQUFLLGdCQUFnQjtRQUNwQywrREFBK0Q7UUFDL0QsK0RBQStEO1FBQy9ELE9BQU8sSUFBSU4sY0FBYztZQUNyQkcsU0FBUztZQUNUQyxNQUFNO1lBQ05DLE9BQU9RO1FBQ1g7SUFDSjtJQUNBLE9BQU8sSUFBSWIsY0FBYztRQUNyQkcsU0FBUztRQUNUQyxNQUFNO1FBQ05DLE9BQU9RO0lBQ1g7QUFDSjtBQUNBOzs7Ozs7OztDQVFDLEdBQ00sU0FBUzBCLDRCQUE0QixFQUFFMUIsS0FBSyxFQUFFRSxPQUFPLEVBQUc7SUFDM0QsTUFBTSxFQUFFRyxTQUFTLEVBQUUsR0FBR0g7SUFDdEIsSUFBSSxDQUFDRyxXQUFXO1FBQ1osTUFBTWpCLE1BQU07SUFDaEI7SUFDQSxJQUFJWSxNQUFNUCxJQUFJLEtBQUssY0FBYztRQUM3QixJQUFJUyxRQUFRSSxNQUFNLFlBQVlDLGFBQWE7WUFDdkMsb0VBQW9FO1lBQ3BFLE9BQU8sSUFBSXBCLGNBQWM7Z0JBQ3JCRyxTQUFTO2dCQUNUQyxNQUFNO2dCQUNOQyxPQUFPUTtZQUNYO1FBQ0o7SUFDSixPQUNLLElBQUlBLE1BQU1QLElBQUksS0FBSyxtQkFBbUI7UUFDdkM7OztTQUdDLEdBQ0QsT0FBTyxJQUFJTixjQUFjO1lBQ3JCRyxTQUFTVSxNQUFNVixPQUFPO1lBQ3RCQyxNQUFNO1lBQ05DLE9BQU9RO1FBQ1g7SUFDSixPQUNLLElBQUlBLE1BQU1QLElBQUksS0FBSyxpQkFBaUI7UUFDckMsTUFBTXlCLGtCQUFrQkMsT0FBT0MsUUFBUSxDQUFDQyxRQUFRO1FBQ2hELElBQUksQ0FBQ25DLHdEQUFhQSxDQUFDZ0Msa0JBQWtCO1lBQ2pDLGdGQUFnRjtZQUNoRixPQUFPLElBQUkvQixjQUFjO2dCQUNyQkcsU0FBUyxDQUFDLEVBQUU2QixPQUFPQyxRQUFRLENBQUNDLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQztnQkFDM0Q5QixNQUFNO2dCQUNOQyxPQUFPUTtZQUNYO1FBQ0osT0FDSyxJQUFJSyxVQUFVc0IsSUFBSSxLQUFLVCxpQkFBaUI7WUFDekMsZ0ZBQWdGO1lBQ2hGLE9BQU8sSUFBSS9CLGNBQWM7Z0JBQ3JCRyxTQUFTLENBQUMsV0FBVyxFQUFFZSxVQUFVc0IsSUFBSSxDQUFDLDRCQUE0QixDQUFDO2dCQUNuRXBDLE1BQU07Z0JBQ05DLE9BQU9RO1lBQ1g7UUFDSjtJQUNKLE9BQ0ssSUFBSUEsTUFBTVAsSUFBSSxLQUFLLGdCQUFnQjtRQUNwQyxtRUFBbUU7UUFDbkUsb0VBQW9FO1FBQ3BFLE9BQU8sSUFBSU4sY0FBYztZQUNyQkcsU0FBUztZQUNUQyxNQUFNO1lBQ05DLE9BQU9RO1FBQ1g7SUFDSjtJQUNBLE9BQU8sSUFBSWIsY0FBYztRQUNyQkcsU0FBUztRQUNUQyxNQUFNO1FBQ05DLE9BQU9RO0lBQ1g7QUFDSixFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLWpzL2Rpc3QvbW9kdWxlL2xpYi93ZWJhdXRobi5lcnJvcnMuanM/Yjk1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnQgKi9cbmltcG9ydCB7IGlzVmFsaWREb21haW4gfSBmcm9tICcuL3dlYmF1dGhuJztcbi8qKlxuICogQSBjdXN0b20gRXJyb3IgdXNlZCB0byByZXR1cm4gYSBtb3JlIG51YW5jZWQgZXJyb3IgZGV0YWlsaW5nIF93aHlfIG9uZSBvZiB0aGUgZWlnaHQgZG9jdW1lbnRlZFxuICogZXJyb3JzIGluIHRoZSBzcGVjIHdhcyByYWlzZWQgYWZ0ZXIgY2FsbGluZyBgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpYCBvclxuICogYG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKWA6XG4gKlxuICogLSBgQWJvcnRFcnJvcmBcbiAqIC0gYENvbnN0cmFpbnRFcnJvcmBcbiAqIC0gYEludmFsaWRTdGF0ZUVycm9yYFxuICogLSBgTm90QWxsb3dlZEVycm9yYFxuICogLSBgTm90U3VwcG9ydGVkRXJyb3JgXG4gKiAtIGBTZWN1cml0eUVycm9yYFxuICogLSBgVHlwZUVycm9yYFxuICogLSBgVW5rbm93bkVycm9yYFxuICpcbiAqIEVycm9yIG1lc3NhZ2VzIHdlcmUgZGV0ZXJtaW5lZCB0aHJvdWdoIGludmVzdGlnYXRpb24gb2YgdGhlIHNwZWMgdG8gZGV0ZXJtaW5lIHVuZGVyIHdoaWNoXG4gKiBzY2VuYXJpb3MgYSBnaXZlbiBlcnJvciB3b3VsZCBiZSByYWlzZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJBdXRobkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSwgY29kZSwgY2F1c2UsIG5hbWUsIH0pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBAdHMtaWdub3JlOiBoZWxwIFJvbGx1cCB1bmRlcnN0YW5kIHRoYXQgYGNhdXNlYCBpcyBva2F5IHRvIHNldFxuICAgICAgICBzdXBlcihtZXNzYWdlLCB7IGNhdXNlIH0pO1xuICAgICAgICB0aGlzLl9faXNXZWJBdXRobkVycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gKF9hID0gbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogKGNhdXNlIGluc3RhbmNlb2YgRXJyb3IgPyBjYXVzZS5uYW1lIDogdW5kZWZpbmVkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ1Vua25vd24gRXJyb3InO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIH1cbn1cbi8qKlxuICogRXJyb3IgY2xhc3MgZm9yIHVua25vd24gV2ViQXV0aG4gZXJyb3JzLlxuICogV3JhcHMgdW5leHBlY3RlZCBlcnJvcnMgdGhhdCBkb24ndCBtYXRjaCBrbm93biBXZWJBdXRobiBlcnJvciBjb25kaXRpb25zLlxuICovXG5leHBvcnQgY2xhc3MgV2ViQXV0aG5Vbmtub3duRXJyb3IgZXh0ZW5kcyBXZWJBdXRobkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9QQVNTVEhST1VHSF9TRUVfQ0FVU0VfUFJPUEVSVFknLFxuICAgICAgICAgICAgY2F1c2U6IG9yaWdpbmFsRXJyb3IsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dlYkF1dGhuVW5rbm93bkVycm9yJztcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcbiAgICB9XG59XG4vKipcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYW4gZXJyb3IgaXMgYSBXZWJBdXRobkVycm9yLlxuICogQHBhcmFtIHt1bmtub3dufSBlcnJvciAtIFRoZSBlcnJvciB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIGVycm9yIGlzIGEgV2ViQXV0aG5FcnJvclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNXZWJBdXRobkVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgJ19faXNXZWJBdXRobkVycm9yJyBpbiBlcnJvcjtcbn1cbi8qKlxuICogQXR0ZW1wdCB0byBpbnR1aXQgX3doeV8gYW4gZXJyb3Igd2FzIHJhaXNlZCBhZnRlciBjYWxsaW5nIGBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKClgLlxuICogTWFwcyBicm93c2VyIGVycm9ycyB0byBzcGVjaWZpYyBXZWJBdXRobiBlcnJvciBjb2RlcyBmb3IgYmV0dGVyIGRlYnVnZ2luZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBFcnJvciBpZGVudGlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0Vycm9yfSBwYXJhbXMuZXJyb3IgLSBUaGUgZXJyb3IgdGhyb3duIGJ5IHRoZSBicm93c2VyXG4gKiBAcGFyYW0ge0NyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnN9IHBhcmFtcy5vcHRpb25zIC0gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIGNyZWRlbnRpYWxzLmNyZWF0ZSgpXG4gKiBAcmV0dXJucyB7V2ViQXV0aG5FcnJvcn0gQSBXZWJBdXRobkVycm9yIHdpdGggYSBzcGVjaWZpYyBlcnJvciBjb2RlXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCBXM0MgV2ViQXV0aG4gU3BlYyAtIENyZWF0ZSBDcmVkZW50aWFsfVxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvcih7IGVycm9yLCBvcHRpb25zLCB9KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgeyBwdWJsaWNLZXkgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFwdWJsaWNLZXkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ29wdGlvbnMgd2FzIG1pc3NpbmcgcmVxdWlyZWQgcHVibGljS2V5IHByb3BlcnR5Jyk7XG4gICAgfVxuICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2lnbmFsIGluc3RhbmNlb2YgQWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgMTYpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdSZWdpc3RyYXRpb24gY2VyZW1vbnkgd2FzIHNlbnQgYW4gYWJvcnQgc2lnbmFsJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQ0VSRU1PTllfQUJPUlRFRCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ0NvbnN0cmFpbnRFcnJvcicpIHtcbiAgICAgICAgaWYgKCgoX2EgPSBwdWJsaWNLZXkuYXV0aGVudGljYXRvclNlbGVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcXVpcmVSZXNpZGVudEtleSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCA0KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnRGlzY292ZXJhYmxlIGNyZWRlbnRpYWxzIHdlcmUgcmVxdWlyZWQgYnV0IG5vIGF2YWlsYWJsZSBhdXRoZW50aWNhdG9yIHN1cHBvcnRlZCBpdCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfTUlTU0lOR19ESVNDT1ZFUkFCTEVfQ1JFREVOVElBTF9TVVBQT1JUJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcbiAgICAgICAgLy8gQHRzLWlnbm9yZTogYG1lZGlhdGlvbmAgZG9lc24ndCB5ZXQgZXhpc3Qgb24gQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyBidXQgaXQncyBwb3NzaWJsZSBhcyBvZiBTZXB0IDIwMjRcbiAgICAgICAgb3B0aW9ucy5tZWRpYXRpb24gPT09ICdjb25kaXRpb25hbCcgJiZcbiAgICAgICAgICAgICgoX2IgPSBwdWJsaWNLZXkuYXV0aGVudGljYXRvclNlbGVjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVzZXJWZXJpZmljYXRpb24pID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCAyMi40KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVXNlciB2ZXJpZmljYXRpb24gd2FzIHJlcXVpcmVkIGR1cmluZyBhdXRvbWF0aWMgcmVnaXN0cmF0aW9uIGJ1dCBpdCBjb3VsZCBub3QgYmUgcGVyZm9ybWVkJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUT19SRUdJU1RFUl9VU0VSX1ZFUklGSUNBVElPTl9GQUlMVVJFJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKF9jID0gcHVibGljS2V5LmF1dGhlbnRpY2F0b3JTZWxlY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy51c2VyVmVyaWZpY2F0aW9uKSA9PT0gJ3JlcXVpcmVkJykge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtbWFrZS1jcmVkIChTdGVwIDUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdVc2VyIHZlcmlmaWNhdGlvbiB3YXMgcmVxdWlyZWQgYnV0IG5vIGF2YWlsYWJsZSBhdXRoZW50aWNhdG9yIHN1cHBvcnRlZCBpdCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfTUlTU0lOR19VU0VSX1ZFUklGSUNBVElPTl9TVVBQT1JUJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnSW52YWxpZFN0YXRlRXJyb3InKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgMjApXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCAzKVxuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ1RoZSBhdXRoZW50aWNhdG9yIHdhcyBwcmV2aW91c2x5IHJlZ2lzdGVyZWQnLFxuICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfUFJFVklPVVNMWV9SRUdJU1RFUkVEJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXNzIHRoZSBlcnJvciBkaXJlY3RseSB0aHJvdWdoLiBQbGF0Zm9ybXMgYXJlIG92ZXJsb2FkaW5nIHRoaXMgZXJyb3IgYmV5b25kIHdoYXQgdGhlIHNwZWNcbiAgICAgICAgICogZGVmaW5lcyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgcG90ZW50aWFsbHkgdXNlZnVsIGVycm9yIG1lc3NhZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfUEFTU1RIUk9VR0hfU0VFX0NBVVNFX1BST1BFUlRZJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RTdXBwb3J0ZWRFcnJvcicpIHtcbiAgICAgICAgY29uc3QgdmFsaWRQdWJLZXlDcmVkUGFyYW1zID0gcHVibGljS2V5LnB1YktleUNyZWRQYXJhbXMuZmlsdGVyKChwYXJhbSkgPT4gcGFyYW0udHlwZSA9PT0gJ3B1YmxpYy1rZXknKTtcbiAgICAgICAgaWYgKHZhbGlkUHViS2V5Q3JlZFBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgMTApXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdObyBlbnRyeSBpbiBwdWJLZXlDcmVkUGFyYW1zIHdhcyBvZiB0eXBlIFwicHVibGljLWtleVwiJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfTUFMRk9STUVEX1BVQktFWUNSRURQQVJBTVMnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCAyKVxuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogJ05vIGF2YWlsYWJsZSBhdXRoZW50aWNhdG9yIHN1cHBvcnRlZCBhbnkgb2YgdGhlIHNwZWNpZmllZCBwdWJLZXlDcmVkUGFyYW1zIGFsZ29yaXRobXMnLFxuICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfTk9fU1VQUE9SVEVEX1BVQktFWUNSRURQQVJBTVNfQUxHJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdTZWN1cml0eUVycm9yJykge1xuICAgICAgICBjb25zdCBlZmZlY3RpdmVEb21haW4gPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gICAgICAgIGlmICghaXNWYWxpZERvbWFpbihlZmZlY3RpdmVEb21haW4pKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDcpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZX0gaXMgYW4gaW52YWxpZCBkb21haW5gLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX0RPTUFJTicsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHVibGljS2V5LnJwLmlkICE9PSBlZmZlY3RpdmVEb21haW4pIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgOClcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFRoZSBSUCBJRCBcIiR7cHVibGljS2V5LnJwLmlkfVwiIGlzIGludmFsaWQgZm9yIHRoaXMgZG9tYWluYCxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfSU5WQUxJRF9SUF9JRCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1R5cGVFcnJvcicpIHtcbiAgICAgICAgaWYgKHB1YmxpY0tleS51c2VyLmlkLmJ5dGVMZW5ndGggPCAxIHx8IHB1YmxpY0tleS51c2VyLmlkLmJ5dGVMZW5ndGggPiA2NCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCA1KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVXNlciBJRCB3YXMgbm90IGJldHdlZW4gMSBhbmQgNjQgY2hhcmFjdGVycycsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0lOVkFMSURfVVNFUl9JRF9MRU5HVEgnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdVbmtub3duRXJyb3InKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLW1ha2UtY3JlZCAoU3RlcCAxKVxuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1tYWtlLWNyZWQgKFN0ZXAgOClcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdUaGUgYXV0aGVudGljYXRvciB3YXMgdW5hYmxlIHRvIHByb2Nlc3MgdGhlIHNwZWNpZmllZCBvcHRpb25zLCBvciBjb3VsZCBub3QgY3JlYXRlIGEgbmV3IGNyZWRlbnRpYWwnLFxuICAgICAgICAgICAgY29kZTogJ0VSUk9SX0FVVEhFTlRJQ0FUT1JfR0VORVJBTF9FUlJPUicsXG4gICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiAnYSBOb24tV2ViYXV0aG4gcmVsYXRlZCBlcnJvciBoYXMgb2NjdXJyZWQnLFxuICAgICAgICBjb2RlOiAnRVJST1JfUEFTU1RIUk9VR0hfU0VFX0NBVVNFX1BST1BFUlRZJyxcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgIH0pO1xufVxuLyoqXG4gKiBBdHRlbXB0IHRvIGludHVpdCBfd2h5XyBhbiBlcnJvciB3YXMgcmFpc2VkIGFmdGVyIGNhbGxpbmcgYG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKWAuXG4gKiBNYXBzIGJyb3dzZXIgZXJyb3JzIHRvIHNwZWNpZmljIFdlYkF1dGhuIGVycm9yIGNvZGVzIGZvciBiZXR0ZXIgZGVidWdnaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIEVycm9yIGlkZW50aWZpY2F0aW9uIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7RXJyb3J9IHBhcmFtcy5lcnJvciAtIFRoZSBlcnJvciB0aHJvd24gYnkgdGhlIGJyb3dzZXJcbiAqIEBwYXJhbSB7Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zfSBwYXJhbXMub3B0aW9ucyAtIFRoZSBvcHRpb25zIHBhc3NlZCB0byBjcmVkZW50aWFscy5nZXQoKVxuICogQHJldHVybnMge1dlYkF1dGhuRXJyb3J9IEEgV2ViQXV0aG5FcnJvciB3aXRoIGEgc3BlY2lmaWMgZXJyb3IgY29kZVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLWdldEFzc2VydGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIEdldCBBc3NlcnRpb259XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IoeyBlcnJvciwgb3B0aW9ucywgfSkge1xuICAgIGNvbnN0IHsgcHVibGljS2V5IH0gPSBvcHRpb25zO1xuICAgIGlmICghcHVibGljS2V5KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdvcHRpb25zIHdhcyBtaXNzaW5nIHJlcXVpcmVkIHB1YmxpY0tleSBwcm9wZXJ0eScpO1xuICAgIH1cbiAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hbCBpbnN0YW5jZW9mIEFib3J0U2lnbmFsKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDE2KVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnQXV0aGVudGljYXRpb24gY2VyZW1vbnkgd2FzIHNlbnQgYW4gYWJvcnQgc2lnbmFsJyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQ0VSRU1PTllfQUJPUlRFRCcsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhc3MgdGhlIGVycm9yIGRpcmVjdGx5IHRocm91Z2guIFBsYXRmb3JtcyBhcmUgb3ZlcmxvYWRpbmcgdGhpcyBlcnJvciBiZXlvbmQgd2hhdCB0aGUgc3BlY1xuICAgICAgICAgKiBkZWZpbmVzIGFuZCB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSBwb3RlbnRpYWxseSB1c2VmdWwgZXJyb3IgbWVzc2FnZXMuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9QQVNTVEhST1VHSF9TRUVfQ0FVU0VfUFJPUEVSVFknLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1NlY3VyaXR5RXJyb3InKSB7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZURvbWFpbiA9IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkRG9tYWluKGVmZmVjdGl2ZURvbWFpbikpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWRpc2NvdmVyLWZyb20tZXh0ZXJuYWwtc291cmNlIChTdGVwIDUpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke3dpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZX0gaXMgYW4gaW52YWxpZCBkb21haW5gLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX0RPTUFJTicsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHVibGljS2V5LnJwSWQgIT09IGVmZmVjdGl2ZURvbWFpbikge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tZGlzY292ZXItZnJvbS1leHRlcm5hbC1zb3VyY2UgKFN0ZXAgNilcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFRoZSBSUCBJRCBcIiR7cHVibGljS2V5LnJwSWR9XCIgaXMgaW52YWxpZCBmb3IgdGhpcyBkb21haW5gLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX1JQX0lEJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnVW5rbm93bkVycm9yJykge1xuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1nZXQtYXNzZXJ0aW9uIChTdGVwIDEpXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLWdldC1hc3NlcnRpb24gKFN0ZXAgMTIpXG4gICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnVGhlIGF1dGhlbnRpY2F0b3Igd2FzIHVuYWJsZSB0byBwcm9jZXNzIHRoZSBzcGVjaWZpZWQgb3B0aW9ucywgb3IgY291bGQgbm90IGNyZWF0ZSBhIG5ldyBhc3NlcnRpb24gc2lnbmF0dXJlJyxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX0dFTkVSQUxfRVJST1InLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogJ2EgTm9uLVdlYmF1dGhuIHJlbGF0ZWQgZXJyb3IgaGFzIG9jY3VycmVkJyxcbiAgICAgICAgY29kZTogJ0VSUk9SX1BBU1NUSFJPVUdIX1NFRV9DQVVTRV9QUk9QRVJUWScsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYmF1dGhuLmVycm9ycy5qcy5tYXAiXSwibmFtZXMiOlsiaXNWYWxpZERvbWFpbiIsIldlYkF1dGhuRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImNvZGUiLCJjYXVzZSIsIm5hbWUiLCJfYSIsIl9faXNXZWJBdXRobkVycm9yIiwidW5kZWZpbmVkIiwiV2ViQXV0aG5Vbmtub3duRXJyb3IiLCJvcmlnaW5hbEVycm9yIiwiaXNXZWJBdXRobkVycm9yIiwiZXJyb3IiLCJpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yIiwib3B0aW9ucyIsIl9iIiwiX2MiLCJwdWJsaWNLZXkiLCJzaWduYWwiLCJBYm9ydFNpZ25hbCIsImF1dGhlbnRpY2F0b3JTZWxlY3Rpb24iLCJyZXF1aXJlUmVzaWRlbnRLZXkiLCJtZWRpYXRpb24iLCJ1c2VyVmVyaWZpY2F0aW9uIiwidmFsaWRQdWJLZXlDcmVkUGFyYW1zIiwicHViS2V5Q3JlZFBhcmFtcyIsImZpbHRlciIsInBhcmFtIiwidHlwZSIsImxlbmd0aCIsImVmZmVjdGl2ZURvbWFpbiIsIndpbmRvdyIsImxvY2F0aW9uIiwiaG9zdG5hbWUiLCJycCIsImlkIiwidXNlciIsImJ5dGVMZW5ndGgiLCJpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IiLCJycElkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_CREATION_OPTIONS: () => (/* binding */ DEFAULT_CREATION_OPTIONS),\n/* harmony export */   DEFAULT_REQUEST_OPTIONS: () => (/* binding */ DEFAULT_REQUEST_OPTIONS),\n/* harmony export */   WebAuthnAbortService: () => (/* binding */ WebAuthnAbortService),\n/* harmony export */   WebAuthnApi: () => (/* binding */ WebAuthnApi),\n/* harmony export */   WebAuthnError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnError),\n/* harmony export */   createCredential: () => (/* binding */ createCredential),\n/* harmony export */   deserializeCredentialCreationOptions: () => (/* binding */ deserializeCredentialCreationOptions),\n/* harmony export */   deserializeCredentialRequestOptions: () => (/* binding */ deserializeCredentialRequestOptions),\n/* harmony export */   getCredential: () => (/* binding */ getCredential),\n/* harmony export */   identifyAuthenticationError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyAuthenticationError),\n/* harmony export */   identifyRegistrationError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyRegistrationError),\n/* harmony export */   isValidDomain: () => (/* binding */ isValidDomain),\n/* harmony export */   isWebAuthnError: () => (/* reexport safe */ _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.isWebAuthnError),\n/* harmony export */   mergeCredentialCreationOptions: () => (/* binding */ mergeCredentialCreationOptions),\n/* harmony export */   mergeCredentialRequestOptions: () => (/* binding */ mergeCredentialRequestOptions),\n/* harmony export */   serializeCredentialCreationResponse: () => (/* binding */ serializeCredentialCreationResponse),\n/* harmony export */   serializeCredentialRequestResponse: () => (/* binding */ serializeCredentialRequestResponse),\n/* harmony export */   webAuthnAbortService: () => (/* binding */ webAuthnAbortService)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _base64url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64url */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/base64url.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/errors.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webauthn.errors */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.errors.js\");\n\n\n\n\n\n\n/**\n * WebAuthn abort service to manage ceremony cancellation.\n * Ensures only one WebAuthn ceremony is active at a time to prevent \"operation already in progress\" errors.\n *\n * @experimental This class is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/#sctn-automation-webdriver-capability W3C WebAuthn Spec - Aborting Ceremonies}\n */ class WebAuthnAbortService {\n    /**\n     * Create an abort signal for a new WebAuthn operation.\n     * Automatically cancels any existing operation.\n     *\n     * @returns {AbortSignal} Signal to pass to navigator.credentials.create() or .get()\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal MDN - AbortSignal}\n     */ createNewAbortSignal() {\n        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()\n        if (this.controller) {\n            const abortError = new Error(\"Cancelling existing WebAuthn API call for new one\");\n            abortError.name = \"AbortError\";\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    /**\n     * Manually cancel the current WebAuthn operation.\n     * Useful for cleaning up when user cancels or navigates away.\n     *\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort MDN - AbortController.abort}\n     */ cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error(\"Manually cancelling existing WebAuthn API call\");\n            abortError.name = \"AbortError\";\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\n/**\n * Singleton instance to ensure only one WebAuthn ceremony is active at a time.\n * This prevents \"operation already in progress\" errors when retrying WebAuthn operations.\n *\n * @experimental This instance is experimental and may change in future releases\n */ const webAuthnAbortService = new WebAuthnAbortService();\n/**\n * Convert base64url encoded strings in WebAuthn credential creation options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseCreationOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialCreationOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialCreationOptionsFuture} Options ready for navigator.credentials.create()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseCreationOptionsFromJSON W3C WebAuthn Spec - parseCreationOptionsFromJSON}\n */ function deserializeCredentialCreationOptions(options) {\n    if (!options) {\n        throw new Error(\"Credential creation options are required\");\n    }\n    // Check if the native parseCreationOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== \"undefined\" && \"parseCreationOptionsFromJSON\" in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseCreationOptionsFromJSON(/** we assert the options here as typescript still doesn't know about future webauthn types */ options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, user: userOpts, excludeCredentials } = options, restOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(options, [\n        \"challenge\",\n        \"user\",\n        \"excludeCredentials\"\n    ]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(challengeStr).buffer;\n    // Convert user.id from base64url to ArrayBuffer\n    const user = Object.assign(Object.assign({}, userOpts), {\n        id: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(userOpts.id).buffer\n    });\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), {\n        challenge,\n        user\n    });\n    // Only add excludeCredentials if it exists\n    if (excludeCredentials && excludeCredentials.length > 0) {\n        result.excludeCredentials = new Array(excludeCredentials.length);\n        for(let i = 0; i < excludeCredentials.length; i++){\n            const cred = excludeCredentials[i];\n            result.excludeCredentials[i] = Object.assign(Object.assign({}, cred), {\n                id: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(cred.id).buffer,\n                type: cred.type || \"public-key\",\n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports\n            });\n        }\n    }\n    return result;\n}\n/**\n * Convert base64url encoded strings in WebAuthn credential request options to ArrayBuffers\n * as required by the WebAuthn browser API.\n * Supports both native WebAuthn Level 3 parseRequestOptionsFromJSON and manual fallback.\n *\n * @param {ServerCredentialRequestOptions} options - JSON options from server with base64url encoded fields\n * @returns {PublicKeyCredentialRequestOptionsFuture} Options ready for navigator.credentials.get()\n * @see {@link https://w3c.github.io/webauthn/#sctn-parseRequestOptionsFromJSON W3C WebAuthn Spec - parseRequestOptionsFromJSON}\n */ function deserializeCredentialRequestOptions(options) {\n    if (!options) {\n        throw new Error(\"Credential request options are required\");\n    }\n    // Check if the native parseRequestOptionsFromJSON method is available\n    if (typeof PublicKeyCredential !== \"undefined\" && \"parseRequestOptionsFromJSON\" in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return PublicKeyCredential.parseRequestOptionsFromJSON(options);\n    }\n    // Fallback to manual parsing for browsers that don't support the native method\n    // Destructure to separate fields that need transformation\n    const { challenge: challengeStr, allowCredentials } = options, restOptions = (0,tslib__WEBPACK_IMPORTED_MODULE_4__.__rest)(options, [\n        \"challenge\",\n        \"allowCredentials\"\n    ]);\n    // Convert challenge from base64url to ArrayBuffer\n    const challenge = (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(challengeStr).buffer;\n    // Build the result object\n    const result = Object.assign(Object.assign({}, restOptions), {\n        challenge\n    });\n    // Only add allowCredentials if it exists\n    if (allowCredentials && allowCredentials.length > 0) {\n        result.allowCredentials = new Array(allowCredentials.length);\n        for(let i = 0; i < allowCredentials.length; i++){\n            const cred = allowCredentials[i];\n            result.allowCredentials[i] = Object.assign(Object.assign({}, cred), {\n                id: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.base64UrlToUint8Array)(cred.id).buffer,\n                type: cred.type || \"public-key\",\n                // Cast transports to handle future transport types like \"cable\"\n                transports: cred.transports\n            });\n        }\n    }\n    return result;\n}\n/**\n * Convert a registration/enrollment credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {RegistrationCredential} credential - Credential from navigator.credentials.create()\n * @returns {RegistrationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */ function serializeCredentialCreationResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if (\"toJSON\" in credential && typeof credential.toJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    const credentialWithAttachment = credential;\n    return {\n        id: credential.id,\n        rawId: credential.id,\n        response: {\n            attestationObject: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(credential.response.attestationObject)),\n            clientDataJSON: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(credential.response.clientDataJSON))\n        },\n        type: \"public-key\",\n        clientExtensionResults: credential.getClientExtensionResults(),\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n    };\n}\n/**\n * Convert an authentication/verification credential response to server format.\n * Serializes binary fields to base64url for JSON transmission.\n * Supports both native WebAuthn Level 3 toJSON and manual fallback.\n *\n * @param {AuthenticationCredential} credential - Credential from navigator.credentials.get()\n * @returns {AuthenticationResponseJSON} JSON-serializable credential for server\n * @see {@link https://w3c.github.io/webauthn/#dom-publickeycredential-tojson W3C WebAuthn Spec - toJSON}\n */ function serializeCredentialRequestResponse(credential) {\n    var _a;\n    // Check if the credential instance has the toJSON method\n    if (\"toJSON\" in credential && typeof credential.toJSON === \"function\") {\n        // Use the native WebAuthn Level 3 method\n        return credential.toJSON();\n    }\n    // Fallback to manual conversion for browsers that don't support toJSON\n    // Access authenticatorAttachment via type assertion to handle TypeScript version differences\n    // @simplewebauthn/types includes this property but base TypeScript 4.7.4 doesn't\n    const credentialWithAttachment = credential;\n    const clientExtensionResults = credential.getClientExtensionResults();\n    const assertionResponse = credential.response;\n    return {\n        id: credential.id,\n        rawId: credential.id,\n        response: {\n            authenticatorData: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.authenticatorData)),\n            clientDataJSON: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.clientDataJSON)),\n            signature: (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.signature)),\n            userHandle: assertionResponse.userHandle ? (0,_base64url__WEBPACK_IMPORTED_MODULE_0__.bytesToBase64URL)(new Uint8Array(assertionResponse.userHandle)) : undefined\n        },\n        type: \"public-key\",\n        clientExtensionResults,\n        // Convert null to undefined and cast to AuthenticatorAttachment type\n        authenticatorAttachment: (_a = credentialWithAttachment.authenticatorAttachment) !== null && _a !== void 0 ? _a : undefined\n    };\n}\n/**\n * A simple test to determine if a hostname is a properly-formatted domain name.\n * Considers localhost valid for development environments.\n *\n * A \"valid domain\" is defined here: https://url.spec.whatwg.org/#valid-domain\n *\n * Regex sourced from here:\n * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html\n *\n * @param {string} hostname - The hostname to validate\n * @returns {boolean} True if valid domain or localhost\n * @see {@link https://url.spec.whatwg.org/#valid-domain WHATWG URL Spec - Valid Domain}\n */ function isValidDomain(hostname) {\n    return(// Consider localhost valid as well since it's okay wrt Secure Contexts\n    hostname === \"localhost\" || /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n/**\n * Determine if the browser is capable of WebAuthn.\n * Checks for necessary Web APIs: PublicKeyCredential and Credential Management.\n *\n * @returns {boolean} True if browser supports WebAuthn\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential#browser_compatibility MDN - PublicKeyCredential Browser Compatibility}\n */ function browserSupportsWebAuthn() {\n    var _a, _b;\n    return !!((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isBrowser)() && \"PublicKeyCredential\" in window && window.PublicKeyCredential && \"credentials\" in navigator && typeof ((_a = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _a === void 0 ? void 0 : _a.create) === \"function\" && typeof ((_b = navigator === null || navigator === void 0 ? void 0 : navigator.credentials) === null || _b === void 0 ? void 0 : _b.get) === \"function\");\n}\n/**\n * Create a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.create() with error handling.\n *\n * @param {CredentialCreationOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<RegistrationCredential, WebAuthnError>>} Created credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-createCredential W3C WebAuthn Spec - Create Credential}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/create MDN - credentials.create}\n */ async function createCredential(options) {\n    try {\n        const response = await navigator.credentials.create(/** we assert the type here until typescript types are updated */ options);\n        if (!response) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Empty credential response\", response)\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Browser returned unexpected credential type\", response)\n            };\n        }\n        return {\n            data: response,\n            error: null\n        };\n    } catch (err) {\n        return {\n            data: null,\n            error: (0,_webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyRegistrationError)({\n                error: err,\n                options\n            })\n        };\n    }\n}\n/**\n * Get a WebAuthn credential using the browser's credentials API.\n * Wraps navigator.credentials.get() with error handling.\n *\n * @param {CredentialRequestOptions} options - Options including publicKey parameters\n * @returns {Promise<RequestResult<AuthenticationCredential, WebAuthnError>>} Retrieved credential or error\n * @see {@link https://w3c.github.io/webauthn/#sctn-getAssertion W3C WebAuthn Spec - Get Assertion}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get MDN - credentials.get}\n */ async function getCredential(options) {\n    try {\n        const response = await navigator.credentials.get(/** we assert the type here until typescript types are updated */ options);\n        if (!response) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Empty credential response\", response)\n            };\n        }\n        if (!(response instanceof PublicKeyCredential)) {\n            return {\n                data: null,\n                error: new _webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.WebAuthnUnknownError(\"Browser returned unexpected credential type\", response)\n            };\n        }\n        return {\n            data: response,\n            error: null\n        };\n    } catch (err) {\n        return {\n            data: null,\n            error: (0,_webauthn_errors__WEBPACK_IMPORTED_MODULE_3__.identifyAuthenticationError)({\n                error: err,\n                options\n            })\n        };\n    }\n}\nconst DEFAULT_CREATION_OPTIONS = {\n    hints: [\n        \"security-key\"\n    ],\n    authenticatorSelection: {\n        authenticatorAttachment: \"cross-platform\",\n        requireResidentKey: false,\n        /** set to preferred because older yubikeys don't have PIN/Biometric */ userVerification: \"preferred\",\n        residentKey: \"discouraged\"\n    },\n    attestation: \"none\"\n};\nconst DEFAULT_REQUEST_OPTIONS = {\n    /** set to preferred because older yubikeys don't have PIN/Biometric */ userVerification: \"preferred\",\n    hints: [\n        \"security-key\"\n    ]\n};\nfunction deepMerge(...sources) {\n    const isObject = (val)=>val !== null && typeof val === \"object\" && !Array.isArray(val);\n    const isArrayBufferLike = (val)=>val instanceof ArrayBuffer || ArrayBuffer.isView(val);\n    const result = {};\n    for (const source of sources){\n        if (!source) continue;\n        for(const key in source){\n            const value = source[key];\n            if (value === undefined) continue;\n            if (Array.isArray(value)) {\n                // preserve array reference, including unions like AuthenticatorTransport[]\n                result[key] = value;\n            } else if (isArrayBufferLike(value)) {\n                result[key] = value;\n            } else if (isObject(value)) {\n                const existing = result[key];\n                if (isObject(existing)) {\n                    result[key] = deepMerge(existing, value);\n                } else {\n                    result[key] = deepMerge(value);\n                }\n            } else {\n                result[key] = value;\n            }\n        }\n    }\n    return result;\n}\n/**\n * Merges WebAuthn credential creation options with overrides.\n * Sets sensible defaults for authenticator selection and extensions.\n *\n * @param {PublicKeyCredentialCreationOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Optional overrides to apply\n * @param {string} friendlyName - Optional friendly name for the credential\n * @returns {PublicKeyCredentialCreationOptionsFuture} Merged credential creation options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-authenticatorselectioncriteria W3C WebAuthn Spec - AuthenticatorSelectionCriteria}\n */ function mergeCredentialCreationOptions(baseOptions, overrides) {\n    return deepMerge(DEFAULT_CREATION_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * Merges WebAuthn credential request options with overrides.\n * Sets sensible defaults for user verification and hints.\n *\n * @param {PublicKeyCredentialRequestOptionsFuture} baseOptions - The base options from the server\n * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Optional overrides to apply\n * @returns {PublicKeyCredentialRequestOptionsFuture} Merged credential request options\n * @see {@link https://w3c.github.io/webauthn/#dictdef-publickeycredentialrequestoptions W3C WebAuthn Spec - PublicKeyCredentialRequestOptions}\n */ function mergeCredentialRequestOptions(baseOptions, overrides) {\n    return deepMerge(DEFAULT_REQUEST_OPTIONS, baseOptions, overrides || {});\n}\n/**\n * WebAuthn API wrapper for Supabase Auth.\n * Provides methods for enrolling, challenging, verifying, authenticating, and registering WebAuthn credentials.\n *\n * @experimental This API is experimental and may change in future releases\n * @see {@link https://w3c.github.io/webauthn/ W3C WebAuthn Specification}\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API MDN - Web Authentication API}\n */ class WebAuthnApi {\n    constructor(client){\n        this.client = client;\n        // Bind all methods so they can be destructured\n        this.enroll = this._enroll.bind(this);\n        this.challenge = this._challenge.bind(this);\n        this.verify = this._verify.bind(this);\n        this.authenticate = this._authenticate.bind(this);\n        this.register = this._register.bind(this);\n    }\n    /**\n     * Enroll a new WebAuthn factor.\n     * Creates an unverified WebAuthn factor that must be verified with a credential.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Omit<MFAEnrollWebauthnParams, 'factorType'>} params - Enrollment parameters (friendlyName required)\n     * @returns {Promise<AuthMFAEnrollWebauthnResponse>} Enrolled factor details or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\n     */ async _enroll(params) {\n        return this.client.mfa.enroll(Object.assign(Object.assign({}, params), {\n            factorType: \"webauthn\"\n        }));\n    }\n    /**\n     * Challenge for WebAuthn credential creation or authentication.\n     * Combines server challenge with browser credential operations.\n     * Handles both registration (create) and authentication (request) flows.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {MFAChallengeWebauthnParams & { friendlyName?: string; signal?: AbortSignal }} params - Challenge parameters including factorId\n     * @param {Object} overrides - Allows you to override the parameters passed to navigator.credentials\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides.create - Override options for credential creation\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides.request - Override options for credential request\n     * @returns {Promise<RequestResult>} Challenge response with credential or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying Assertion}\n     */ async _challenge({ factorId, webauthn, friendlyName, signal }, overrides) {\n        try {\n            // Get challenge from server using the client's MFA methods\n            const { data: challengeResponse, error: challengeError } = await this.client.mfa.challenge({\n                factorId,\n                webauthn\n            });\n            if (!challengeResponse) {\n                return {\n                    data: null,\n                    error: challengeError\n                };\n            }\n            const abortSignal = signal !== null && signal !== void 0 ? signal : webAuthnAbortService.createNewAbortSignal();\n            /** webauthn will fail if either of the name/displayname are blank */ if (challengeResponse.webauthn.type === \"create\") {\n                const { user } = challengeResponse.webauthn.credential_options.publicKey;\n                if (!user.name) {\n                    user.name = `${user.id}:${friendlyName}`;\n                }\n                if (!user.displayName) {\n                    user.displayName = user.name;\n                }\n            }\n            switch(challengeResponse.webauthn.type){\n                case \"create\":\n                    {\n                        const options = mergeCredentialCreationOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.create);\n                        const { data, error } = await createCredential({\n                            publicKey: options,\n                            signal: abortSignal\n                        });\n                        if (data) {\n                            return {\n                                data: {\n                                    factorId,\n                                    challengeId: challengeResponse.id,\n                                    webauthn: {\n                                        type: challengeResponse.webauthn.type,\n                                        credential_response: data\n                                    }\n                                },\n                                error: null\n                            };\n                        }\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n                case \"request\":\n                    {\n                        const options = mergeCredentialRequestOptions(challengeResponse.webauthn.credential_options.publicKey, overrides === null || overrides === void 0 ? void 0 : overrides.request);\n                        const { data, error } = await getCredential(Object.assign(Object.assign({}, challengeResponse.webauthn.credential_options), {\n                            publicKey: options,\n                            signal: abortSignal\n                        }));\n                        if (data) {\n                            return {\n                                data: {\n                                    factorId,\n                                    challengeId: challengeResponse.id,\n                                    webauthn: {\n                                        type: challengeResponse.webauthn.type,\n                                        credential_response: data\n                                    }\n                                },\n                                error: null\n                            };\n                        }\n                        return {\n                            data: null,\n                            error\n                        };\n                    }\n            }\n        } catch (error) {\n            if ((0,_errors__WEBPACK_IMPORTED_MODULE_1__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Unexpected error in challenge\", error)\n            };\n        }\n    }\n    /**\n     * Verify a WebAuthn credential with the server.\n     * Completes the WebAuthn ceremony by sending the credential to the server for verification.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Verification parameters\n     * @param {string} params.challengeId - ID of the challenge being verified\n     * @param {string} params.factorId - ID of the WebAuthn factor\n     * @param {MFAVerifyWebauthnParams<T>['webauthn']} params.webauthn - WebAuthn credential response\n     * @returns {Promise<AuthMFAVerifyResponse>} Verification result with session or error\n     * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\n     * */ async _verify({ challengeId, factorId, webauthn }) {\n        return this.client.mfa.verify({\n            factorId,\n            challengeId,\n            webauthn: webauthn\n        });\n    }\n    /**\n     * Complete WebAuthn authentication flow.\n     * Performs challenge and verification in a single operation for existing credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Authentication parameters\n     * @param {string} params.factorId - ID of the WebAuthn factor to authenticate with\n     * @param {Object} params.webauthn - WebAuthn configuration\n     * @param {string} params.webauthn.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.webauthn.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.webauthn.signal - Optional abort signal\n     * @param {PublicKeyCredentialRequestOptionsFuture} overrides - Override options for navigator.credentials.get\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Authentication result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-authentication W3C WebAuthn Spec - Authentication Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialRequestOptions MDN - PublicKeyCredentialRequestOptions}\n     */ async _authenticate({ factorId, webauthn: { rpId =  false ? 0 : undefined, rpOrigins =  false ? 0 : undefined, signal } }, overrides) {\n        if (!rpId) {\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthError(\"rpId is required for WebAuthn authentication\")\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Browser does not support WebAuthn\", null)\n                };\n            }\n            // Get challenge and credential\n            const { data: challengeResponse, error: challengeError } = await this.challenge({\n                factorId,\n                webauthn: {\n                    rpId,\n                    rpOrigins\n                },\n                signal\n            }, {\n                request: overrides\n            });\n            if (!challengeResponse) {\n                return {\n                    data: null,\n                    error: challengeError\n                };\n            }\n            const { webauthn } = challengeResponse;\n            // Verify credential\n            return this._verify({\n                factorId,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    type: webauthn.type,\n                    rpId,\n                    rpOrigins,\n                    credential_response: webauthn.credential_response\n                }\n            });\n        } catch (error) {\n            if ((0,_errors__WEBPACK_IMPORTED_MODULE_1__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Unexpected error in authenticate\", error)\n            };\n        }\n    }\n    /**\n     * Complete WebAuthn registration flow.\n     * Performs enrollment, challenge, and verification in a single operation for new credentials.\n     *\n     * @experimental This method is experimental and may change in future releases\n     * @param {Object} params - Registration parameters\n     * @param {string} params.friendlyName - User-friendly name for the credential\n     * @param {string} params.rpId - Relying Party ID (defaults to current hostname)\n     * @param {string[]} params.rpOrigins - Allowed origins (defaults to current origin)\n     * @param {AbortSignal} params.signal - Optional abort signal\n     * @param {PublicKeyCredentialCreationOptionsFuture} overrides - Override options for navigator.credentials.create\n     * @returns {Promise<RequestResult<AuthMFAVerifyResponseData, WebAuthnError | AuthError>>} Registration result\n     * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registration Ceremony}\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions MDN - PublicKeyCredentialCreationOptions}\n     */ async _register({ friendlyName, rpId =  false ? 0 : undefined, rpOrigins =  false ? 0 : undefined, signal }, overrides) {\n        if (!rpId) {\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthError(\"rpId is required for WebAuthn registration\")\n            };\n        }\n        try {\n            if (!browserSupportsWebAuthn()) {\n                return {\n                    data: null,\n                    error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Browser does not support WebAuthn\", null)\n                };\n            }\n            // Enroll factor\n            const { data: factor, error: enrollError } = await this._enroll({\n                friendlyName\n            });\n            if (!factor) {\n                await this.client.mfa.listFactors().then((factors)=>{\n                    var _a;\n                    return (_a = factors.data) === null || _a === void 0 ? void 0 : _a.all.find((v)=>v.factor_type === \"webauthn\" && v.friendly_name === friendlyName && v.status !== \"unverified\");\n                }).then((factor)=>factor ? this.client.mfa.unenroll({\n                        factorId: factor === null || factor === void 0 ? void 0 : factor.id\n                    }) : void 0);\n                return {\n                    data: null,\n                    error: enrollError\n                };\n            }\n            // Get challenge and create credential\n            const { data: challengeResponse, error: challengeError } = await this._challenge({\n                factorId: factor.id,\n                friendlyName: factor.friendly_name,\n                webauthn: {\n                    rpId,\n                    rpOrigins\n                },\n                signal\n            }, {\n                create: overrides\n            });\n            if (!challengeResponse) {\n                return {\n                    data: null,\n                    error: challengeError\n                };\n            }\n            return this._verify({\n                factorId: factor.id,\n                challengeId: challengeResponse.challengeId,\n                webauthn: {\n                    rpId,\n                    rpOrigins,\n                    type: challengeResponse.webauthn.type,\n                    credential_response: challengeResponse.webauthn.credential_response\n                }\n            });\n        } catch (error) {\n            if ((0,_errors__WEBPACK_IMPORTED_MODULE_1__.isAuthError)(error)) {\n                return {\n                    data: null,\n                    error\n                };\n            }\n            return {\n                data: null,\n                error: new _errors__WEBPACK_IMPORTED_MODULE_1__.AuthUnknownError(\"Unexpected error in register\", error)\n            };\n        }\n    }\n} //# sourceMappingURL=webauthn.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtanMvZGlzdC9tb2R1bGUvbGliL3dlYmF1dGhuLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ3VDO0FBQ0Y7QUFDOUI7QUFDNEc7QUFDaEQ7QUFDbEc7Ozs7OztDQU1DLEdBQ00sTUFBTVk7SUFDVDs7Ozs7O0tBTUMsR0FDREMsdUJBQXVCO1FBQ25CLDRGQUE0RjtRQUM1RixJQUFJLElBQUksQ0FBQ0MsVUFBVSxFQUFFO1lBQ2pCLE1BQU1DLGFBQWEsSUFBSUMsTUFBTTtZQUM3QkQsV0FBV0UsSUFBSSxHQUFHO1lBQ2xCLElBQUksQ0FBQ0gsVUFBVSxDQUFDSSxLQUFLLENBQUNIO1FBQzFCO1FBQ0EsTUFBTUksZ0JBQWdCLElBQUlDO1FBQzFCLElBQUksQ0FBQ04sVUFBVSxHQUFHSztRQUNsQixPQUFPQSxjQUFjRSxNQUFNO0lBQy9CO0lBQ0E7Ozs7O0tBS0MsR0FDREMsaUJBQWlCO1FBQ2IsSUFBSSxJQUFJLENBQUNSLFVBQVUsRUFBRTtZQUNqQixNQUFNQyxhQUFhLElBQUlDLE1BQU07WUFDN0JELFdBQVdFLElBQUksR0FBRztZQUNsQixJQUFJLENBQUNILFVBQVUsQ0FBQ0ksS0FBSyxDQUFDSDtZQUN0QixJQUFJLENBQUNELFVBQVUsR0FBR1M7UUFDdEI7SUFDSjtBQUNKO0FBQ0E7Ozs7O0NBS0MsR0FDTSxNQUFNQyx1QkFBdUIsSUFBSVosdUJBQXVCO0FBQy9EOzs7Ozs7OztDQVFDLEdBQ00sU0FBU2EscUNBQXFDQyxPQUFPO0lBQ3hELElBQUksQ0FBQ0EsU0FBUztRQUNWLE1BQU0sSUFBSVYsTUFBTTtJQUNwQjtJQUNBLHVFQUF1RTtJQUN2RSxJQUFJLE9BQU9XLHdCQUF3QixlQUMvQixrQ0FBa0NBLHVCQUNsQyxPQUFPQSxvQkFDRkMsNEJBQTRCLEtBQUssWUFBWTtRQUNsRCx5Q0FBeUM7UUFDekMsT0FBT0Qsb0JBQW9CQyw0QkFBNEIsQ0FDdkQs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TSxXQUFXO2dCQUMxQ1IsVUFBVTtvQkFDTlc7b0JBQ0FFO29CQUNBNUYsTUFBTWlGLGtCQUFrQkYsUUFBUSxDQUFDL0UsSUFBSTtvQkFDckN3RixxQkFBcUJQLGtCQUFrQkYsUUFBUSxDQUFDUyxtQkFBbUI7Z0JBQ3ZFO1lBQ0o7UUFDSixFQUNBLE9BQU9yRCxPQUFPO1lBQ1YsSUFBSTFFLG9EQUFXQSxDQUFDMEUsUUFBUTtnQkFDcEIsT0FBTztvQkFBRUQsTUFBTTtvQkFBTUM7Z0JBQU07WUFDL0I7WUFDQSxPQUFPO2dCQUNIRCxNQUFNO2dCQUNOQyxPQUFPLElBQUkzRSxxREFBZ0JBLENBQUMsZ0NBQWdDMkU7WUFDaEU7UUFDSjtJQUNKO0FBQ0osRUFDQSxvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvYXV0aC1qcy9kaXN0L21vZHVsZS9saWIvd2ViYXV0aG4uanM/ODhjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGJhc2U2NFVybFRvVWludDhBcnJheSwgYnl0ZXNUb0Jhc2U2NFVSTCB9IGZyb20gJy4vYmFzZTY0dXJsJztcbmltcG9ydCB7IEF1dGhFcnJvciwgQXV0aFVua25vd25FcnJvciwgaXNBdXRoRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tICcuL2hlbHBlcnMnO1xuaW1wb3J0IHsgaWRlbnRpZnlBdXRoZW50aWNhdGlvbkVycm9yLCBpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yLCBpc1dlYkF1dGhuRXJyb3IsIFdlYkF1dGhuRXJyb3IsIFdlYkF1dGhuVW5rbm93bkVycm9yLCB9IGZyb20gJy4vd2ViYXV0aG4uZXJyb3JzJztcbmV4cG9ydCB7IFdlYkF1dGhuRXJyb3IsIGlzV2ViQXV0aG5FcnJvciwgaWRlbnRpZnlSZWdpc3RyYXRpb25FcnJvciwgaWRlbnRpZnlBdXRoZW50aWNhdGlvbkVycm9yIH07XG4vKipcbiAqIFdlYkF1dGhuIGFib3J0IHNlcnZpY2UgdG8gbWFuYWdlIGNlcmVtb255IGNhbmNlbGxhdGlvbi5cbiAqIEVuc3VyZXMgb25seSBvbmUgV2ViQXV0aG4gY2VyZW1vbnkgaXMgYWN0aXZlIGF0IGEgdGltZSB0byBwcmV2ZW50IFwib3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiBlcnJvcnMuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGNsYXNzIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgcmVsZWFzZXNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1hdXRvbWF0aW9uLXdlYmRyaXZlci1jYXBhYmlsaXR5IFczQyBXZWJBdXRobiBTcGVjIC0gQWJvcnRpbmcgQ2VyZW1vbmllc31cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYkF1dGhuQWJvcnRTZXJ2aWNlIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gYWJvcnQgc2lnbmFsIGZvciBhIG5ldyBXZWJBdXRobiBvcGVyYXRpb24uXG4gICAgICogQXV0b21hdGljYWxseSBjYW5jZWxzIGFueSBleGlzdGluZyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QWJvcnRTaWduYWx9IFNpZ25hbCB0byBwYXNzIHRvIG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoKSBvciAuZ2V0KClcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQWJvcnRTaWduYWwgTUROIC0gQWJvcnRTaWduYWx9XG4gICAgICovXG4gICAgY3JlYXRlTmV3QWJvcnRTaWduYWwoKSB7XG4gICAgICAgIC8vIEFib3J0IGFueSBleGlzdGluZyBjYWxscyB0byBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKCkgb3IgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldCgpXG4gICAgICAgIGlmICh0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoJ0NhbmNlbGxpbmcgZXhpc3RpbmcgV2ViQXV0aG4gQVBJIGNhbGwgZm9yIG5ldyBvbmUnKTtcbiAgICAgICAgICAgIGFib3J0RXJyb3IubmFtZSA9ICdBYm9ydEVycm9yJztcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5hYm9ydChhYm9ydEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBuZXdDb250cm9sbGVyO1xuICAgICAgICByZXR1cm4gbmV3Q29udHJvbGxlci5zaWduYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IGNhbmNlbCB0aGUgY3VycmVudCBXZWJBdXRobiBvcGVyYXRpb24uXG4gICAgICogVXNlZnVsIGZvciBjbGVhbmluZyB1cCB3aGVuIHVzZXIgY2FuY2VscyBvciBuYXZpZ2F0ZXMgYXdheS5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BYm9ydENvbnRyb2xsZXIvYWJvcnQgTUROIC0gQWJvcnRDb250cm9sbGVyLmFib3J0fVxuICAgICAqL1xuICAgIGNhbmNlbENlcmVtb255KCkge1xuICAgICAgICBpZiAodGhpcy5jb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBhYm9ydEVycm9yID0gbmV3IEVycm9yKCdNYW51YWxseSBjYW5jZWxsaW5nIGV4aXN0aW5nIFdlYkF1dGhuIEFQSSBjYWxsJyk7XG4gICAgICAgICAgICBhYm9ydEVycm9yLm5hbWUgPSAnQWJvcnRFcnJvcic7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoYWJvcnRFcnJvcik7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFNpbmdsZXRvbiBpbnN0YW5jZSB0byBlbnN1cmUgb25seSBvbmUgV2ViQXV0aG4gY2VyZW1vbnkgaXMgYWN0aXZlIGF0IGEgdGltZS5cbiAqIFRoaXMgcHJldmVudHMgXCJvcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzc1wiIGVycm9ycyB3aGVuIHJldHJ5aW5nIFdlYkF1dGhuIG9wZXJhdGlvbnMuXG4gKlxuICogQGV4cGVyaW1lbnRhbCBUaGlzIGluc3RhbmNlIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgcmVsZWFzZXNcbiAqL1xuZXhwb3J0IGNvbnN0IHdlYkF1dGhuQWJvcnRTZXJ2aWNlID0gbmV3IFdlYkF1dGhuQWJvcnRTZXJ2aWNlKCk7XG4vKipcbiAqIENvbnZlcnQgYmFzZTY0dXJsIGVuY29kZWQgc3RyaW5ncyBpbiBXZWJBdXRobiBjcmVkZW50aWFsIGNyZWF0aW9uIG9wdGlvbnMgdG8gQXJyYXlCdWZmZXJzXG4gKiBhcyByZXF1aXJlZCBieSB0aGUgV2ViQXV0aG4gYnJvd3NlciBBUEkuXG4gKiBTdXBwb3J0cyBib3RoIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIHBhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT04gYW5kIG1hbnVhbCBmYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge1NlcnZlckNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnN9IG9wdGlvbnMgLSBKU09OIG9wdGlvbnMgZnJvbSBzZXJ2ZXIgd2l0aCBiYXNlNjR1cmwgZW5jb2RlZCBmaWVsZHNcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlfSBPcHRpb25zIHJlYWR5IGZvciBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKClcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1wYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OIFczQyBXZWJBdXRobiBTcGVjIC0gcGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXplQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3JlZGVudGlhbCBjcmVhdGlvbiBvcHRpb25zIGFyZSByZXF1aXJlZCcpO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgbmF0aXZlIHBhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT04gbWV0aG9kIGlzIGF2YWlsYWJsZVxuICAgIGlmICh0eXBlb2YgUHVibGljS2V5Q3JlZGVudGlhbCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgJ3BhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT04nIGluIFB1YmxpY0tleUNyZWRlbnRpYWwgJiZcbiAgICAgICAgdHlwZW9mIFB1YmxpY0tleUNyZWRlbnRpYWxcbiAgICAgICAgICAgIC5wYXJzZUNyZWF0aW9uT3B0aW9uc0Zyb21KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgbmF0aXZlIFdlYkF1dGhuIExldmVsIDMgbWV0aG9kXG4gICAgICAgIHJldHVybiBQdWJsaWNLZXlDcmVkZW50aWFsLnBhcnNlQ3JlYXRpb25PcHRpb25zRnJvbUpTT04oXG4gICAgICAgIC8qKiB3ZSBhc3NlcnQgdGhlIG9wdGlvbnMgaGVyZSBhcyB0eXBlc2NyaXB0IHN0aWxsIGRvZXNuJ3Qga25vdyBhYm91dCBmdXR1cmUgd2ViYXV0aG4gdHlwZXMgKi9cbiAgICAgICAgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIHRvIG1hbnVhbCBwYXJzaW5nIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIG5hdGl2ZSBtZXRob2RcbiAgICAvLyBEZXN0cnVjdHVyZSB0byBzZXBhcmF0ZSBmaWVsZHMgdGhhdCBuZWVkIHRyYW5zZm9ybWF0aW9uXG4gICAgY29uc3QgeyBjaGFsbGVuZ2U6IGNoYWxsZW5nZVN0ciwgdXNlcjogdXNlck9wdHMsIGV4Y2x1ZGVDcmVkZW50aWFscyB9ID0gb3B0aW9ucywgcmVzdE9wdGlvbnMgPSBfX3Jlc3Qob3B0aW9uc1xuICAgIC8vIENvbnZlcnQgY2hhbGxlbmdlIGZyb20gYmFzZTY0dXJsIHRvIEFycmF5QnVmZmVyXG4gICAgLCBbXCJjaGFsbGVuZ2VcIiwgXCJ1c2VyXCIsIFwiZXhjbHVkZUNyZWRlbnRpYWxzXCJdKTtcbiAgICAvLyBDb252ZXJ0IGNoYWxsZW5nZSBmcm9tIGJhc2U2NHVybCB0byBBcnJheUJ1ZmZlclxuICAgIGNvbnN0IGNoYWxsZW5nZSA9IGJhc2U2NFVybFRvVWludDhBcnJheShjaGFsbGVuZ2VTdHIpLmJ1ZmZlcjtcbiAgICAvLyBDb252ZXJ0IHVzZXIuaWQgZnJvbSBiYXNlNjR1cmwgdG8gQXJyYXlCdWZmZXJcbiAgICBjb25zdCB1c2VyID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB1c2VyT3B0cyksIHsgaWQ6IGJhc2U2NFVybFRvVWludDhBcnJheSh1c2VyT3B0cy5pZCkuYnVmZmVyIH0pO1xuICAgIC8vIEJ1aWxkIHRoZSByZXN1bHQgb2JqZWN0XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0T3B0aW9ucyksIHsgY2hhbGxlbmdlLFxuICAgICAgICB1c2VyIH0pO1xuICAgIC8vIE9ubHkgYWRkIGV4Y2x1ZGVDcmVkZW50aWFscyBpZiBpdCBleGlzdHNcbiAgICBpZiAoZXhjbHVkZUNyZWRlbnRpYWxzICYmIGV4Y2x1ZGVDcmVkZW50aWFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3VsdC5leGNsdWRlQ3JlZGVudGlhbHMgPSBuZXcgQXJyYXkoZXhjbHVkZUNyZWRlbnRpYWxzLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhjbHVkZUNyZWRlbnRpYWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjcmVkID0gZXhjbHVkZUNyZWRlbnRpYWxzW2ldO1xuICAgICAgICAgICAgcmVzdWx0LmV4Y2x1ZGVDcmVkZW50aWFsc1tpXSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY3JlZCksIHsgaWQ6IGJhc2U2NFVybFRvVWludDhBcnJheShjcmVkLmlkKS5idWZmZXIsIHR5cGU6IGNyZWQudHlwZSB8fCAncHVibGljLWtleScsIFxuICAgICAgICAgICAgICAgIC8vIENhc3QgdHJhbnNwb3J0cyB0byBoYW5kbGUgZnV0dXJlIHRyYW5zcG9ydCB0eXBlcyBsaWtlIFwiY2FibGVcIlxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydHM6IGNyZWQudHJhbnNwb3J0cyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb252ZXJ0IGJhc2U2NHVybCBlbmNvZGVkIHN0cmluZ3MgaW4gV2ViQXV0aG4gY3JlZGVudGlhbCByZXF1ZXN0IG9wdGlvbnMgdG8gQXJyYXlCdWZmZXJzXG4gKiBhcyByZXF1aXJlZCBieSB0aGUgV2ViQXV0aG4gYnJvd3NlciBBUEkuXG4gKiBTdXBwb3J0cyBib3RoIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIHBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTiBhbmQgbWFudWFsIGZhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7U2VydmVyQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zfSBvcHRpb25zIC0gSlNPTiBvcHRpb25zIGZyb20gc2VydmVyIHdpdGggYmFzZTY0dXJsIGVuY29kZWQgZmllbGRzXG4gKiBAcmV0dXJucyB7UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zRnV0dXJlfSBPcHRpb25zIHJlYWR5IGZvciBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KClcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1wYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT04gVzNDIFdlYkF1dGhuIFNwZWMgLSBwYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT059XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ3JlZGVudGlhbCByZXF1ZXN0IG9wdGlvbnMgYXJlIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoZSBuYXRpdmUgcGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OIG1ldGhvZCBpcyBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIFB1YmxpY0tleUNyZWRlbnRpYWwgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICdwYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT04nIGluIFB1YmxpY0tleUNyZWRlbnRpYWwgJiZcbiAgICAgICAgdHlwZW9mIFB1YmxpY0tleUNyZWRlbnRpYWxcbiAgICAgICAgICAgIC5wYXJzZVJlcXVlc3RPcHRpb25zRnJvbUpTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyBtZXRob2RcbiAgICAgICAgcmV0dXJuIFB1YmxpY0tleUNyZWRlbnRpYWwucGFyc2VSZXF1ZXN0T3B0aW9uc0Zyb21KU09OKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBtYW51YWwgcGFyc2luZyBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IHRoZSBuYXRpdmUgbWV0aG9kXG4gICAgLy8gRGVzdHJ1Y3R1cmUgdG8gc2VwYXJhdGUgZmllbGRzIHRoYXQgbmVlZCB0cmFuc2Zvcm1hdGlvblxuICAgIGNvbnN0IHsgY2hhbGxlbmdlOiBjaGFsbGVuZ2VTdHIsIGFsbG93Q3JlZGVudGlhbHMgfSA9IG9wdGlvbnMsIHJlc3RPcHRpb25zID0gX19yZXN0KG9wdGlvbnNcbiAgICAvLyBDb252ZXJ0IGNoYWxsZW5nZSBmcm9tIGJhc2U2NHVybCB0byBBcnJheUJ1ZmZlclxuICAgICwgW1wiY2hhbGxlbmdlXCIsIFwiYWxsb3dDcmVkZW50aWFsc1wiXSk7XG4gICAgLy8gQ29udmVydCBjaGFsbGVuZ2UgZnJvbSBiYXNlNjR1cmwgdG8gQXJyYXlCdWZmZXJcbiAgICBjb25zdCBjaGFsbGVuZ2UgPSBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkoY2hhbGxlbmdlU3RyKS5idWZmZXI7XG4gICAgLy8gQnVpbGQgdGhlIHJlc3VsdCBvYmplY3RcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3RPcHRpb25zKSwgeyBjaGFsbGVuZ2UgfSk7XG4gICAgLy8gT25seSBhZGQgYWxsb3dDcmVkZW50aWFscyBpZiBpdCBleGlzdHNcbiAgICBpZiAoYWxsb3dDcmVkZW50aWFscyAmJiBhbGxvd0NyZWRlbnRpYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzdWx0LmFsbG93Q3JlZGVudGlhbHMgPSBuZXcgQXJyYXkoYWxsb3dDcmVkZW50aWFscy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbG93Q3JlZGVudGlhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNyZWQgPSBhbGxvd0NyZWRlbnRpYWxzW2ldO1xuICAgICAgICAgICAgcmVzdWx0LmFsbG93Q3JlZGVudGlhbHNbaV0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNyZWQpLCB7IGlkOiBiYXNlNjRVcmxUb1VpbnQ4QXJyYXkoY3JlZC5pZCkuYnVmZmVyLCB0eXBlOiBjcmVkLnR5cGUgfHwgJ3B1YmxpYy1rZXknLCBcbiAgICAgICAgICAgICAgICAvLyBDYXN0IHRyYW5zcG9ydHMgdG8gaGFuZGxlIGZ1dHVyZSB0cmFuc3BvcnQgdHlwZXMgbGlrZSBcImNhYmxlXCJcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRzOiBjcmVkLnRyYW5zcG9ydHMgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQ29udmVydCBhIHJlZ2lzdHJhdGlvbi9lbnJvbGxtZW50IGNyZWRlbnRpYWwgcmVzcG9uc2UgdG8gc2VydmVyIGZvcm1hdC5cbiAqIFNlcmlhbGl6ZXMgYmluYXJ5IGZpZWxkcyB0byBiYXNlNjR1cmwgZm9yIEpTT04gdHJhbnNtaXNzaW9uLlxuICogU3VwcG9ydHMgYm90aCBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyB0b0pTT04gYW5kIG1hbnVhbCBmYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0ge1JlZ2lzdHJhdGlvbkNyZWRlbnRpYWx9IGNyZWRlbnRpYWwgLSBDcmVkZW50aWFsIGZyb20gbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpXG4gKiBAcmV0dXJucyB7UmVnaXN0cmF0aW9uUmVzcG9uc2VKU09OfSBKU09OLXNlcmlhbGl6YWJsZSBjcmVkZW50aWFsIGZvciBzZXJ2ZXJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jZG9tLXB1YmxpY2tleWNyZWRlbnRpYWwtdG9qc29uIFczQyBXZWJBdXRobiBTcGVjIC0gdG9KU09OfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplQ3JlZGVudGlhbENyZWF0aW9uUmVzcG9uc2UoY3JlZGVudGlhbCkge1xuICAgIHZhciBfYTtcbiAgICAvLyBDaGVjayBpZiB0aGUgY3JlZGVudGlhbCBpbnN0YW5jZSBoYXMgdGhlIHRvSlNPTiBtZXRob2RcbiAgICBpZiAoJ3RvSlNPTicgaW4gY3JlZGVudGlhbCAmJiB0eXBlb2YgY3JlZGVudGlhbC50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBuYXRpdmUgV2ViQXV0aG4gTGV2ZWwgMyBtZXRob2RcbiAgICAgICAgcmV0dXJuIGNyZWRlbnRpYWwudG9KU09OKCk7XG4gICAgfVxuICAgIGNvbnN0IGNyZWRlbnRpYWxXaXRoQXR0YWNobWVudCA9IGNyZWRlbnRpYWw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGNyZWRlbnRpYWwuaWQsXG4gICAgICAgIHJhd0lkOiBjcmVkZW50aWFsLmlkLFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgYXR0ZXN0YXRpb25PYmplY3Q6IGJ5dGVzVG9CYXNlNjRVUkwobmV3IFVpbnQ4QXJyYXkoY3JlZGVudGlhbC5yZXNwb25zZS5hdHRlc3RhdGlvbk9iamVjdCkpLFxuICAgICAgICAgICAgY2xpZW50RGF0YUpTT046IGJ5dGVzVG9CYXNlNjRVUkwobmV3IFVpbnQ4QXJyYXkoY3JlZGVudGlhbC5yZXNwb25zZS5jbGllbnREYXRhSlNPTikpLFxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiAncHVibGljLWtleScsXG4gICAgICAgIGNsaWVudEV4dGVuc2lvblJlc3VsdHM6IGNyZWRlbnRpYWwuZ2V0Q2xpZW50RXh0ZW5zaW9uUmVzdWx0cygpLFxuICAgICAgICAvLyBDb252ZXJ0IG51bGwgdG8gdW5kZWZpbmVkIGFuZCBjYXN0IHRvIEF1dGhlbnRpY2F0b3JBdHRhY2htZW50IHR5cGVcbiAgICAgICAgYXV0aGVudGljYXRvckF0dGFjaG1lbnQ6ICgoX2EgPSBjcmVkZW50aWFsV2l0aEF0dGFjaG1lbnQuYXV0aGVudGljYXRvckF0dGFjaG1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydCBhbiBhdXRoZW50aWNhdGlvbi92ZXJpZmljYXRpb24gY3JlZGVudGlhbCByZXNwb25zZSB0byBzZXJ2ZXIgZm9ybWF0LlxuICogU2VyaWFsaXplcyBiaW5hcnkgZmllbGRzIHRvIGJhc2U2NHVybCBmb3IgSlNPTiB0cmFuc21pc3Npb24uXG4gKiBTdXBwb3J0cyBib3RoIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIHRvSlNPTiBhbmQgbWFudWFsIGZhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7QXV0aGVudGljYXRpb25DcmVkZW50aWFsfSBjcmVkZW50aWFsIC0gQ3JlZGVudGlhbCBmcm9tIG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKVxuICogQHJldHVybnMge0F1dGhlbnRpY2F0aW9uUmVzcG9uc2VKU09OfSBKU09OLXNlcmlhbGl6YWJsZSBjcmVkZW50aWFsIGZvciBzZXJ2ZXJcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jZG9tLXB1YmxpY2tleWNyZWRlbnRpYWwtdG9qc29uIFczQyBXZWJBdXRobiBTcGVjIC0gdG9KU09OfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplQ3JlZGVudGlhbFJlcXVlc3RSZXNwb25zZShjcmVkZW50aWFsKSB7XG4gICAgdmFyIF9hO1xuICAgIC8vIENoZWNrIGlmIHRoZSBjcmVkZW50aWFsIGluc3RhbmNlIGhhcyB0aGUgdG9KU09OIG1ldGhvZFxuICAgIGlmICgndG9KU09OJyBpbiBjcmVkZW50aWFsICYmIHR5cGVvZiBjcmVkZW50aWFsLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBVc2UgdGhlIG5hdGl2ZSBXZWJBdXRobiBMZXZlbCAzIG1ldGhvZFxuICAgICAgICByZXR1cm4gY3JlZGVudGlhbC50b0pTT04oKTtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgdG8gbWFudWFsIGNvbnZlcnNpb24gZm9yIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCB0b0pTT05cbiAgICAvLyBBY2Nlc3MgYXV0aGVudGljYXRvckF0dGFjaG1lbnQgdmlhIHR5cGUgYXNzZXJ0aW9uIHRvIGhhbmRsZSBUeXBlU2NyaXB0IHZlcnNpb24gZGlmZmVyZW5jZXNcbiAgICAvLyBAc2ltcGxld2ViYXV0aG4vdHlwZXMgaW5jbHVkZXMgdGhpcyBwcm9wZXJ0eSBidXQgYmFzZSBUeXBlU2NyaXB0IDQuNy40IGRvZXNuJ3RcbiAgICBjb25zdCBjcmVkZW50aWFsV2l0aEF0dGFjaG1lbnQgPSBjcmVkZW50aWFsO1xuICAgIGNvbnN0IGNsaWVudEV4dGVuc2lvblJlc3VsdHMgPSBjcmVkZW50aWFsLmdldENsaWVudEV4dGVuc2lvblJlc3VsdHMoKTtcbiAgICBjb25zdCBhc3NlcnRpb25SZXNwb25zZSA9IGNyZWRlbnRpYWwucmVzcG9uc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGNyZWRlbnRpYWwuaWQsXG4gICAgICAgIHJhd0lkOiBjcmVkZW50aWFsLmlkLCAvLyBXM0Mgc3BlYyBleHBlY3RzIHJhd0lkIHRvIG1hdGNoIGlkIGZvciBKU09OIGZvcm1hdFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgYXV0aGVudGljYXRvckRhdGE6IGJ5dGVzVG9CYXNlNjRVUkwobmV3IFVpbnQ4QXJyYXkoYXNzZXJ0aW9uUmVzcG9uc2UuYXV0aGVudGljYXRvckRhdGEpKSxcbiAgICAgICAgICAgIGNsaWVudERhdGFKU09OOiBieXRlc1RvQmFzZTY0VVJMKG5ldyBVaW50OEFycmF5KGFzc2VydGlvblJlc3BvbnNlLmNsaWVudERhdGFKU09OKSksXG4gICAgICAgICAgICBzaWduYXR1cmU6IGJ5dGVzVG9CYXNlNjRVUkwobmV3IFVpbnQ4QXJyYXkoYXNzZXJ0aW9uUmVzcG9uc2Uuc2lnbmF0dXJlKSksXG4gICAgICAgICAgICB1c2VySGFuZGxlOiBhc3NlcnRpb25SZXNwb25zZS51c2VySGFuZGxlXG4gICAgICAgICAgICAgICAgPyBieXRlc1RvQmFzZTY0VVJMKG5ldyBVaW50OEFycmF5KGFzc2VydGlvblJlc3BvbnNlLnVzZXJIYW5kbGUpKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiAncHVibGljLWtleScsXG4gICAgICAgIGNsaWVudEV4dGVuc2lvblJlc3VsdHMsXG4gICAgICAgIC8vIENvbnZlcnQgbnVsbCB0byB1bmRlZmluZWQgYW5kIGNhc3QgdG8gQXV0aGVudGljYXRvckF0dGFjaG1lbnQgdHlwZVxuICAgICAgICBhdXRoZW50aWNhdG9yQXR0YWNobWVudDogKChfYSA9IGNyZWRlbnRpYWxXaXRoQXR0YWNobWVudC5hdXRoZW50aWNhdG9yQXR0YWNobWVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkKSxcbiAgICB9O1xufVxuLyoqXG4gKiBBIHNpbXBsZSB0ZXN0IHRvIGRldGVybWluZSBpZiBhIGhvc3RuYW1lIGlzIGEgcHJvcGVybHktZm9ybWF0dGVkIGRvbWFpbiBuYW1lLlxuICogQ29uc2lkZXJzIGxvY2FsaG9zdCB2YWxpZCBmb3IgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICpcbiAqIEEgXCJ2YWxpZCBkb21haW5cIiBpcyBkZWZpbmVkIGhlcmU6IGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdmFsaWQtZG9tYWluXG4gKlxuICogUmVnZXggc291cmNlZCBmcm9tIGhlcmU6XG4gKiBodHRwczovL3d3dy5vcmVpbGx5LmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgxNDQ5MzI3NDUzL2NoMDhzMTUuaHRtbFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBob3N0bmFtZSAtIFRoZSBob3N0bmFtZSB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsaWQgZG9tYWluIG9yIGxvY2FsaG9zdFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN2YWxpZC1kb21haW4gV0hBVFdHIFVSTCBTcGVjIC0gVmFsaWQgRG9tYWlufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZERvbWFpbihob3N0bmFtZSkge1xuICAgIHJldHVybiAoXG4gICAgLy8gQ29uc2lkZXIgbG9jYWxob3N0IHZhbGlkIGFzIHdlbGwgc2luY2UgaXQncyBva2F5IHdydCBTZWN1cmUgQ29udGV4dHNcbiAgICBob3N0bmFtZSA9PT0gJ2xvY2FsaG9zdCcgfHwgL14oW2EtejAtOV0rKC1bYS16MC05XSspKlxcLikrW2Etel17Mix9JC9pLnRlc3QoaG9zdG5hbWUpKTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBicm93c2VyIGlzIGNhcGFibGUgb2YgV2ViQXV0aG4uXG4gKiBDaGVja3MgZm9yIG5lY2Vzc2FyeSBXZWIgQVBJczogUHVibGljS2V5Q3JlZGVudGlhbCBhbmQgQ3JlZGVudGlhbCBNYW5hZ2VtZW50LlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIGJyb3dzZXIgc3VwcG9ydHMgV2ViQXV0aG5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9QdWJsaWNLZXlDcmVkZW50aWFsI2Jyb3dzZXJfY29tcGF0aWJpbGl0eSBNRE4gLSBQdWJsaWNLZXlDcmVkZW50aWFsIEJyb3dzZXIgQ29tcGF0aWJpbGl0eX1cbiAqL1xuZnVuY3Rpb24gYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4oKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gISEoaXNCcm93c2VyKCkgJiZcbiAgICAgICAgJ1B1YmxpY0tleUNyZWRlbnRpYWwnIGluIHdpbmRvdyAmJlxuICAgICAgICB3aW5kb3cuUHVibGljS2V5Q3JlZGVudGlhbCAmJlxuICAgICAgICAnY3JlZGVudGlhbHMnIGluIG5hdmlnYXRvciAmJlxuICAgICAgICB0eXBlb2YgKChfYSA9IG5hdmlnYXRvciA9PT0gbnVsbCB8fCBuYXZpZ2F0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5hdmlnYXRvci5jcmVkZW50aWFscykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNyZWF0ZSkgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mICgoX2IgPSBuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IuY3JlZGVudGlhbHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXQpID09PSAnZnVuY3Rpb24nKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgV2ViQXV0aG4gY3JlZGVudGlhbCB1c2luZyB0aGUgYnJvd3NlcidzIGNyZWRlbnRpYWxzIEFQSS5cbiAqIFdyYXBzIG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoKSB3aXRoIGVycm9yIGhhbmRsaW5nLlxuICpcbiAqIEBwYXJhbSB7Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc30gb3B0aW9ucyAtIE9wdGlvbnMgaW5jbHVkaW5nIHB1YmxpY0tleSBwYXJhbWV0ZXJzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSZXF1ZXN0UmVzdWx0PFJlZ2lzdHJhdGlvbkNyZWRlbnRpYWwsIFdlYkF1dGhuRXJyb3I+Pn0gQ3JlYXRlZCBjcmVkZW50aWFsIG9yIGVycm9yXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCBXM0MgV2ViQXV0aG4gU3BlYyAtIENyZWF0ZSBDcmVkZW50aWFsfVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NyZWRlbnRpYWxzQ29udGFpbmVyL2NyZWF0ZSBNRE4gLSBjcmVkZW50aWFscy5jcmVhdGV9XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVDcmVkZW50aWFsKG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoXG4gICAgICAgIC8qKiB3ZSBhc3NlcnQgdGhlIHR5cGUgaGVyZSB1bnRpbCB0eXBlc2NyaXB0IHR5cGVzIGFyZSB1cGRhdGVkICovXG4gICAgICAgIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBXZWJBdXRoblVua25vd25FcnJvcignRW1wdHkgY3JlZGVudGlhbCByZXNwb25zZScsIHJlc3BvbnNlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEocmVzcG9uc2UgaW5zdGFuY2VvZiBQdWJsaWNLZXlDcmVkZW50aWFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgV2ViQXV0aG5Vbmtub3duRXJyb3IoJ0Jyb3dzZXIgcmV0dXJuZWQgdW5leHBlY3RlZCBjcmVkZW50aWFsIHR5cGUnLCByZXNwb25zZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGE6IHJlc3BvbnNlLCBlcnJvcjogbnVsbCB9O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgZXJyb3I6IGlkZW50aWZ5UmVnaXN0cmF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogR2V0IGEgV2ViQXV0aG4gY3JlZGVudGlhbCB1c2luZyB0aGUgYnJvd3NlcidzIGNyZWRlbnRpYWxzIEFQSS5cbiAqIFdyYXBzIG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKSB3aXRoIGVycm9yIGhhbmRsaW5nLlxuICpcbiAqIEBwYXJhbSB7Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zfSBvcHRpb25zIC0gT3B0aW9ucyBpbmNsdWRpbmcgcHVibGljS2V5IHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIHtQcm9taXNlPFJlcXVlc3RSZXN1bHQ8QXV0aGVudGljYXRpb25DcmVkZW50aWFsLCBXZWJBdXRobkVycm9yPj59IFJldHJpZXZlZCBjcmVkZW50aWFsIG9yIGVycm9yXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tZ2V0QXNzZXJ0aW9uIFczQyBXZWJBdXRobiBTcGVjIC0gR2V0IEFzc2VydGlvbn1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DcmVkZW50aWFsc0NvbnRhaW5lci9nZXQgTUROIC0gY3JlZGVudGlhbHMuZ2V0fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3JlZGVudGlhbChvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuZ2V0KFxuICAgICAgICAvKiogd2UgYXNzZXJ0IHRoZSB0eXBlIGhlcmUgdW50aWwgdHlwZXNjcmlwdCB0eXBlcyBhcmUgdXBkYXRlZCAqL1xuICAgICAgICBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgV2ViQXV0aG5Vbmtub3duRXJyb3IoJ0VtcHR5IGNyZWRlbnRpYWwgcmVzcG9uc2UnLCByZXNwb25zZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgUHVibGljS2V5Q3JlZGVudGlhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IFdlYkF1dGhuVW5rbm93bkVycm9yKCdCcm93c2VyIHJldHVybmVkIHVuZXhwZWN0ZWQgY3JlZGVudGlhbCB0eXBlJywgcmVzcG9uc2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhOiByZXNwb25zZSwgZXJyb3I6IG51bGwgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgIGVycm9yOiBpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBERUZBVUxUX0NSRUFUSU9OX09QVElPTlMgPSB7XG4gICAgaGludHM6IFsnc2VjdXJpdHkta2V5J10sXG4gICAgYXV0aGVudGljYXRvclNlbGVjdGlvbjoge1xuICAgICAgICBhdXRoZW50aWNhdG9yQXR0YWNobWVudDogJ2Nyb3NzLXBsYXRmb3JtJyxcbiAgICAgICAgcmVxdWlyZVJlc2lkZW50S2V5OiBmYWxzZSxcbiAgICAgICAgLyoqIHNldCB0byBwcmVmZXJyZWQgYmVjYXVzZSBvbGRlciB5dWJpa2V5cyBkb24ndCBoYXZlIFBJTi9CaW9tZXRyaWMgKi9cbiAgICAgICAgdXNlclZlcmlmaWNhdGlvbjogJ3ByZWZlcnJlZCcsXG4gICAgICAgIHJlc2lkZW50S2V5OiAnZGlzY291cmFnZWQnLFxuICAgIH0sXG4gICAgYXR0ZXN0YXRpb246ICdub25lJyxcbn07XG5leHBvcnQgY29uc3QgREVGQVVMVF9SRVFVRVNUX09QVElPTlMgPSB7XG4gICAgLyoqIHNldCB0byBwcmVmZXJyZWQgYmVjYXVzZSBvbGRlciB5dWJpa2V5cyBkb24ndCBoYXZlIFBJTi9CaW9tZXRyaWMgKi9cbiAgICB1c2VyVmVyaWZpY2F0aW9uOiAncHJlZmVycmVkJyxcbiAgICBoaW50czogWydzZWN1cml0eS1rZXknXSxcbn07XG5mdW5jdGlvbiBkZWVwTWVyZ2UoLi4uc291cmNlcykge1xuICAgIGNvbnN0IGlzT2JqZWN0ID0gKHZhbCkgPT4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHZhbCk7XG4gICAgY29uc3QgaXNBcnJheUJ1ZmZlckxpa2UgPSAodmFsKSA9PiB2YWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgICAgIGlmICghc291cmNlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gcHJlc2VydmUgYXJyYXkgcmVmZXJlbmNlLCBpbmNsdWRpbmcgdW5pb25zIGxpa2UgQXV0aGVudGljYXRvclRyYW5zcG9ydFtdXG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlCdWZmZXJMaWtlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHJlc3VsdFtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChleGlzdGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBkZWVwTWVyZ2UoZXhpc3RpbmcsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZGVlcE1lcmdlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIE1lcmdlcyBXZWJBdXRobiBjcmVkZW50aWFsIGNyZWF0aW9uIG9wdGlvbnMgd2l0aCBvdmVycmlkZXMuXG4gKiBTZXRzIHNlbnNpYmxlIGRlZmF1bHRzIGZvciBhdXRoZW50aWNhdG9yIHNlbGVjdGlvbiBhbmQgZXh0ZW5zaW9ucy5cbiAqXG4gKiBAcGFyYW0ge1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnNGdXR1cmV9IGJhc2VPcHRpb25zIC0gVGhlIGJhc2Ugb3B0aW9ucyBmcm9tIHRoZSBzZXJ2ZXJcbiAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZX0gb3ZlcnJpZGVzIC0gT3B0aW9uYWwgb3ZlcnJpZGVzIHRvIGFwcGx5XG4gKiBAcGFyYW0ge3N0cmluZ30gZnJpZW5kbHlOYW1lIC0gT3B0aW9uYWwgZnJpZW5kbHkgbmFtZSBmb3IgdGhlIGNyZWRlbnRpYWxcbiAqIEByZXR1cm5zIHtQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zRnV0dXJlfSBNZXJnZWQgY3JlZGVudGlhbCBjcmVhdGlvbiBvcHRpb25zXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI2RpY3RkZWYtYXV0aGVudGljYXRvcnNlbGVjdGlvbmNyaXRlcmlhIFczQyBXZWJBdXRobiBTcGVjIC0gQXV0aGVudGljYXRvclNlbGVjdGlvbkNyaXRlcmlhfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zKGJhc2VPcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICByZXR1cm4gZGVlcE1lcmdlKERFRkFVTFRfQ1JFQVRJT05fT1BUSU9OUywgYmFzZU9wdGlvbnMsIG92ZXJyaWRlcyB8fCB7fSk7XG59XG4vKipcbiAqIE1lcmdlcyBXZWJBdXRobiBjcmVkZW50aWFsIHJlcXVlc3Qgb3B0aW9ucyB3aXRoIG92ZXJyaWRlcy5cbiAqIFNldHMgc2Vuc2libGUgZGVmYXVsdHMgZm9yIHVzZXIgdmVyaWZpY2F0aW9uIGFuZCBoaW50cy5cbiAqXG4gKiBAcGFyYW0ge1B1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZX0gYmFzZU9wdGlvbnMgLSBUaGUgYmFzZSBvcHRpb25zIGZyb20gdGhlIHNlcnZlclxuICogQHBhcmFtIHtQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnNGdXR1cmV9IG92ZXJyaWRlcyAtIE9wdGlvbmFsIG92ZXJyaWRlcyB0byBhcHBseVxuICogQHJldHVybnMge1B1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZX0gTWVyZ2VkIGNyZWRlbnRpYWwgcmVxdWVzdCBvcHRpb25zXG4gKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI2RpY3RkZWYtcHVibGlja2V5Y3JlZGVudGlhbHJlcXVlc3RvcHRpb25zIFczQyBXZWJBdXRobiBTcGVjIC0gUHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zfVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMoYmFzZU9wdGlvbnMsIG92ZXJyaWRlcykge1xuICAgIHJldHVybiBkZWVwTWVyZ2UoREVGQVVMVF9SRVFVRVNUX09QVElPTlMsIGJhc2VPcHRpb25zLCBvdmVycmlkZXMgfHwge30pO1xufVxuLyoqXG4gKiBXZWJBdXRobiBBUEkgd3JhcHBlciBmb3IgU3VwYWJhc2UgQXV0aC5cbiAqIFByb3ZpZGVzIG1ldGhvZHMgZm9yIGVucm9sbGluZywgY2hhbGxlbmdpbmcsIHZlcmlmeWluZywgYXV0aGVudGljYXRpbmcsIGFuZCByZWdpc3RlcmluZyBXZWJBdXRobiBjcmVkZW50aWFscy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgcmVsZWFzZXNcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8gVzNDIFdlYkF1dGhuIFNwZWNpZmljYXRpb259XG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX0F1dGhlbnRpY2F0aW9uX0FQSSBNRE4gLSBXZWIgQXV0aGVudGljYXRpb24gQVBJfVxuICovXG5leHBvcnQgY2xhc3MgV2ViQXV0aG5BcGkge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgLy8gQmluZCBhbGwgbWV0aG9kcyBzbyB0aGV5IGNhbiBiZSBkZXN0cnVjdHVyZWRcbiAgICAgICAgdGhpcy5lbnJvbGwgPSB0aGlzLl9lbnJvbGwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jaGFsbGVuZ2UgPSB0aGlzLl9jaGFsbGVuZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy52ZXJpZnkgPSB0aGlzLl92ZXJpZnkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hdXRoZW50aWNhdGUgPSB0aGlzLl9hdXRoZW50aWNhdGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlciA9IHRoaXMuX3JlZ2lzdGVyLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVucm9sbCBhIG5ldyBXZWJBdXRobiBmYWN0b3IuXG4gICAgICogQ3JlYXRlcyBhbiB1bnZlcmlmaWVkIFdlYkF1dGhuIGZhY3RvciB0aGF0IG11c3QgYmUgdmVyaWZpZWQgd2l0aCBhIGNyZWRlbnRpYWwuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0aG9kIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICAgKiBAcGFyYW0ge09taXQ8TUZBRW5yb2xsV2ViYXV0aG5QYXJhbXMsICdmYWN0b3JUeXBlJz59IHBhcmFtcyAtIEVucm9sbG1lbnQgcGFyYW1ldGVycyAoZnJpZW5kbHlOYW1lIHJlcXVpcmVkKVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPEF1dGhNRkFFbnJvbGxXZWJhdXRoblJlc3BvbnNlPn0gRW5yb2xsZWQgZmFjdG9yIGRldGFpbHMgb3IgZXJyb3JcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tcmVnaXN0ZXJpbmctYS1uZXctY3JlZGVudGlhbCBXM0MgV2ViQXV0aG4gU3BlYyAtIFJlZ2lzdGVyaW5nIGEgTmV3IENyZWRlbnRpYWx9XG4gICAgICovXG4gICAgYXN5bmMgX2Vucm9sbChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50Lm1mYS5lbnJvbGwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IGZhY3RvclR5cGU6ICd3ZWJhdXRobicgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFsbGVuZ2UgZm9yIFdlYkF1dGhuIGNyZWRlbnRpYWwgY3JlYXRpb24gb3IgYXV0aGVudGljYXRpb24uXG4gICAgICogQ29tYmluZXMgc2VydmVyIGNoYWxsZW5nZSB3aXRoIGJyb3dzZXIgY3JlZGVudGlhbCBvcGVyYXRpb25zLlxuICAgICAqIEhhbmRsZXMgYm90aCByZWdpc3RyYXRpb24gKGNyZWF0ZSkgYW5kIGF1dGhlbnRpY2F0aW9uIChyZXF1ZXN0KSBmbG93cy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2QgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICAgICAqIEBwYXJhbSB7TUZBQ2hhbGxlbmdlV2ViYXV0aG5QYXJhbXMgJiB7IGZyaWVuZGx5TmFtZT86IHN0cmluZzsgc2lnbmFsPzogQWJvcnRTaWduYWwgfX0gcGFyYW1zIC0gQ2hhbGxlbmdlIHBhcmFtZXRlcnMgaW5jbHVkaW5nIGZhY3RvcklkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyAtIEFsbG93cyB5b3UgdG8gb3ZlcnJpZGUgdGhlIHBhcmFtZXRlcnMgcGFzc2VkIHRvIG5hdmlnYXRvci5jcmVkZW50aWFsc1xuICAgICAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZX0gb3ZlcnJpZGVzLmNyZWF0ZSAtIE92ZXJyaWRlIG9wdGlvbnMgZm9yIGNyZWRlbnRpYWwgY3JlYXRpb25cbiAgICAgKiBAcGFyYW0ge1B1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZX0gb3ZlcnJpZGVzLnJlcXVlc3QgLSBPdmVycmlkZSBvcHRpb25zIGZvciBjcmVkZW50aWFsIHJlcXVlc3RcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZXF1ZXN0UmVzdWx0Pn0gQ2hhbGxlbmdlIHJlc3BvbnNlIHdpdGggY3JlZGVudGlhbCBvciBlcnJvclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1jcmVkZW50aWFsLWNyZWF0aW9uIFczQyBXZWJBdXRobiBTcGVjIC0gQ3JlZGVudGlhbCBDcmVhdGlvbn1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tdmVyaWZ5aW5nLWFzc2VydGlvbiBXM0MgV2ViQXV0aG4gU3BlYyAtIFZlcmlmeWluZyBBc3NlcnRpb259XG4gICAgICovXG4gICAgYXN5bmMgX2NoYWxsZW5nZSh7IGZhY3RvcklkLCB3ZWJhdXRobiwgZnJpZW5kbHlOYW1lLCBzaWduYWwsIH0sIG92ZXJyaWRlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gR2V0IGNoYWxsZW5nZSBmcm9tIHNlcnZlciB1c2luZyB0aGUgY2xpZW50J3MgTUZBIG1ldGhvZHNcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogY2hhbGxlbmdlUmVzcG9uc2UsIGVycm9yOiBjaGFsbGVuZ2VFcnJvciB9ID0gYXdhaXQgdGhpcy5jbGllbnQubWZhLmNoYWxsZW5nZSh7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgICAgICAgICAgd2ViYXV0aG4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghY2hhbGxlbmdlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFib3J0U2lnbmFsID0gc2lnbmFsICE9PSBudWxsICYmIHNpZ25hbCAhPT0gdm9pZCAwID8gc2lnbmFsIDogd2ViQXV0aG5BYm9ydFNlcnZpY2UuY3JlYXRlTmV3QWJvcnRTaWduYWwoKTtcbiAgICAgICAgICAgIC8qKiB3ZWJhdXRobiB3aWxsIGZhaWwgaWYgZWl0aGVyIG9mIHRoZSBuYW1lL2Rpc3BsYXluYW1lIGFyZSBibGFuayAqL1xuICAgICAgICAgICAgaWYgKGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLnR5cGUgPT09ICdjcmVhdGUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB1c2VyIH0gPSBjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMucHVibGljS2V5O1xuICAgICAgICAgICAgICAgIGlmICghdXNlci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXIubmFtZSA9IGAke3VzZXIuaWR9OiR7ZnJpZW5kbHlOYW1lfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdXNlci5kaXNwbGF5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB1c2VyLmRpc3BsYXlOYW1lID0gdXNlci5uYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4udHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NyZWF0ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyhjaGFsbGVuZ2VSZXNwb25zZS53ZWJhdXRobi5jcmVkZW50aWFsX29wdGlvbnMucHVibGljS2V5LCBvdmVycmlkZXMgPT09IG51bGwgfHwgb3ZlcnJpZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdmVycmlkZXMuY3JlYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgY3JlYXRlQ3JlZGVudGlhbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwdWJsaWNLZXk6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZVJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWJhdXRobjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxfcmVzcG9uc2U6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAncmVxdWVzdCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1lcmdlQ3JlZGVudGlhbFJlcXVlc3RPcHRpb25zKGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucy5wdWJsaWNLZXksIG92ZXJyaWRlcyA9PT0gbnVsbCB8fCBvdmVycmlkZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG92ZXJyaWRlcy5yZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgZ2V0Q3JlZGVudGlhbChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNoYWxsZW5nZVJlc3BvbnNlLndlYmF1dGhuLmNyZWRlbnRpYWxfb3B0aW9ucyksIHsgcHVibGljS2V5OiBvcHRpb25zLCBzaWduYWw6IGFib3J0U2lnbmFsIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3JJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZVJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWJhdXRobjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxfcmVzcG9uc2U6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhVbmtub3duRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgaW4gY2hhbGxlbmdlJywgZXJyb3IpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZnkgYSBXZWJBdXRobiBjcmVkZW50aWFsIHdpdGggdGhlIHNlcnZlci5cbiAgICAgKiBDb21wbGV0ZXMgdGhlIFdlYkF1dGhuIGNlcmVtb255IGJ5IHNlbmRpbmcgdGhlIGNyZWRlbnRpYWwgdG8gdGhlIHNlcnZlciBmb3IgdmVyaWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbCBUaGlzIG1ldGhvZCBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UgaW4gZnV0dXJlIHJlbGVhc2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFZlcmlmaWNhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5jaGFsbGVuZ2VJZCAtIElEIG9mIHRoZSBjaGFsbGVuZ2UgYmVpbmcgdmVyaWZpZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLmZhY3RvcklkIC0gSUQgb2YgdGhlIFdlYkF1dGhuIGZhY3RvclxuICAgICAqIEBwYXJhbSB7TUZBVmVyaWZ5V2ViYXV0aG5QYXJhbXM8VD5bJ3dlYmF1dGhuJ119IHBhcmFtcy53ZWJhdXRobiAtIFdlYkF1dGhuIGNyZWRlbnRpYWwgcmVzcG9uc2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxBdXRoTUZBVmVyaWZ5UmVzcG9uc2U+fSBWZXJpZmljYXRpb24gcmVzdWx0IHdpdGggc2Vzc2lvbiBvciBlcnJvclxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi12ZXJpZnlpbmctYXNzZXJ0aW9uIFczQyBXZWJBdXRobiBTcGVjIC0gVmVyaWZ5aW5nIGFuIEF1dGhlbnRpY2F0aW9uIEFzc2VydGlvbn1cbiAgICAgKiAqL1xuICAgIGFzeW5jIF92ZXJpZnkoeyBjaGFsbGVuZ2VJZCwgZmFjdG9ySWQsIHdlYmF1dGhuLCB9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5tZmEudmVyaWZ5KHtcbiAgICAgICAgICAgIGZhY3RvcklkLFxuICAgICAgICAgICAgY2hhbGxlbmdlSWQsXG4gICAgICAgICAgICB3ZWJhdXRobjogd2ViYXV0aG4sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb21wbGV0ZSBXZWJBdXRobiBhdXRoZW50aWNhdGlvbiBmbG93LlxuICAgICAqIFBlcmZvcm1zIGNoYWxsZW5nZSBhbmQgdmVyaWZpY2F0aW9uIGluIGEgc2luZ2xlIG9wZXJhdGlvbiBmb3IgZXhpc3RpbmcgY3JlZGVudGlhbHMuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsIFRoaXMgbWV0aG9kIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgcmVsZWFzZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gQXV0aGVudGljYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZmFjdG9ySWQgLSBJRCBvZiB0aGUgV2ViQXV0aG4gZmFjdG9yIHRvIGF1dGhlbnRpY2F0ZSB3aXRoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcy53ZWJhdXRobiAtIFdlYkF1dGhuIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLndlYmF1dGhuLnJwSWQgLSBSZWx5aW5nIFBhcnR5IElEIChkZWZhdWx0cyB0byBjdXJyZW50IGhvc3RuYW1lKVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhcmFtcy53ZWJhdXRobi5ycE9yaWdpbnMgLSBBbGxvd2VkIG9yaWdpbnMgKGRlZmF1bHRzIHRvIGN1cnJlbnQgb3JpZ2luKVxuICAgICAqIEBwYXJhbSB7QWJvcnRTaWduYWx9IHBhcmFtcy53ZWJhdXRobi5zaWduYWwgLSBPcHRpb25hbCBhYm9ydCBzaWduYWxcbiAgICAgKiBAcGFyYW0ge1B1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc0Z1dHVyZX0gb3ZlcnJpZGVzIC0gT3ZlcnJpZGUgb3B0aW9ucyBmb3IgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldFxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlcXVlc3RSZXN1bHQ8QXV0aE1GQVZlcmlmeVJlc3BvbnNlRGF0YSwgV2ViQXV0aG5FcnJvciB8IEF1dGhFcnJvcj4+fSBBdXRoZW50aWNhdGlvbiByZXN1bHRcbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3czYy5naXRodWIuaW8vd2ViYXV0aG4vI3NjdG4tYXV0aGVudGljYXRpb24gVzNDIFdlYkF1dGhuIFNwZWMgLSBBdXRoZW50aWNhdGlvbiBDZXJlbW9ueX1cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zIE1ETiAtIFB1YmxpY0tleUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9uc31cbiAgICAgKi9cbiAgICBhc3luYyBfYXV0aGVudGljYXRlKHsgZmFjdG9ySWQsIHdlYmF1dGhuOiB7IHJwSWQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA6IHVuZGVmaW5lZCwgcnBPcmlnaW5zID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBbd2luZG93LmxvY2F0aW9uLm9yaWdpbl0gOiB1bmRlZmluZWQsIHNpZ25hbCwgfSwgfSwgb3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmICghcnBJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aEVycm9yKCdycElkIGlzIHJlcXVpcmVkIGZvciBXZWJBdXRobiBhdXRoZW50aWNhdGlvbicpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFicm93c2VyU3VwcG9ydHNXZWJBdXRobigpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG5ldyBBdXRoVW5rbm93bkVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViQXV0aG4nLCBudWxsKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IGNoYWxsZW5nZSBhbmQgY3JlZGVudGlhbFxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBjaGFsbGVuZ2VSZXNwb25zZSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCB0aGlzLmNoYWxsZW5nZSh7XG4gICAgICAgICAgICAgICAgZmFjdG9ySWQsXG4gICAgICAgICAgICAgICAgd2ViYXV0aG46IHsgcnBJZCwgcnBPcmlnaW5zIH0sXG4gICAgICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgICAgfSwgeyByZXF1ZXN0OiBvdmVycmlkZXMgfSk7XG4gICAgICAgICAgICBpZiAoIWNoYWxsZW5nZVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHdlYmF1dGhuIH0gPSBjaGFsbGVuZ2VSZXNwb25zZTtcbiAgICAgICAgICAgIC8vIFZlcmlmeSBjcmVkZW50aWFsXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmVyaWZ5KHtcbiAgICAgICAgICAgICAgICBmYWN0b3JJZCxcbiAgICAgICAgICAgICAgICBjaGFsbGVuZ2VJZDogY2hhbGxlbmdlUmVzcG9uc2UuY2hhbGxlbmdlSWQsXG4gICAgICAgICAgICAgICAgd2ViYXV0aG46IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogd2ViYXV0aG4udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcnBJZCxcbiAgICAgICAgICAgICAgICAgICAgcnBPcmlnaW5zLFxuICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsX3Jlc3BvbnNlOiB3ZWJhdXRobi5jcmVkZW50aWFsX3Jlc3BvbnNlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChpc0F1dGhFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignVW5leHBlY3RlZCBlcnJvciBpbiBhdXRoZW50aWNhdGUnLCBlcnJvciksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBsZXRlIFdlYkF1dGhuIHJlZ2lzdHJhdGlvbiBmbG93LlxuICAgICAqIFBlcmZvcm1zIGVucm9sbG1lbnQsIGNoYWxsZW5nZSwgYW5kIHZlcmlmaWNhdGlvbiBpbiBhIHNpbmdsZSBvcGVyYXRpb24gZm9yIG5ldyBjcmVkZW50aWFscy5cbiAgICAgKlxuICAgICAqIEBleHBlcmltZW50YWwgVGhpcyBtZXRob2QgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSByZWxlYXNlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBSZWdpc3RyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuZnJpZW5kbHlOYW1lIC0gVXNlci1mcmllbmRseSBuYW1lIGZvciB0aGUgY3JlZGVudGlhbFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMucnBJZCAtIFJlbHlpbmcgUGFydHkgSUQgKGRlZmF1bHRzIHRvIGN1cnJlbnQgaG9zdG5hbWUpXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGFyYW1zLnJwT3JpZ2lucyAtIEFsbG93ZWQgb3JpZ2lucyAoZGVmYXVsdHMgdG8gY3VycmVudCBvcmlnaW4pXG4gICAgICogQHBhcmFtIHtBYm9ydFNpZ25hbH0gcGFyYW1zLnNpZ25hbCAtIE9wdGlvbmFsIGFib3J0IHNpZ25hbFxuICAgICAqIEBwYXJhbSB7UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc0Z1dHVyZX0gb3ZlcnJpZGVzIC0gT3ZlcnJpZGUgb3B0aW9ucyBmb3IgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPFJlcXVlc3RSZXN1bHQ8QXV0aE1GQVZlcmlmeVJlc3BvbnNlRGF0YSwgV2ViQXV0aG5FcnJvciB8IEF1dGhFcnJvcj4+fSBSZWdpc3RyYXRpb24gcmVzdWx0XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmF1dGhuLyNzY3RuLXJlZ2lzdGVyaW5nLWEtbmV3LWNyZWRlbnRpYWwgVzNDIFdlYkF1dGhuIFNwZWMgLSBSZWdpc3RyYXRpb24gQ2VyZW1vbnl9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1B1YmxpY0tleUNyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMgTUROIC0gUHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9uc31cbiAgICAgKi9cbiAgICBhc3luYyBfcmVnaXN0ZXIoeyBmcmllbmRseU5hbWUsIHJwSWQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA6IHVuZGVmaW5lZCwgcnBPcmlnaW5zID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyBbd2luZG93LmxvY2F0aW9uLm9yaWdpbl0gOiB1bmRlZmluZWQsIHNpZ25hbCwgfSwgb3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmICghcnBJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBudWxsLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aEVycm9yKCdycElkIGlzIHJlcXVpcmVkIGZvciBXZWJBdXRobiByZWdpc3RyYXRpb24nKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgQXV0aFVua25vd25FcnJvcignQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkF1dGhuJywgbnVsbCksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVucm9sbCBmYWN0b3JcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogZmFjdG9yLCBlcnJvcjogZW5yb2xsRXJyb3IgfSA9IGF3YWl0IHRoaXMuX2Vucm9sbCh7XG4gICAgICAgICAgICAgICAgZnJpZW5kbHlOYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIWZhY3Rvcikge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2xpZW50Lm1mYVxuICAgICAgICAgICAgICAgICAgICAubGlzdEZhY3RvcnMoKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoZmFjdG9ycykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSBmYWN0b3JzLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hbGwuZmluZCgodikgPT4gdi5mYWN0b3JfdHlwZSA9PT0gJ3dlYmF1dGhuJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdi5mcmllbmRseV9uYW1lID09PSBmcmllbmRseU5hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHYuc3RhdHVzICE9PSAndW52ZXJpZmllZCcpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKChmYWN0b3IpID0+IChmYWN0b3IgPyB0aGlzLmNsaWVudC5tZmEudW5lbnJvbGwoeyBmYWN0b3JJZDogZmFjdG9yID09PSBudWxsIHx8IGZhY3RvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFjdG9yLmlkIH0pIDogdm9pZCAwKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3I6IGVucm9sbEVycm9yIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgY2hhbGxlbmdlIGFuZCBjcmVhdGUgY3JlZGVudGlhbFxuICAgICAgICAgICAgY29uc3QgeyBkYXRhOiBjaGFsbGVuZ2VSZXNwb25zZSwgZXJyb3I6IGNoYWxsZW5nZUVycm9yIH0gPSBhd2FpdCB0aGlzLl9jaGFsbGVuZ2Uoe1xuICAgICAgICAgICAgICAgIGZhY3RvcklkOiBmYWN0b3IuaWQsXG4gICAgICAgICAgICAgICAgZnJpZW5kbHlOYW1lOiBmYWN0b3IuZnJpZW5kbHlfbmFtZSxcbiAgICAgICAgICAgICAgICB3ZWJhdXRobjogeyBycElkLCBycE9yaWdpbnMgfSxcbiAgICAgICAgICAgICAgICBzaWduYWwsXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgY3JlYXRlOiBvdmVycmlkZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghY2hhbGxlbmdlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogY2hhbGxlbmdlRXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92ZXJpZnkoe1xuICAgICAgICAgICAgICAgIGZhY3RvcklkOiBmYWN0b3IuaWQsXG4gICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IGNoYWxsZW5nZVJlc3BvbnNlLmNoYWxsZW5nZUlkLFxuICAgICAgICAgICAgICAgIHdlYmF1dGhuOiB7XG4gICAgICAgICAgICAgICAgICAgIHJwSWQsXG4gICAgICAgICAgICAgICAgICAgIHJwT3JpZ2lucyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4udHlwZSxcbiAgICAgICAgICAgICAgICAgICAgY3JlZGVudGlhbF9yZXNwb25zZTogY2hhbGxlbmdlUmVzcG9uc2Uud2ViYXV0aG4uY3JlZGVudGlhbF9yZXNwb25zZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoaXNBdXRoRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICBlcnJvcjogbmV3IEF1dGhVbmtub3duRXJyb3IoJ1VuZXhwZWN0ZWQgZXJyb3IgaW4gcmVnaXN0ZXInLCBlcnJvciksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViYXV0aG4uanMubWFwIl0sIm5hbWVzIjpbIl9fcmVzdCIsImJhc2U2NFVybFRvVWludDhBcnJheSIsImJ5dGVzVG9CYXNlNjRVUkwiLCJBdXRoRXJyb3IiLCJBdXRoVW5rbm93bkVycm9yIiwiaXNBdXRoRXJyb3IiLCJpc0Jyb3dzZXIiLCJpZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IiLCJpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yIiwiaXNXZWJBdXRobkVycm9yIiwiV2ViQXV0aG5FcnJvciIsIldlYkF1dGhuVW5rbm93bkVycm9yIiwiV2ViQXV0aG5BYm9ydFNlcnZpY2UiLCJjcmVhdGVOZXdBYm9ydFNpZ25hbCIsImNvbnRyb2xsZXIiLCJhYm9ydEVycm9yIiwiRXJyb3IiLCJuYW1lIiwiYWJvcnQiLCJuZXdDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwic2lnbmFsIiwiY2FuY2VsQ2VyZW1vbnkiLCJ1bmRlZmluZWQiLCJ3ZWJBdXRobkFib3J0U2VydmljZSIsImRlc2VyaWFsaXplQ3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyIsIm9wdGlvbnMiLCJQdWJsaWNLZXlDcmVkZW50aWFsIiwicGFyc2VDcmVhdGlvbk9wdGlvbnNGcm9tSlNPTiIsImNoYWxsZW5nZSIsImNoYWxsZW5nZVN0ciIsInVzZXIiLCJ1c2VyT3B0cyIsImV4Y2x1ZGVDcmVkZW50aWFscyIsInJlc3RPcHRpb25zIiwiYnVmZmVyIiwiT2JqZWN0IiwiYXNzaWduIiwiaWQiLCJyZXN1bHQiLCJsZW5ndGgiLCJBcnJheSIsImkiLCJjcmVkIiwidHlwZSIsInRyYW5zcG9ydHMiLCJkZXNlcmlhbGl6ZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyIsInBhcnNlUmVxdWVzdE9wdGlvbnNGcm9tSlNPTiIsImFsbG93Q3JlZGVudGlhbHMiLCJzZXJpYWxpemVDcmVkZW50aWFsQ3JlYXRpb25SZXNwb25zZSIsImNyZWRlbnRpYWwiLCJfYSIsInRvSlNPTiIsImNyZWRlbnRpYWxXaXRoQXR0YWNobWVudCIsInJhd0lkIiwicmVzcG9uc2UiLCJhdHRlc3RhdGlvbk9iamVjdCIsIlVpbnQ4QXJyYXkiLCJjbGllbnREYXRhSlNPTiIsImNsaWVudEV4dGVuc2lvblJlc3VsdHMiLCJnZXRDbGllbnRFeHRlbnNpb25SZXN1bHRzIiwiYXV0aGVudGljYXRvckF0dGFjaG1lbnQiLCJzZXJpYWxpemVDcmVkZW50aWFsUmVxdWVzdFJlc3BvbnNlIiwiYXNzZXJ0aW9uUmVzcG9uc2UiLCJhdXRoZW50aWNhdG9yRGF0YSIsInNpZ25hdHVyZSIsInVzZXJIYW5kbGUiLCJpc1ZhbGlkRG9tYWluIiwiaG9zdG5hbWUiLCJ0ZXN0IiwiYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4iLCJfYiIsIndpbmRvdyIsIm5hdmlnYXRvciIsImNyZWRlbnRpYWxzIiwiY3JlYXRlIiwiZ2V0IiwiY3JlYXRlQ3JlZGVudGlhbCIsImRhdGEiLCJlcnJvciIsImVyciIsImdldENyZWRlbnRpYWwiLCJERUZBVUxUX0NSRUFUSU9OX09QVElPTlMiLCJoaW50cyIsImF1dGhlbnRpY2F0b3JTZWxlY3Rpb24iLCJyZXF1aXJlUmVzaWRlbnRLZXkiLCJ1c2VyVmVyaWZpY2F0aW9uIiwicmVzaWRlbnRLZXkiLCJhdHRlc3RhdGlvbiIsIkRFRkFVTFRfUkVRVUVTVF9PUFRJT05TIiwiZGVlcE1lcmdlIiwic291cmNlcyIsImlzT2JqZWN0IiwidmFsIiwiaXNBcnJheSIsImlzQXJyYXlCdWZmZXJMaWtlIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJzb3VyY2UiLCJrZXkiLCJ2YWx1ZSIsImV4aXN0aW5nIiwibWVyZ2VDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zIiwiYmFzZU9wdGlvbnMiLCJvdmVycmlkZXMiLCJtZXJnZUNyZWRlbnRpYWxSZXF1ZXN0T3B0aW9ucyIsIldlYkF1dGhuQXBpIiwiY29uc3RydWN0b3IiLCJjbGllbnQiLCJlbnJvbGwiLCJfZW5yb2xsIiwiYmluZCIsIl9jaGFsbGVuZ2UiLCJ2ZXJpZnkiLCJfdmVyaWZ5IiwiYXV0aGVudGljYXRlIiwiX2F1dGhlbnRpY2F0ZSIsInJlZ2lzdGVyIiwiX3JlZ2lzdGVyIiwicGFyYW1zIiwibWZhIiwiZmFjdG9yVHlwZSIsImZhY3RvcklkIiwid2ViYXV0aG4iLCJmcmllbmRseU5hbWUiLCJjaGFsbGVuZ2VSZXNwb25zZSIsImNoYWxsZW5nZUVycm9yIiwiYWJvcnRTaWduYWwiLCJjcmVkZW50aWFsX29wdGlvbnMiLCJwdWJsaWNLZXkiLCJkaXNwbGF5TmFtZSIsImNoYWxsZW5nZUlkIiwiY3JlZGVudGlhbF9yZXNwb25zZSIsInJlcXVlc3QiLCJycElkIiwibG9jYXRpb24iLCJycE9yaWdpbnMiLCJvcmlnaW4iLCJmYWN0b3IiLCJlbnJvbGxFcnJvciIsImxpc3RGYWN0b3JzIiwidGhlbiIsImZhY3RvcnMiLCJhbGwiLCJmaW5kIiwidiIsImZhY3Rvcl90eXBlIiwiZnJpZW5kbHlfbmFtZSIsInN0YXR1cyIsInVuZW5yb2xsIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/auth-js/dist/module/lib/webauthn.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionsClient: () => (/* binding */ FunctionsClient)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _helper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helper */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/helper.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js\");\n\n\n\nclass FunctionsClient {\n    constructor(url, { headers = {}, customFetch, region = _types__WEBPACK_IMPORTED_MODULE_0__.FunctionRegion.Any } = {}){\n        this.url = url;\n        this.headers = headers;\n        this.region = region;\n        this.fetch = (0,_helper__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(customFetch);\n    }\n    /**\n     * Updates the authorization header\n     * @param token - the new jwt token sent in the authorisation header\n     */ setAuth(token) {\n        this.headers.Authorization = `Bearer ${token}`;\n    }\n    /**\n     * Invokes a function\n     * @param functionName - The name of the Function to invoke.\n     * @param options - Options for invoking the Function.\n     */ invoke(functionName_1) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, arguments, void 0, function*(functionName, options = {}) {\n            var _a;\n            try {\n                const { headers, method, body: functionArgs, signal } = options;\n                let _headers = {};\n                let { region } = options;\n                if (!region) {\n                    region = this.region;\n                }\n                // Add region as query parameter using URL API\n                const url = new URL(`${this.url}/${functionName}`);\n                if (region && region !== \"any\") {\n                    _headers[\"x-region\"] = region;\n                    url.searchParams.set(\"forceFunctionRegion\", region);\n                }\n                let body;\n                if (functionArgs && (headers && !Object.prototype.hasOwnProperty.call(headers, \"Content-Type\") || !headers)) {\n                    if (typeof Blob !== \"undefined\" && functionArgs instanceof Blob || functionArgs instanceof ArrayBuffer) {\n                        // will work for File as File inherits Blob\n                        // also works for ArrayBuffer as it is the same underlying structure as a Blob\n                        _headers[\"Content-Type\"] = \"application/octet-stream\";\n                        body = functionArgs;\n                    } else if (typeof functionArgs === \"string\") {\n                        // plain string\n                        _headers[\"Content-Type\"] = \"text/plain\";\n                        body = functionArgs;\n                    } else if (typeof FormData !== \"undefined\" && functionArgs instanceof FormData) {\n                        // don't set content-type headers\n                        // Request will automatically add the right boundary value\n                        body = functionArgs;\n                    } else {\n                        // default, assume this is JSON\n                        _headers[\"Content-Type\"] = \"application/json\";\n                        body = JSON.stringify(functionArgs);\n                    }\n                } else {\n                    // if the Content-Type was supplied, simply set the body\n                    body = functionArgs;\n                }\n                const response = yield this.fetch(url.toString(), {\n                    method: method || \"POST\",\n                    // headers priority is (high to low):\n                    // 1. invoke-level headers\n                    // 2. client-level headers\n                    // 3. default Content-Type header\n                    headers: Object.assign(Object.assign(Object.assign({}, _headers), this.headers), headers),\n                    body,\n                    signal\n                }).catch((fetchError)=>{\n                    if (fetchError.name === \"AbortError\") {\n                        throw fetchError;\n                    }\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsFetchError(fetchError);\n                });\n                const isRelayError = response.headers.get(\"x-relay-error\");\n                if (isRelayError && isRelayError === \"true\") {\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsRelayError(response);\n                }\n                if (!response.ok) {\n                    throw new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsHttpError(response);\n                }\n                let responseType = ((_a = response.headers.get(\"Content-Type\")) !== null && _a !== void 0 ? _a : \"text/plain\").split(\";\")[0].trim();\n                let data;\n                if (responseType === \"application/json\") {\n                    data = yield response.json();\n                } else if (responseType === \"application/octet-stream\" || responseType === \"application/pdf\") {\n                    data = yield response.blob();\n                } else if (responseType === \"text/event-stream\") {\n                    data = response;\n                } else if (responseType === \"multipart/form-data\") {\n                    data = yield response.formData();\n                } else {\n                    // default to text\n                    data = yield response.text();\n                }\n                return {\n                    data,\n                    error: null,\n                    response\n                };\n            } catch (error) {\n                if (error instanceof Error && error.name === \"AbortError\") {\n                    return {\n                        data: null,\n                        error: new _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsFetchError(error)\n                    };\n                }\n                return {\n                    data: null,\n                    error,\n                    response: error instanceof _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsHttpError || error instanceof _types__WEBPACK_IMPORTED_MODULE_0__.FunctionsRelayError ? error.context : undefined\n                };\n            }\n        });\n    }\n} //# sourceMappingURL=FunctionsClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS9GdW5jdGlvbnNDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFrQztBQUNNO0FBQ2dFO0FBQ2pHLE1BQU1NO0lBQ1RDLFlBQVlDLEdBQUcsRUFBRSxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFQyxXQUFXLEVBQUVDLFNBQVNULGtEQUFjQSxDQUFDVSxHQUFHLEVBQUcsR0FBRyxDQUFDLENBQUMsQ0FBRTtRQUMvRSxJQUFJLENBQUNKLEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNFLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNFLEtBQUssR0FBR1oscURBQVlBLENBQUNTO0lBQzlCO0lBQ0E7OztLQUdDLEdBQ0RJLFFBQVFDLEtBQUssRUFBRTtRQUNYLElBQUksQ0FBQ04sT0FBTyxDQUFDTyxhQUFhLEdBQUcsQ0FBQyxPQUFPLEVBQUVELE1BQU0sQ0FBQztJQUNsRDtJQUNBOzs7O0tBSUMsR0FDREUsT0FBT0MsY0FBYyxFQUFFO1FBQ25CLE9BQU9sQixnREFBU0EsQ0FBQyxJQUFJLEVBQUVtQixXQUFXLEtBQUssR0FBRyxVQUFXQyxZQUFZLEVBQUVDLFVBQVUsQ0FBQyxDQUFDO1lBQzNFLElBQUlDO1lBQ0osSUFBSTtnQkFDQSxNQUFNLEVBQUViLE9BQU8sRUFBRWMsTUFBTSxFQUFFQyxNQUFNQyxZQUFZLEVBQUVDLE1BQU0sRUFBRSxHQUFHTDtnQkFDeEQsSUFBSU0sV0FBVyxDQUFDO2dCQUNoQixJQUFJLEVBQUVoQixNQUFNLEVBQUUsR0FBR1U7Z0JBQ2pCLElBQUksQ0FBQ1YsUUFBUTtvQkFDVEEsU0FBUyxJQUFJLENBQUNBLE1BQU07Z0JBQ3hCO2dCQUNBLDhDQUE4QztnQkFDOUMsTUFBTUgsTUFBTSxJQUFJb0IsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDcEIsR0FBRyxDQUFDLENBQUMsRUFBRVks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TUFBTVosSUFBSSxLQUFLLGNBQWM7b0JBQ3ZELE9BQU87d0JBQUVPLE1BQU07d0JBQU1LLE9BQU8sSUFBSXRELHVEQUFtQkEsQ0FBQ3NEO29CQUFPO2dCQUMvRDtnQkFDQSxPQUFPO29CQUNITCxNQUFNO29CQUNOSztvQkFDQWpCLFVBQVVpQixpQkFBaUJyRCxzREFBa0JBLElBQUlxRCxpQkFBaUJwRCx1REFBbUJBLEdBQy9Fb0QsTUFBTUUsT0FBTyxHQUNiQztnQkFDVjtZQUNKO1FBQ0o7SUFDSjtBQUNKLEVBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS9GdW5jdGlvbnNDbGllbnQuanM/NWMzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2F3YWl0ZXIgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IHJlc29sdmVGZXRjaCB9IGZyb20gJy4vaGVscGVyJztcbmltcG9ydCB7IEZ1bmN0aW9uUmVnaW9uLCBGdW5jdGlvbnNGZXRjaEVycm9yLCBGdW5jdGlvbnNIdHRwRXJyb3IsIEZ1bmN0aW9uc1JlbGF5RXJyb3IsIH0gZnJvbSAnLi90eXBlcyc7XG5leHBvcnQgY2xhc3MgRnVuY3Rpb25zQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHsgaGVhZGVycyA9IHt9LCBjdXN0b21GZXRjaCwgcmVnaW9uID0gRnVuY3Rpb25SZWdpb24uQW55LCB9ID0ge30pIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIHRoaXMucmVnaW9uID0gcmVnaW9uO1xuICAgICAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGN1c3RvbUZldGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYXV0aG9yaXphdGlvbiBoZWFkZXJcbiAgICAgKiBAcGFyYW0gdG9rZW4gLSB0aGUgbmV3IGp3dCB0b2tlbiBzZW50IGluIHRoZSBhdXRob3Jpc2F0aW9uIGhlYWRlclxuICAgICAqL1xuICAgIHNldEF1dGgodG9rZW4pIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlcyBhIGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIGZ1bmN0aW9uTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBGdW5jdGlvbiB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGZvciBpbnZva2luZyB0aGUgRnVuY3Rpb24uXG4gICAgICovXG4gICAgaW52b2tlKGZ1bmN0aW9uTmFtZV8xKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uKiAoZnVuY3Rpb25OYW1lLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBoZWFkZXJzLCBtZXRob2QsIGJvZHk6IGZ1bmN0aW9uQXJncywgc2lnbmFsIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGxldCBfaGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIGxldCB7IHJlZ2lvbiB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZWdpb24gPSB0aGlzLnJlZ2lvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIHJlZ2lvbiBhcyBxdWVyeSBwYXJhbWV0ZXIgdXNpbmcgVVJMIEFQSVxuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9LyR7ZnVuY3Rpb25OYW1lfWApO1xuICAgICAgICAgICAgICAgIGlmIChyZWdpb24gJiYgcmVnaW9uICE9PSAnYW55Jykge1xuICAgICAgICAgICAgICAgICAgICBfaGVhZGVyc1sneC1yZWdpb24nXSA9IHJlZ2lvbjtcbiAgICAgICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2ZvcmNlRnVuY3Rpb25SZWdpb24nLCByZWdpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25BcmdzICYmXG4gICAgICAgICAgICAgICAgICAgICgoaGVhZGVycyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKSkgfHwgIWhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIEJsb2IgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkFyZ3MgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCB3b3JrIGZvciBGaWxlIGFzIEZpbGUgaW5oZXJpdHMgQmxvYlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyB3b3JrcyBmb3IgQXJyYXlCdWZmZXIgYXMgaXQgaXMgdGhlIHNhbWUgdW5kZXJseWluZyBzdHJ1Y3R1cmUgYXMgYSBCbG9iXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uQXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWluIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ3RleHQvcGxhaW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJncztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZ1bmN0aW9uQXJncyBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBzZXQgY29udGVudC10eXBlIGhlYWRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcXVlc3Qgd2lsbCBhdXRvbWF0aWNhbGx5IGFkZCB0aGUgcmlnaHQgYm91bmRhcnkgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmdW5jdGlvbkFyZ3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0LCBhc3N1bWUgdGhpcyBpcyBKU09OXG4gICAgICAgICAgICAgICAgICAgICAgICBfaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5zdHJpbmdpZnkoZnVuY3Rpb25BcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIENvbnRlbnQtVHlwZSB3YXMgc3VwcGxpZWQsIHNpbXBseSBzZXQgdGhlIGJvZHlcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZ1bmN0aW9uQXJncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmZldGNoKHVybC50b1N0cmluZygpLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kIHx8ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgLy8gaGVhZGVycyBwcmlvcml0eSBpcyAoaGlnaCB0byBsb3cpOlxuICAgICAgICAgICAgICAgICAgICAvLyAxLiBpbnZva2UtbGV2ZWwgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAvLyAyLiBjbGllbnQtbGV2ZWwgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAvLyAzLiBkZWZhdWx0IENvbnRlbnQtVHlwZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF9oZWFkZXJzKSwgdGhpcy5oZWFkZXJzKSwgaGVhZGVycyksXG4gICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZmV0Y2hFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmV0Y2hFcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGZldGNoRXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZ1bmN0aW9uc0ZldGNoRXJyb3IoZmV0Y2hFcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWxheUVycm9yID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtcmVsYXktZXJyb3InKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWxheUVycm9yICYmIGlzUmVsYXlFcnJvciA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGdW5jdGlvbnNSZWxheUVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRnVuY3Rpb25zSHR0cEVycm9yKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlVHlwZSA9ICgoX2EgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd0ZXh0L3BsYWluJykuc3BsaXQoJzsnKVswXS50cmltKCk7XG4gICAgICAgICAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlVHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScgfHxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlID09PSAnYXBwbGljYXRpb24vcGRmJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICd0ZXh0L2V2ZW50LXN0cmVhbScpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuZm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gdGV4dFxuICAgICAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCwgcmVzcG9uc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvcjogbmV3IEZ1bmN0aW9uc0ZldGNoRXJyb3IoZXJyb3IpIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogZXJyb3IgaW5zdGFuY2VvZiBGdW5jdGlvbnNIdHRwRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBGdW5jdGlvbnNSZWxheUVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGVycm9yLmNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZ1bmN0aW9uc0NsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwicmVzb2x2ZUZldGNoIiwiRnVuY3Rpb25SZWdpb24iLCJGdW5jdGlvbnNGZXRjaEVycm9yIiwiRnVuY3Rpb25zSHR0cEVycm9yIiwiRnVuY3Rpb25zUmVsYXlFcnJvciIsIkZ1bmN0aW9uc0NsaWVudCIsImNvbnN0cnVjdG9yIiwidXJsIiwiaGVhZGVycyIsImN1c3RvbUZldGNoIiwicmVnaW9uIiwiQW55IiwiZmV0Y2giLCJzZXRBdXRoIiwidG9rZW4iLCJBdXRob3JpemF0aW9uIiwiaW52b2tlIiwiZnVuY3Rpb25OYW1lXzEiLCJhcmd1bWVudHMiLCJmdW5jdGlvbk5hbWUiLCJvcHRpb25zIiwiX2EiLCJtZXRob2QiLCJib2R5IiwiZnVuY3Rpb25BcmdzIiwic2lnbmFsIiwiX2hlYWRlcnMiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJzZXQiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJCbG9iIiwiQXJyYXlCdWZmZXIiLCJGb3JtRGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXNwb25zZSIsInRvU3RyaW5nIiwiYXNzaWduIiwiY2F0Y2giLCJmZXRjaEVycm9yIiwibmFtZSIsImlzUmVsYXlFcnJvciIsImdldCIsIm9rIiwicmVzcG9uc2VUeXBlIiwic3BsaXQiLCJ0cmltIiwiZGF0YSIsImpzb24iLCJibG9iIiwiZm9ybURhdGEiLCJ0ZXh0IiwiZXJyb3IiLCJFcnJvciIsImNvbnRleHQiLCJ1bmRlZmluZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/functions-js/dist/module/helper.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/helper.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch)\n/* harmony export */ });\nconst resolveFetch = (customFetch)=>{\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    } else if (typeof fetch === \"undefined\") {\n        _fetch = (...args)=>Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\", 23)).then(({ default: fetch1 })=>fetch1(...args));\n    } else {\n        _fetch = fetch;\n    }\n    return (...args)=>_fetch(...args);\n}; //# sourceMappingURL=helper.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS9oZWxwZXIuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPLE1BQU1BLGVBQWUsQ0FBQ0M7SUFDekIsSUFBSUM7SUFDSixJQUFJRCxhQUFhO1FBQ2JDLFNBQVNEO0lBQ2IsT0FDSyxJQUFJLE9BQU9FLFVBQVUsYUFBYTtRQUNuQ0QsU0FBUyxDQUFDLEdBQUdFLE9BQVMsZ0xBQU8sQ0FBd0JDLElBQUksQ0FBQyxDQUFDLEVBQUVDLFNBQVNILE1BQUssRUFBRSxHQUFLQSxVQUFTQztJQUMvRixPQUNLO1FBQ0RGLFNBQVNDO0lBQ2I7SUFDQSxPQUFPLENBQUMsR0FBR0MsT0FBU0YsVUFBVUU7QUFDbEMsRUFBRSxDQUNGLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9mdW5jdGlvbnMtanMvZGlzdC9tb2R1bGUvaGVscGVyLmpzP2I2OTUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuICAgIGxldCBfZmV0Y2g7XG4gICAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIF9mZXRjaCA9ICguLi5hcmdzKSA9PiBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJykudGhlbigoeyBkZWZhdWx0OiBmZXRjaCB9KSA9PiBmZXRjaCguLi5hcmdzKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfZmV0Y2ggPSBmZXRjaDtcbiAgICB9XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBfZmV0Y2goLi4uYXJncyk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJyZXNvbHZlRmV0Y2giLCJjdXN0b21GZXRjaCIsIl9mZXRjaCIsImZldGNoIiwiYXJncyIsInRoZW4iLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/functions-js/dist/module/helper.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/functions-js/dist/module/types.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FunctionRegion: () => (/* binding */ FunctionRegion),\n/* harmony export */   FunctionsError: () => (/* binding */ FunctionsError),\n/* harmony export */   FunctionsFetchError: () => (/* binding */ FunctionsFetchError),\n/* harmony export */   FunctionsHttpError: () => (/* binding */ FunctionsHttpError),\n/* harmony export */   FunctionsRelayError: () => (/* binding */ FunctionsRelayError)\n/* harmony export */ });\nclass FunctionsError extends Error {\n    constructor(message, name = \"FunctionsError\", context){\n        super(message);\n        this.name = name;\n        this.context = context;\n    }\n}\nclass FunctionsFetchError extends FunctionsError {\n    constructor(context){\n        super(\"Failed to send a request to the Edge Function\", \"FunctionsFetchError\", context);\n    }\n}\nclass FunctionsRelayError extends FunctionsError {\n    constructor(context){\n        super(\"Relay Error invoking the Edge Function\", \"FunctionsRelayError\", context);\n    }\n}\nclass FunctionsHttpError extends FunctionsError {\n    constructor(context){\n        super(\"Edge Function returned a non-2xx status code\", \"FunctionsHttpError\", context);\n    }\n}\n// Define the enum for the 'region' property\nvar FunctionRegion;\n(function(FunctionRegion) {\n    FunctionRegion[\"Any\"] = \"any\";\n    FunctionRegion[\"ApNortheast1\"] = \"ap-northeast-1\";\n    FunctionRegion[\"ApNortheast2\"] = \"ap-northeast-2\";\n    FunctionRegion[\"ApSouth1\"] = \"ap-south-1\";\n    FunctionRegion[\"ApSoutheast1\"] = \"ap-southeast-1\";\n    FunctionRegion[\"ApSoutheast2\"] = \"ap-southeast-2\";\n    FunctionRegion[\"CaCentral1\"] = \"ca-central-1\";\n    FunctionRegion[\"EuCentral1\"] = \"eu-central-1\";\n    FunctionRegion[\"EuWest1\"] = \"eu-west-1\";\n    FunctionRegion[\"EuWest2\"] = \"eu-west-2\";\n    FunctionRegion[\"EuWest3\"] = \"eu-west-3\";\n    FunctionRegion[\"SaEast1\"] = \"sa-east-1\";\n    FunctionRegion[\"UsEast1\"] = \"us-east-1\";\n    FunctionRegion[\"UsWest1\"] = \"us-west-1\";\n    FunctionRegion[\"UsWest2\"] = \"us-west-2\";\n})(FunctionRegion || (FunctionRegion = {})); //# sourceMappingURL=types.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcy9kaXN0L21vZHVsZS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFPLE1BQU1BLHVCQUF1QkM7SUFDaENDLFlBQVlDLE9BQU8sRUFBRUMsT0FBTyxnQkFBZ0IsRUFBRUMsT0FBTyxDQUFFO1FBQ25ELEtBQUssQ0FBQ0Y7UUFDTixJQUFJLENBQUNDLElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNDLE9BQU8sR0FBR0E7SUFDbkI7QUFDSjtBQUNPLE1BQU1DLDRCQUE0Qk47SUFDckNFLFlBQVlHLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUMsaURBQWlELHVCQUF1QkE7SUFDbEY7QUFDSjtBQUNPLE1BQU1FLDRCQUE0QlA7SUFDckNFLFlBQVlHLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUMsMENBQTBDLHVCQUF1QkE7SUFDM0U7QUFDSjtBQUNPLE1BQU1HLDJCQUEyQlI7SUFDcENFLFlBQVlHLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUMsZ0RBQWdELHNCQUFzQkE7SUFDaEY7QUFDSjtBQUNBLDRDQUE0QztBQUNyQyxJQUFJSSxlQUFlO0FBQ3pCLFVBQVVBLGNBQWM7SUFDckJBLGNBQWMsQ0FBQyxNQUFNLEdBQUc7SUFDeEJBLGNBQWMsQ0FBQyxlQUFlLEdBQUc7SUFDakNBLGNBQWMsQ0FBQyxlQUFlLEdBQUc7SUFDakNBLGNBQWMsQ0FBQyxXQUFXLEdBQUc7SUFDN0JBLGNBQWMsQ0FBQyxlQUFlLEdBQUc7SUFDakNBLGNBQWMsQ0FBQyxlQUFlLEdBQUc7SUFDakNBLGNBQWMsQ0FBQyxhQUFhLEdBQUc7SUFDL0JBLGNBQWMsQ0FBQyxhQUFhLEdBQUc7SUFDL0JBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7QUFDaEMsR0FBR0Esa0JBQW1CQSxDQUFBQSxpQkFBaUIsQ0FBQyxLQUN4QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvZnVuY3Rpb25zLWpzL2Rpc3QvbW9kdWxlL3R5cGVzLmpzPzY4OGUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG5hbWUgPSAnRnVuY3Rpb25zRXJyb3InLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNGZXRjaEVycm9yIGV4dGVuZHMgRnVuY3Rpb25zRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoJ0ZhaWxlZCB0byBzZW5kIGEgcmVxdWVzdCB0byB0aGUgRWRnZSBGdW5jdGlvbicsICdGdW5jdGlvbnNGZXRjaEVycm9yJywgY29udGV4dCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZ1bmN0aW9uc1JlbGF5RXJyb3IgZXh0ZW5kcyBGdW5jdGlvbnNFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcignUmVsYXkgRXJyb3IgaW52b2tpbmcgdGhlIEVkZ2UgRnVuY3Rpb24nLCAnRnVuY3Rpb25zUmVsYXlFcnJvcicsIGNvbnRleHQpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGdW5jdGlvbnNIdHRwRXJyb3IgZXh0ZW5kcyBGdW5jdGlvbnNFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcignRWRnZSBGdW5jdGlvbiByZXR1cm5lZCBhIG5vbi0yeHggc3RhdHVzIGNvZGUnLCAnRnVuY3Rpb25zSHR0cEVycm9yJywgY29udGV4dCk7XG4gICAgfVxufVxuLy8gRGVmaW5lIHRoZSBlbnVtIGZvciB0aGUgJ3JlZ2lvbicgcHJvcGVydHlcbmV4cG9ydCB2YXIgRnVuY3Rpb25SZWdpb247XG4oZnVuY3Rpb24gKEZ1bmN0aW9uUmVnaW9uKSB7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJBbnlcIl0gPSBcImFueVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQXBOb3J0aGVhc3QxXCJdID0gXCJhcC1ub3J0aGVhc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQXBOb3J0aGVhc3QyXCJdID0gXCJhcC1ub3J0aGVhc3QtMlwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiQXBTb3V0aDFcIl0gPSBcImFwLXNvdXRoLTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFwU291dGhlYXN0MVwiXSA9IFwiYXAtc291dGhlYXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkFwU291dGhlYXN0MlwiXSA9IFwiYXAtc291dGhlYXN0LTJcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkNhQ2VudHJhbDFcIl0gPSBcImNhLWNlbnRyYWwtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiRXVDZW50cmFsMVwiXSA9IFwiZXUtY2VudHJhbC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJFdVdlc3QxXCJdID0gXCJldS13ZXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIkV1V2VzdDJcIl0gPSBcImV1LXdlc3QtMlwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiRXVXZXN0M1wiXSA9IFwiZXUtd2VzdC0zXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJTYUVhc3QxXCJdID0gXCJzYS1lYXN0LTFcIjtcbiAgICBGdW5jdGlvblJlZ2lvbltcIlVzRWFzdDFcIl0gPSBcInVzLWVhc3QtMVwiO1xuICAgIEZ1bmN0aW9uUmVnaW9uW1wiVXNXZXN0MVwiXSA9IFwidXMtd2VzdC0xXCI7XG4gICAgRnVuY3Rpb25SZWdpb25bXCJVc1dlc3QyXCJdID0gXCJ1cy13ZXN0LTJcIjtcbn0pKEZ1bmN0aW9uUmVnaW9uIHx8IChGdW5jdGlvblJlZ2lvbiA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiXSwibmFtZXMiOlsiRnVuY3Rpb25zRXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsIm5hbWUiLCJjb250ZXh0IiwiRnVuY3Rpb25zRmV0Y2hFcnJvciIsIkZ1bmN0aW9uc1JlbGF5RXJyb3IiLCJGdW5jdGlvbnNIdHRwRXJyb3IiLCJGdW5jdGlvblJlZ2lvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/node-fetch/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@supabase/node-fetch/lib/index.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nfunction _interopDefault(ex) {\n    return ex && typeof ex === \"object\" && \"default\" in ex ? ex[\"default\"] : ex;\n}\nvar Stream = _interopDefault(__webpack_require__(/*! stream */ \"stream\"));\nvar http = _interopDefault(__webpack_require__(/*! http */ \"http\"));\nvar Url = _interopDefault(__webpack_require__(/*! url */ \"url\"));\nvar whatwgUrl = _interopDefault(__webpack_require__(/*! whatwg-url */ \"(ssr)/./node_modules/whatwg-url/lib/public-api.js\"));\nvar https = _interopDefault(__webpack_require__(/*! https */ \"https\"));\nvar zlib = _interopDefault(__webpack_require__(/*! zlib */ \"zlib\"));\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n// fix for \"Readable\" isn't a named export issue\nconst Readable = Stream.Readable;\nconst BUFFER = Symbol(\"buffer\");\nconst TYPE = Symbol(\"type\");\nclass Blob {\n    constructor(){\n        this[TYPE] = \"\";\n        const blobParts = arguments[0];\n        const options = arguments[1];\n        const buffers = [];\n        let size = 0;\n        if (blobParts) {\n            const a = blobParts;\n            const length = Number(a.length);\n            for(let i = 0; i < length; i++){\n                const element = a[i];\n                let buffer;\n                if (element instanceof Buffer) {\n                    buffer = element;\n                } else if (ArrayBuffer.isView(element)) {\n                    buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n                } else if (element instanceof ArrayBuffer) {\n                    buffer = Buffer.from(element);\n                } else if (element instanceof Blob) {\n                    buffer = element[BUFFER];\n                } else {\n                    buffer = Buffer.from(typeof element === \"string\" ? element : String(element));\n                }\n                size += buffer.length;\n                buffers.push(buffer);\n            }\n        }\n        this[BUFFER] = Buffer.concat(buffers);\n        let type = options && options.type !== undefined && String(options.type).toLowerCase();\n        if (type && !/[^\\u0020-\\u007E]/.test(type)) {\n            this[TYPE] = type;\n        }\n    }\n    get size() {\n        return this[BUFFER].length;\n    }\n    get type() {\n        return this[TYPE];\n    }\n    text() {\n        return Promise.resolve(this[BUFFER].toString());\n    }\n    arrayBuffer() {\n        const buf = this[BUFFER];\n        const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n        return Promise.resolve(ab);\n    }\n    stream() {\n        const readable = new Readable();\n        readable._read = function() {};\n        readable.push(this[BUFFER]);\n        readable.push(null);\n        return readable;\n    }\n    toString() {\n        return \"[object Blob]\";\n    }\n    slice() {\n        const size = this.size;\n        const start = arguments[0];\n        const end = arguments[1];\n        let relativeStart, relativeEnd;\n        if (start === undefined) {\n            relativeStart = 0;\n        } else if (start < 0) {\n            relativeStart = Math.max(size + start, 0);\n        } else {\n            relativeStart = Math.min(start, size);\n        }\n        if (end === undefined) {\n            relativeEnd = size;\n        } else if (end < 0) {\n            relativeEnd = Math.max(size + end, 0);\n        } else {\n            relativeEnd = Math.min(end, size);\n        }\n        const span = Math.max(relativeEnd - relativeStart, 0);\n        const buffer = this[BUFFER];\n        const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n        const blob = new Blob([], {\n            type: arguments[2]\n        });\n        blob[BUFFER] = slicedBuffer;\n        return blob;\n    }\n}\nObject.defineProperties(Blob.prototype, {\n    size: {\n        enumerable: true\n    },\n    type: {\n        enumerable: true\n    },\n    slice: {\n        enumerable: true\n    }\n});\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n    value: \"Blob\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */ /**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */ function FetchError(message, type, systemError) {\n    Error.call(this, message);\n    this.message = message;\n    this.type = type;\n    // when err.type is `system`, err.code contains system error code\n    if (systemError) {\n        this.code = this.errno = systemError.code;\n    }\n    // hide custom error implementation details from end-users\n    Error.captureStackTrace(this, this.constructor);\n}\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = \"FetchError\";\nlet convert;\nconst INTERNALS = Symbol(\"Body internals\");\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = Stream.PassThrough;\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */ function Body(body) {\n    var _this = this;\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, _ref$size = _ref.size;\n    let size = _ref$size === undefined ? 0 : _ref$size;\n    var _ref$timeout = _ref.timeout;\n    let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n    if (body == null) {\n        // body is undefined or null\n        body = null;\n    } else if (isURLSearchParams(body)) {\n        // body is a URLSearchParams\n        body = Buffer.from(body.toString());\n    } else if (isBlob(body)) ;\n    else if (Buffer.isBuffer(body)) ;\n    else if (Object.prototype.toString.call(body) === \"[object ArrayBuffer]\") {\n        // body is ArrayBuffer\n        body = Buffer.from(body);\n    } else if (ArrayBuffer.isView(body)) {\n        // body is ArrayBufferView\n        body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n    } else if (body instanceof Stream) ;\n    else {\n        // none of the above\n        // coerce to string then buffer\n        body = Buffer.from(String(body));\n    }\n    this[INTERNALS] = {\n        body,\n        disturbed: false,\n        error: null\n    };\n    this.size = size;\n    this.timeout = timeout;\n    if (body instanceof Stream) {\n        body.on(\"error\", function(err) {\n            const error = err.name === \"AbortError\" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, \"system\", err);\n            _this[INTERNALS].error = error;\n        });\n    }\n}\nBody.prototype = {\n    get body () {\n        return this[INTERNALS].body;\n    },\n    get bodyUsed () {\n        return this[INTERNALS].disturbed;\n    },\n    /**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */ arrayBuffer () {\n        return consumeBody.call(this).then(function(buf) {\n            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n        });\n    },\n    /**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */ blob () {\n        let ct = this.headers && this.headers.get(\"content-type\") || \"\";\n        return consumeBody.call(this).then(function(buf) {\n            return Object.assign(// Prevent copying\n            new Blob([], {\n                type: ct.toLowerCase()\n            }), {\n                [BUFFER]: buf\n            });\n        });\n    },\n    /**\n  * Decode response as json\n  *\n  * @return  Promise\n  */ json () {\n        var _this2 = this;\n        return consumeBody.call(this).then(function(buffer) {\n            try {\n                return JSON.parse(buffer.toString());\n            } catch (err) {\n                return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, \"invalid-json\"));\n            }\n        });\n    },\n    /**\n  * Decode response as text\n  *\n  * @return  Promise\n  */ text () {\n        return consumeBody.call(this).then(function(buffer) {\n            return buffer.toString();\n        });\n    },\n    /**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */ buffer () {\n        return consumeBody.call(this);\n    },\n    /**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */ textConverted () {\n        var _this3 = this;\n        return consumeBody.call(this).then(function(buffer) {\n            return convertBody(buffer, _this3.headers);\n        });\n    }\n};\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n    body: {\n        enumerable: true\n    },\n    bodyUsed: {\n        enumerable: true\n    },\n    arrayBuffer: {\n        enumerable: true\n    },\n    blob: {\n        enumerable: true\n    },\n    json: {\n        enumerable: true\n    },\n    text: {\n        enumerable: true\n    }\n});\nBody.mixIn = function(proto) {\n    for (const name of Object.getOwnPropertyNames(Body.prototype)){\n        // istanbul ignore else: future proof\n        if (!(name in proto)) {\n            const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n            Object.defineProperty(proto, name, desc);\n        }\n    }\n};\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */ function consumeBody() {\n    var _this4 = this;\n    if (this[INTERNALS].disturbed) {\n        return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n    }\n    this[INTERNALS].disturbed = true;\n    if (this[INTERNALS].error) {\n        return Body.Promise.reject(this[INTERNALS].error);\n    }\n    let body = this.body;\n    // body is null\n    if (body === null) {\n        return Body.Promise.resolve(Buffer.alloc(0));\n    }\n    // body is blob\n    if (isBlob(body)) {\n        body = body.stream();\n    }\n    // body is buffer\n    if (Buffer.isBuffer(body)) {\n        return Body.Promise.resolve(body);\n    }\n    // istanbul ignore if: should never happen\n    if (!(body instanceof Stream)) {\n        return Body.Promise.resolve(Buffer.alloc(0));\n    }\n    // body is stream\n    // get ready to actually consume the body\n    let accum = [];\n    let accumBytes = 0;\n    let abort = false;\n    return new Body.Promise(function(resolve, reject) {\n        let resTimeout;\n        // allow timeout on slow response body\n        if (_this4.timeout) {\n            resTimeout = setTimeout(function() {\n                abort = true;\n                reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, \"body-timeout\"));\n            }, _this4.timeout);\n        }\n        // handle stream errors\n        body.on(\"error\", function(err) {\n            if (err.name === \"AbortError\") {\n                // if the request was aborted, reject with this Error\n                abort = true;\n                reject(err);\n            } else {\n                // other errors, such as incorrect content-encoding\n                reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, \"system\", err));\n            }\n        });\n        body.on(\"data\", function(chunk) {\n            if (abort || chunk === null) {\n                return;\n            }\n            if (_this4.size && accumBytes + chunk.length > _this4.size) {\n                abort = true;\n                reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, \"max-size\"));\n                return;\n            }\n            accumBytes += chunk.length;\n            accum.push(chunk);\n        });\n        body.on(\"end\", function() {\n            if (abort) {\n                return;\n            }\n            clearTimeout(resTimeout);\n            try {\n                resolve(Buffer.concat(accum, accumBytes));\n            } catch (err) {\n                // handle streams that have accumulated too much data (issue #414)\n                reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, \"system\", err));\n            }\n        });\n    });\n}\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */ function convertBody(buffer, headers) {\n    {\n        throw new Error(\"The package `encoding` must be installed to use the textConverted() function\");\n    }\n    const ct = headers.get(\"content-type\");\n    let charset = \"utf-8\";\n    let res, str;\n    // header\n    if (ct) {\n        res = /charset=([^;]*)/i.exec(ct);\n    }\n    // no charset in content type, peek at response body for at most 1024 bytes\n    str = buffer.slice(0, 1024).toString();\n    // html5\n    if (!res && str) {\n        res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n    }\n    // html4\n    if (!res && str) {\n        res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n        if (!res) {\n            res = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n            if (res) {\n                res.pop(); // drop last quote\n            }\n        }\n        if (res) {\n            res = /charset=(.*)/i.exec(res.pop());\n        }\n    }\n    // xml\n    if (!res && str) {\n        res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n    }\n    // found charset\n    if (res) {\n        charset = res.pop();\n        // prevent decode issues when sites use incorrect encoding\n        // ref: https://hsivonen.fi/encoding-menu/\n        if (charset === \"gb2312\" || charset === \"gbk\") {\n            charset = \"gb18030\";\n        }\n    }\n    // turn raw buffers into a single utf-8 buffer\n    return convert(buffer, \"UTF-8\", charset).toString();\n}\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */ function isURLSearchParams(obj) {\n    // Duck-typing as a necessary condition.\n    if (typeof obj !== \"object\" || typeof obj.append !== \"function\" || typeof obj.delete !== \"function\" || typeof obj.get !== \"function\" || typeof obj.getAll !== \"function\" || typeof obj.has !== \"function\" || typeof obj.set !== \"function\") {\n        return false;\n    }\n    // Brand-checking and more duck-typing as optional condition.\n    return obj.constructor.name === \"URLSearchParams\" || Object.prototype.toString.call(obj) === \"[object URLSearchParams]\" || typeof obj.sort === \"function\";\n}\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */ function isBlob(obj) {\n    return typeof obj === \"object\" && typeof obj.arrayBuffer === \"function\" && typeof obj.type === \"string\" && typeof obj.stream === \"function\" && typeof obj.constructor === \"function\" && typeof obj.constructor.name === \"string\" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */ function clone(instance) {\n    let p1, p2;\n    let body = instance.body;\n    // don't allow cloning a used body\n    if (instance.bodyUsed) {\n        throw new Error(\"cannot clone body after it is used\");\n    }\n    // check that body is a stream and not form-data object\n    // note: we can't clone the form-data object without having it as a dependency\n    if (body instanceof Stream && typeof body.getBoundary !== \"function\") {\n        // tee instance body\n        p1 = new PassThrough();\n        p2 = new PassThrough();\n        body.pipe(p1);\n        body.pipe(p2);\n        // set instance body to teed body and return the other teed body\n        instance[INTERNALS].body = p1;\n        body = p2;\n    }\n    return body;\n}\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */ function extractContentType(body) {\n    if (body === null) {\n        // body is null\n        return null;\n    } else if (typeof body === \"string\") {\n        // body is string\n        return \"text/plain;charset=UTF-8\";\n    } else if (isURLSearchParams(body)) {\n        // body is a URLSearchParams\n        return \"application/x-www-form-urlencoded;charset=UTF-8\";\n    } else if (isBlob(body)) {\n        // body is blob\n        return body.type || null;\n    } else if (Buffer.isBuffer(body)) {\n        // body is buffer\n        return null;\n    } else if (Object.prototype.toString.call(body) === \"[object ArrayBuffer]\") {\n        // body is ArrayBuffer\n        return null;\n    } else if (ArrayBuffer.isView(body)) {\n        // body is ArrayBufferView\n        return null;\n    } else if (typeof body.getBoundary === \"function\") {\n        // detect form data input from form-data module\n        return `multipart/form-data;boundary=${body.getBoundary()}`;\n    } else if (body instanceof Stream) {\n        // body is stream\n        // can't really do much about this\n        return null;\n    } else {\n        // Body constructor defaults other things to string\n        return \"text/plain;charset=UTF-8\";\n    }\n}\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */ function getTotalBytes(instance) {\n    const body = instance.body;\n    if (body === null) {\n        // body is null\n        return 0;\n    } else if (isBlob(body)) {\n        return body.size;\n    } else if (Buffer.isBuffer(body)) {\n        // body is buffer\n        return body.length;\n    } else if (body && typeof body.getLengthSync === \"function\") {\n        // detect form data input from form-data module\n        if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n        body.hasKnownLength && body.hasKnownLength()) {\n            // 2.x\n            return body.getLengthSync();\n        }\n        return null;\n    } else {\n        // body is stream\n        return null;\n    }\n}\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */ function writeToStream(dest, instance) {\n    const body = instance.body;\n    if (body === null) {\n        // body is null\n        dest.end();\n    } else if (isBlob(body)) {\n        body.stream().pipe(dest);\n    } else if (Buffer.isBuffer(body)) {\n        // body is buffer\n        dest.write(body);\n        dest.end();\n    } else {\n        // body is stream\n        body.pipe(dest);\n    }\n}\n// expose Promise\nBody.Promise = global.Promise;\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */ const invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\nfunction validateName(name) {\n    name = `${name}`;\n    if (invalidTokenRegex.test(name) || name === \"\") {\n        throw new TypeError(`${name} is not a legal HTTP header name`);\n    }\n}\nfunction validateValue(value) {\n    value = `${value}`;\n    if (invalidHeaderCharRegex.test(value)) {\n        throw new TypeError(`${value} is not a legal HTTP header value`);\n    }\n}\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */ function find(map, name) {\n    name = name.toLowerCase();\n    for(const key in map){\n        if (key.toLowerCase() === name) {\n            return key;\n        }\n    }\n    return undefined;\n}\nconst MAP = Symbol(\"map\");\nclass Headers {\n    /**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */ constructor(){\n        let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n        this[MAP] = Object.create(null);\n        if (init instanceof Headers) {\n            const rawHeaders = init.raw();\n            const headerNames = Object.keys(rawHeaders);\n            for (const headerName of headerNames){\n                for (const value of rawHeaders[headerName]){\n                    this.append(headerName, value);\n                }\n            }\n            return;\n        }\n        // We don't worry about converting prop to ByteString here as append()\n        // will handle it.\n        if (init == null) ;\n        else if (typeof init === \"object\") {\n            const method = init[Symbol.iterator];\n            if (method != null) {\n                if (typeof method !== \"function\") {\n                    throw new TypeError(\"Header pairs must be iterable\");\n                }\n                // sequence<sequence<ByteString>>\n                // Note: per spec we have to first exhaust the lists then process them\n                const pairs = [];\n                for (const pair of init){\n                    if (typeof pair !== \"object\" || typeof pair[Symbol.iterator] !== \"function\") {\n                        throw new TypeError(\"Each header pair must be iterable\");\n                    }\n                    pairs.push(Array.from(pair));\n                }\n                for (const pair of pairs){\n                    if (pair.length !== 2) {\n                        throw new TypeError(\"Each header pair must be a name/value tuple\");\n                    }\n                    this.append(pair[0], pair[1]);\n                }\n            } else {\n                // record<ByteString, ByteString>\n                for (const key of Object.keys(init)){\n                    const value = init[key];\n                    this.append(key, value);\n                }\n            }\n        } else {\n            throw new TypeError(\"Provided initializer must be an object\");\n        }\n    }\n    /**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */ get(name) {\n        name = `${name}`;\n        validateName(name);\n        const key = find(this[MAP], name);\n        if (key === undefined) {\n            return null;\n        }\n        return this[MAP][key].join(\", \");\n    }\n    /**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */ forEach(callback) {\n        let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n        let pairs = getHeaders(this);\n        let i = 0;\n        while(i < pairs.length){\n            var _pairs$i = pairs[i];\n            const name = _pairs$i[0], value = _pairs$i[1];\n            callback.call(thisArg, value, name, this);\n            pairs = getHeaders(this);\n            i++;\n        }\n    }\n    /**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */ set(name, value) {\n        name = `${name}`;\n        value = `${value}`;\n        validateName(name);\n        validateValue(value);\n        const key = find(this[MAP], name);\n        this[MAP][key !== undefined ? key : name] = [\n            value\n        ];\n    }\n    /**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */ append(name, value) {\n        name = `${name}`;\n        value = `${value}`;\n        validateName(name);\n        validateValue(value);\n        const key = find(this[MAP], name);\n        if (key !== undefined) {\n            this[MAP][key].push(value);\n        } else {\n            this[MAP][name] = [\n                value\n            ];\n        }\n    }\n    /**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */ has(name) {\n        name = `${name}`;\n        validateName(name);\n        return find(this[MAP], name) !== undefined;\n    }\n    /**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */ delete(name) {\n        name = `${name}`;\n        validateName(name);\n        const key = find(this[MAP], name);\n        if (key !== undefined) {\n            delete this[MAP][key];\n        }\n    }\n    /**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */ raw() {\n        return this[MAP];\n    }\n    /**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */ keys() {\n        return createHeadersIterator(this, \"key\");\n    }\n    /**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */ values() {\n        return createHeadersIterator(this, \"value\");\n    }\n    /**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */ [Symbol.iterator]() {\n        return createHeadersIterator(this, \"key+value\");\n    }\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n    value: \"Headers\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\nObject.defineProperties(Headers.prototype, {\n    get: {\n        enumerable: true\n    },\n    forEach: {\n        enumerable: true\n    },\n    set: {\n        enumerable: true\n    },\n    append: {\n        enumerable: true\n    },\n    has: {\n        enumerable: true\n    },\n    delete: {\n        enumerable: true\n    },\n    keys: {\n        enumerable: true\n    },\n    values: {\n        enumerable: true\n    },\n    entries: {\n        enumerable: true\n    }\n});\nfunction getHeaders(headers) {\n    let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"key+value\";\n    const keys = Object.keys(headers[MAP]).sort();\n    return keys.map(kind === \"key\" ? function(k) {\n        return k.toLowerCase();\n    } : kind === \"value\" ? function(k) {\n        return headers[MAP][k].join(\", \");\n    } : function(k) {\n        return [\n            k.toLowerCase(),\n            headers[MAP][k].join(\", \")\n        ];\n    });\n}\nconst INTERNAL = Symbol(\"internal\");\nfunction createHeadersIterator(target, kind) {\n    const iterator = Object.create(HeadersIteratorPrototype);\n    iterator[INTERNAL] = {\n        target,\n        kind,\n        index: 0\n    };\n    return iterator;\n}\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n    next () {\n        // istanbul ignore if\n        if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n            throw new TypeError(\"Value of `this` is not a HeadersIterator\");\n        }\n        var _INTERNAL = this[INTERNAL];\n        const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;\n        const values = getHeaders(target, kind);\n        const len = values.length;\n        if (index >= len) {\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n        this[INTERNAL].index = index + 1;\n        return {\n            value: values[index],\n            done: false\n        };\n    }\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n    value: \"HeadersIterator\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */ function exportNodeCompatibleHeaders(headers) {\n    const obj = Object.assign({\n        __proto__: null\n    }, headers[MAP]);\n    // http.request() only supports string as Host header. This hack makes\n    // specifying custom Host header possible.\n    const hostHeaderKey = find(headers[MAP], \"Host\");\n    if (hostHeaderKey !== undefined) {\n        obj[hostHeaderKey] = obj[hostHeaderKey][0];\n    }\n    return obj;\n}\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */ function createHeadersLenient(obj) {\n    const headers = new Headers();\n    for (const name of Object.keys(obj)){\n        if (invalidTokenRegex.test(name)) {\n            continue;\n        }\n        if (Array.isArray(obj[name])) {\n            for (const val of obj[name]){\n                if (invalidHeaderCharRegex.test(val)) {\n                    continue;\n                }\n                if (headers[MAP][name] === undefined) {\n                    headers[MAP][name] = [\n                        val\n                    ];\n                } else {\n                    headers[MAP][name].push(val);\n                }\n            }\n        } else if (!invalidHeaderCharRegex.test(obj[name])) {\n            headers[MAP][name] = [\n                obj[name]\n            ];\n        }\n    }\n    return headers;\n}\nconst INTERNALS$1 = Symbol(\"Response internals\");\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http.STATUS_CODES;\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */ class Response {\n    constructor(){\n        let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        Body.call(this, body, opts);\n        const status = opts.status || 200;\n        const headers = new Headers(opts.headers);\n        if (body != null && !headers.has(\"Content-Type\")) {\n            const contentType = extractContentType(body);\n            if (contentType) {\n                headers.append(\"Content-Type\", contentType);\n            }\n        }\n        this[INTERNALS$1] = {\n            url: opts.url,\n            status,\n            statusText: opts.statusText || STATUS_CODES[status],\n            headers,\n            counter: opts.counter\n        };\n    }\n    get url() {\n        return this[INTERNALS$1].url || \"\";\n    }\n    get status() {\n        return this[INTERNALS$1].status;\n    }\n    /**\n  * Convenience property representing if the request ended normally\n  */ get ok() {\n        return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n    }\n    get redirected() {\n        return this[INTERNALS$1].counter > 0;\n    }\n    get statusText() {\n        return this[INTERNALS$1].statusText;\n    }\n    get headers() {\n        return this[INTERNALS$1].headers;\n    }\n    /**\n  * Clone this response\n  *\n  * @return  Response\n  */ clone() {\n        return new Response(clone(this), {\n            url: this.url,\n            status: this.status,\n            statusText: this.statusText,\n            headers: this.headers,\n            ok: this.ok,\n            redirected: this.redirected\n        });\n    }\n}\nBody.mixIn(Response.prototype);\nObject.defineProperties(Response.prototype, {\n    url: {\n        enumerable: true\n    },\n    status: {\n        enumerable: true\n    },\n    ok: {\n        enumerable: true\n    },\n    redirected: {\n        enumerable: true\n    },\n    statusText: {\n        enumerable: true\n    },\n    headers: {\n        enumerable: true\n    },\n    clone: {\n        enumerable: true\n    }\n});\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n    value: \"Response\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\nconst INTERNALS$2 = Symbol(\"Request internals\");\nconst URL = Url.URL || whatwgUrl.URL;\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = Url.parse;\nconst format_url = Url.format;\n/**\n * Wrapper around `new URL` to handle arbitrary URLs\n *\n * @param  {string} urlStr\n * @return {void}\n */ function parseURL(urlStr) {\n    /*\n \tCheck whether the URL is absolute or not\n \t\tScheme: https://tools.ietf.org/html/rfc3986#section-3.1\n \tAbsolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\n */ if (/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.exec(urlStr)) {\n        urlStr = new URL(urlStr).toString();\n    }\n    // Fallback to old implementation for arbitrary URLs\n    return parse_url(urlStr);\n}\nconst streamDestructionSupported = \"destroy\" in Stream.Readable.prototype;\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */ function isRequest(input) {\n    return typeof input === \"object\" && typeof input[INTERNALS$2] === \"object\";\n}\nfunction isAbortSignal(signal) {\n    const proto = signal && typeof signal === \"object\" && Object.getPrototypeOf(signal);\n    return !!(proto && proto.constructor.name === \"AbortSignal\");\n}\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */ class Request {\n    constructor(input){\n        let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let parsedURL;\n        // normalize input\n        if (!isRequest(input)) {\n            if (input && input.href) {\n                // in order to support Node.js' Url objects; though WHATWG's URL objects\n                // will fall into this branch also (since their `toString()` will return\n                // `href` property anyway)\n                parsedURL = parseURL(input.href);\n            } else {\n                // coerce input to a string before attempting to parse\n                parsedURL = parseURL(`${input}`);\n            }\n            input = {};\n        } else {\n            parsedURL = parseURL(input.url);\n        }\n        let method = init.method || input.method || \"GET\";\n        method = method.toUpperCase();\n        if ((init.body != null || isRequest(input) && input.body !== null) && (method === \"GET\" || method === \"HEAD\")) {\n            throw new TypeError(\"Request with GET/HEAD method cannot have body\");\n        }\n        let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n        Body.call(this, inputBody, {\n            timeout: init.timeout || input.timeout || 0,\n            size: init.size || input.size || 0\n        });\n        const headers = new Headers(init.headers || input.headers || {});\n        if (inputBody != null && !headers.has(\"Content-Type\")) {\n            const contentType = extractContentType(inputBody);\n            if (contentType) {\n                headers.append(\"Content-Type\", contentType);\n            }\n        }\n        let signal = isRequest(input) ? input.signal : null;\n        if (\"signal\" in init) signal = init.signal;\n        if (signal != null && !isAbortSignal(signal)) {\n            throw new TypeError(\"Expected signal to be an instanceof AbortSignal\");\n        }\n        this[INTERNALS$2] = {\n            method,\n            redirect: init.redirect || input.redirect || \"follow\",\n            headers,\n            parsedURL,\n            signal\n        };\n        // node-fetch-only options\n        this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n        this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n        this.counter = init.counter || input.counter || 0;\n        this.agent = init.agent || input.agent;\n    }\n    get method() {\n        return this[INTERNALS$2].method;\n    }\n    get url() {\n        return format_url(this[INTERNALS$2].parsedURL);\n    }\n    get headers() {\n        return this[INTERNALS$2].headers;\n    }\n    get redirect() {\n        return this[INTERNALS$2].redirect;\n    }\n    get signal() {\n        return this[INTERNALS$2].signal;\n    }\n    /**\n  * Clone this request\n  *\n  * @return  Request\n  */ clone() {\n        return new Request(this);\n    }\n}\nBody.mixIn(Request.prototype);\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n    value: \"Request\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\nObject.defineProperties(Request.prototype, {\n    method: {\n        enumerable: true\n    },\n    url: {\n        enumerable: true\n    },\n    headers: {\n        enumerable: true\n    },\n    redirect: {\n        enumerable: true\n    },\n    clone: {\n        enumerable: true\n    },\n    signal: {\n        enumerable: true\n    }\n});\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */ function getNodeRequestOptions(request) {\n    const parsedURL = request[INTERNALS$2].parsedURL;\n    const headers = new Headers(request[INTERNALS$2].headers);\n    // fetch step 1.3\n    if (!headers.has(\"Accept\")) {\n        headers.set(\"Accept\", \"*/*\");\n    }\n    // Basic fetch\n    if (!parsedURL.protocol || !parsedURL.hostname) {\n        throw new TypeError(\"Only absolute URLs are supported\");\n    }\n    if (!/^https?:$/.test(parsedURL.protocol)) {\n        throw new TypeError(\"Only HTTP(S) protocols are supported\");\n    }\n    if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {\n        throw new Error(\"Cancellation of streamed requests with AbortSignal is not supported in node < 8\");\n    }\n    // HTTP-network-or-cache fetch steps 2.4-2.7\n    let contentLengthValue = null;\n    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n        contentLengthValue = \"0\";\n    }\n    if (request.body != null) {\n        const totalBytes = getTotalBytes(request);\n        if (typeof totalBytes === \"number\") {\n            contentLengthValue = String(totalBytes);\n        }\n    }\n    if (contentLengthValue) {\n        headers.set(\"Content-Length\", contentLengthValue);\n    }\n    // HTTP-network-or-cache fetch step 2.11\n    if (!headers.has(\"User-Agent\")) {\n        headers.set(\"User-Agent\", \"node-fetch/1.0 (+https://github.com/bitinn/node-fetch)\");\n    }\n    // HTTP-network-or-cache fetch step 2.15\n    if (request.compress && !headers.has(\"Accept-Encoding\")) {\n        headers.set(\"Accept-Encoding\", \"gzip,deflate\");\n    }\n    let agent = request.agent;\n    if (typeof agent === \"function\") {\n        agent = agent(parsedURL);\n    }\n    if (!headers.has(\"Connection\") && !agent) {\n        headers.set(\"Connection\", \"close\");\n    }\n    // HTTP-network fetch step 4.2\n    // chunked encoding is handled by Node.js\n    return Object.assign({}, parsedURL, {\n        method: request.method,\n        headers: exportNodeCompatibleHeaders(headers),\n        agent\n    });\n}\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */ /**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */ function AbortError(message) {\n    Error.call(this, message);\n    this.type = \"aborted\";\n    this.message = message;\n    // hide custom error implementation details from end-users\n    Error.captureStackTrace(this, this.constructor);\n}\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = \"AbortError\";\nconst URL$1 = Url.URL || whatwgUrl.URL;\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = Stream.PassThrough;\nconst isDomainOrSubdomain = function isDomainOrSubdomain(destination, original) {\n    const orig = new URL$1(original).hostname;\n    const dest = new URL$1(destination).hostname;\n    return orig === dest || orig[orig.length - dest.length - 1] === \".\" && orig.endsWith(dest);\n};\n/**\n * isSameProtocol reports whether the two provided URLs use the same protocol.\n *\n * Both domains must already be in canonical form.\n * @param {string|URL} original\n * @param {string|URL} destination\n */ const isSameProtocol = function isSameProtocol(destination, original) {\n    const orig = new URL$1(original).protocol;\n    const dest = new URL$1(destination).protocol;\n    return orig === dest;\n};\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */ function fetch(url, opts) {\n    // allow custom promise\n    if (!fetch.Promise) {\n        throw new Error(\"native promise missing, set fetch.Promise to your favorite alternative\");\n    }\n    Body.Promise = fetch.Promise;\n    // wrap http.request into fetch\n    return new fetch.Promise(function(resolve, reject) {\n        // build request object\n        const request = new Request(url, opts);\n        const options = getNodeRequestOptions(request);\n        const send = (options.protocol === \"https:\" ? https : http).request;\n        const signal = request.signal;\n        let response = null;\n        const abort = function abort() {\n            let error = new AbortError(\"The user aborted a request.\");\n            reject(error);\n            if (request.body && request.body instanceof Stream.Readable) {\n                destroyStream(request.body, error);\n            }\n            if (!response || !response.body) return;\n            response.body.emit(\"error\", error);\n        };\n        if (signal && signal.aborted) {\n            abort();\n            return;\n        }\n        const abortAndFinalize = function abortAndFinalize() {\n            abort();\n            finalize();\n        };\n        // send request\n        const req = send(options);\n        let reqTimeout;\n        if (signal) {\n            signal.addEventListener(\"abort\", abortAndFinalize);\n        }\n        function finalize() {\n            req.abort();\n            if (signal) signal.removeEventListener(\"abort\", abortAndFinalize);\n            clearTimeout(reqTimeout);\n        }\n        if (request.timeout) {\n            req.once(\"socket\", function(socket) {\n                reqTimeout = setTimeout(function() {\n                    reject(new FetchError(`network timeout at: ${request.url}`, \"request-timeout\"));\n                    finalize();\n                }, request.timeout);\n            });\n        }\n        req.on(\"error\", function(err) {\n            reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, \"system\", err));\n            if (response && response.body) {\n                destroyStream(response.body, err);\n            }\n            finalize();\n        });\n        fixResponseChunkedTransferBadEnding(req, function(err) {\n            if (signal && signal.aborted) {\n                return;\n            }\n            if (response && response.body) {\n                destroyStream(response.body, err);\n            }\n        });\n        /* c8 ignore next 18 */ if (parseInt(process.version.substring(1)) < 14) {\n            // Before Node.js 14, pipeline() does not fully support async iterators and does not always\n            // properly handle when the socket close/end events are out of order.\n            req.on(\"socket\", function(s) {\n                s.addListener(\"close\", function(hadError) {\n                    // if a data listener is still present we didn't end cleanly\n                    const hasDataListener = s.listenerCount(\"data\") > 0;\n                    // if end happened before close but the socket didn't emit an error, do it now\n                    if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {\n                        const err = new Error(\"Premature close\");\n                        err.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n                        response.body.emit(\"error\", err);\n                    }\n                });\n            });\n        }\n        req.on(\"response\", function(res) {\n            clearTimeout(reqTimeout);\n            const headers = createHeadersLenient(res.headers);\n            // HTTP fetch step 5\n            if (fetch.isRedirect(res.statusCode)) {\n                // HTTP fetch step 5.2\n                const location = headers.get(\"Location\");\n                // HTTP fetch step 5.3\n                let locationURL = null;\n                try {\n                    locationURL = location === null ? null : new URL$1(location, request.url).toString();\n                } catch (err) {\n                    // error here can only be invalid URL in Location: header\n                    // do not throw when options.redirect == manual\n                    // let the user extract the errorneous redirect URL\n                    if (request.redirect !== \"manual\") {\n                        reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, \"invalid-redirect\"));\n                        finalize();\n                        return;\n                    }\n                }\n                // HTTP fetch step 5.5\n                switch(request.redirect){\n                    case \"error\":\n                        reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, \"no-redirect\"));\n                        finalize();\n                        return;\n                    case \"manual\":\n                        // node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n                        if (locationURL !== null) {\n                            // handle corrupted header\n                            try {\n                                headers.set(\"Location\", locationURL);\n                            } catch (err) {\n                                // istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n                                reject(err);\n                            }\n                        }\n                        break;\n                    case \"follow\":\n                        // HTTP-redirect fetch step 2\n                        if (locationURL === null) {\n                            break;\n                        }\n                        // HTTP-redirect fetch step 5\n                        if (request.counter >= request.follow) {\n                            reject(new FetchError(`maximum redirect reached at: ${request.url}`, \"max-redirect\"));\n                            finalize();\n                            return;\n                        }\n                        // HTTP-redirect fetch step 6 (counter increment)\n                        // Create a new Request object.\n                        const requestOpts = {\n                            headers: new Headers(request.headers),\n                            follow: request.follow,\n                            counter: request.counter + 1,\n                            agent: request.agent,\n                            compress: request.compress,\n                            method: request.method,\n                            body: request.body,\n                            signal: request.signal,\n                            timeout: request.timeout,\n                            size: request.size\n                        };\n                        if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {\n                            for (const name of [\n                                \"authorization\",\n                                \"www-authenticate\",\n                                \"cookie\",\n                                \"cookie2\"\n                            ]){\n                                requestOpts.headers.delete(name);\n                            }\n                        }\n                        // HTTP-redirect fetch step 9\n                        if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n                            reject(new FetchError(\"Cannot follow redirect with body being a readable stream\", \"unsupported-redirect\"));\n                            finalize();\n                            return;\n                        }\n                        // HTTP-redirect fetch step 11\n                        if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === \"POST\") {\n                            requestOpts.method = \"GET\";\n                            requestOpts.body = undefined;\n                            requestOpts.headers.delete(\"content-length\");\n                        }\n                        // HTTP-redirect fetch step 15\n                        resolve(fetch(new Request(locationURL, requestOpts)));\n                        finalize();\n                        return;\n                }\n            }\n            // prepare response\n            res.once(\"end\", function() {\n                if (signal) signal.removeEventListener(\"abort\", abortAndFinalize);\n            });\n            let body = res.pipe(new PassThrough$1());\n            const response_options = {\n                url: request.url,\n                status: res.statusCode,\n                statusText: res.statusMessage,\n                headers: headers,\n                size: request.size,\n                timeout: request.timeout,\n                counter: request.counter\n            };\n            // HTTP-network fetch step 12.1.1.3\n            const codings = headers.get(\"Content-Encoding\");\n            // HTTP-network fetch step 12.1.1.4: handle content codings\n            // in following scenarios we ignore compression support\n            // 1. compression support is disabled\n            // 2. HEAD request\n            // 3. no Content-Encoding header\n            // 4. no content response (204)\n            // 5. content not modified response (304)\n            if (!request.compress || request.method === \"HEAD\" || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n                response = new Response(body, response_options);\n                resolve(response);\n                return;\n            }\n            // For Node v6+\n            // Be less strict when decoding compressed responses, since sometimes\n            // servers send slightly invalid responses that are still accepted\n            // by common browsers.\n            // Always using Z_SYNC_FLUSH is what cURL does.\n            const zlibOptions = {\n                flush: zlib.Z_SYNC_FLUSH,\n                finishFlush: zlib.Z_SYNC_FLUSH\n            };\n            // for gzip\n            if (codings == \"gzip\" || codings == \"x-gzip\") {\n                body = body.pipe(zlib.createGunzip(zlibOptions));\n                response = new Response(body, response_options);\n                resolve(response);\n                return;\n            }\n            // for deflate\n            if (codings == \"deflate\" || codings == \"x-deflate\") {\n                // handle the infamous raw deflate response from old servers\n                // a hack for old IIS and Apache servers\n                const raw = res.pipe(new PassThrough$1());\n                raw.once(\"data\", function(chunk) {\n                    // see http://stackoverflow.com/questions/37519828\n                    if ((chunk[0] & 0x0F) === 0x08) {\n                        body = body.pipe(zlib.createInflate());\n                    } else {\n                        body = body.pipe(zlib.createInflateRaw());\n                    }\n                    response = new Response(body, response_options);\n                    resolve(response);\n                });\n                raw.on(\"end\", function() {\n                    // some old IIS servers return zero-length OK deflate responses, so 'data' is never emitted.\n                    if (!response) {\n                        response = new Response(body, response_options);\n                        resolve(response);\n                    }\n                });\n                return;\n            }\n            // for br\n            if (codings == \"br\" && typeof zlib.createBrotliDecompress === \"function\") {\n                body = body.pipe(zlib.createBrotliDecompress());\n                response = new Response(body, response_options);\n                resolve(response);\n                return;\n            }\n            // otherwise, use response as-is\n            response = new Response(body, response_options);\n            resolve(response);\n        });\n        writeToStream(req, request);\n    });\n}\nfunction fixResponseChunkedTransferBadEnding(request, errorCallback) {\n    let socket;\n    request.on(\"socket\", function(s) {\n        socket = s;\n    });\n    request.on(\"response\", function(response) {\n        const headers = response.headers;\n        if (headers[\"transfer-encoding\"] === \"chunked\" && !headers[\"content-length\"]) {\n            response.once(\"close\", function(hadError) {\n                // tests for socket presence, as in some situations the\n                // the 'socket' event is not triggered for the request\n                // (happens in deno), avoids `TypeError`\n                // if a data listener is still present we didn't end cleanly\n                const hasDataListener = socket && socket.listenerCount(\"data\") > 0;\n                if (hasDataListener && !hadError) {\n                    const err = new Error(\"Premature close\");\n                    err.code = \"ERR_STREAM_PREMATURE_CLOSE\";\n                    errorCallback(err);\n                }\n            });\n        }\n    });\n}\nfunction destroyStream(stream, err) {\n    if (stream.destroy) {\n        stream.destroy(err);\n    } else {\n        // node < 8\n        stream.emit(\"error\", err);\n        stream.end();\n    }\n}\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */ fetch.isRedirect = function(code) {\n    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n// expose Promise\nfetch.Promise = global.Promise;\nmodule.exports = exports = fetch;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports[\"default\"] = exports;\nexports.Headers = Headers;\nexports.Request = Request;\nexports.Response = Response;\nexports.FetchError = FetchError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL25vZGUtZmV0Y2gvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELFNBQVNDLGdCQUFpQkMsRUFBRTtJQUFJLE9BQU8sTUFBUSxPQUFPQSxPQUFPLFlBQWEsYUFBYUEsS0FBTUEsRUFBRSxDQUFDLFVBQVUsR0FBR0E7QUFBSTtBQUVqSCxJQUFJQyxTQUFTRixnQkFBZ0JHLG1CQUFPQSxDQUFDO0FBQ3JDLElBQUlDLE9BQU9KLGdCQUFnQkcsbUJBQU9BLENBQUM7QUFDbkMsSUFBSUUsTUFBTUwsZ0JBQWdCRyxtQkFBT0EsQ0FBQztBQUNsQyxJQUFJRyxZQUFZTixnQkFBZ0JHLG1CQUFPQSxDQUFDO0FBQ3hDLElBQUlJLFFBQVFQLGdCQUFnQkcsbUJBQU9BLENBQUM7QUFDcEMsSUFBSUssT0FBT1IsZ0JBQWdCRyxtQkFBT0EsQ0FBQztBQUVuQyxrSEFBa0g7QUFFbEgsZ0RBQWdEO0FBQ2hELE1BQU1NLFdBQVdQLE9BQU9PLFFBQVE7QUFFaEMsTUFBTUMsU0FBU0MsT0FBTztBQUN0QixNQUFNQyxPQUFPRCxPQUFPO0FBRXBCLE1BQU1FO0lBQ0xDLGFBQWM7UUFDYixJQUFJLENBQUNGLEtBQUssR0FBRztRQUViLE1BQU1HLFlBQVlDLFNBQVMsQ0FBQyxFQUFFO1FBQzlCLE1BQU1DLFVBQVVELFNBQVMsQ0FBQyxFQUFFO1FBRTVCLE1BQU1FLFVBQVUsRUFBRTtRQUNsQixJQUFJQyxPQUFPO1FBRVgsSUFBSUosV0FBVztZQUNkLE1BQU1LLElBQUlMO1lBQ1YsTUFBTU0sU0FBU0MsT0FBT0YsRUFBRUMsTUFBTTtZQUM5QixJQUFLLElBQUlFLElBQUksR0FBR0EsSUFBSUYsUUFBUUUsSUFBSztnQkFDaEMsTUFBTUMsVUFBVUosQ0FBQyxDQUFDRyxFQUFFO2dCQUNwQixJQUFJRTtnQkFDSixJQUFJRCxtQkFBbUJFLFFBQVE7b0JBQzlC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Q2pGO0FBRUEsaUJBQWlCO0FBQ2pCNkssTUFBTTVNLE9BQU8sR0FBRzhHLE9BQU85RyxPQUFPO0FBRTlCc1AsT0FBT2hTLE9BQU8sR0FBR0EsVUFBVXNQO0FBQzNCeFAsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFlLEdBQUdBO0FBQ2xCQSxlQUFlLEdBQUdpSztBQUNsQmpLLGVBQWUsR0FBRzhOO0FBQ2xCOU4sZ0JBQWdCLEdBQUcwTTtBQUNuQjFNLGtCQUFrQixHQUFHb0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvbm9kZS1mZXRjaC9saWIvaW5kZXguanM/ZWUyYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgU3RyZWFtID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3N0cmVhbScpKTtcbnZhciBodHRwID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2h0dHAnKSk7XG52YXIgVXJsID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3VybCcpKTtcbnZhciB3aGF0d2dVcmwgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnd2hhdHdnLXVybCcpKTtcbnZhciBodHRwcyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdodHRwcycpKTtcbnZhciB6bGliID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3psaWInKSk7XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS90bXB2YXIvanNkb20vYmxvYi9hYTg1YjJhYmYwNzc2NmZmN2JmNWMxZjZkYWFmYjM3MjZmMmYyZGI1L2xpYi9qc2RvbS9saXZpbmcvYmxvYi5qc1xuXG4vLyBmaXggZm9yIFwiUmVhZGFibGVcIiBpc24ndCBhIG5hbWVkIGV4cG9ydCBpc3N1ZVxuY29uc3QgUmVhZGFibGUgPSBTdHJlYW0uUmVhZGFibGU7XG5cbmNvbnN0IEJVRkZFUiA9IFN5bWJvbCgnYnVmZmVyJyk7XG5jb25zdCBUWVBFID0gU3ltYm9sKCd0eXBlJyk7XG5cbmNsYXNzIEJsb2Ige1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzW1RZUEVdID0gJyc7XG5cblx0XHRjb25zdCBibG9iUGFydHMgPSBhcmd1bWVudHNbMF07XG5cdFx0Y29uc3Qgb3B0aW9ucyA9IGFyZ3VtZW50c1sxXTtcblxuXHRcdGNvbnN0IGJ1ZmZlcnMgPSBbXTtcblx0XHRsZXQgc2l6ZSA9IDA7XG5cblx0XHRpZiAoYmxvYlBhcnRzKSB7XG5cdFx0XHRjb25zdCBhID0gYmxvYlBhcnRzO1xuXHRcdFx0Y29uc3QgbGVuZ3RoID0gTnVtYmVyKGEubGVuZ3RoKTtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgZWxlbWVudCA9IGFbaV07XG5cdFx0XHRcdGxldCBidWZmZXI7XG5cdFx0XHRcdGlmIChlbGVtZW50IGluc3RhbmNlb2YgQnVmZmVyKSB7XG5cdFx0XHRcdFx0YnVmZmVyID0gZWxlbWVudDtcblx0XHRcdFx0fSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZWxlbWVudCkpIHtcblx0XHRcdFx0XHRidWZmZXIgPSBCdWZmZXIuZnJvbShlbGVtZW50LmJ1ZmZlciwgZWxlbWVudC5ieXRlT2Zmc2V0LCBlbGVtZW50LmJ5dGVMZW5ndGgpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHRcdFx0XHRcdGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGVsZW1lbnQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBCbG9iKSB7XG5cdFx0XHRcdFx0YnVmZmVyID0gZWxlbWVudFtCVUZGRVJdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyA/IGVsZW1lbnQgOiBTdHJpbmcoZWxlbWVudCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNpemUgKz0gYnVmZmVyLmxlbmd0aDtcblx0XHRcdFx0YnVmZmVycy5wdXNoKGJ1ZmZlcik7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpc1tCVUZGRVJdID0gQnVmZmVyLmNvbmNhdChidWZmZXJzKTtcblxuXHRcdGxldCB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgIT09IHVuZGVmaW5lZCAmJiBTdHJpbmcob3B0aW9ucy50eXBlKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGlmICh0eXBlICYmICEvW15cXHUwMDIwLVxcdTAwN0VdLy50ZXN0KHR5cGUpKSB7XG5cdFx0XHR0aGlzW1RZUEVdID0gdHlwZTtcblx0XHR9XG5cdH1cblx0Z2V0IHNpemUoKSB7XG5cdFx0cmV0dXJuIHRoaXNbQlVGRkVSXS5sZW5ndGg7XG5cdH1cblx0Z2V0IHR5cGUoKSB7XG5cdFx0cmV0dXJuIHRoaXNbVFlQRV07XG5cdH1cblx0dGV4dCgpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXNbQlVGRkVSXS50b1N0cmluZygpKTtcblx0fVxuXHRhcnJheUJ1ZmZlcigpIHtcblx0XHRjb25zdCBidWYgPSB0aGlzW0JVRkZFUl07XG5cdFx0Y29uc3QgYWIgPSBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5ieXRlTGVuZ3RoKTtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFiKTtcblx0fVxuXHRzdHJlYW0oKSB7XG5cdFx0Y29uc3QgcmVhZGFibGUgPSBuZXcgUmVhZGFibGUoKTtcblx0XHRyZWFkYWJsZS5fcmVhZCA9IGZ1bmN0aW9uICgpIHt9O1xuXHRcdHJlYWRhYmxlLnB1c2godGhpc1tCVUZGRVJdKTtcblx0XHRyZWFkYWJsZS5wdXNoKG51bGwpO1xuXHRcdHJldHVybiByZWFkYWJsZTtcblx0fVxuXHR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gJ1tvYmplY3QgQmxvYl0nO1xuXHR9XG5cdHNsaWNlKCkge1xuXHRcdGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG5cblx0XHRjb25zdCBzdGFydCA9IGFyZ3VtZW50c1swXTtcblx0XHRjb25zdCBlbmQgPSBhcmd1bWVudHNbMV07XG5cdFx0bGV0IHJlbGF0aXZlU3RhcnQsIHJlbGF0aXZlRW5kO1xuXHRcdGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZWxhdGl2ZVN0YXJ0ID0gMDtcblx0XHR9IGVsc2UgaWYgKHN0YXJ0IDwgMCkge1xuXHRcdFx0cmVsYXRpdmVTdGFydCA9IE1hdGgubWF4KHNpemUgKyBzdGFydCwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbGF0aXZlU3RhcnQgPSBNYXRoLm1pbihzdGFydCwgc2l6ZSk7XG5cdFx0fVxuXHRcdGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmVsYXRpdmVFbmQgPSBzaXplO1xuXHRcdH0gZWxzZSBpZiAoZW5kIDwgMCkge1xuXHRcdFx0cmVsYXRpdmVFbmQgPSBNYXRoLm1heChzaXplICsgZW5kLCAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVsYXRpdmVFbmQgPSBNYXRoLm1pbihlbmQsIHNpemUpO1xuXHRcdH1cblx0XHRjb25zdCBzcGFuID0gTWF0aC5tYXgocmVsYXRpdmVFbmQgLSByZWxhdGl2ZVN0YXJ0LCAwKTtcblxuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXNbQlVGRkVSXTtcblx0XHRjb25zdCBzbGljZWRCdWZmZXIgPSBidWZmZXIuc2xpY2UocmVsYXRpdmVTdGFydCwgcmVsYXRpdmVTdGFydCArIHNwYW4pO1xuXHRcdGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbXSwgeyB0eXBlOiBhcmd1bWVudHNbMl0gfSk7XG5cdFx0YmxvYltCVUZGRVJdID0gc2xpY2VkQnVmZmVyO1xuXHRcdHJldHVybiBibG9iO1xuXHR9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJsb2IucHJvdG90eXBlLCB7XG5cdHNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHR0eXBlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0c2xpY2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJsb2IucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcblx0dmFsdWU6ICdCbG9iJyxcblx0d3JpdGFibGU6IGZhbHNlLFxuXHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0Y29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBmZXRjaC1lcnJvci5qc1xuICpcbiAqIEZldGNoRXJyb3IgaW50ZXJmYWNlIGZvciBvcGVyYXRpb25hbCBlcnJvcnNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBGZXRjaEVycm9yIGluc3RhbmNlXG4gKlxuICogQHBhcmFtICAgU3RyaW5nICAgICAgbWVzc2FnZSAgICAgIEVycm9yIG1lc3NhZ2UgZm9yIGh1bWFuXG4gKiBAcGFyYW0gICBTdHJpbmcgICAgICB0eXBlICAgICAgICAgRXJyb3IgdHlwZSBmb3IgbWFjaGluZVxuICogQHBhcmFtICAgU3RyaW5nICAgICAgc3lzdGVtRXJyb3IgIEZvciBOb2RlLmpzIHN5c3RlbSBlcnJvclxuICogQHJldHVybiAgRmV0Y2hFcnJvclxuICovXG5mdW5jdGlvbiBGZXRjaEVycm9yKG1lc3NhZ2UsIHR5cGUsIHN5c3RlbUVycm9yKSB7XG4gIEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcblxuICAvLyB3aGVuIGVyci50eXBlIGlzIGBzeXN0ZW1gLCBlcnIuY29kZSBjb250YWlucyBzeXN0ZW0gZXJyb3IgY29kZVxuICBpZiAoc3lzdGVtRXJyb3IpIHtcbiAgICB0aGlzLmNvZGUgPSB0aGlzLmVycm5vID0gc3lzdGVtRXJyb3IuY29kZTtcbiAgfVxuXG4gIC8vIGhpZGUgY3VzdG9tIGVycm9yIGltcGxlbWVudGF0aW9uIGRldGFpbHMgZnJvbSBlbmQtdXNlcnNcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG59XG5cbkZldGNoRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuRmV0Y2hFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGZXRjaEVycm9yO1xuRmV0Y2hFcnJvci5wcm90b3R5cGUubmFtZSA9ICdGZXRjaEVycm9yJztcblxubGV0IGNvbnZlcnQ7XG5cbmNvbnN0IElOVEVSTkFMUyA9IFN5bWJvbCgnQm9keSBpbnRlcm5hbHMnKTtcblxuLy8gZml4IGFuIGlzc3VlIHdoZXJlIFwiUGFzc1Rocm91Z2hcIiBpc24ndCBhIG5hbWVkIGV4cG9ydCBmb3Igbm9kZSA8MTBcbmNvbnN0IFBhc3NUaHJvdWdoID0gU3RyZWFtLlBhc3NUaHJvdWdoO1xuXG4vKipcbiAqIEJvZHkgbWl4aW5cbiAqXG4gKiBSZWY6IGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNib2R5XG4gKlxuICogQHBhcmFtICAgU3RyZWFtICBib2R5ICBSZWFkYWJsZSBzdHJlYW1cbiAqIEBwYXJhbSAgIE9iamVjdCAgb3B0cyAgUmVzcG9uc2Ugb3B0aW9uc1xuICogQHJldHVybiAgVm9pZFxuICovXG5mdW5jdGlvbiBCb2R5KGJvZHkpIHtcblx0dmFyIF90aGlzID0gdGhpcztcblxuXHR2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG5cdCAgICBfcmVmJHNpemUgPSBfcmVmLnNpemU7XG5cblx0bGV0IHNpemUgPSBfcmVmJHNpemUgPT09IHVuZGVmaW5lZCA/IDAgOiBfcmVmJHNpemU7XG5cdHZhciBfcmVmJHRpbWVvdXQgPSBfcmVmLnRpbWVvdXQ7XG5cdGxldCB0aW1lb3V0ID0gX3JlZiR0aW1lb3V0ID09PSB1bmRlZmluZWQgPyAwIDogX3JlZiR0aW1lb3V0O1xuXG5cdGlmIChib2R5ID09IG51bGwpIHtcblx0XHQvLyBib2R5IGlzIHVuZGVmaW5lZCBvciBudWxsXG5cdFx0Ym9keSA9IG51bGw7XG5cdH0gZWxzZSBpZiAoaXNVUkxTZWFyY2hQYXJhbXMoYm9keSkpIHtcblx0XHQvLyBib2R5IGlzIGEgVVJMU2VhcmNoUGFyYW1zXG5cdFx0Ym9keSA9IEJ1ZmZlci5mcm9tKGJvZHkudG9TdHJpbmcoKSk7XG5cdH0gZWxzZSBpZiAoaXNCbG9iKGJvZHkpKSA7IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihib2R5KSkgOyBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcblx0XHQvLyBib2R5IGlzIEFycmF5QnVmZmVyXG5cdFx0Ym9keSA9IEJ1ZmZlci5mcm9tKGJvZHkpO1xuXHR9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhib2R5KSkge1xuXHRcdC8vIGJvZHkgaXMgQXJyYXlCdWZmZXJWaWV3XG5cdFx0Ym9keSA9IEJ1ZmZlci5mcm9tKGJvZHkuYnVmZmVyLCBib2R5LmJ5dGVPZmZzZXQsIGJvZHkuYnl0ZUxlbmd0aCk7XG5cdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkgOyBlbHNlIHtcblx0XHQvLyBub25lIG9mIHRoZSBhYm92ZVxuXHRcdC8vIGNvZXJjZSB0byBzdHJpbmcgdGhlbiBidWZmZXJcblx0XHRib2R5ID0gQnVmZmVyLmZyb20oU3RyaW5nKGJvZHkpKTtcblx0fVxuXHR0aGlzW0lOVEVSTkFMU10gPSB7XG5cdFx0Ym9keSxcblx0XHRkaXN0dXJiZWQ6IGZhbHNlLFxuXHRcdGVycm9yOiBudWxsXG5cdH07XG5cdHRoaXMuc2l6ZSA9IHNpemU7XG5cdHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG5cblx0aWYgKGJvZHkgaW5zdGFuY2VvZiBTdHJlYW0pIHtcblx0XHRib2R5Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdGNvbnN0IGVycm9yID0gZXJyLm5hbWUgPT09ICdBYm9ydEVycm9yJyA/IGVyciA6IG5ldyBGZXRjaEVycm9yKGBJbnZhbGlkIHJlc3BvbnNlIGJvZHkgd2hpbGUgdHJ5aW5nIHRvIGZldGNoICR7X3RoaXMudXJsfTogJHtlcnIubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyKTtcblx0XHRcdF90aGlzW0lOVEVSTkFMU10uZXJyb3IgPSBlcnJvcjtcblx0XHR9KTtcblx0fVxufVxuXG5Cb2R5LnByb3RvdHlwZSA9IHtcblx0Z2V0IGJvZHkoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTXS5ib2R5O1xuXHR9LFxuXG5cdGdldCBib2R5VXNlZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFNdLmRpc3R1cmJlZDtcblx0fSxcblxuXHQvKipcbiAgKiBEZWNvZGUgcmVzcG9uc2UgYXMgQXJyYXlCdWZmZXJcbiAgKlxuICAqIEByZXR1cm4gIFByb21pc2VcbiAgKi9cblx0YXJyYXlCdWZmZXIoKSB7XG5cdFx0cmV0dXJuIGNvbnN1bWVCb2R5LmNhbGwodGhpcykudGhlbihmdW5jdGlvbiAoYnVmKSB7XG5cdFx0XHRyZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYuYnl0ZUxlbmd0aCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG4gICogUmV0dXJuIHJhdyByZXNwb25zZSBhcyBCbG9iXG4gICpcbiAgKiBAcmV0dXJuIFByb21pc2VcbiAgKi9cblx0YmxvYigpIHtcblx0XHRsZXQgY3QgPSB0aGlzLmhlYWRlcnMgJiYgdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykgfHwgJyc7XG5cdFx0cmV0dXJuIGNvbnN1bWVCb2R5LmNhbGwodGhpcykudGhlbihmdW5jdGlvbiAoYnVmKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbihcblx0XHRcdC8vIFByZXZlbnQgY29weWluZ1xuXHRcdFx0bmV3IEJsb2IoW10sIHtcblx0XHRcdFx0dHlwZTogY3QudG9Mb3dlckNhc2UoKVxuXHRcdFx0fSksIHtcblx0XHRcdFx0W0JVRkZFUl06IGJ1ZlxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG4gICogRGVjb2RlIHJlc3BvbnNlIGFzIGpzb25cbiAgKlxuICAqIEByZXR1cm4gIFByb21pc2VcbiAgKi9cblx0anNvbigpIHtcblx0XHR2YXIgX3RoaXMyID0gdGhpcztcblxuXHRcdHJldHVybiBjb25zdW1lQm9keS5jYWxsKHRoaXMpLnRoZW4oZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmV0dXJuIEpTT04ucGFyc2UoYnVmZmVyLnRvU3RyaW5nKCkpO1xuXHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdHJldHVybiBCb2R5LlByb21pc2UucmVqZWN0KG5ldyBGZXRjaEVycm9yKGBpbnZhbGlkIGpzb24gcmVzcG9uc2UgYm9keSBhdCAke190aGlzMi51cmx9IHJlYXNvbjogJHtlcnIubWVzc2FnZX1gLCAnaW52YWxpZC1qc29uJykpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuICAqIERlY29kZSByZXNwb25zZSBhcyB0ZXh0XG4gICpcbiAgKiBAcmV0dXJuICBQcm9taXNlXG4gICovXG5cdHRleHQoKSB7XG5cdFx0cmV0dXJuIGNvbnN1bWVCb2R5LmNhbGwodGhpcykudGhlbihmdW5jdGlvbiAoYnVmZmVyKSB7XG5cdFx0XHRyZXR1cm4gYnVmZmVyLnRvU3RyaW5nKCk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG4gICogRGVjb2RlIHJlc3BvbnNlIGFzIGJ1ZmZlciAobm9uLXNwZWMgYXBpKVxuICAqXG4gICogQHJldHVybiAgUHJvbWlzZVxuICAqL1xuXHRidWZmZXIoKSB7XG5cdFx0cmV0dXJuIGNvbnN1bWVCb2R5LmNhbGwodGhpcyk7XG5cdH0sXG5cblx0LyoqXG4gICogRGVjb2RlIHJlc3BvbnNlIGFzIHRleHQsIHdoaWxlIGF1dG9tYXRpY2FsbHkgZGV0ZWN0aW5nIHRoZSBlbmNvZGluZyBhbmRcbiAgKiB0cnlpbmcgdG8gZGVjb2RlIHRvIFVURi04IChub24tc3BlYyBhcGkpXG4gICpcbiAgKiBAcmV0dXJuICBQcm9taXNlXG4gICovXG5cdHRleHRDb252ZXJ0ZWQoKSB7XG5cdFx0dmFyIF90aGlzMyA9IHRoaXM7XG5cblx0XHRyZXR1cm4gY29uc3VtZUJvZHkuY2FsbCh0aGlzKS50aGVuKGZ1bmN0aW9uIChidWZmZXIpIHtcblx0XHRcdHJldHVybiBjb252ZXJ0Qm9keShidWZmZXIsIF90aGlzMy5oZWFkZXJzKTtcblx0XHR9KTtcblx0fVxufTtcblxuLy8gSW4gYnJvd3NlcnMsIGFsbCBwcm9wZXJ0aWVzIGFyZSBlbnVtZXJhYmxlLlxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQm9keS5wcm90b3R5cGUsIHtcblx0Ym9keTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGJvZHlVc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0YXJyYXlCdWZmZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRibG9iOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0anNvbjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHRleHQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcblxuQm9keS5taXhJbiA9IGZ1bmN0aW9uIChwcm90bykge1xuXHRmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoQm9keS5wcm90b3R5cGUpKSB7XG5cdFx0Ly8gaXN0YW5idWwgaWdub3JlIGVsc2U6IGZ1dHVyZSBwcm9vZlxuXHRcdGlmICghKG5hbWUgaW4gcHJvdG8pKSB7XG5cdFx0XHRjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihCb2R5LnByb3RvdHlwZSwgbmFtZSk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIGRlc2MpO1xuXHRcdH1cblx0fVxufTtcblxuLyoqXG4gKiBDb25zdW1lIGFuZCBjb252ZXJ0IGFuIGVudGlyZSBCb2R5IHRvIGEgQnVmZmVyLlxuICpcbiAqIFJlZjogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keS1jb25zdW1lLWJvZHlcbiAqXG4gKiBAcmV0dXJuICBQcm9taXNlXG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVCb2R5KCkge1xuXHR2YXIgX3RoaXM0ID0gdGhpcztcblxuXHRpZiAodGhpc1tJTlRFUk5BTFNdLmRpc3R1cmJlZCkge1xuXHRcdHJldHVybiBCb2R5LlByb21pc2UucmVqZWN0KG5ldyBUeXBlRXJyb3IoYGJvZHkgdXNlZCBhbHJlYWR5IGZvcjogJHt0aGlzLnVybH1gKSk7XG5cdH1cblxuXHR0aGlzW0lOVEVSTkFMU10uZGlzdHVyYmVkID0gdHJ1ZTtcblxuXHRpZiAodGhpc1tJTlRFUk5BTFNdLmVycm9yKSB7XG5cdFx0cmV0dXJuIEJvZHkuUHJvbWlzZS5yZWplY3QodGhpc1tJTlRFUk5BTFNdLmVycm9yKTtcblx0fVxuXG5cdGxldCBib2R5ID0gdGhpcy5ib2R5O1xuXG5cdC8vIGJvZHkgaXMgbnVsbFxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBCb2R5LlByb21pc2UucmVzb2x2ZShCdWZmZXIuYWxsb2MoMCkpO1xuXHR9XG5cblx0Ly8gYm9keSBpcyBibG9iXG5cdGlmIChpc0Jsb2IoYm9keSkpIHtcblx0XHRib2R5ID0gYm9keS5zdHJlYW0oKTtcblx0fVxuXG5cdC8vIGJvZHkgaXMgYnVmZmVyXG5cdGlmIChCdWZmZXIuaXNCdWZmZXIoYm9keSkpIHtcblx0XHRyZXR1cm4gQm9keS5Qcm9taXNlLnJlc29sdmUoYm9keSk7XG5cdH1cblxuXHQvLyBpc3RhbmJ1bCBpZ25vcmUgaWY6IHNob3VsZCBuZXZlciBoYXBwZW5cblx0aWYgKCEoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkpIHtcblx0XHRyZXR1cm4gQm9keS5Qcm9taXNlLnJlc29sdmUoQnVmZmVyLmFsbG9jKDApKTtcblx0fVxuXG5cdC8vIGJvZHkgaXMgc3RyZWFtXG5cdC8vIGdldCByZWFkeSB0byBhY3R1YWxseSBjb25zdW1lIHRoZSBib2R5XG5cdGxldCBhY2N1bSA9IFtdO1xuXHRsZXQgYWNjdW1CeXRlcyA9IDA7XG5cdGxldCBhYm9ydCA9IGZhbHNlO1xuXG5cdHJldHVybiBuZXcgQm9keS5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0XHRsZXQgcmVzVGltZW91dDtcblxuXHRcdC8vIGFsbG93IHRpbWVvdXQgb24gc2xvdyByZXNwb25zZSBib2R5XG5cdFx0aWYgKF90aGlzNC50aW1lb3V0KSB7XG5cdFx0XHRyZXNUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGFib3J0ID0gdHJ1ZTtcblx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBSZXNwb25zZSB0aW1lb3V0IHdoaWxlIHRyeWluZyB0byBmZXRjaCAke190aGlzNC51cmx9IChvdmVyICR7X3RoaXM0LnRpbWVvdXR9bXMpYCwgJ2JvZHktdGltZW91dCcpKTtcblx0XHRcdH0sIF90aGlzNC50aW1lb3V0KTtcblx0XHR9XG5cblx0XHQvLyBoYW5kbGUgc3RyZWFtIGVycm9yc1xuXHRcdGJvZHkub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0aWYgKGVyci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcblx0XHRcdFx0Ly8gaWYgdGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWQsIHJlamVjdCB3aXRoIHRoaXMgRXJyb3Jcblx0XHRcdFx0YWJvcnQgPSB0cnVlO1xuXHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIG90aGVyIGVycm9ycywgc3VjaCBhcyBpbmNvcnJlY3QgY29udGVudC1lbmNvZGluZ1xuXHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgYm9keSB3aGlsZSB0cnlpbmcgdG8gZmV0Y2ggJHtfdGhpczQudXJsfTogJHtlcnIubWVzc2FnZX1gLCAnc3lzdGVtJywgZXJyKSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRib2R5Lm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG5cdFx0XHRpZiAoYWJvcnQgfHwgY2h1bmsgPT09IG51bGwpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoX3RoaXM0LnNpemUgJiYgYWNjdW1CeXRlcyArIGNodW5rLmxlbmd0aCA+IF90aGlzNC5zaXplKSB7XG5cdFx0XHRcdGFib3J0ID0gdHJ1ZTtcblx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBjb250ZW50IHNpemUgYXQgJHtfdGhpczQudXJsfSBvdmVyIGxpbWl0OiAke190aGlzNC5zaXplfWAsICdtYXgtc2l6ZScpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRhY2N1bUJ5dGVzICs9IGNodW5rLmxlbmd0aDtcblx0XHRcdGFjY3VtLnB1c2goY2h1bmspO1xuXHRcdH0pO1xuXG5cdFx0Ym9keS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKGFib3J0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y2xlYXJUaW1lb3V0KHJlc1RpbWVvdXQpO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXNvbHZlKEJ1ZmZlci5jb25jYXQoYWNjdW0sIGFjY3VtQnl0ZXMpKTtcblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHQvLyBoYW5kbGUgc3RyZWFtcyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdG9vIG11Y2ggZGF0YSAoaXNzdWUgIzQxNClcblx0XHRcdFx0cmVqZWN0KG5ldyBGZXRjaEVycm9yKGBDb3VsZCBub3QgY3JlYXRlIEJ1ZmZlciBmcm9tIHJlc3BvbnNlIGJvZHkgZm9yICR7X3RoaXM0LnVybH06ICR7ZXJyLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycikpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcbn1cblxuLyoqXG4gKiBEZXRlY3QgYnVmZmVyIGVuY29kaW5nIGFuZCBjb252ZXJ0IHRvIHRhcmdldCBlbmNvZGluZ1xuICogcmVmOiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1dELWh0bWw1LTIwMTEwMTEzL3BhcnNpbmcuaHRtbCNkZXRlcm1pbmluZy10aGUtY2hhcmFjdGVyLWVuY29kaW5nXG4gKlxuICogQHBhcmFtICAgQnVmZmVyICBidWZmZXIgICAgSW5jb21pbmcgYnVmZmVyXG4gKiBAcGFyYW0gICBTdHJpbmcgIGVuY29kaW5nICBUYXJnZXQgZW5jb2RpbmdcbiAqIEByZXR1cm4gIFN0cmluZ1xuICovXG5mdW5jdGlvbiBjb252ZXJ0Qm9keShidWZmZXIsIGhlYWRlcnMpIHtcblx0e1xuXHRcdHRocm93IG5ldyBFcnJvcignVGhlIHBhY2thZ2UgYGVuY29kaW5nYCBtdXN0IGJlIGluc3RhbGxlZCB0byB1c2UgdGhlIHRleHRDb252ZXJ0ZWQoKSBmdW5jdGlvbicpO1xuXHR9XG5cblx0Y29uc3QgY3QgPSBoZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG5cdGxldCBjaGFyc2V0ID0gJ3V0Zi04Jztcblx0bGV0IHJlcywgc3RyO1xuXG5cdC8vIGhlYWRlclxuXHRpZiAoY3QpIHtcblx0XHRyZXMgPSAvY2hhcnNldD0oW147XSopL2kuZXhlYyhjdCk7XG5cdH1cblxuXHQvLyBubyBjaGFyc2V0IGluIGNvbnRlbnQgdHlwZSwgcGVlayBhdCByZXNwb25zZSBib2R5IGZvciBhdCBtb3N0IDEwMjQgYnl0ZXNcblx0c3RyID0gYnVmZmVyLnNsaWNlKDAsIDEwMjQpLnRvU3RyaW5nKCk7XG5cblx0Ly8gaHRtbDVcblx0aWYgKCFyZXMgJiYgc3RyKSB7XG5cdFx0cmVzID0gLzxtZXRhLis/Y2hhcnNldD0oWydcIl0pKC4rPylcXDEvaS5leGVjKHN0cik7XG5cdH1cblxuXHQvLyBodG1sNFxuXHRpZiAoIXJlcyAmJiBzdHIpIHtcblx0XHRyZXMgPSAvPG1ldGFbXFxzXSs/aHR0cC1lcXVpdj0oWydcIl0pY29udGVudC10eXBlXFwxW1xcc10rP2NvbnRlbnQ9KFsnXCJdKSguKz8pXFwyL2kuZXhlYyhzdHIpO1xuXHRcdGlmICghcmVzKSB7XG5cdFx0XHRyZXMgPSAvPG1ldGFbXFxzXSs/Y29udGVudD0oWydcIl0pKC4rPylcXDFbXFxzXSs/aHR0cC1lcXVpdj0oWydcIl0pY29udGVudC10eXBlXFwzL2kuZXhlYyhzdHIpO1xuXHRcdFx0aWYgKHJlcykge1xuXHRcdFx0XHRyZXMucG9wKCk7IC8vIGRyb3AgbGFzdCBxdW90ZVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChyZXMpIHtcblx0XHRcdHJlcyA9IC9jaGFyc2V0PSguKikvaS5leGVjKHJlcy5wb3AoKSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8geG1sXG5cdGlmICghcmVzICYmIHN0cikge1xuXHRcdHJlcyA9IC88XFw/eG1sLis/ZW5jb2Rpbmc9KFsnXCJdKSguKz8pXFwxL2kuZXhlYyhzdHIpO1xuXHR9XG5cblx0Ly8gZm91bmQgY2hhcnNldFxuXHRpZiAocmVzKSB7XG5cdFx0Y2hhcnNldCA9IHJlcy5wb3AoKTtcblxuXHRcdC8vIHByZXZlbnQgZGVjb2RlIGlzc3VlcyB3aGVuIHNpdGVzIHVzZSBpbmNvcnJlY3QgZW5jb2Rpbmdcblx0XHQvLyByZWY6IGh0dHBzOi8vaHNpdm9uZW4uZmkvZW5jb2RpbmctbWVudS9cblx0XHRpZiAoY2hhcnNldCA9PT0gJ2diMjMxMicgfHwgY2hhcnNldCA9PT0gJ2diaycpIHtcblx0XHRcdGNoYXJzZXQgPSAnZ2IxODAzMCc7XG5cdFx0fVxuXHR9XG5cblx0Ly8gdHVybiByYXcgYnVmZmVycyBpbnRvIGEgc2luZ2xlIHV0Zi04IGJ1ZmZlclxuXHRyZXR1cm4gY29udmVydChidWZmZXIsICdVVEYtOCcsIGNoYXJzZXQpLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogRGV0ZWN0IGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICogcmVmOiBodHRwczovL2dpdGh1Yi5jb20vYml0aW5uL25vZGUtZmV0Y2gvaXNzdWVzLzI5NiNpc3N1ZWNvbW1lbnQtMzA3NTk4MTQzXG4gKlxuICogQHBhcmFtICAgT2JqZWN0ICBvYmogICAgIE9iamVjdCB0byBkZXRlY3QgYnkgdHlwZSBvciBicmFuZFxuICogQHJldHVybiAgU3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKG9iaikge1xuXHQvLyBEdWNrLXR5cGluZyBhcyBhIG5lY2Vzc2FyeSBjb25kaXRpb24uXG5cdGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqLmFwcGVuZCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmRlbGV0ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmdldEFsbCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLmhhcyAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygb2JqLnNldCAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIEJyYW5kLWNoZWNraW5nIGFuZCBtb3JlIGR1Y2stdHlwaW5nIGFzIG9wdGlvbmFsIGNvbmRpdGlvbi5cblx0cmV0dXJuIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVVJMU2VhcmNoUGFyYW1zJyB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgVVJMU2VhcmNoUGFyYW1zXScgfHwgdHlwZW9mIG9iai5zb3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgVzNDIGBCbG9iYCBvYmplY3QgKHdoaWNoIGBGaWxlYCBpbmhlcml0cyBmcm9tKVxuICogQHBhcmFtICB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0Jsb2Iob2JqKSB7XG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqLmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmoudHlwZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIG9iai5zdHJlYW0gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdzdHJpbmcnICYmIC9eKEJsb2J8RmlsZSkkLy50ZXN0KG9iai5jb25zdHJ1Y3Rvci5uYW1lKSAmJiAvXihCbG9ifEZpbGUpJC8udGVzdChvYmpbU3ltYm9sLnRvU3RyaW5nVGFnXSk7XG59XG5cbi8qKlxuICogQ2xvbmUgYm9keSBnaXZlbiBSZXMvUmVxIGluc3RhbmNlXG4gKlxuICogQHBhcmFtICAgTWl4ZWQgIGluc3RhbmNlICBSZXNwb25zZSBvciBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcmV0dXJuICBNaXhlZFxuICovXG5mdW5jdGlvbiBjbG9uZShpbnN0YW5jZSkge1xuXHRsZXQgcDEsIHAyO1xuXHRsZXQgYm9keSA9IGluc3RhbmNlLmJvZHk7XG5cblx0Ly8gZG9uJ3QgYWxsb3cgY2xvbmluZyBhIHVzZWQgYm9keVxuXHRpZiAoaW5zdGFuY2UuYm9keVVzZWQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBjbG9uZSBib2R5IGFmdGVyIGl0IGlzIHVzZWQnKTtcblx0fVxuXG5cdC8vIGNoZWNrIHRoYXQgYm9keSBpcyBhIHN0cmVhbSBhbmQgbm90IGZvcm0tZGF0YSBvYmplY3Rcblx0Ly8gbm90ZTogd2UgY2FuJ3QgY2xvbmUgdGhlIGZvcm0tZGF0YSBvYmplY3Qgd2l0aG91dCBoYXZpbmcgaXQgYXMgYSBkZXBlbmRlbmN5XG5cdGlmIChib2R5IGluc3RhbmNlb2YgU3RyZWFtICYmIHR5cGVvZiBib2R5LmdldEJvdW5kYXJ5ICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gdGVlIGluc3RhbmNlIGJvZHlcblx0XHRwMSA9IG5ldyBQYXNzVGhyb3VnaCgpO1xuXHRcdHAyID0gbmV3IFBhc3NUaHJvdWdoKCk7XG5cdFx0Ym9keS5waXBlKHAxKTtcblx0XHRib2R5LnBpcGUocDIpO1xuXHRcdC8vIHNldCBpbnN0YW5jZSBib2R5IHRvIHRlZWQgYm9keSBhbmQgcmV0dXJuIHRoZSBvdGhlciB0ZWVkIGJvZHlcblx0XHRpbnN0YW5jZVtJTlRFUk5BTFNdLmJvZHkgPSBwMTtcblx0XHRib2R5ID0gcDI7XG5cdH1cblxuXHRyZXR1cm4gYm9keTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyB0aGUgb3BlcmF0aW9uIFwiZXh0cmFjdCBhIGBDb250ZW50LVR5cGVgIHZhbHVlIGZyb20gfG9iamVjdHxcIiBhc1xuICogc3BlY2lmaWVkIGluIHRoZSBzcGVjaWZpY2F0aW9uOlxuICogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtYm9keWluaXQtZXh0cmFjdFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGluc3RhbmNlLmJvZHkgaXMgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0gICBNaXhlZCAgaW5zdGFuY2UgIEFueSBvcHRpb25zLmJvZHkgaW5wdXRcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbnRlbnRUeXBlKGJvZHkpIHtcblx0aWYgKGJvZHkgPT09IG51bGwpIHtcblx0XHQvLyBib2R5IGlzIG51bGxcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcblx0XHQvLyBib2R5IGlzIHN0cmluZ1xuXHRcdHJldHVybiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jztcblx0fSBlbHNlIGlmIChpc1VSTFNlYXJjaFBhcmFtcyhib2R5KSkge1xuXHRcdC8vIGJvZHkgaXMgYSBVUkxTZWFyY2hQYXJhbXNcblx0XHRyZXR1cm4gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jztcblx0fSBlbHNlIGlmIChpc0Jsb2IoYm9keSkpIHtcblx0XHQvLyBib2R5IGlzIGJsb2Jcblx0XHRyZXR1cm4gYm9keS50eXBlIHx8IG51bGw7XG5cdH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBidWZmZXJcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcblx0XHQvLyBib2R5IGlzIEFycmF5QnVmZmVyXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBBcnJheUJ1ZmZlclZpZXdcblx0XHRyZXR1cm4gbnVsbDtcblx0fSBlbHNlIGlmICh0eXBlb2YgYm9keS5nZXRCb3VuZGFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdC8vIGRldGVjdCBmb3JtIGRhdGEgaW5wdXQgZnJvbSBmb3JtLWRhdGEgbW9kdWxlXG5cdFx0cmV0dXJuIGBtdWx0aXBhcnQvZm9ybS1kYXRhO2JvdW5kYXJ5PSR7Ym9keS5nZXRCb3VuZGFyeSgpfWA7XG5cdH0gZWxzZSBpZiAoYm9keSBpbnN0YW5jZW9mIFN0cmVhbSkge1xuXHRcdC8vIGJvZHkgaXMgc3RyZWFtXG5cdFx0Ly8gY2FuJ3QgcmVhbGx5IGRvIG11Y2ggYWJvdXQgdGhpc1xuXHRcdHJldHVybiBudWxsO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEJvZHkgY29uc3RydWN0b3IgZGVmYXVsdHMgb3RoZXIgdGhpbmdzIHRvIHN0cmluZ1xuXHRcdHJldHVybiAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jztcblx0fVxufVxuXG4vKipcbiAqIFRoZSBGZXRjaCBTdGFuZGFyZCB0cmVhdHMgdGhpcyBhcyBpZiBcInRvdGFsIGJ5dGVzXCIgaXMgYSBwcm9wZXJ0eSBvbiB0aGUgYm9keS5cbiAqIEZvciB1cywgd2UgaGF2ZSB0byBleHBsaWNpdGx5IGdldCBpdCB3aXRoIGEgZnVuY3Rpb24uXG4gKlxuICogcmVmOiBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1ib2R5LXRvdGFsLWJ5dGVzXG4gKlxuICogQHBhcmFtICAgQm9keSAgICBpbnN0YW5jZSAgIEluc3RhbmNlIG9mIEJvZHlcbiAqIEByZXR1cm4gIE51bWJlcj8gICAgICAgICAgICBOdW1iZXIgb2YgYnl0ZXMsIG9yIG51bGwgaWYgbm90IHBvc3NpYmxlXG4gKi9cbmZ1bmN0aW9uIGdldFRvdGFsQnl0ZXMoaW5zdGFuY2UpIHtcblx0Y29uc3QgYm9keSA9IGluc3RhbmNlLmJvZHk7XG5cblxuXHRpZiAoYm9keSA9PT0gbnVsbCkge1xuXHRcdC8vIGJvZHkgaXMgbnVsbFxuXHRcdHJldHVybiAwO1xuXHR9IGVsc2UgaWYgKGlzQmxvYihib2R5KSkge1xuXHRcdHJldHVybiBib2R5LnNpemU7XG5cdH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBidWZmZXJcblx0XHRyZXR1cm4gYm9keS5sZW5ndGg7XG5cdH0gZWxzZSBpZiAoYm9keSAmJiB0eXBlb2YgYm9keS5nZXRMZW5ndGhTeW5jID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gZGV0ZWN0IGZvcm0gZGF0YSBpbnB1dCBmcm9tIGZvcm0tZGF0YSBtb2R1bGVcblx0XHRpZiAoYm9keS5fbGVuZ3RoUmV0cmlldmVycyAmJiBib2R5Ll9sZW5ndGhSZXRyaWV2ZXJzLmxlbmd0aCA9PSAwIHx8IC8vIDEueFxuXHRcdGJvZHkuaGFzS25vd25MZW5ndGggJiYgYm9keS5oYXNLbm93bkxlbmd0aCgpKSB7XG5cdFx0XHQvLyAyLnhcblx0XHRcdHJldHVybiBib2R5LmdldExlbmd0aFN5bmMoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gYm9keSBpcyBzdHJlYW1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIFdyaXRlIGEgQm9keSB0byBhIE5vZGUuanMgV3JpdGFibGVTdHJlYW0gKGUuZy4gaHR0cC5SZXF1ZXN0KSBvYmplY3QuXG4gKlxuICogQHBhcmFtICAgQm9keSAgICBpbnN0YW5jZSAgIEluc3RhbmNlIG9mIEJvZHlcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuZnVuY3Rpb24gd3JpdGVUb1N0cmVhbShkZXN0LCBpbnN0YW5jZSkge1xuXHRjb25zdCBib2R5ID0gaW5zdGFuY2UuYm9keTtcblxuXG5cdGlmIChib2R5ID09PSBudWxsKSB7XG5cdFx0Ly8gYm9keSBpcyBudWxsXG5cdFx0ZGVzdC5lbmQoKTtcblx0fSBlbHNlIGlmIChpc0Jsb2IoYm9keSkpIHtcblx0XHRib2R5LnN0cmVhbSgpLnBpcGUoZGVzdCk7XG5cdH0gZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG5cdFx0Ly8gYm9keSBpcyBidWZmZXJcblx0XHRkZXN0LndyaXRlKGJvZHkpO1xuXHRcdGRlc3QuZW5kKCk7XG5cdH0gZWxzZSB7XG5cdFx0Ly8gYm9keSBpcyBzdHJlYW1cblx0XHRib2R5LnBpcGUoZGVzdCk7XG5cdH1cbn1cblxuLy8gZXhwb3NlIFByb21pc2VcbkJvZHkuUHJvbWlzZSA9IGdsb2JhbC5Qcm9taXNlO1xuXG4vKipcbiAqIGhlYWRlcnMuanNcbiAqXG4gKiBIZWFkZXJzIGNsYXNzIG9mZmVycyBjb252ZW5pZW50IGhlbHBlcnNcbiAqL1xuXG5jb25zdCBpbnZhbGlkVG9rZW5SZWdleCA9IC9bXlxcXl9gYS16QS1aXFwtMC05ISMkJSYnKisufH5dLztcbmNvbnN0IGludmFsaWRIZWFkZXJDaGFyUmVnZXggPSAvW15cXHRcXHgyMC1cXHg3ZVxceDgwLVxceGZmXS87XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTmFtZShuYW1lKSB7XG5cdG5hbWUgPSBgJHtuYW1lfWA7XG5cdGlmIChpbnZhbGlkVG9rZW5SZWdleC50ZXN0KG5hbWUpIHx8IG5hbWUgPT09ICcnKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgJHtuYW1lfSBpcyBub3QgYSBsZWdhbCBIVFRQIGhlYWRlciBuYW1lYCk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVWYWx1ZSh2YWx1ZSkge1xuXHR2YWx1ZSA9IGAke3ZhbHVlfWA7XG5cdGlmIChpbnZhbGlkSGVhZGVyQ2hhclJlZ2V4LnRlc3QodmFsdWUpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgbGVnYWwgSFRUUCBoZWFkZXIgdmFsdWVgKTtcblx0fVxufVxuXG4vKipcbiAqIEZpbmQgdGhlIGtleSBpbiB0aGUgbWFwIG9iamVjdCBnaXZlbiBhIGhlYWRlciBuYW1lLlxuICpcbiAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZC5cbiAqXG4gKiBAcGFyYW0gICBTdHJpbmcgIG5hbWUgIEhlYWRlciBuYW1lXG4gKiBAcmV0dXJuICBTdHJpbmd8VW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGZpbmQobWFwLCBuYW1lKSB7XG5cdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdGZvciAoY29uc3Qga2V5IGluIG1hcCkge1xuXHRcdGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSkge1xuXHRcdFx0cmV0dXJuIGtleTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuY29uc3QgTUFQID0gU3ltYm9sKCdtYXAnKTtcbmNsYXNzIEhlYWRlcnMge1xuXHQvKipcbiAgKiBIZWFkZXJzIGNsYXNzXG4gICpcbiAgKiBAcGFyYW0gICBPYmplY3QgIGhlYWRlcnMgIFJlc3BvbnNlIGhlYWRlcnNcbiAgKiBAcmV0dXJuICBWb2lkXG4gICovXG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdGxldCBpbml0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQ7XG5cblx0XHR0aGlzW01BUF0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5cdFx0aWYgKGluaXQgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG5cdFx0XHRjb25zdCByYXdIZWFkZXJzID0gaW5pdC5yYXcoKTtcblx0XHRcdGNvbnN0IGhlYWRlck5hbWVzID0gT2JqZWN0LmtleXMocmF3SGVhZGVycyk7XG5cblx0XHRcdGZvciAoY29uc3QgaGVhZGVyTmFtZSBvZiBoZWFkZXJOYW1lcykge1xuXHRcdFx0XHRmb3IgKGNvbnN0IHZhbHVlIG9mIHJhd0hlYWRlcnNbaGVhZGVyTmFtZV0pIHtcblx0XHRcdFx0XHR0aGlzLmFwcGVuZChoZWFkZXJOYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFdlIGRvbid0IHdvcnJ5IGFib3V0IGNvbnZlcnRpbmcgcHJvcCB0byBCeXRlU3RyaW5nIGhlcmUgYXMgYXBwZW5kKClcblx0XHQvLyB3aWxsIGhhbmRsZSBpdC5cblx0XHRpZiAoaW5pdCA9PSBudWxsKSA7IGVsc2UgaWYgKHR5cGVvZiBpbml0ID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Y29uc3QgbWV0aG9kID0gaW5pdFtTeW1ib2wuaXRlcmF0b3JdO1xuXHRcdFx0aWYgKG1ldGhvZCAhPSBudWxsKSB7XG5cdFx0XHRcdGlmICh0eXBlb2YgbWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignSGVhZGVyIHBhaXJzIG11c3QgYmUgaXRlcmFibGUnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIHNlcXVlbmNlPHNlcXVlbmNlPEJ5dGVTdHJpbmc+PlxuXHRcdFx0XHQvLyBOb3RlOiBwZXIgc3BlYyB3ZSBoYXZlIHRvIGZpcnN0IGV4aGF1c3QgdGhlIGxpc3RzIHRoZW4gcHJvY2VzcyB0aGVtXG5cdFx0XHRcdGNvbnN0IHBhaXJzID0gW107XG5cdFx0XHRcdGZvciAoY29uc3QgcGFpciBvZiBpbml0KSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBwYWlyICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFpcltTeW1ib2wuaXRlcmF0b3JdICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFYWNoIGhlYWRlciBwYWlyIG11c3QgYmUgaXRlcmFibGUnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFpcnMucHVzaChBcnJheS5mcm9tKHBhaXIpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuXHRcdFx0XHRcdGlmIChwYWlyLmxlbmd0aCAhPT0gMikge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRWFjaCBoZWFkZXIgcGFpciBtdXN0IGJlIGEgbmFtZS92YWx1ZSB0dXBsZScpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmFwcGVuZChwYWlyWzBdLCBwYWlyWzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gcmVjb3JkPEJ5dGVTdHJpbmcsIEJ5dGVTdHJpbmc+XG5cdFx0XHRcdGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGluaXQpKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSBpbml0W2tleV07XG5cdFx0XHRcdFx0dGhpcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignUHJvdmlkZWQgaW5pdGlhbGl6ZXIgbXVzdCBiZSBhbiBvYmplY3QnKTtcblx0XHR9XG5cdH1cblxuXHQvKipcbiAgKiBSZXR1cm4gY29tYmluZWQgaGVhZGVyIHZhbHVlIGdpdmVuIG5hbWVcbiAgKlxuICAqIEBwYXJhbSAgIFN0cmluZyAgbmFtZSAgSGVhZGVyIG5hbWVcbiAgKiBAcmV0dXJuICBNaXhlZFxuICAqL1xuXHRnZXQobmFtZSkge1xuXHRcdG5hbWUgPSBgJHtuYW1lfWA7XG5cdFx0dmFsaWRhdGVOYW1lKG5hbWUpO1xuXHRcdGNvbnN0IGtleSA9IGZpbmQodGhpc1tNQVBdLCBuYW1lKTtcblx0XHRpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzW01BUF1ba2V5XS5qb2luKCcsICcpO1xuXHR9XG5cblx0LyoqXG4gICogSXRlcmF0ZSBvdmVyIGFsbCBoZWFkZXJzXG4gICpcbiAgKiBAcGFyYW0gICBGdW5jdGlvbiAgY2FsbGJhY2sgIEV4ZWN1dGVkIGZvciBlYWNoIGl0ZW0gd2l0aCBwYXJhbWV0ZXJzICh2YWx1ZSwgbmFtZSwgdGhpc0FyZylcbiAgKiBAcGFyYW0gICBCb29sZWFuICAgdGhpc0FyZyAgIGB0aGlzYCBjb250ZXh0IGZvciBjYWxsYmFjayBmdW5jdGlvblxuICAqIEByZXR1cm4gIFZvaWRcbiAgKi9cblx0Zm9yRWFjaChjYWxsYmFjaykge1xuXHRcdGxldCB0aGlzQXJnID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG5cblx0XHRsZXQgcGFpcnMgPSBnZXRIZWFkZXJzKHRoaXMpO1xuXHRcdGxldCBpID0gMDtcblx0XHR3aGlsZSAoaSA8IHBhaXJzLmxlbmd0aCkge1xuXHRcdFx0dmFyIF9wYWlycyRpID0gcGFpcnNbaV07XG5cdFx0XHRjb25zdCBuYW1lID0gX3BhaXJzJGlbMF0sXG5cdFx0XHQgICAgICB2YWx1ZSA9IF9wYWlycyRpWzFdO1xuXG5cdFx0XHRjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHZhbHVlLCBuYW1lLCB0aGlzKTtcblx0XHRcdHBhaXJzID0gZ2V0SGVhZGVycyh0aGlzKTtcblx0XHRcdGkrKztcblx0XHR9XG5cdH1cblxuXHQvKipcbiAgKiBPdmVyd3JpdGUgaGVhZGVyIHZhbHVlcyBnaXZlbiBuYW1lXG4gICpcbiAgKiBAcGFyYW0gICBTdHJpbmcgIG5hbWUgICBIZWFkZXIgbmFtZVxuICAqIEBwYXJhbSAgIFN0cmluZyAgdmFsdWUgIEhlYWRlciB2YWx1ZVxuICAqIEByZXR1cm4gIFZvaWRcbiAgKi9cblx0c2V0KG5hbWUsIHZhbHVlKSB7XG5cdFx0bmFtZSA9IGAke25hbWV9YDtcblx0XHR2YWx1ZSA9IGAke3ZhbHVlfWA7XG5cdFx0dmFsaWRhdGVOYW1lKG5hbWUpO1xuXHRcdHZhbGlkYXRlVmFsdWUodmFsdWUpO1xuXHRcdGNvbnN0IGtleSA9IGZpbmQodGhpc1tNQVBdLCBuYW1lKTtcblx0XHR0aGlzW01BUF1ba2V5ICE9PSB1bmRlZmluZWQgPyBrZXkgOiBuYW1lXSA9IFt2YWx1ZV07XG5cdH1cblxuXHQvKipcbiAgKiBBcHBlbmQgYSB2YWx1ZSBvbnRvIGV4aXN0aW5nIGhlYWRlclxuICAqXG4gICogQHBhcmFtICAgU3RyaW5nICBuYW1lICAgSGVhZGVyIG5hbWVcbiAgKiBAcGFyYW0gICBTdHJpbmcgIHZhbHVlICBIZWFkZXIgdmFsdWVcbiAgKiBAcmV0dXJuICBWb2lkXG4gICovXG5cdGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuXHRcdG5hbWUgPSBgJHtuYW1lfWA7XG5cdFx0dmFsdWUgPSBgJHt2YWx1ZX1gO1xuXHRcdHZhbGlkYXRlTmFtZShuYW1lKTtcblx0XHR2YWxpZGF0ZVZhbHVlKHZhbHVlKTtcblx0XHRjb25zdCBrZXkgPSBmaW5kKHRoaXNbTUFQXSwgbmFtZSk7XG5cdFx0aWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzW01BUF1ba2V5XS5wdXNoKHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpc1tNQVBdW25hbWVdID0gW3ZhbHVlXTtcblx0XHR9XG5cdH1cblxuXHQvKipcbiAgKiBDaGVjayBmb3IgaGVhZGVyIG5hbWUgZXhpc3RlbmNlXG4gICpcbiAgKiBAcGFyYW0gICBTdHJpbmcgICBuYW1lICBIZWFkZXIgbmFtZVxuICAqIEByZXR1cm4gIEJvb2xlYW5cbiAgKi9cblx0aGFzKG5hbWUpIHtcblx0XHRuYW1lID0gYCR7bmFtZX1gO1xuXHRcdHZhbGlkYXRlTmFtZShuYW1lKTtcblx0XHRyZXR1cm4gZmluZCh0aGlzW01BUF0sIG5hbWUpICE9PSB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKipcbiAgKiBEZWxldGUgYWxsIGhlYWRlciB2YWx1ZXMgZ2l2ZW4gbmFtZVxuICAqXG4gICogQHBhcmFtICAgU3RyaW5nICBuYW1lICBIZWFkZXIgbmFtZVxuICAqIEByZXR1cm4gIFZvaWRcbiAgKi9cblx0ZGVsZXRlKG5hbWUpIHtcblx0XHRuYW1lID0gYCR7bmFtZX1gO1xuXHRcdHZhbGlkYXRlTmFtZShuYW1lKTtcblx0XHRjb25zdCBrZXkgPSBmaW5kKHRoaXNbTUFQXSwgbmFtZSk7XG5cdFx0aWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRkZWxldGUgdGhpc1tNQVBdW2tleV07XG5cdFx0fVxuXHR9XG5cblx0LyoqXG4gICogUmV0dXJuIHJhdyBoZWFkZXJzIChub24tc3BlYyBhcGkpXG4gICpcbiAgKiBAcmV0dXJuICBPYmplY3RcbiAgKi9cblx0cmF3KCkge1xuXHRcdHJldHVybiB0aGlzW01BUF07XG5cdH1cblxuXHQvKipcbiAgKiBHZXQgYW4gaXRlcmF0b3Igb24ga2V5cy5cbiAgKlxuICAqIEByZXR1cm4gIEl0ZXJhdG9yXG4gICovXG5cdGtleXMoKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZUhlYWRlcnNJdGVyYXRvcih0aGlzLCAna2V5Jyk7XG5cdH1cblxuXHQvKipcbiAgKiBHZXQgYW4gaXRlcmF0b3Igb24gdmFsdWVzLlxuICAqXG4gICogQHJldHVybiAgSXRlcmF0b3JcbiAgKi9cblx0dmFsdWVzKCkge1xuXHRcdHJldHVybiBjcmVhdGVIZWFkZXJzSXRlcmF0b3IodGhpcywgJ3ZhbHVlJyk7XG5cdH1cblxuXHQvKipcbiAgKiBHZXQgYW4gaXRlcmF0b3Igb24gZW50cmllcy5cbiAgKlxuICAqIFRoaXMgaXMgdGhlIGRlZmF1bHQgaXRlcmF0b3Igb2YgdGhlIEhlYWRlcnMgb2JqZWN0LlxuICAqXG4gICogQHJldHVybiAgSXRlcmF0b3JcbiAgKi9cblx0W1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cdFx0cmV0dXJuIGNyZWF0ZUhlYWRlcnNJdGVyYXRvcih0aGlzLCAna2V5K3ZhbHVlJyk7XG5cdH1cbn1cbkhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBIZWFkZXJzLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSGVhZGVycy5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywge1xuXHR2YWx1ZTogJ0hlYWRlcnMnLFxuXHR3cml0YWJsZTogZmFsc2UsXG5cdGVudW1lcmFibGU6IGZhbHNlLFxuXHRjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhIZWFkZXJzLnByb3RvdHlwZSwge1xuXHRnZXQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRmb3JFYWNoOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0c2V0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0YXBwZW5kOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0aGFzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0ZGVsZXRlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0a2V5czogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHZhbHVlczogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdGVudHJpZXM6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcblxuZnVuY3Rpb24gZ2V0SGVhZGVycyhoZWFkZXJzKSB7XG5cdGxldCBraW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAna2V5K3ZhbHVlJztcblxuXHRjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaGVhZGVyc1tNQVBdKS5zb3J0KCk7XG5cdHJldHVybiBrZXlzLm1hcChraW5kID09PSAna2V5JyA/IGZ1bmN0aW9uIChrKSB7XG5cdFx0cmV0dXJuIGsudG9Mb3dlckNhc2UoKTtcblx0fSA6IGtpbmQgPT09ICd2YWx1ZScgPyBmdW5jdGlvbiAoaykge1xuXHRcdHJldHVybiBoZWFkZXJzW01BUF1ba10uam9pbignLCAnKTtcblx0fSA6IGZ1bmN0aW9uIChrKSB7XG5cdFx0cmV0dXJuIFtrLnRvTG93ZXJDYXNlKCksIGhlYWRlcnNbTUFQXVtrXS5qb2luKCcsICcpXTtcblx0fSk7XG59XG5cbmNvbnN0IElOVEVSTkFMID0gU3ltYm9sKCdpbnRlcm5hbCcpO1xuXG5mdW5jdGlvbiBjcmVhdGVIZWFkZXJzSXRlcmF0b3IodGFyZ2V0LCBraW5kKSB7XG5cdGNvbnN0IGl0ZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShIZWFkZXJzSXRlcmF0b3JQcm90b3R5cGUpO1xuXHRpdGVyYXRvcltJTlRFUk5BTF0gPSB7XG5cdFx0dGFyZ2V0LFxuXHRcdGtpbmQsXG5cdFx0aW5kZXg6IDBcblx0fTtcblx0cmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5jb25zdCBIZWFkZXJzSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2Yoe1xuXHRuZXh0KCkge1xuXHRcdC8vIGlzdGFuYnVsIGlnbm9yZSBpZlxuXHRcdGlmICghdGhpcyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykgIT09IEhlYWRlcnNJdGVyYXRvclByb3RvdHlwZSkge1xuXHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignVmFsdWUgb2YgYHRoaXNgIGlzIG5vdCBhIEhlYWRlcnNJdGVyYXRvcicpO1xuXHRcdH1cblxuXHRcdHZhciBfSU5URVJOQUwgPSB0aGlzW0lOVEVSTkFMXTtcblx0XHRjb25zdCB0YXJnZXQgPSBfSU5URVJOQUwudGFyZ2V0LFxuXHRcdCAgICAgIGtpbmQgPSBfSU5URVJOQUwua2luZCxcblx0XHQgICAgICBpbmRleCA9IF9JTlRFUk5BTC5pbmRleDtcblxuXHRcdGNvbnN0IHZhbHVlcyA9IGdldEhlYWRlcnModGFyZ2V0LCBraW5kKTtcblx0XHRjb25zdCBsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuXHRcdGlmIChpbmRleCA+PSBsZW4pIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHZhbHVlOiB1bmRlZmluZWQsXG5cdFx0XHRcdGRvbmU6IHRydWVcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0dGhpc1tJTlRFUk5BTF0uaW5kZXggPSBpbmRleCArIDE7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dmFsdWU6IHZhbHVlc1tpbmRleF0sXG5cdFx0XHRkb25lOiBmYWxzZVxuXHRcdH07XG5cdH1cbn0sIE9iamVjdC5nZXRQcm90b3R5cGVPZihPYmplY3QuZ2V0UHJvdG90eXBlT2YoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSkpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSGVhZGVyc0l0ZXJhdG9yUHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcblx0dmFsdWU6ICdIZWFkZXJzSXRlcmF0b3InLFxuXHR3cml0YWJsZTogZmFsc2UsXG5cdGVudW1lcmFibGU6IGZhbHNlLFxuXHRjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG4vKipcbiAqIEV4cG9ydCB0aGUgSGVhZGVycyBvYmplY3QgaW4gYSBmb3JtIHRoYXQgTm9kZS5qcyBjYW4gY29uc3VtZS5cbiAqXG4gKiBAcGFyYW0gICBIZWFkZXJzICBoZWFkZXJzXG4gKiBAcmV0dXJuICBPYmplY3RcbiAqL1xuZnVuY3Rpb24gZXhwb3J0Tm9kZUNvbXBhdGlibGVIZWFkZXJzKGhlYWRlcnMpIHtcblx0Y29uc3Qgb2JqID0gT2JqZWN0LmFzc2lnbih7IF9fcHJvdG9fXzogbnVsbCB9LCBoZWFkZXJzW01BUF0pO1xuXG5cdC8vIGh0dHAucmVxdWVzdCgpIG9ubHkgc3VwcG9ydHMgc3RyaW5nIGFzIEhvc3QgaGVhZGVyLiBUaGlzIGhhY2sgbWFrZXNcblx0Ly8gc3BlY2lmeWluZyBjdXN0b20gSG9zdCBoZWFkZXIgcG9zc2libGUuXG5cdGNvbnN0IGhvc3RIZWFkZXJLZXkgPSBmaW5kKGhlYWRlcnNbTUFQXSwgJ0hvc3QnKTtcblx0aWYgKGhvc3RIZWFkZXJLZXkgIT09IHVuZGVmaW5lZCkge1xuXHRcdG9ialtob3N0SGVhZGVyS2V5XSA9IG9ialtob3N0SGVhZGVyS2V5XVswXTtcblx0fVxuXG5cdHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgSGVhZGVycyBvYmplY3QgZnJvbSBhbiBvYmplY3Qgb2YgaGVhZGVycywgaWdub3JpbmcgdGhvc2UgdGhhdCBkb1xuICogbm90IGNvbmZvcm0gdG8gSFRUUCBncmFtbWFyIHByb2R1Y3Rpb25zLlxuICpcbiAqIEBwYXJhbSAgIE9iamVjdCAgb2JqICBPYmplY3Qgb2YgaGVhZGVyc1xuICogQHJldHVybiAgSGVhZGVyc1xuICovXG5mdW5jdGlvbiBjcmVhdGVIZWFkZXJzTGVuaWVudChvYmopIHtcblx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG5cdGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG5cdFx0aWYgKGludmFsaWRUb2tlblJlZ2V4LnRlc3QobmFtZSkpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblx0XHRpZiAoQXJyYXkuaXNBcnJheShvYmpbbmFtZV0pKSB7XG5cdFx0XHRmb3IgKGNvbnN0IHZhbCBvZiBvYmpbbmFtZV0pIHtcblx0XHRcdFx0aWYgKGludmFsaWRIZWFkZXJDaGFyUmVnZXgudGVzdCh2YWwpKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhlYWRlcnNbTUFQXVtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1tNQVBdW25hbWVdID0gW3ZhbF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aGVhZGVyc1tNQVBdW25hbWVdLnB1c2godmFsKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIWludmFsaWRIZWFkZXJDaGFyUmVnZXgudGVzdChvYmpbbmFtZV0pKSB7XG5cdFx0XHRoZWFkZXJzW01BUF1bbmFtZV0gPSBbb2JqW25hbWVdXTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGhlYWRlcnM7XG59XG5cbmNvbnN0IElOVEVSTkFMUyQxID0gU3ltYm9sKCdSZXNwb25zZSBpbnRlcm5hbHMnKTtcblxuLy8gZml4IGFuIGlzc3VlIHdoZXJlIFwiU1RBVFVTX0NPREVTXCIgYXJlbid0IGEgbmFtZWQgZXhwb3J0IGZvciBub2RlIDwxMFxuY29uc3QgU1RBVFVTX0NPREVTID0gaHR0cC5TVEFUVVNfQ09ERVM7XG5cbi8qKlxuICogUmVzcG9uc2UgY2xhc3NcbiAqXG4gKiBAcGFyYW0gICBTdHJlYW0gIGJvZHkgIFJlYWRhYmxlIHN0cmVhbVxuICogQHBhcmFtICAgT2JqZWN0ICBvcHRzICBSZXNwb25zZSBvcHRpb25zXG4gKiBAcmV0dXJuICBWb2lkXG4gKi9cbmNsYXNzIFJlc3BvbnNlIHtcblx0Y29uc3RydWN0b3IoKSB7XG5cdFx0bGV0IGJvZHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cdFx0bGV0IG9wdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG5cdFx0Qm9keS5jYWxsKHRoaXMsIGJvZHksIG9wdHMpO1xuXG5cdFx0Y29uc3Qgc3RhdHVzID0gb3B0cy5zdGF0dXMgfHwgMjAwO1xuXHRcdGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRzLmhlYWRlcnMpO1xuXG5cdFx0aWYgKGJvZHkgIT0gbnVsbCAmJiAhaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpKSB7XG5cdFx0XHRjb25zdCBjb250ZW50VHlwZSA9IGV4dHJhY3RDb250ZW50VHlwZShib2R5KTtcblx0XHRcdGlmIChjb250ZW50VHlwZSkge1xuXHRcdFx0XHRoZWFkZXJzLmFwcGVuZCgnQ29udGVudC1UeXBlJywgY29udGVudFR5cGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXNbSU5URVJOQUxTJDFdID0ge1xuXHRcdFx0dXJsOiBvcHRzLnVybCxcblx0XHRcdHN0YXR1cyxcblx0XHRcdHN0YXR1c1RleHQ6IG9wdHMuc3RhdHVzVGV4dCB8fCBTVEFUVVNfQ09ERVNbc3RhdHVzXSxcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRjb3VudGVyOiBvcHRzLmNvdW50ZXJcblx0XHR9O1xuXHR9XG5cblx0Z2V0IHVybCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0udXJsIHx8ICcnO1xuXHR9XG5cblx0Z2V0IHN0YXR1cygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzO1xuXHR9XG5cblx0LyoqXG4gICogQ29udmVuaWVuY2UgcHJvcGVydHkgcmVwcmVzZW50aW5nIGlmIHRoZSByZXF1ZXN0IGVuZGVkIG5vcm1hbGx5XG4gICovXG5cdGdldCBvaygpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzID49IDIwMCAmJiB0aGlzW0lOVEVSTkFMUyQxXS5zdGF0dXMgPCAzMDA7XG5cdH1cblxuXHRnZXQgcmVkaXJlY3RlZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uY291bnRlciA+IDA7XG5cdH1cblxuXHRnZXQgc3RhdHVzVGV4dCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMV0uc3RhdHVzVGV4dDtcblx0fVxuXG5cdGdldCBoZWFkZXJzKCkge1xuXHRcdHJldHVybiB0aGlzW0lOVEVSTkFMUyQxXS5oZWFkZXJzO1xuXHR9XG5cblx0LyoqXG4gICogQ2xvbmUgdGhpcyByZXNwb25zZVxuICAqXG4gICogQHJldHVybiAgUmVzcG9uc2VcbiAgKi9cblx0Y2xvbmUoKSB7XG5cdFx0cmV0dXJuIG5ldyBSZXNwb25zZShjbG9uZSh0aGlzKSwge1xuXHRcdFx0dXJsOiB0aGlzLnVybCxcblx0XHRcdHN0YXR1czogdGhpcy5zdGF0dXMsXG5cdFx0XHRzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG5cdFx0XHRoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG5cdFx0XHRvazogdGhpcy5vayxcblx0XHRcdHJlZGlyZWN0ZWQ6IHRoaXMucmVkaXJlY3RlZFxuXHRcdH0pO1xuXHR9XG59XG5cbkJvZHkubWl4SW4oUmVzcG9uc2UucHJvdG90eXBlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVzcG9uc2UucHJvdG90eXBlLCB7XG5cdHVybDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHN0YXR1czogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdG9rOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0cmVkaXJlY3RlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHN0YXR1c1RleHQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRoZWFkZXJzOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0Y2xvbmU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlc3BvbnNlLnByb3RvdHlwZSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7XG5cdHZhbHVlOiAnUmVzcG9uc2UnLFxuXHR3cml0YWJsZTogZmFsc2UsXG5cdGVudW1lcmFibGU6IGZhbHNlLFxuXHRjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG5jb25zdCBJTlRFUk5BTFMkMiA9IFN5bWJvbCgnUmVxdWVzdCBpbnRlcm5hbHMnKTtcbmNvbnN0IFVSTCA9IFVybC5VUkwgfHwgd2hhdHdnVXJsLlVSTDtcblxuLy8gZml4IGFuIGlzc3VlIHdoZXJlIFwiZm9ybWF0XCIsIFwicGFyc2VcIiBhcmVuJ3QgYSBuYW1lZCBleHBvcnQgZm9yIG5vZGUgPDEwXG5jb25zdCBwYXJzZV91cmwgPSBVcmwucGFyc2U7XG5jb25zdCBmb3JtYXRfdXJsID0gVXJsLmZvcm1hdDtcblxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCBgbmV3IFVSTGAgdG8gaGFuZGxlIGFyYml0cmFyeSBVUkxzXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB1cmxTdHJcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlVVJMKHVybFN0cikge1xuXHQvKlxuIFx0Q2hlY2sgd2hldGhlciB0aGUgVVJMIGlzIGFic29sdXRlIG9yIG5vdFxuIFx0XHRTY2hlbWU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4gXHRBYnNvbHV0ZSBVUkw6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNC4zXG4gKi9cblx0aWYgKC9eW2EtekEtWl1bYS16QS1aXFxkK1xcLS5dKjovLmV4ZWModXJsU3RyKSkge1xuXHRcdHVybFN0ciA9IG5ldyBVUkwodXJsU3RyKS50b1N0cmluZygpO1xuXHR9XG5cblx0Ly8gRmFsbGJhY2sgdG8gb2xkIGltcGxlbWVudGF0aW9uIGZvciBhcmJpdHJhcnkgVVJMc1xuXHRyZXR1cm4gcGFyc2VfdXJsKHVybFN0cik7XG59XG5cbmNvbnN0IHN0cmVhbURlc3RydWN0aW9uU3VwcG9ydGVkID0gJ2Rlc3Ryb3knIGluIFN0cmVhbS5SZWFkYWJsZS5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBpbnN0YW5jZSBvZiBSZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSAgIE1peGVkICAgaW5wdXRcbiAqIEByZXR1cm4gIEJvb2xlYW5cbiAqL1xuZnVuY3Rpb24gaXNSZXF1ZXN0KGlucHV0KSB7XG5cdHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnB1dFtJTlRFUk5BTFMkMl0gPT09ICdvYmplY3QnO1xufVxuXG5mdW5jdGlvbiBpc0Fib3J0U2lnbmFsKHNpZ25hbCkge1xuXHRjb25zdCBwcm90byA9IHNpZ25hbCAmJiB0eXBlb2Ygc2lnbmFsID09PSAnb2JqZWN0JyAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc2lnbmFsKTtcblx0cmV0dXJuICEhKHByb3RvICYmIHByb3RvLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBYm9ydFNpZ25hbCcpO1xufVxuXG4vKipcbiAqIFJlcXVlc3QgY2xhc3NcbiAqXG4gKiBAcGFyYW0gICBNaXhlZCAgIGlucHV0ICBVcmwgb3IgUmVxdWVzdCBpbnN0YW5jZVxuICogQHBhcmFtICAgT2JqZWN0ICBpbml0ICAgQ3VzdG9tIG9wdGlvbnNcbiAqIEByZXR1cm4gIFZvaWRcbiAqL1xuY2xhc3MgUmVxdWVzdCB7XG5cdGNvbnN0cnVjdG9yKGlucHV0KSB7XG5cdFx0bGV0IGluaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG5cdFx0bGV0IHBhcnNlZFVSTDtcblxuXHRcdC8vIG5vcm1hbGl6ZSBpbnB1dFxuXHRcdGlmICghaXNSZXF1ZXN0KGlucHV0KSkge1xuXHRcdFx0aWYgKGlucHV0ICYmIGlucHV0LmhyZWYpIHtcblx0XHRcdFx0Ly8gaW4gb3JkZXIgdG8gc3VwcG9ydCBOb2RlLmpzJyBVcmwgb2JqZWN0czsgdGhvdWdoIFdIQVRXRydzIFVSTCBvYmplY3RzXG5cdFx0XHRcdC8vIHdpbGwgZmFsbCBpbnRvIHRoaXMgYnJhbmNoIGFsc28gKHNpbmNlIHRoZWlyIGB0b1N0cmluZygpYCB3aWxsIHJldHVyblxuXHRcdFx0XHQvLyBgaHJlZmAgcHJvcGVydHkgYW55d2F5KVxuXHRcdFx0XHRwYXJzZWRVUkwgPSBwYXJzZVVSTChpbnB1dC5ocmVmKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGNvZXJjZSBpbnB1dCB0byBhIHN0cmluZyBiZWZvcmUgYXR0ZW1wdGluZyB0byBwYXJzZVxuXHRcdFx0XHRwYXJzZWRVUkwgPSBwYXJzZVVSTChgJHtpbnB1dH1gKTtcblx0XHRcdH1cblx0XHRcdGlucHV0ID0ge307XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBhcnNlZFVSTCA9IHBhcnNlVVJMKGlucHV0LnVybCk7XG5cdFx0fVxuXG5cdFx0bGV0IG1ldGhvZCA9IGluaXQubWV0aG9kIHx8IGlucHV0Lm1ldGhvZCB8fCAnR0VUJztcblx0XHRtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcblxuXHRcdGlmICgoaW5pdC5ib2R5ICE9IG51bGwgfHwgaXNSZXF1ZXN0KGlucHV0KSAmJiBpbnB1dC5ib2R5ICE9PSBudWxsKSAmJiAobWV0aG9kID09PSAnR0VUJyB8fCBtZXRob2QgPT09ICdIRUFEJykpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlcXVlc3Qgd2l0aCBHRVQvSEVBRCBtZXRob2QgY2Fubm90IGhhdmUgYm9keScpO1xuXHRcdH1cblxuXHRcdGxldCBpbnB1dEJvZHkgPSBpbml0LmJvZHkgIT0gbnVsbCA/IGluaXQuYm9keSA6IGlzUmVxdWVzdChpbnB1dCkgJiYgaW5wdXQuYm9keSAhPT0gbnVsbCA/IGNsb25lKGlucHV0KSA6IG51bGw7XG5cblx0XHRCb2R5LmNhbGwodGhpcywgaW5wdXRCb2R5LCB7XG5cdFx0XHR0aW1lb3V0OiBpbml0LnRpbWVvdXQgfHwgaW5wdXQudGltZW91dCB8fCAwLFxuXHRcdFx0c2l6ZTogaW5pdC5zaXplIHx8IGlucHV0LnNpemUgfHwgMFxuXHRcdH0pO1xuXG5cdFx0Y29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKGluaXQuaGVhZGVycyB8fCBpbnB1dC5oZWFkZXJzIHx8IHt9KTtcblxuXHRcdGlmIChpbnB1dEJvZHkgIT0gbnVsbCAmJiAhaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpKSB7XG5cdFx0XHRjb25zdCBjb250ZW50VHlwZSA9IGV4dHJhY3RDb250ZW50VHlwZShpbnB1dEJvZHkpO1xuXHRcdFx0aWYgKGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdGhlYWRlcnMuYXBwZW5kKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHNpZ25hbCA9IGlzUmVxdWVzdChpbnB1dCkgPyBpbnB1dC5zaWduYWwgOiBudWxsO1xuXHRcdGlmICgnc2lnbmFsJyBpbiBpbml0KSBzaWduYWwgPSBpbml0LnNpZ25hbDtcblxuXHRcdGlmIChzaWduYWwgIT0gbnVsbCAmJiAhaXNBYm9ydFNpZ25hbChzaWduYWwpKSB7XG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBzaWduYWwgdG8gYmUgYW4gaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCcpO1xuXHRcdH1cblxuXHRcdHRoaXNbSU5URVJOQUxTJDJdID0ge1xuXHRcdFx0bWV0aG9kLFxuXHRcdFx0cmVkaXJlY3Q6IGluaXQucmVkaXJlY3QgfHwgaW5wdXQucmVkaXJlY3QgfHwgJ2ZvbGxvdycsXG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0cGFyc2VkVVJMLFxuXHRcdFx0c2lnbmFsXG5cdFx0fTtcblxuXHRcdC8vIG5vZGUtZmV0Y2gtb25seSBvcHRpb25zXG5cdFx0dGhpcy5mb2xsb3cgPSBpbml0LmZvbGxvdyAhPT0gdW5kZWZpbmVkID8gaW5pdC5mb2xsb3cgOiBpbnB1dC5mb2xsb3cgIT09IHVuZGVmaW5lZCA/IGlucHV0LmZvbGxvdyA6IDIwO1xuXHRcdHRoaXMuY29tcHJlc3MgPSBpbml0LmNvbXByZXNzICE9PSB1bmRlZmluZWQgPyBpbml0LmNvbXByZXNzIDogaW5wdXQuY29tcHJlc3MgIT09IHVuZGVmaW5lZCA/IGlucHV0LmNvbXByZXNzIDogdHJ1ZTtcblx0XHR0aGlzLmNvdW50ZXIgPSBpbml0LmNvdW50ZXIgfHwgaW5wdXQuY291bnRlciB8fCAwO1xuXHRcdHRoaXMuYWdlbnQgPSBpbml0LmFnZW50IHx8IGlucHV0LmFnZW50O1xuXHR9XG5cblx0Z2V0IG1ldGhvZCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMl0ubWV0aG9kO1xuXHR9XG5cblx0Z2V0IHVybCgpIHtcblx0XHRyZXR1cm4gZm9ybWF0X3VybCh0aGlzW0lOVEVSTkFMUyQyXS5wYXJzZWRVUkwpO1xuXHR9XG5cblx0Z2V0IGhlYWRlcnMoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDJdLmhlYWRlcnM7XG5cdH1cblxuXHRnZXQgcmVkaXJlY3QoKSB7XG5cdFx0cmV0dXJuIHRoaXNbSU5URVJOQUxTJDJdLnJlZGlyZWN0O1xuXHR9XG5cblx0Z2V0IHNpZ25hbCgpIHtcblx0XHRyZXR1cm4gdGhpc1tJTlRFUk5BTFMkMl0uc2lnbmFsO1xuXHR9XG5cblx0LyoqXG4gICogQ2xvbmUgdGhpcyByZXF1ZXN0XG4gICpcbiAgKiBAcmV0dXJuICBSZXF1ZXN0XG4gICovXG5cdGNsb25lKCkge1xuXHRcdHJldHVybiBuZXcgUmVxdWVzdCh0aGlzKTtcblx0fVxufVxuXG5Cb2R5Lm1peEluKFJlcXVlc3QucHJvdG90eXBlKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlcXVlc3QucHJvdG90eXBlLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcblx0dmFsdWU6ICdSZXF1ZXN0Jyxcblx0d3JpdGFibGU6IGZhbHNlLFxuXHRlbnVtZXJhYmxlOiBmYWxzZSxcblx0Y29uZmlndXJhYmxlOiB0cnVlXG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVxdWVzdC5wcm90b3R5cGUsIHtcblx0bWV0aG9kOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0dXJsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0aGVhZGVyczogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG5cdHJlZGlyZWN0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcblx0Y2xvbmU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuXHRzaWduYWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgUmVxdWVzdCB0byBOb2RlLmpzIGh0dHAgcmVxdWVzdCBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSAgIFJlcXVlc3QgIEEgUmVxdWVzdCBpbnN0YW5jZVxuICogQHJldHVybiAgT2JqZWN0ICAgVGhlIG9wdGlvbnMgb2JqZWN0IHRvIGJlIHBhc3NlZCB0byBodHRwLnJlcXVlc3RcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZVJlcXVlc3RPcHRpb25zKHJlcXVlc3QpIHtcblx0Y29uc3QgcGFyc2VkVVJMID0gcmVxdWVzdFtJTlRFUk5BTFMkMl0ucGFyc2VkVVJMO1xuXHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVxdWVzdFtJTlRFUk5BTFMkMl0uaGVhZGVycyk7XG5cblx0Ly8gZmV0Y2ggc3RlcCAxLjNcblx0aWYgKCFoZWFkZXJzLmhhcygnQWNjZXB0JykpIHtcblx0XHRoZWFkZXJzLnNldCgnQWNjZXB0JywgJyovKicpO1xuXHR9XG5cblx0Ly8gQmFzaWMgZmV0Y2hcblx0aWYgKCFwYXJzZWRVUkwucHJvdG9jb2wgfHwgIXBhcnNlZFVSTC5ob3N0bmFtZSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09ubHkgYWJzb2x1dGUgVVJMcyBhcmUgc3VwcG9ydGVkJyk7XG5cdH1cblxuXHRpZiAoIS9eaHR0cHM/OiQvLnRlc3QocGFyc2VkVVJMLnByb3RvY29sKSkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09ubHkgSFRUUChTKSBwcm90b2NvbHMgYXJlIHN1cHBvcnRlZCcpO1xuXHR9XG5cblx0aWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3QuYm9keSBpbnN0YW5jZW9mIFN0cmVhbS5SZWFkYWJsZSAmJiAhc3RyZWFtRGVzdHJ1Y3Rpb25TdXBwb3J0ZWQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NhbmNlbGxhdGlvbiBvZiBzdHJlYW1lZCByZXF1ZXN0cyB3aXRoIEFib3J0U2lnbmFsIGlzIG5vdCBzdXBwb3J0ZWQgaW4gbm9kZSA8IDgnKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yay1vci1jYWNoZSBmZXRjaCBzdGVwcyAyLjQtMi43XG5cdGxldCBjb250ZW50TGVuZ3RoVmFsdWUgPSBudWxsO1xuXHRpZiAocmVxdWVzdC5ib2R5ID09IG51bGwgJiYgL14oUE9TVHxQVVQpJC9pLnRlc3QocmVxdWVzdC5tZXRob2QpKSB7XG5cdFx0Y29udGVudExlbmd0aFZhbHVlID0gJzAnO1xuXHR9XG5cdGlmIChyZXF1ZXN0LmJvZHkgIT0gbnVsbCkge1xuXHRcdGNvbnN0IHRvdGFsQnl0ZXMgPSBnZXRUb3RhbEJ5dGVzKHJlcXVlc3QpO1xuXHRcdGlmICh0eXBlb2YgdG90YWxCeXRlcyA9PT0gJ251bWJlcicpIHtcblx0XHRcdGNvbnRlbnRMZW5ndGhWYWx1ZSA9IFN0cmluZyh0b3RhbEJ5dGVzKTtcblx0XHR9XG5cdH1cblx0aWYgKGNvbnRlbnRMZW5ndGhWYWx1ZSkge1xuXHRcdGhlYWRlcnMuc2V0KCdDb250ZW50LUxlbmd0aCcsIGNvbnRlbnRMZW5ndGhWYWx1ZSk7XG5cdH1cblxuXHQvLyBIVFRQLW5ldHdvcmstb3ItY2FjaGUgZmV0Y2ggc3RlcCAyLjExXG5cdGlmICghaGVhZGVycy5oYXMoJ1VzZXItQWdlbnQnKSkge1xuXHRcdGhlYWRlcnMuc2V0KCdVc2VyLUFnZW50JywgJ25vZGUtZmV0Y2gvMS4wICgraHR0cHM6Ly9naXRodWIuY29tL2JpdGlubi9ub2RlLWZldGNoKScpO1xuXHR9XG5cblx0Ly8gSFRUUC1uZXR3b3JrLW9yLWNhY2hlIGZldGNoIHN0ZXAgMi4xNVxuXHRpZiAocmVxdWVzdC5jb21wcmVzcyAmJiAhaGVhZGVycy5oYXMoJ0FjY2VwdC1FbmNvZGluZycpKSB7XG5cdFx0aGVhZGVycy5zZXQoJ0FjY2VwdC1FbmNvZGluZycsICdnemlwLGRlZmxhdGUnKTtcblx0fVxuXG5cdGxldCBhZ2VudCA9IHJlcXVlc3QuYWdlbnQ7XG5cdGlmICh0eXBlb2YgYWdlbnQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRhZ2VudCA9IGFnZW50KHBhcnNlZFVSTCk7XG5cdH1cblxuXHRpZiAoIWhlYWRlcnMuaGFzKCdDb25uZWN0aW9uJykgJiYgIWFnZW50KSB7XG5cdFx0aGVhZGVycy5zZXQoJ0Nvbm5lY3Rpb24nLCAnY2xvc2UnKTtcblx0fVxuXG5cdC8vIEhUVFAtbmV0d29yayBmZXRjaCBzdGVwIDQuMlxuXHQvLyBjaHVua2VkIGVuY29kaW5nIGlzIGhhbmRsZWQgYnkgTm9kZS5qc1xuXG5cdHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwYXJzZWRVUkwsIHtcblx0XHRtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuXHRcdGhlYWRlcnM6IGV4cG9ydE5vZGVDb21wYXRpYmxlSGVhZGVycyhoZWFkZXJzKSxcblx0XHRhZ2VudFxuXHR9KTtcbn1cblxuLyoqXG4gKiBhYm9ydC1lcnJvci5qc1xuICpcbiAqIEFib3J0RXJyb3IgaW50ZXJmYWNlIGZvciBjYW5jZWxsZWQgcmVxdWVzdHNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBBYm9ydEVycm9yIGluc3RhbmNlXG4gKlxuICogQHBhcmFtICAgU3RyaW5nICAgICAgbWVzc2FnZSAgICAgIEVycm9yIG1lc3NhZ2UgZm9yIGh1bWFuXG4gKiBAcmV0dXJuICBBYm9ydEVycm9yXG4gKi9cbmZ1bmN0aW9uIEFib3J0RXJyb3IobWVzc2FnZSkge1xuICBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuXG4gIHRoaXMudHlwZSA9ICdhYm9ydGVkJztcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblxuICAvLyBoaWRlIGN1c3RvbSBlcnJvciBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIGZyb20gZW5kLXVzZXJzXG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xufVxuXG5BYm9ydEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbkFib3J0RXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWJvcnRFcnJvcjtcbkFib3J0RXJyb3IucHJvdG90eXBlLm5hbWUgPSAnQWJvcnRFcnJvcic7XG5cbmNvbnN0IFVSTCQxID0gVXJsLlVSTCB8fCB3aGF0d2dVcmwuVVJMO1xuXG4vLyBmaXggYW4gaXNzdWUgd2hlcmUgXCJQYXNzVGhyb3VnaFwiLCBcInJlc29sdmVcIiBhcmVuJ3QgYSBuYW1lZCBleHBvcnQgZm9yIG5vZGUgPDEwXG5jb25zdCBQYXNzVGhyb3VnaCQxID0gU3RyZWFtLlBhc3NUaHJvdWdoO1xuXG5jb25zdCBpc0RvbWFpbk9yU3ViZG9tYWluID0gZnVuY3Rpb24gaXNEb21haW5PclN1YmRvbWFpbihkZXN0aW5hdGlvbiwgb3JpZ2luYWwpIHtcblx0Y29uc3Qgb3JpZyA9IG5ldyBVUkwkMShvcmlnaW5hbCkuaG9zdG5hbWU7XG5cdGNvbnN0IGRlc3QgPSBuZXcgVVJMJDEoZGVzdGluYXRpb24pLmhvc3RuYW1lO1xuXG5cdHJldHVybiBvcmlnID09PSBkZXN0IHx8IG9yaWdbb3JpZy5sZW5ndGggLSBkZXN0Lmxlbmd0aCAtIDFdID09PSAnLicgJiYgb3JpZy5lbmRzV2l0aChkZXN0KTtcbn07XG5cbi8qKlxuICogaXNTYW1lUHJvdG9jb2wgcmVwb3J0cyB3aGV0aGVyIHRoZSB0d28gcHJvdmlkZWQgVVJMcyB1c2UgdGhlIHNhbWUgcHJvdG9jb2wuXG4gKlxuICogQm90aCBkb21haW5zIG11c3QgYWxyZWFkeSBiZSBpbiBjYW5vbmljYWwgZm9ybS5cbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gb3JpZ2luYWxcbiAqIEBwYXJhbSB7c3RyaW5nfFVSTH0gZGVzdGluYXRpb25cbiAqL1xuY29uc3QgaXNTYW1lUHJvdG9jb2wgPSBmdW5jdGlvbiBpc1NhbWVQcm90b2NvbChkZXN0aW5hdGlvbiwgb3JpZ2luYWwpIHtcblx0Y29uc3Qgb3JpZyA9IG5ldyBVUkwkMShvcmlnaW5hbCkucHJvdG9jb2w7XG5cdGNvbnN0IGRlc3QgPSBuZXcgVVJMJDEoZGVzdGluYXRpb24pLnByb3RvY29sO1xuXG5cdHJldHVybiBvcmlnID09PSBkZXN0O1xufTtcblxuLyoqXG4gKiBGZXRjaCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSAgIE1peGVkICAgIHVybCAgIEFic29sdXRlIHVybCBvciBSZXF1ZXN0IGluc3RhbmNlXG4gKiBAcGFyYW0gICBPYmplY3QgICBvcHRzICBGZXRjaCBvcHRpb25zXG4gKiBAcmV0dXJuICBQcm9taXNlXG4gKi9cbmZ1bmN0aW9uIGZldGNoKHVybCwgb3B0cykge1xuXG5cdC8vIGFsbG93IGN1c3RvbSBwcm9taXNlXG5cdGlmICghZmV0Y2guUHJvbWlzZSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignbmF0aXZlIHByb21pc2UgbWlzc2luZywgc2V0IGZldGNoLlByb21pc2UgdG8geW91ciBmYXZvcml0ZSBhbHRlcm5hdGl2ZScpO1xuXHR9XG5cblx0Qm9keS5Qcm9taXNlID0gZmV0Y2guUHJvbWlzZTtcblxuXHQvLyB3cmFwIGh0dHAucmVxdWVzdCBpbnRvIGZldGNoXG5cdHJldHVybiBuZXcgZmV0Y2guUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0Ly8gYnVpbGQgcmVxdWVzdCBvYmplY3Rcblx0XHRjb25zdCByZXF1ZXN0ID0gbmV3IFJlcXVlc3QodXJsLCBvcHRzKTtcblx0XHRjb25zdCBvcHRpb25zID0gZ2V0Tm9kZVJlcXVlc3RPcHRpb25zKHJlcXVlc3QpO1xuXG5cdFx0Y29uc3Qgc2VuZCA9IChvcHRpb25zLnByb3RvY29sID09PSAnaHR0cHM6JyA/IGh0dHBzIDogaHR0cCkucmVxdWVzdDtcblx0XHRjb25zdCBzaWduYWwgPSByZXF1ZXN0LnNpZ25hbDtcblxuXHRcdGxldCByZXNwb25zZSA9IG51bGw7XG5cblx0XHRjb25zdCBhYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuXHRcdFx0bGV0IGVycm9yID0gbmV3IEFib3J0RXJyb3IoJ1RoZSB1c2VyIGFib3J0ZWQgYSByZXF1ZXN0LicpO1xuXHRcdFx0cmVqZWN0KGVycm9yKTtcblx0XHRcdGlmIChyZXF1ZXN0LmJvZHkgJiYgcmVxdWVzdC5ib2R5IGluc3RhbmNlb2YgU3RyZWFtLlJlYWRhYmxlKSB7XG5cdFx0XHRcdGRlc3Ryb3lTdHJlYW0ocmVxdWVzdC5ib2R5LCBlcnJvcik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIXJlc3BvbnNlIHx8ICFyZXNwb25zZS5ib2R5KSByZXR1cm47XG5cdFx0XHRyZXNwb25zZS5ib2R5LmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuXHRcdH07XG5cblx0XHRpZiAoc2lnbmFsICYmIHNpZ25hbC5hYm9ydGVkKSB7XG5cdFx0XHRhYm9ydCgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGNvbnN0IGFib3J0QW5kRmluYWxpemUgPSBmdW5jdGlvbiBhYm9ydEFuZEZpbmFsaXplKCkge1xuXHRcdFx0YWJvcnQoKTtcblx0XHRcdGZpbmFsaXplKCk7XG5cdFx0fTtcblxuXHRcdC8vIHNlbmQgcmVxdWVzdFxuXHRcdGNvbnN0IHJlcSA9IHNlbmQob3B0aW9ucyk7XG5cdFx0bGV0IHJlcVRpbWVvdXQ7XG5cblx0XHRpZiAoc2lnbmFsKSB7XG5cdFx0XHRzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFuZEZpbmFsaXplKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaW5hbGl6ZSgpIHtcblx0XHRcdHJlcS5hYm9ydCgpO1xuXHRcdFx0aWYgKHNpZ25hbCkgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0XHRjbGVhclRpbWVvdXQocmVxVGltZW91dCk7XG5cdFx0fVxuXG5cdFx0aWYgKHJlcXVlc3QudGltZW91dCkge1xuXHRcdFx0cmVxLm9uY2UoJ3NvY2tldCcsIGZ1bmN0aW9uIChzb2NrZXQpIHtcblx0XHRcdFx0cmVxVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgbmV0d29yayB0aW1lb3V0IGF0OiAke3JlcXVlc3QudXJsfWAsICdyZXF1ZXN0LXRpbWVvdXQnKSk7XG5cdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0fSwgcmVxdWVzdC50aW1lb3V0KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYHJlcXVlc3QgdG8gJHtyZXF1ZXN0LnVybH0gZmFpbGVkLCByZWFzb246ICR7ZXJyLm1lc3NhZ2V9YCwgJ3N5c3RlbScsIGVycikpO1xuXG5cdFx0XHRpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuYm9keSkge1xuXHRcdFx0XHRkZXN0cm95U3RyZWFtKHJlc3BvbnNlLmJvZHksIGVycik7XG5cdFx0XHR9XG5cblx0XHRcdGZpbmFsaXplKCk7XG5cdFx0fSk7XG5cblx0XHRmaXhSZXNwb25zZUNodW5rZWRUcmFuc2ZlckJhZEVuZGluZyhyZXEsIGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdGlmIChzaWduYWwgJiYgc2lnbmFsLmFib3J0ZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAocmVzcG9uc2UgJiYgcmVzcG9uc2UuYm9keSkge1xuXHRcdFx0XHRkZXN0cm95U3RyZWFtKHJlc3BvbnNlLmJvZHksIGVycik7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKiBjOCBpZ25vcmUgbmV4dCAxOCAqL1xuXHRcdGlmIChwYXJzZUludChwcm9jZXNzLnZlcnNpb24uc3Vic3RyaW5nKDEpKSA8IDE0KSB7XG5cdFx0XHQvLyBCZWZvcmUgTm9kZS5qcyAxNCwgcGlwZWxpbmUoKSBkb2VzIG5vdCBmdWxseSBzdXBwb3J0IGFzeW5jIGl0ZXJhdG9ycyBhbmQgZG9lcyBub3QgYWx3YXlzXG5cdFx0XHQvLyBwcm9wZXJseSBoYW5kbGUgd2hlbiB0aGUgc29ja2V0IGNsb3NlL2VuZCBldmVudHMgYXJlIG91dCBvZiBvcmRlci5cblx0XHRcdHJlcS5vbignc29ja2V0JywgZnVuY3Rpb24gKHMpIHtcblx0XHRcdFx0cy5hZGRMaXN0ZW5lcignY2xvc2UnLCBmdW5jdGlvbiAoaGFkRXJyb3IpIHtcblx0XHRcdFx0XHQvLyBpZiBhIGRhdGEgbGlzdGVuZXIgaXMgc3RpbGwgcHJlc2VudCB3ZSBkaWRuJ3QgZW5kIGNsZWFubHlcblx0XHRcdFx0XHRjb25zdCBoYXNEYXRhTGlzdGVuZXIgPSBzLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDA7XG5cblx0XHRcdFx0XHQvLyBpZiBlbmQgaGFwcGVuZWQgYmVmb3JlIGNsb3NlIGJ1dCB0aGUgc29ja2V0IGRpZG4ndCBlbWl0IGFuIGVycm9yLCBkbyBpdCBub3dcblx0XHRcdFx0XHRpZiAocmVzcG9uc2UgJiYgaGFzRGF0YUxpc3RlbmVyICYmICFoYWRFcnJvciAmJiAhKHNpZ25hbCAmJiBzaWduYWwuYWJvcnRlZCkpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGVyciA9IG5ldyBFcnJvcignUHJlbWF0dXJlIGNsb3NlJyk7XG5cdFx0XHRcdFx0XHRlcnIuY29kZSA9ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSc7XG5cdFx0XHRcdFx0XHRyZXNwb25zZS5ib2R5LmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0cmVxLm9uKCdyZXNwb25zZScsIGZ1bmN0aW9uIChyZXMpIHtcblx0XHRcdGNsZWFyVGltZW91dChyZXFUaW1lb3V0KTtcblxuXHRcdFx0Y29uc3QgaGVhZGVycyA9IGNyZWF0ZUhlYWRlcnNMZW5pZW50KHJlcy5oZWFkZXJzKTtcblxuXHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDVcblx0XHRcdGlmIChmZXRjaC5pc1JlZGlyZWN0KHJlcy5zdGF0dXNDb2RlKSkge1xuXHRcdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNS4yXG5cdFx0XHRcdGNvbnN0IGxvY2F0aW9uID0gaGVhZGVycy5nZXQoJ0xvY2F0aW9uJyk7XG5cblx0XHRcdFx0Ly8gSFRUUCBmZXRjaCBzdGVwIDUuM1xuXHRcdFx0XHRsZXQgbG9jYXRpb25VUkwgPSBudWxsO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGxvY2F0aW9uVVJMID0gbG9jYXRpb24gPT09IG51bGwgPyBudWxsIDogbmV3IFVSTCQxKGxvY2F0aW9uLCByZXF1ZXN0LnVybCkudG9TdHJpbmcoKTtcblx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0Ly8gZXJyb3IgaGVyZSBjYW4gb25seSBiZSBpbnZhbGlkIFVSTCBpbiBMb2NhdGlvbjogaGVhZGVyXG5cdFx0XHRcdFx0Ly8gZG8gbm90IHRocm93IHdoZW4gb3B0aW9ucy5yZWRpcmVjdCA9PSBtYW51YWxcblx0XHRcdFx0XHQvLyBsZXQgdGhlIHVzZXIgZXh0cmFjdCB0aGUgZXJyb3JuZW91cyByZWRpcmVjdCBVUkxcblx0XHRcdFx0XHRpZiAocmVxdWVzdC5yZWRpcmVjdCAhPT0gJ21hbnVhbCcpIHtcblx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgdXJpIHJlcXVlc3RlZCByZXNwb25kcyB3aXRoIGFuIGludmFsaWQgcmVkaXJlY3QgVVJMOiAke2xvY2F0aW9ufWAsICdpbnZhbGlkLXJlZGlyZWN0JykpO1xuXHRcdFx0XHRcdFx0ZmluYWxpemUoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIVFRQIGZldGNoIHN0ZXAgNS41XG5cdFx0XHRcdHN3aXRjaCAocmVxdWVzdC5yZWRpcmVjdCkge1xuXHRcdFx0XHRcdGNhc2UgJ2Vycm9yJzpcblx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcihgdXJpIHJlcXVlc3RlZCByZXNwb25kcyB3aXRoIGEgcmVkaXJlY3QsIHJlZGlyZWN0IG1vZGUgaXMgc2V0IHRvIGVycm9yOiAke3JlcXVlc3QudXJsfWAsICduby1yZWRpcmVjdCcpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0Y2FzZSAnbWFudWFsJzpcblx0XHRcdFx0XHRcdC8vIG5vZGUtZmV0Y2gtc3BlY2lmaWMgc3RlcDogbWFrZSBtYW51YWwgcmVkaXJlY3QgYSBiaXQgZWFzaWVyIHRvIHVzZSBieSBzZXR0aW5nIHRoZSBMb2NhdGlvbiBoZWFkZXIgdmFsdWUgdG8gdGhlIHJlc29sdmVkIFVSTC5cblx0XHRcdFx0XHRcdGlmIChsb2NhdGlvblVSTCAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHQvLyBoYW5kbGUgY29ycnVwdGVkIGhlYWRlclxuXHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdGhlYWRlcnMuc2V0KCdMb2NhdGlvbicsIGxvY2F0aW9uVVJMKTtcblx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gaXN0YW5idWwgaWdub3JlIG5leHQ6IG5vZGVqcyBzZXJ2ZXIgcHJldmVudCBpbnZhbGlkIHJlc3BvbnNlIGhlYWRlcnMsIHdlIGNhbid0IHRlc3QgdGhpcyB0aHJvdWdoIG5vcm1hbCByZXF1ZXN0XG5cdFx0XHRcdFx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ2ZvbGxvdyc6XG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgMlxuXHRcdFx0XHRcdFx0aWYgKGxvY2F0aW9uVVJMID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBIVFRQLXJlZGlyZWN0IGZldGNoIHN0ZXAgNVxuXHRcdFx0XHRcdFx0aWYgKHJlcXVlc3QuY291bnRlciA+PSByZXF1ZXN0LmZvbGxvdykge1xuXHRcdFx0XHRcdFx0XHRyZWplY3QobmV3IEZldGNoRXJyb3IoYG1heGltdW0gcmVkaXJlY3QgcmVhY2hlZCBhdDogJHtyZXF1ZXN0LnVybH1gLCAnbWF4LXJlZGlyZWN0JykpO1xuXHRcdFx0XHRcdFx0XHRmaW5hbGl6ZSgpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEhUVFAtcmVkaXJlY3QgZmV0Y2ggc3RlcCA2IChjb3VudGVyIGluY3JlbWVudClcblx0XHRcdFx0XHRcdC8vIENyZWF0ZSBhIG5ldyBSZXF1ZXN0IG9iamVjdC5cblx0XHRcdFx0XHRcdGNvbnN0IHJlcXVlc3RPcHRzID0ge1xuXHRcdFx0XHRcdFx0XHRoZWFkZXJzOiBuZXcgSGVhZGVycyhyZXF1ZXN0LmhlYWRlcnMpLFxuXHRcdFx0XHRcdFx0XHRmb2xsb3c6IHJlcXVlc3QuZm9sbG93LFxuXHRcdFx0XHRcdFx0XHRjb3VudGVyOiByZXF1ZXN0LmNvdW50ZXIgKyAxLFxuXHRcdFx0XHRcdFx0XHRhZ2VudDogcmVxdWVzdC5hZ2VudCxcblx0XHRcdFx0XHRcdFx0Y29tcHJlc3M6IHJlcXVlc3QuY29tcHJlc3MsXG5cdFx0XHRcdFx0XHRcdG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG5cdFx0XHRcdFx0XHRcdGJvZHk6IHJlcXVlc3QuYm9keSxcblx0XHRcdFx0XHRcdFx0c2lnbmFsOiByZXF1ZXN0LnNpZ25hbCxcblx0XHRcdFx0XHRcdFx0dGltZW91dDogcmVxdWVzdC50aW1lb3V0LFxuXHRcdFx0XHRcdFx0XHRzaXplOiByZXF1ZXN0LnNpemVcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdGlmICghaXNEb21haW5PclN1YmRvbWFpbihyZXF1ZXN0LnVybCwgbG9jYXRpb25VUkwpIHx8ICFpc1NhbWVQcm90b2NvbChyZXF1ZXN0LnVybCwgbG9jYXRpb25VUkwpKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoY29uc3QgbmFtZSBvZiBbJ2F1dGhvcml6YXRpb24nLCAnd3d3LWF1dGhlbnRpY2F0ZScsICdjb29raWUnLCAnY29va2llMiddKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVxdWVzdE9wdHMuaGVhZGVycy5kZWxldGUobmFtZSk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDlcblx0XHRcdFx0XHRcdGlmIChyZXMuc3RhdHVzQ29kZSAhPT0gMzAzICYmIHJlcXVlc3QuYm9keSAmJiBnZXRUb3RhbEJ5dGVzKHJlcXVlc3QpID09PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRcdHJlamVjdChuZXcgRmV0Y2hFcnJvcignQ2Fubm90IGZvbGxvdyByZWRpcmVjdCB3aXRoIGJvZHkgYmVpbmcgYSByZWFkYWJsZSBzdHJlYW0nLCAndW5zdXBwb3J0ZWQtcmVkaXJlY3QnKSk7XG5cdFx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDExXG5cdFx0XHRcdFx0XHRpZiAocmVzLnN0YXR1c0NvZGUgPT09IDMwMyB8fCAocmVzLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXMuc3RhdHVzQ29kZSA9PT0gMzAyKSAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSB7XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RPcHRzLm1ldGhvZCA9ICdHRVQnO1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0cy5ib2R5ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0T3B0cy5oZWFkZXJzLmRlbGV0ZSgnY29udGVudC1sZW5ndGgnKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gSFRUUC1yZWRpcmVjdCBmZXRjaCBzdGVwIDE1XG5cdFx0XHRcdFx0XHRyZXNvbHZlKGZldGNoKG5ldyBSZXF1ZXN0KGxvY2F0aW9uVVJMLCByZXF1ZXN0T3B0cykpKTtcblx0XHRcdFx0XHRcdGZpbmFsaXplKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJlcGFyZSByZXNwb25zZVxuXHRcdFx0cmVzLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0aWYgKHNpZ25hbCkgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbmRGaW5hbGl6ZSk7XG5cdFx0XHR9KTtcblx0XHRcdGxldCBib2R5ID0gcmVzLnBpcGUobmV3IFBhc3NUaHJvdWdoJDEoKSk7XG5cblx0XHRcdGNvbnN0IHJlc3BvbnNlX29wdGlvbnMgPSB7XG5cdFx0XHRcdHVybDogcmVxdWVzdC51cmwsXG5cdFx0XHRcdHN0YXR1czogcmVzLnN0YXR1c0NvZGUsXG5cdFx0XHRcdHN0YXR1c1RleHQ6IHJlcy5zdGF0dXNNZXNzYWdlLFxuXHRcdFx0XHRoZWFkZXJzOiBoZWFkZXJzLFxuXHRcdFx0XHRzaXplOiByZXF1ZXN0LnNpemUsXG5cdFx0XHRcdHRpbWVvdXQ6IHJlcXVlc3QudGltZW91dCxcblx0XHRcdFx0Y291bnRlcjogcmVxdWVzdC5jb3VudGVyXG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBIVFRQLW5ldHdvcmsgZmV0Y2ggc3RlcCAxMi4xLjEuM1xuXHRcdFx0Y29uc3QgY29kaW5ncyA9IGhlYWRlcnMuZ2V0KCdDb250ZW50LUVuY29kaW5nJyk7XG5cblx0XHRcdC8vIEhUVFAtbmV0d29yayBmZXRjaCBzdGVwIDEyLjEuMS40OiBoYW5kbGUgY29udGVudCBjb2RpbmdzXG5cblx0XHRcdC8vIGluIGZvbGxvd2luZyBzY2VuYXJpb3Mgd2UgaWdub3JlIGNvbXByZXNzaW9uIHN1cHBvcnRcblx0XHRcdC8vIDEuIGNvbXByZXNzaW9uIHN1cHBvcnQgaXMgZGlzYWJsZWRcblx0XHRcdC8vIDIuIEhFQUQgcmVxdWVzdFxuXHRcdFx0Ly8gMy4gbm8gQ29udGVudC1FbmNvZGluZyBoZWFkZXJcblx0XHRcdC8vIDQuIG5vIGNvbnRlbnQgcmVzcG9uc2UgKDIwNClcblx0XHRcdC8vIDUuIGNvbnRlbnQgbm90IG1vZGlmaWVkIHJlc3BvbnNlICgzMDQpXG5cdFx0XHRpZiAoIXJlcXVlc3QuY29tcHJlc3MgfHwgcmVxdWVzdC5tZXRob2QgPT09ICdIRUFEJyB8fCBjb2RpbmdzID09PSBudWxsIHx8IHJlcy5zdGF0dXNDb2RlID09PSAyMDQgfHwgcmVzLnN0YXR1c0NvZGUgPT09IDMwNCkge1xuXHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZV9vcHRpb25zKTtcblx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIE5vZGUgdjYrXG5cdFx0XHQvLyBCZSBsZXNzIHN0cmljdCB3aGVuIGRlY29kaW5nIGNvbXByZXNzZWQgcmVzcG9uc2VzLCBzaW5jZSBzb21ldGltZXNcblx0XHRcdC8vIHNlcnZlcnMgc2VuZCBzbGlnaHRseSBpbnZhbGlkIHJlc3BvbnNlcyB0aGF0IGFyZSBzdGlsbCBhY2NlcHRlZFxuXHRcdFx0Ly8gYnkgY29tbW9uIGJyb3dzZXJzLlxuXHRcdFx0Ly8gQWx3YXlzIHVzaW5nIFpfU1lOQ19GTFVTSCBpcyB3aGF0IGNVUkwgZG9lcy5cblx0XHRcdGNvbnN0IHpsaWJPcHRpb25zID0ge1xuXHRcdFx0XHRmbHVzaDogemxpYi5aX1NZTkNfRkxVU0gsXG5cdFx0XHRcdGZpbmlzaEZsdXNoOiB6bGliLlpfU1lOQ19GTFVTSFxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZm9yIGd6aXBcblx0XHRcdGlmIChjb2RpbmdzID09ICdnemlwJyB8fCBjb2RpbmdzID09ICd4LWd6aXAnKSB7XG5cdFx0XHRcdGJvZHkgPSBib2R5LnBpcGUoemxpYi5jcmVhdGVHdW56aXAoemxpYk9wdGlvbnMpKTtcblx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2Vfb3B0aW9ucyk7XG5cdFx0XHRcdHJlc29sdmUocmVzcG9uc2UpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIGZvciBkZWZsYXRlXG5cdFx0XHRpZiAoY29kaW5ncyA9PSAnZGVmbGF0ZScgfHwgY29kaW5ncyA9PSAneC1kZWZsYXRlJykge1xuXHRcdFx0XHQvLyBoYW5kbGUgdGhlIGluZmFtb3VzIHJhdyBkZWZsYXRlIHJlc3BvbnNlIGZyb20gb2xkIHNlcnZlcnNcblx0XHRcdFx0Ly8gYSBoYWNrIGZvciBvbGQgSUlTIGFuZCBBcGFjaGUgc2VydmVyc1xuXHRcdFx0XHRjb25zdCByYXcgPSByZXMucGlwZShuZXcgUGFzc1Rocm91Z2gkMSgpKTtcblx0XHRcdFx0cmF3Lm9uY2UoJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcblx0XHRcdFx0XHQvLyBzZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNzUxOTgyOFxuXHRcdFx0XHRcdGlmICgoY2h1bmtbMF0gJiAweDBGKSA9PT0gMHgwOCkge1xuXHRcdFx0XHRcdFx0Ym9keSA9IGJvZHkucGlwZSh6bGliLmNyZWF0ZUluZmxhdGUoKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJvZHkgPSBib2R5LnBpcGUoemxpYi5jcmVhdGVJbmZsYXRlUmF3KCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZV9vcHRpb25zKTtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJhdy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdC8vIHNvbWUgb2xkIElJUyBzZXJ2ZXJzIHJldHVybiB6ZXJvLWxlbmd0aCBPSyBkZWZsYXRlIHJlc3BvbnNlcywgc28gJ2RhdGEnIGlzIG5ldmVyIGVtaXR0ZWQuXG5cdFx0XHRcdFx0aWYgKCFyZXNwb25zZSkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoYm9keSwgcmVzcG9uc2Vfb3B0aW9ucyk7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3BvbnNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIGZvciBiclxuXHRcdFx0aWYgKGNvZGluZ3MgPT0gJ2JyJyAmJiB0eXBlb2YgemxpYi5jcmVhdGVCcm90bGlEZWNvbXByZXNzID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGJvZHkgPSBib2R5LnBpcGUoemxpYi5jcmVhdGVCcm90bGlEZWNvbXByZXNzKCkpO1xuXHRcdFx0XHRyZXNwb25zZSA9IG5ldyBSZXNwb25zZShib2R5LCByZXNwb25zZV9vcHRpb25zKTtcblx0XHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gb3RoZXJ3aXNlLCB1c2UgcmVzcG9uc2UgYXMtaXNcblx0XHRcdHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKGJvZHksIHJlc3BvbnNlX29wdGlvbnMpO1xuXHRcdFx0cmVzb2x2ZShyZXNwb25zZSk7XG5cdFx0fSk7XG5cblx0XHR3cml0ZVRvU3RyZWFtKHJlcSwgcmVxdWVzdCk7XG5cdH0pO1xufVxuZnVuY3Rpb24gZml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmcocmVxdWVzdCwgZXJyb3JDYWxsYmFjaykge1xuXHRsZXQgc29ja2V0O1xuXG5cdHJlcXVlc3Qub24oJ3NvY2tldCcsIGZ1bmN0aW9uIChzKSB7XG5cdFx0c29ja2V0ID0gcztcblx0fSk7XG5cblx0cmVxdWVzdC5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0XHRjb25zdCBoZWFkZXJzID0gcmVzcG9uc2UuaGVhZGVycztcblxuXHRcdGlmIChoZWFkZXJzWyd0cmFuc2Zlci1lbmNvZGluZyddID09PSAnY2h1bmtlZCcgJiYgIWhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10pIHtcblx0XHRcdHJlc3BvbnNlLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gKGhhZEVycm9yKSB7XG5cdFx0XHRcdC8vIHRlc3RzIGZvciBzb2NrZXQgcHJlc2VuY2UsIGFzIGluIHNvbWUgc2l0dWF0aW9ucyB0aGVcblx0XHRcdFx0Ly8gdGhlICdzb2NrZXQnIGV2ZW50IGlzIG5vdCB0cmlnZ2VyZWQgZm9yIHRoZSByZXF1ZXN0XG5cdFx0XHRcdC8vIChoYXBwZW5zIGluIGRlbm8pLCBhdm9pZHMgYFR5cGVFcnJvcmBcblx0XHRcdFx0Ly8gaWYgYSBkYXRhIGxpc3RlbmVyIGlzIHN0aWxsIHByZXNlbnQgd2UgZGlkbid0IGVuZCBjbGVhbmx5XG5cdFx0XHRcdGNvbnN0IGhhc0RhdGFMaXN0ZW5lciA9IHNvY2tldCAmJiBzb2NrZXQubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMDtcblxuXHRcdFx0XHRpZiAoaGFzRGF0YUxpc3RlbmVyICYmICFoYWRFcnJvcikge1xuXHRcdFx0XHRcdGNvbnN0IGVyciA9IG5ldyBFcnJvcignUHJlbWF0dXJlIGNsb3NlJyk7XG5cdFx0XHRcdFx0ZXJyLmNvZGUgPSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnO1xuXHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gZGVzdHJveVN0cmVhbShzdHJlYW0sIGVycikge1xuXHRpZiAoc3RyZWFtLmRlc3Ryb3kpIHtcblx0XHRzdHJlYW0uZGVzdHJveShlcnIpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIG5vZGUgPCA4XG5cdFx0c3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0XHRzdHJlYW0uZW5kKCk7XG5cdH1cbn1cblxuLyoqXG4gKiBSZWRpcmVjdCBjb2RlIG1hdGNoaW5nXG4gKlxuICogQHBhcmFtICAgTnVtYmVyICAgY29kZSAgU3RhdHVzIGNvZGVcbiAqIEByZXR1cm4gIEJvb2xlYW5cbiAqL1xuZmV0Y2guaXNSZWRpcmVjdCA9IGZ1bmN0aW9uIChjb2RlKSB7XG5cdHJldHVybiBjb2RlID09PSAzMDEgfHwgY29kZSA9PT0gMzAyIHx8IGNvZGUgPT09IDMwMyB8fCBjb2RlID09PSAzMDcgfHwgY29kZSA9PT0gMzA4O1xufTtcblxuLy8gZXhwb3NlIFByb21pc2VcbmZldGNoLlByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmV0Y2g7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzO1xuZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5leHBvcnRzLlJlc3BvbnNlID0gUmVzcG9uc2U7XG5leHBvcnRzLkZldGNoRXJyb3IgPSBGZXRjaEVycm9yO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiX2ludGVyb3BEZWZhdWx0IiwiZXgiLCJTdHJlYW0iLCJyZXF1aXJlIiwiaHR0cCIsIlVybCIsIndoYXR3Z1VybCIsImh0dHBzIiwiemxpYiIsIlJlYWRhYmxlIiwiQlVGRkVSIiwiU3ltYm9sIiwiVFlQRSIsIkJsb2IiLCJjb25zdHJ1Y3RvciIsImJsb2JQYXJ0cyIsImFyZ3VtZW50cyIsIm9wdGlvbnMiLCJidWZmZXJzIiwic2l6ZSIsImEiLCJsZW5ndGgiLCJOdW1iZXIiLCJpIiwiZWxlbWVudCIsImJ1ZmZlciIsIkJ1ZmZlciIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiZnJvbSIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiU3RyaW5nIiwicHVzaCIsImNvbmNhdCIsInR5cGUiLCJ1bmRlZmluZWQiLCJ0b0xvd2VyQ2FzZSIsInRlc3QiLCJ0ZXh0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0b1N0cmluZyIsImFycmF5QnVmZmVyIiwiYnVmIiwiYWIiLCJzbGljZSIsInN0cmVhbSIsInJlYWRhYmxlIiwiX3JlYWQiLCJzdGFydCIsImVuZCIsInJlbGF0aXZlU3RhcnQiLCJyZWxhdGl2ZUVuZCIsIk1hdGgiLCJtYXgiLCJtaW4iLCJzcGFuIiwic2xpY2VkQnVmZmVyIiwiYmxvYiIsImRlZmluZVByb3BlcnRpZXMiLCJwcm90b3R5cGUiLCJlbnVtZXJhYmxlIiwidG9TdHJpbmdUYWciLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsIkZldGNoRXJyb3IiLCJtZXNzYWdlIiwic3lzdGVtRXJyb3IiLCJFcnJvciIsImNhbGwiLCJjb2RlIiwiZXJybm8iLCJjYXB0dXJlU3RhY2tUcmFjZSIsImNyZWF0ZSIsIm5hbWUiLCJjb252ZXJ0IiwiSU5URVJOQUxTIiwiUGFzc1Rocm91Z2giLCJCb2R5IiwiYm9keSIsIl90aGlzIiwiX3JlZiIsIl9yZWYkc2l6ZSIsIl9yZWYkdGltZW91dCIsInRpbWVvdXQiLCJpc1VSTFNlYXJjaFBhcmFtcyIsImlzQmxvYiIsImlzQnVmZmVyIiwiZGlzdHVyYmVkIiwiZXJyb3IiLCJvbiIsImVyciIsInVybCIsImJvZHlVc2VkIiwiY29uc3VtZUJvZHkiLCJ0aGVuIiwiY3QiLCJoZWFkZXJzIiwiZ2V0IiwiYXNzaWduIiwianNvbiIsIl90aGlzMiIsIkpTT04iLCJwYXJzZSIsInJlamVjdCIsInRleHRDb252ZXJ0ZWQiLCJfdGhpczMiLCJjb252ZXJ0Qm9keSIsIm1peEluIiwicHJvdG8iLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl90aGlzNCIsIlR5cGVFcnJvciIsImFsbG9jIiwiYWNjdW0iLCJhY2N1bUJ5dGVzIiwiYWJvcnQiLCJyZXNUaW1lb3V0Iiwic2V0VGltZW91dCIsImNodW5rIiwiY2xlYXJUaW1lb3V0IiwiY2hhcnNldCIsInJlcyIsInN0ciIsImV4ZWMiLCJwb3AiLCJvYmoiLCJhcHBlbmQiLCJkZWxldGUiLCJnZXRBbGwiLCJoYXMiLCJzZXQiLCJzb3J0IiwiY2xvbmUiLCJpbnN0YW5jZSIsInAxIiwicDIiLCJnZXRCb3VuZGFyeSIsInBpcGUiLCJleHRyYWN0Q29udGVudFR5cGUiLCJnZXRUb3RhbEJ5dGVzIiwiZ2V0TGVuZ3RoU3luYyIsIl9sZW5ndGhSZXRyaWV2ZXJzIiwiaGFzS25vd25MZW5ndGgiLCJ3cml0ZVRvU3RyZWFtIiwiZGVzdCIsIndyaXRlIiwiZ2xvYmFsIiwiaW52YWxpZFRva2VuUmVnZXgiLCJpbnZhbGlkSGVhZGVyQ2hhclJlZ2V4IiwidmFsaWRhdGVOYW1lIiwidmFsaWRhdGVWYWx1ZSIsImZpbmQiLCJtYXAiLCJrZXkiLCJNQVAiLCJIZWFkZXJzIiwiaW5pdCIsInJhd0hlYWRlcnMiLCJyYXciLCJoZWFkZXJOYW1lcyIsImtleXMiLCJoZWFkZXJOYW1lIiwibWV0aG9kIiwiaXRlcmF0b3IiLCJwYWlycyIsInBhaXIiLCJBcnJheSIsImpvaW4iLCJmb3JFYWNoIiwiY2FsbGJhY2siLCJ0aGlzQXJnIiwiZ2V0SGVhZGVycyIsIl9wYWlycyRpIiwiY3JlYXRlSGVhZGVyc0l0ZXJhdG9yIiwidmFsdWVzIiwiZW50cmllcyIsImtpbmQiLCJrIiwiSU5URVJOQUwiLCJ0YXJnZXQiLCJIZWFkZXJzSXRlcmF0b3JQcm90b3R5cGUiLCJpbmRleCIsInNldFByb3RvdHlwZU9mIiwibmV4dCIsImdldFByb3RvdHlwZU9mIiwiX0lOVEVSTkFMIiwibGVuIiwiZG9uZSIsImV4cG9ydE5vZGVDb21wYXRpYmxlSGVhZGVycyIsIl9fcHJvdG9fXyIsImhvc3RIZWFkZXJLZXkiLCJjcmVhdGVIZWFkZXJzTGVuaWVudCIsImlzQXJyYXkiLCJ2YWwiLCJJTlRFUk5BTFMkMSIsIlNUQVRVU19DT0RFUyIsIlJlc3BvbnNlIiwib3B0cyIsInN0YXR1cyIsImNvbnRlbnRUeXBlIiwic3RhdHVzVGV4dCIsImNvdW50ZXIiLCJvayIsInJlZGlyZWN0ZWQiLCJJTlRFUk5BTFMkMiIsIlVSTCIsInBhcnNlX3VybCIsImZvcm1hdF91cmwiLCJmb3JtYXQiLCJwYXJzZVVSTCIsInVybFN0ciIsInN0cmVhbURlc3RydWN0aW9uU3VwcG9ydGVkIiwiaXNSZXF1ZXN0IiwiaW5wdXQiLCJpc0Fib3J0U2lnbmFsIiwic2lnbmFsIiwiUmVxdWVzdCIsInBhcnNlZFVSTCIsImhyZWYiLCJ0b1VwcGVyQ2FzZSIsImlucHV0Qm9keSIsInJlZGlyZWN0IiwiZm9sbG93IiwiY29tcHJlc3MiLCJhZ2VudCIsImdldE5vZGVSZXF1ZXN0T3B0aW9ucyIsInJlcXVlc3QiLCJwcm90b2NvbCIsImhvc3RuYW1lIiwiY29udGVudExlbmd0aFZhbHVlIiwidG90YWxCeXRlcyIsIkFib3J0RXJyb3IiLCJVUkwkMSIsIlBhc3NUaHJvdWdoJDEiLCJpc0RvbWFpbk9yU3ViZG9tYWluIiwiZGVzdGluYXRpb24iLCJvcmlnaW5hbCIsIm9yaWciLCJlbmRzV2l0aCIsImlzU2FtZVByb3RvY29sIiwiZmV0Y2giLCJzZW5kIiwicmVzcG9uc2UiLCJkZXN0cm95U3RyZWFtIiwiZW1pdCIsImFib3J0ZWQiLCJhYm9ydEFuZEZpbmFsaXplIiwiZmluYWxpemUiLCJyZXEiLCJyZXFUaW1lb3V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvbmNlIiwic29ja2V0IiwiZml4UmVzcG9uc2VDaHVua2VkVHJhbnNmZXJCYWRFbmRpbmciLCJwYXJzZUludCIsInByb2Nlc3MiLCJ2ZXJzaW9uIiwic3Vic3RyaW5nIiwicyIsImFkZExpc3RlbmVyIiwiaGFkRXJyb3IiLCJoYXNEYXRhTGlzdGVuZXIiLCJsaXN0ZW5lckNvdW50IiwiaXNSZWRpcmVjdCIsInN0YXR1c0NvZGUiLCJsb2NhdGlvbiIsImxvY2F0aW9uVVJMIiwicmVxdWVzdE9wdHMiLCJyZXNwb25zZV9vcHRpb25zIiwic3RhdHVzTWVzc2FnZSIsImNvZGluZ3MiLCJ6bGliT3B0aW9ucyIsImZsdXNoIiwiWl9TWU5DX0ZMVVNIIiwiZmluaXNoRmx1c2giLCJjcmVhdGVHdW56aXAiLCJjcmVhdGVJbmZsYXRlIiwiY3JlYXRlSW5mbGF0ZVJhdyIsImNyZWF0ZUJyb3RsaURlY29tcHJlc3MiLCJlcnJvckNhbGxiYWNrIiwiZGVzdHJveSIsIm1vZHVsZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n// @ts-ignore\nconst node_fetch_1 = tslib_1.__importDefault(__webpack_require__(/*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\"));\nconst PostgrestError_1 = tslib_1.__importDefault(__webpack_require__(/*! ./PostgrestError */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js\"));\nclass PostgrestBuilder {\n    constructor(builder){\n        var _a, _b;\n        this.shouldThrowOnError = false;\n        this.method = builder.method;\n        this.url = builder.url;\n        this.headers = new Headers(builder.headers);\n        this.schema = builder.schema;\n        this.body = builder.body;\n        this.shouldThrowOnError = (_a = builder.shouldThrowOnError) !== null && _a !== void 0 ? _a : false;\n        this.signal = builder.signal;\n        this.isMaybeSingle = (_b = builder.isMaybeSingle) !== null && _b !== void 0 ? _b : false;\n        if (builder.fetch) {\n            this.fetch = builder.fetch;\n        } else if (typeof fetch === \"undefined\") {\n            this.fetch = node_fetch_1.default;\n        } else {\n            this.fetch = fetch;\n        }\n    }\n    /**\n     * If there's an error with the query, throwOnError will reject the promise by\n     * throwing the error instead of returning it as part of a successful response.\n     *\n     * {@link https://github.com/supabase/supabase-js/issues/92}\n     */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n     * Set an HTTP header for the request.\n     */ setHeader(name, value) {\n        this.headers = new Headers(this.headers);\n        this.headers.set(name, value);\n        return this;\n    }\n    then(onfulfilled, onrejected) {\n        // https://postgrest.org/en/stable/api.html#switching-schemas\n        if (this.schema === undefined) {\n        // skip\n        } else if ([\n            \"GET\",\n            \"HEAD\"\n        ].includes(this.method)) {\n            this.headers.set(\"Accept-Profile\", this.schema);\n        } else {\n            this.headers.set(\"Content-Profile\", this.schema);\n        }\n        if (this.method !== \"GET\" && this.method !== \"HEAD\") {\n            this.headers.set(\"Content-Type\", \"application/json\");\n        }\n        // NOTE: Invoke w/o `this` to avoid illegal invocation error.\n        // https://github.com/supabase/postgrest-js/pull/247\n        const _fetch = this.fetch;\n        let res = _fetch(this.url.toString(), {\n            method: this.method,\n            headers: this.headers,\n            body: JSON.stringify(this.body),\n            signal: this.signal\n        }).then(async (res)=>{\n            var _a, _b, _c, _d;\n            let error = null;\n            let data = null;\n            let count = null;\n            let status = res.status;\n            let statusText = res.statusText;\n            if (res.ok) {\n                if (this.method !== \"HEAD\") {\n                    const body = await res.text();\n                    if (body === \"\") {\n                    // Prefer: return=minimal\n                    } else if (this.headers.get(\"Accept\") === \"text/csv\") {\n                        data = body;\n                    } else if (this.headers.get(\"Accept\") && ((_a = this.headers.get(\"Accept\")) === null || _a === void 0 ? void 0 : _a.includes(\"application/vnd.pgrst.plan+text\"))) {\n                        data = body;\n                    } else {\n                        data = JSON.parse(body);\n                    }\n                }\n                const countHeader = (_b = this.headers.get(\"Prefer\")) === null || _b === void 0 ? void 0 : _b.match(/count=(exact|planned|estimated)/);\n                const contentRange = (_c = res.headers.get(\"content-range\")) === null || _c === void 0 ? void 0 : _c.split(\"/\");\n                if (countHeader && contentRange && contentRange.length > 1) {\n                    count = parseInt(contentRange[1]);\n                }\n                // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n                // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n                if (this.isMaybeSingle && this.method === \"GET\" && Array.isArray(data)) {\n                    if (data.length > 1) {\n                        error = {\n                            // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553\n                            code: \"PGRST116\",\n                            details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n                            hint: null,\n                            message: \"JSON object requested, multiple (or no) rows returned\"\n                        };\n                        data = null;\n                        count = null;\n                        status = 406;\n                        statusText = \"Not Acceptable\";\n                    } else if (data.length === 1) {\n                        data = data[0];\n                    } else {\n                        data = null;\n                    }\n                }\n            } else {\n                const body = await res.text();\n                try {\n                    error = JSON.parse(body);\n                    // Workaround for https://github.com/supabase/postgrest-js/issues/295\n                    if (Array.isArray(error) && res.status === 404) {\n                        data = [];\n                        error = null;\n                        status = 200;\n                        statusText = \"OK\";\n                    }\n                } catch (_e) {\n                    // Workaround for https://github.com/supabase/postgrest-js/issues/295\n                    if (res.status === 404 && body === \"\") {\n                        status = 204;\n                        statusText = \"No Content\";\n                    } else {\n                        error = {\n                            message: body\n                        };\n                    }\n                }\n                if (error && this.isMaybeSingle && ((_d = error === null || error === void 0 ? void 0 : error.details) === null || _d === void 0 ? void 0 : _d.includes(\"0 rows\"))) {\n                    error = null;\n                    status = 200;\n                    statusText = \"OK\";\n                }\n                if (error && this.shouldThrowOnError) {\n                    throw new PostgrestError_1.default(error);\n                }\n            }\n            const postgrestResponse = {\n                error,\n                data,\n                count,\n                status,\n                statusText\n            };\n            return postgrestResponse;\n        });\n        if (!this.shouldThrowOnError) {\n            res = res.catch((fetchError)=>{\n                var _a, _b, _c;\n                return {\n                    error: {\n                        message: `${(_a = fetchError === null || fetchError === void 0 ? void 0 : fetchError.name) !== null && _a !== void 0 ? _a : \"FetchError\"}: ${fetchError === null || fetchError === void 0 ? void 0 : fetchError.message}`,\n                        details: `${(_b = fetchError === null || fetchError === void 0 ? void 0 : fetchError.stack) !== null && _b !== void 0 ? _b : \"\"}`,\n                        hint: \"\",\n                        code: `${(_c = fetchError === null || fetchError === void 0 ? void 0 : fetchError.code) !== null && _c !== void 0 ? _c : \"\"}`\n                    },\n                    data: null,\n                    count: null,\n                    status: 0,\n                    statusText: \"\"\n                };\n            });\n        }\n        return res.then(onfulfilled, onrejected);\n    }\n    /**\n     * Override the type of the returned `data`.\n     *\n     * @typeParam NewResult - The new result type to override with\n     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n     */ returns() {\n        /* istanbul ignore next */ return this;\n    }\n    /**\n     * Override the type of the returned `data` field in the response.\n     *\n     * @typeParam NewResult - The new type to cast the response data to\n     * @typeParam Options - Optional type configuration (defaults to { merge: true })\n     * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n     * @example\n     * ```typescript\n     * // Merge with existing types (default behavior)\n     * const query = supabase\n     *   .from('users')\n     *   .select()\n     *   .overrideTypes<{ custom_field: string }>()\n     *\n     * // Replace existing types completely\n     * const replaceQuery = supabase\n     *   .from('users')\n     *   .select()\n     *   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n     * ```\n     * @returns A PostgrestBuilder instance with the new type\n     */ overrideTypes() {\n        return this;\n    }\n}\nexports[\"default\"] = PostgrestBuilder; //# sourceMappingURL=PostgrestBuilder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RCdWlsZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLHVEQUFPO0FBQy9CLGFBQWE7QUFDYixNQUFNQyxlQUFlRixRQUFRRyxlQUFlLENBQUNGLG1CQUFPQSxDQUFDLG9GQUFzQjtBQUMzRSxNQUFNRyxtQkFBbUJKLFFBQVFHLGVBQWUsQ0FBQ0YsbUJBQU9BLENBQUMsZ0dBQWtCO0FBQzNFLE1BQU1JO0lBQ0ZDLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixJQUFJQyxJQUFJQztRQUNSLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDQyxNQUFNLEdBQUdKLFFBQVFJLE1BQU07UUFDNUIsSUFBSSxDQUFDQyxHQUFHLEdBQUdMLFFBQVFLLEdBQUc7UUFDdEIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUMsUUFBUVAsUUFBUU0sT0FBTztRQUMxQyxJQUFJLENBQUNFLE1BQU0sR0FBR1IsUUFBUVEsTUFBTTtRQUM1QixJQUFJLENBQUNDLElBQUksR0FBR1QsUUFBUVMsSUFBSTtRQUN4QixJQUFJLENBQUNOLGtCQUFrQixHQUFHLENBQUNGLEtBQUtELFFBQVFHLGtCQUFrQixNQUFNLFFBQVFGLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQzdGLElBQUksQ0FBQ1MsTUFBTSxHQUFHVixRQUFRVSxNQUFNO1FBQzVCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLENBQUNULEtBQUtGLFFBQVFXLGFBQWEsTUFBTSxRQUFRVCxPQUFPLEtBQUssSUFBSUEsS0FBSztRQUNuRixJQUFJRixRQUFRWSxLQUFLLEVBQUU7WUFDZixJQUFJLENBQUNBLEtBQUssR0FBR1osUUFBUVksS0FBSztRQUM5QixPQUNLLElBQUksT0FBT0EsVUFBVSxhQUFhO1lB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QUNORixNQUFNLENBQUMsRUFBRSxDQUFDbkIsS0FBSzBCLGVBQWUsUUFBUUEsZUFBZSxLQUFLLElBQUksS0FBSyxJQUFJQSxXQUFXUCxJQUFJLE1BQU0sUUFBUW5CLE9BQU8sS0FBSyxJQUFJQSxLQUFLLEdBQUcsQ0FBQztvQkFDakk7b0JBQ0FHLE1BQU07b0JBQ05DLE9BQU87b0JBQ1BDLFFBQVE7b0JBQ1JDLFlBQVk7Z0JBQ2hCO1lBQ0o7UUFDSjtRQUNBLE9BQU9WLElBQUlOLElBQUksQ0FBQ0MsYUFBYUM7SUFDakM7SUFDQTs7Ozs7S0FLQyxHQUNEb0MsVUFBVTtRQUNOLHdCQUF3QixHQUN4QixPQUFPLElBQUk7SUFDZjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FxQkMsR0FDREMsZ0JBQWdCO1FBQ1osT0FBTyxJQUFJO0lBQ2Y7QUFDSjtBQUNBbEUsa0JBQWUsR0FBR08sa0JBQ2xCLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9janMvUG9zdGdyZXN0QnVpbGRlci5qcz8yMjczIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbi8vIEB0cy1pZ25vcmVcbmNvbnN0IG5vZGVfZmV0Y2hfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAc3VwYWJhc2Uvbm9kZS1mZXRjaFwiKSk7XG5jb25zdCBQb3N0Z3Jlc3RFcnJvcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0RXJyb3JcIikpO1xuY2xhc3MgUG9zdGdyZXN0QnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoYnVpbGRlcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IGJ1aWxkZXIubWV0aG9kO1xuICAgICAgICB0aGlzLnVybCA9IGJ1aWxkZXIudXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhidWlsZGVyLmhlYWRlcnMpO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGJ1aWxkZXIuc2NoZW1hO1xuICAgICAgICB0aGlzLmJvZHkgPSBidWlsZGVyLmJvZHk7XG4gICAgICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gKF9hID0gYnVpbGRlci5zaG91bGRUaHJvd09uRXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgICAgICB0aGlzLnNpZ25hbCA9IGJ1aWxkZXIuc2lnbmFsO1xuICAgICAgICB0aGlzLmlzTWF5YmVTaW5nbGUgPSAoX2IgPSBidWlsZGVyLmlzTWF5YmVTaW5nbGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlO1xuICAgICAgICBpZiAoYnVpbGRlci5mZXRjaCkge1xuICAgICAgICAgICAgdGhpcy5mZXRjaCA9IGJ1aWxkZXIuZmV0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5mZXRjaCA9IG5vZGVfZmV0Y2hfMS5kZWZhdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mZXRjaCA9IGZldGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZXJlJ3MgYW4gZXJyb3Igd2l0aCB0aGUgcXVlcnksIHRocm93T25FcnJvciB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZSBieVxuICAgICAqIHRocm93aW5nIHRoZSBlcnJvciBpbnN0ZWFkIG9mIHJldHVybmluZyBpdCBhcyBwYXJ0IG9mIGEgc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2Uvc3VwYWJhc2UtanMvaXNzdWVzLzkyfVxuICAgICAqL1xuICAgIHRocm93T25FcnJvcigpIHtcbiAgICAgICAgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IGFuIEhUVFAgaGVhZGVyIGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBzZXRIZWFkZXIobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjc3dpdGNoaW5nLXNjaGVtYXNcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHNraXBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChbJ0dFVCcsICdIRUFEJ10uaW5jbHVkZXModGhpcy5tZXRob2QpKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdBY2NlcHQtUHJvZmlsZScsIHRoaXMuc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0NvbnRlbnQtUHJvZmlsZScsIHRoaXMuc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRob2QgIT09ICdHRVQnICYmIHRoaXMubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URTogSW52b2tlIHcvbyBgdGhpc2AgdG8gYXZvaWQgaWxsZWdhbCBpbnZvY2F0aW9uIGVycm9yLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL3B1bGwvMjQ3XG4gICAgICAgIGNvbnN0IF9mZXRjaCA9IHRoaXMuZmV0Y2g7XG4gICAgICAgIGxldCByZXMgPSBfZmV0Y2godGhpcy51cmwudG9TdHJpbmcoKSwge1xuICAgICAgICAgICAgbWV0aG9kOiB0aGlzLm1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHRoaXMuYm9keSksXG4gICAgICAgICAgICBzaWduYWw6IHRoaXMuc2lnbmFsLFxuICAgICAgICB9KS50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIGxldCBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IG51bGw7XG4gICAgICAgICAgICBsZXQgY291bnQgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHN0YXR1cyA9IHJlcy5zdGF0dXM7XG4gICAgICAgICAgICBsZXQgc3RhdHVzVGV4dCA9IHJlcy5zdGF0dXNUZXh0O1xuICAgICAgICAgICAgaWYgKHJlcy5vaykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1ldGhvZCAhPT0gJ0hFQUQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByZWZlcjogcmV0dXJuPW1pbmltYWxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmhlYWRlcnMuZ2V0KCdBY2NlcHQnKSA9PT0gJ3RleHQvY3N2Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5oZWFkZXJzLmdldCgnQWNjZXB0JykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLmhlYWRlcnMuZ2V0KCdBY2NlcHQnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi92bmQucGdyc3QucGxhbit0ZXh0JykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gYm9keTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50SGVhZGVyID0gKF9iID0gdGhpcy5oZWFkZXJzLmdldCgnUHJlZmVyJykpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXRjaCgvY291bnQ9KGV4YWN0fHBsYW5uZWR8ZXN0aW1hdGVkKS8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRSYW5nZSA9IChfYyA9IHJlcy5oZWFkZXJzLmdldCgnY29udGVudC1yYW5nZScpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRIZWFkZXIgJiYgY29udGVudFJhbmdlICYmIGNvbnRlbnRSYW5nZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50ID0gcGFyc2VJbnQoY29udGVudFJhbmdlWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGVtcG9yYXJ5IHBhcnRpYWwgZml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy8zNjFcbiAgICAgICAgICAgICAgICAvLyBJc3N1ZSBwZXJzaXN0cyBlLmcuIGZvciBgLmluc2VydChbLi4uXSkuc2VsZWN0KCkubWF5YmVTaW5nbGUoKWBcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc01heWJlU2luZ2xlICYmIHRoaXMubWV0aG9kID09PSAnR0VUJyAmJiBBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb3N0Z1JFU1QvcG9zdGdyZXN0L2Jsb2IvYTg2N2Q3OWM0MjQxOWFmMTZjMThjM2ZiMDE5ZWJhOGRmOTkyNjI2Zi9zcmMvUG9zdGdSRVNUL0Vycm9yLmhzI0w1NTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiAnUEdSU1QxMTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZXN1bHRzIGNvbnRhaW4gJHtkYXRhLmxlbmd0aH0gcm93cywgYXBwbGljYXRpb24vdm5kLnBncnN0Lm9iamVjdCtqc29uIHJlcXVpcmVzIDEgcm93YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdKU09OIG9iamVjdCByZXF1ZXN0ZWQsIG11bHRpcGxlIChvciBubykgcm93cyByZXR1cm5lZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSA0MDY7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0ID0gJ05vdCBBY2NlcHRhYmxlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFbMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3N1cGFiYXNlL3Bvc3RncmVzdC1qcy9pc3N1ZXMvMjk1XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVycm9yKSAmJiByZXMuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQgPSAnT0snO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy8yOTVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCAmJiBib2R5ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdObyBDb250ZW50JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnJvciAmJiB0aGlzLmlzTWF5YmVTaW5nbGUgJiYgKChfZCA9IGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5kZXRhaWxzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaW5jbHVkZXMoJzAgcm93cycpKSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dCA9ICdPSyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnJvciAmJiB0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUG9zdGdyZXN0RXJyb3JfMS5kZWZhdWx0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb3N0Z3Jlc3RSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGNvdW50LFxuICAgICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXNUZXh0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0Z3Jlc3RSZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgIHJlcyA9IHJlcy5jYXRjaCgoZmV0Y2hFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYCR7KF9hID0gZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdGZXRjaEVycm9yJ306ICR7ZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLm1lc3NhZ2V9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGAkeyhfYiA9IGZldGNoRXJyb3IgPT09IG51bGwgfHwgZmV0Y2hFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hFcnJvci5zdGFjaykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyd9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpbnQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogYCR7KF9jID0gZmV0Y2hFcnJvciA9PT0gbnVsbCB8fCBmZXRjaEVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZXRjaEVycm9yLmNvZGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICcnfWAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNvdW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6ICcnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIEB0eXBlUGFyYW0gTmV3UmVzdWx0IC0gVGhlIG5ldyByZXN1bHQgdHlwZSB0byBvdmVycmlkZSB3aXRoXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIG92ZXJyaWRlVHlwZXM8eW91clR5cGUsIHsgbWVyZ2U6IGZhbHNlIH0+KCkgbWV0aG9kIGF0IHRoZSBlbmQgb2YgeW91ciBjYWxsIGNoYWluIGluc3RlYWRcbiAgICAgKi9cbiAgICByZXR1cm5zKCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhlIHR5cGUgb2YgdGhlIHJldHVybmVkIGBkYXRhYCBmaWVsZCBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAdHlwZVBhcmFtIE5ld1Jlc3VsdCAtIFRoZSBuZXcgdHlwZSB0byBjYXN0IHRoZSByZXNwb25zZSBkYXRhIHRvXG4gICAgICogQHR5cGVQYXJhbSBPcHRpb25zIC0gT3B0aW9uYWwgdHlwZSBjb25maWd1cmF0aW9uIChkZWZhdWx0cyB0byB7IG1lcmdlOiB0cnVlIH0pXG4gICAgICogQHR5cGVQYXJhbSBPcHRpb25zLm1lcmdlIC0gV2hlbiB0cnVlLCBtZXJnZXMgdGhlIG5ldyB0eXBlIHdpdGggZXhpc3RpbmcgcmV0dXJuIHR5cGUuIFdoZW4gZmFsc2UsIHJlcGxhY2VzIHRoZSBleGlzdGluZyB0eXBlcyBlbnRpcmVseSAoZGVmYXVsdHMgdG8gdHJ1ZSlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBNZXJnZSB3aXRoIGV4aXN0aW5nIHR5cGVzIChkZWZhdWx0IGJlaGF2aW9yKVxuICAgICAqIGNvbnN0IHF1ZXJ5ID0gc3VwYWJhc2VcbiAgICAgKiAgIC5mcm9tKCd1c2VycycpXG4gICAgICogICAuc2VsZWN0KClcbiAgICAgKiAgIC5vdmVycmlkZVR5cGVzPHsgY3VzdG9tX2ZpZWxkOiBzdHJpbmcgfT4oKVxuICAgICAqXG4gICAgICogLy8gUmVwbGFjZSBleGlzdGluZyB0eXBlcyBjb21wbGV0ZWx5XG4gICAgICogY29uc3QgcmVwbGFjZVF1ZXJ5ID0gc3VwYWJhc2VcbiAgICAgKiAgIC5mcm9tKCd1c2VycycpXG4gICAgICogICAuc2VsZWN0KClcbiAgICAgKiAgIC5vdmVycmlkZVR5cGVzPHsgaWQ6IG51bWJlcjsgbmFtZTogc3RyaW5nIH0sIHsgbWVyZ2U6IGZhbHNlIH0+KClcbiAgICAgKiBgYGBcbiAgICAgKiBAcmV0dXJucyBBIFBvc3RncmVzdEJ1aWxkZXIgaW5zdGFuY2Ugd2l0aCB0aGUgbmV3IHR5cGVcbiAgICAgKi9cbiAgICBvdmVycmlkZVR5cGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0QnVpbGRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0c2xpYl8xIiwicmVxdWlyZSIsIm5vZGVfZmV0Y2hfMSIsIl9faW1wb3J0RGVmYXVsdCIsIlBvc3RncmVzdEVycm9yXzEiLCJQb3N0Z3Jlc3RCdWlsZGVyIiwiY29uc3RydWN0b3IiLCJidWlsZGVyIiwiX2EiLCJfYiIsInNob3VsZFRocm93T25FcnJvciIsIm1ldGhvZCIsInVybCIsImhlYWRlcnMiLCJIZWFkZXJzIiwic2NoZW1hIiwiYm9keSIsInNpZ25hbCIsImlzTWF5YmVTaW5nbGUiLCJmZXRjaCIsImRlZmF1bHQiLCJ0aHJvd09uRXJyb3IiLCJzZXRIZWFkZXIiLCJuYW1lIiwic2V0IiwidGhlbiIsIm9uZnVsZmlsbGVkIiwib25yZWplY3RlZCIsInVuZGVmaW5lZCIsImluY2x1ZGVzIiwiX2ZldGNoIiwicmVzIiwidG9TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiX2MiLCJfZCIsImVycm9yIiwiZGF0YSIsImNvdW50Iiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIm9rIiwidGV4dCIsImdldCIsInBhcnNlIiwiY291bnRIZWFkZXIiLCJtYXRjaCIsImNvbnRlbnRSYW5nZSIsInNwbGl0IiwibGVuZ3RoIiwicGFyc2VJbnQiLCJBcnJheSIsImlzQXJyYXkiLCJjb2RlIiwiZGV0YWlscyIsImhpbnQiLCJtZXNzYWdlIiwiX2UiLCJwb3N0Z3Jlc3RSZXNwb25zZSIsImNhdGNoIiwiZmV0Y2hFcnJvciIsInN0YWNrIiwicmV0dXJucyIsIm92ZXJyaWRlVHlwZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\nconst PostgrestQueryBuilder_1 = tslib_1.__importDefault(__webpack_require__(/*! ./PostgrestQueryBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js\"));\nconst PostgrestFilterBuilder_1 = tslib_1.__importDefault(__webpack_require__(/*! ./PostgrestFilterBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\"));\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */ class PostgrestClient {\n    // TODO: Add back shouldThrowOnError once we figure out the typings\n    /**\n     * Creates a PostgREST client.\n     *\n     * @param url - URL of the PostgREST endpoint\n     * @param options - Named parameters\n     * @param options.headers - Custom headers\n     * @param options.schema - Postgres schema to switch to\n     * @param options.fetch - Custom fetch\n     */ constructor(url, { headers = {}, schema, fetch: fetch1 } = {}){\n        this.url = url;\n        this.headers = new Headers(headers);\n        this.schemaName = schema;\n        this.fetch = fetch1;\n    }\n    /**\n     * Perform a query on a table or a view.\n     *\n     * @param relation - The table or view name to query\n     */ from(relation) {\n        const url = new URL(`${this.url}/${relation}`);\n        return new PostgrestQueryBuilder_1.default(url, {\n            headers: new Headers(this.headers),\n            schema: this.schemaName,\n            fetch: this.fetch\n        });\n    }\n    /**\n     * Select a schema to query or perform an function (rpc) call.\n     *\n     * The schema needs to be on the list of exposed schemas inside Supabase.\n     *\n     * @param schema - The schema to query\n     */ schema(schema) {\n        return new PostgrestClient(this.url, {\n            headers: this.headers,\n            schema,\n            fetch: this.fetch\n        });\n    }\n    /**\n     * Perform a function call.\n     *\n     * @param fn - The function name to call\n     * @param args - The arguments to pass to the function call\n     * @param options - Named parameters\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     * @param options.get - When set to `true`, the function will be called with\n     * read-only access mode.\n     * @param options.count - Count algorithm to use to count rows returned by the\n     * function. Only applicable for [set-returning\n     * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */ rpc(fn, args = {}, { head = false, get = false, count } = {}) {\n        var _a;\n        let method;\n        const url = new URL(`${this.url}/rpc/${fn}`);\n        let body;\n        if (head || get) {\n            method = head ? \"HEAD\" : \"GET\";\n            Object.entries(args)// params with undefined value needs to be filtered out, otherwise it'll\n            // show up as `?param=undefined`\n            .filter(([_, value])=>value !== undefined)// array values need special syntax\n            .map(([name, value])=>[\n                    name,\n                    Array.isArray(value) ? `{${value.join(\",\")}}` : `${value}`\n                ]).forEach(([name, value])=>{\n                url.searchParams.append(name, value);\n            });\n        } else {\n            method = \"POST\";\n            body = args;\n        }\n        const headers = new Headers(this.headers);\n        if (count) {\n            headers.set(\"Prefer\", `count=${count}`);\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url,\n            headers,\n            schema: this.schemaName,\n            body,\n            fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch\n        });\n    }\n}\nexports[\"default\"] = PostgrestClient; //# sourceMappingURL=PostgrestClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RDbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsVUFBVUMsbUJBQU9BLENBQUMsdURBQU87QUFDL0IsTUFBTUMsMEJBQTBCRixRQUFRRyxlQUFlLENBQUNGLG1CQUFPQSxDQUFDLDhHQUF5QjtBQUN6RixNQUFNRywyQkFBMkJKLFFBQVFHLGVBQWUsQ0FBQ0YsbUJBQU9BLENBQUMsZ0hBQTBCO0FBQzNGOzs7Ozs7Ozs7Q0FTQyxHQUNELE1BQU1JO0lBQ0YsbUVBQW1FO0lBQ25FOzs7Ozs7OztLQVFDLEdBQ0RDLFlBQVlDLEdBQUcsRUFBRSxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFQyxNQUFNLEVBQUVDLE9BQUFBLE1BQUssRUFBRyxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQ3BELElBQUksQ0FBQ0gsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlHLFFBQVFIO1FBQzNCLElBQUksQ0FBQ0ksVUFBVSxHQUFHSDtRQUNsQixJQUFJLENBQUNDLEtBQUssR0FBR0E7SUFDakI7SUFDQTs7OztLQUlDLEdBQ0RHLEtBQUtDLFFBQVEsRUFBRTtRQUNYLE1BQU1QLE1BQU0sSUFBSVEsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDUixHQUFHLENBQUMsQ0FBQyxFQUFFTyxTQUFTLENBQUM7UUFDN0MsT0FBTyxJQUFJWix3QkFBd0JjLE9BQU8sQ0FBQ1QsS0FBSztZQUM1Q0MsU0FBUyxJQUFJRyxRQUFRLElBQUksQ0FBQ0gsT0FBTztZQUNqQ0MsUUFBUSxJQUFJLENBQUNHLFVBQVU7WUFDdkJGLE9BQU8sSUFBSSxDQUFDQSxLQUFLO1FBQ3JCO0lBQ0o7SUFDQTs7Ozs7O0tBTUMsR0FDREQsT0FBT0EsTUFBTSxFQUFFO1FBQ1gsT0FBTyxJQUFJSixnQkFBZ0IsSUFBSSxDQUFDRSxHQUFHLEVBQUU7WUFDakNDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCQztZQUNBQyxPQUFPLElBQUksQ0FBQ0EsS0FBSztRQUNyQjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FzQkMsR0FDRE8sSUFBSUMsRUFBRSxFQUFFQyxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUVDLE9BQU8sS0FBSyxFQUFFQyxNQUFNLEtBQUssRUFBRUMsS0FBSyxFQUFHLEdBQUcsQ0FBQyxDQUFDLEVBQUU7UUFDM0QsSUFBSUM7UUFDSixJQUFJQztRQUNKLE1BQU1qQixNQUFNLElBQUlRLElBQUksQ0FBQyxFQUFFLElBQUksQ0FBQ1IsR0FBRyxDQUFDLEtBQUssRUFBRVcsR0FBRyxDQUFDO1FBQzNDLElBQUlPO1FBQ0osSUFBSUwsUUFBUUMsS0FBSztZQUNiRyxTQUFTSixPQUFPLFNBQVM7WUFDekJ4QixPQUFPOEIsT0FBTyxDQUFDUCxLQUNYLHdFQUF3RTtZQUN4RSxnQ0FBZ0M7YUFDL0JRLE1BQU0sQ0FBQyxDQUFDLENBQUNDLEdBQUc3QixNQUFNLEdBQUtBLFVBQVU4QixVQUNsQyxtQ0FBbUM7YUFDbENDLEdBQUcsQ0FBQyxDQUFDLENBQUNDLE1BQU1oQyxNQUFNLEdBQUs7b0JBQUNnQztvQkFBTUMsTUFBTUMsT0FBTyxDQUFDbEMsU0FBUyxDQUFDLENBQUMsRUFBRUEsTUFBTW1DLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRW5DLE1BQU0sQ0FBQztpQkFBQyxFQUN6Rm9DLE9BQU8sQ0FBQyxDQUFDLENBQUNKLE1BQU1oQyxNQUFNO2dCQUN2QlEsSUFBSTZCLFlBQVksQ0FBQ0MsTUFBTSxDQUFDTixNQUFNaEM7WUFDbEM7UUFDSixPQUNLO1lBQ0R5QixTQUFTO1lBQ1RDLE9BQU9OO1FBQ1g7UUFDQSxNQUFNWCxVQUFVLElBQUlHLFFBQVEsSUFBSSxDQUFDSCxPQUFPO1FBQ3hDLElBQUljLE9BQU87WUFDUGQsUUFBUThCLEdBQUcsQ0FBQyxVQUFVLENBQUMsTUFBTSxFQUFFaEIsTUFBTSxDQUFDO1FBQzFDO1FBQ0EsT0FBTyxJQUFJbEIseUJBQXlCWSxPQUFPLENBQUM7WUFDeENRO1lBQ0FqQjtZQUNBQztZQUNBQyxRQUFRLElBQUksQ0FBQ0csVUFBVTtZQUN2QmE7WUFDQWYsT0FBTyxDQUFDYSxLQUFLLElBQUksQ0FBQ2IsS0FBSyxNQUFNLFFBQVFhLE9BQU8sS0FBSyxJQUFJQSxLQUFLYjtRQUM5RDtJQUNKO0FBQ0o7QUFDQVosa0JBQWUsR0FBR08saUJBQ2xCLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9janMvUG9zdGdyZXN0Q2xpZW50LmpzP2U2NDAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xuY29uc3QgUG9zdGdyZXN0UXVlcnlCdWlsZGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXJcIikpO1xuY29uc3QgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlclwiKSk7XG4vKipcbiAqIFBvc3RnUkVTVCBjbGllbnQuXG4gKlxuICogQHR5cGVQYXJhbSBEYXRhYmFzZSAtIFR5cGVzIGZvciB0aGUgc2NoZW1hIGZyb20gdGhlIFt0eXBlXG4gKiBnZW5lcmF0b3JdKGh0dHBzOi8vc3VwYWJhc2UuY29tL2RvY3MvcmVmZXJlbmNlL2phdmFzY3JpcHQvbmV4dC90eXBlc2NyaXB0LXN1cHBvcnQpXG4gKlxuICogQHR5cGVQYXJhbSBTY2hlbWFOYW1lIC0gUG9zdGdyZXMgc2NoZW1hIHRvIHN3aXRjaCB0by4gTXVzdCBiZSBhIHN0cmluZ1xuICogbGl0ZXJhbCwgdGhlIHNhbWUgb25lIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuIElmIHRoZSBzY2hlbWEgaXMgbm90XG4gKiBgXCJwdWJsaWNcImAsIHRoaXMgbXVzdCBiZSBzdXBwbGllZCBtYW51YWxseS5cbiAqL1xuY2xhc3MgUG9zdGdyZXN0Q2xpZW50IHtcbiAgICAvLyBUT0RPOiBBZGQgYmFjayBzaG91bGRUaHJvd09uRXJyb3Igb25jZSB3ZSBmaWd1cmUgb3V0IHRoZSB0eXBpbmdzXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFBvc3RnUkVTVCBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIC0gVVJMIG9mIHRoZSBQb3N0Z1JFU1QgZW5kcG9pbnRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5oZWFkZXJzIC0gQ3VzdG9tIGhlYWRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zY2hlbWEgLSBQb3N0Z3JlcyBzY2hlbWEgdG8gc3dpdGNoIHRvXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZmV0Y2ggLSBDdXN0b20gZmV0Y2hcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHsgaGVhZGVycyA9IHt9LCBzY2hlbWEsIGZldGNoLCB9ID0ge30pIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICB0aGlzLnNjaGVtYU5hbWUgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSBmZXRjaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIHF1ZXJ5IG9uIGEgdGFibGUgb3IgYSB2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbGF0aW9uIC0gVGhlIHRhYmxlIG9yIHZpZXcgbmFtZSB0byBxdWVyeVxuICAgICAqL1xuICAgIGZyb20ocmVsYXRpb24pIHtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChgJHt0aGlzLnVybH0vJHtyZWxhdGlvbn1gKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXJfMS5kZWZhdWx0KHVybCwge1xuICAgICAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWFOYW1lLFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYSBzY2hlbWEgdG8gcXVlcnkgb3IgcGVyZm9ybSBhbiBmdW5jdGlvbiAocnBjKSBjYWxsLlxuICAgICAqXG4gICAgICogVGhlIHNjaGVtYSBuZWVkcyB0byBiZSBvbiB0aGUgbGlzdCBvZiBleHBvc2VkIHNjaGVtYXMgaW5zaWRlIFN1cGFiYXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgdG8gcXVlcnlcbiAgICAgKi9cbiAgICBzY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zdGdyZXN0Q2xpZW50KHRoaXMudXJsLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzY2hlbWEsXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBmdW5jdGlvbiBjYWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIG5hbWUgdG8gY2FsbFxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBjYWxsXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoXG4gICAgICogcmVhZC1vbmx5IGFjY2VzcyBtb2RlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIHJldHVybmVkIGJ5IHRoZVxuICAgICAqIGZ1bmN0aW9uLiBPbmx5IGFwcGxpY2FibGUgZm9yIFtzZXQtcmV0dXJuaW5nXG4gICAgICogZnVuY3Rpb25zXShodHRwczovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzL2N1cnJlbnQvZnVuY3Rpb25zLXNyZi5odG1sKS5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICovXG4gICAgcnBjKGZuLCBhcmdzID0ge30sIHsgaGVhZCA9IGZhbHNlLCBnZXQgPSBmYWxzZSwgY291bnQsIH0gPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBtZXRob2Q7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy51cmx9L3JwYy8ke2ZufWApO1xuICAgICAgICBsZXQgYm9keTtcbiAgICAgICAgaWYgKGhlYWQgfHwgZ2V0KSB7XG4gICAgICAgICAgICBtZXRob2QgPSBoZWFkID8gJ0hFQUQnIDogJ0dFVCc7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhhcmdzKVxuICAgICAgICAgICAgICAgIC8vIHBhcmFtcyB3aXRoIHVuZGVmaW5lZCB2YWx1ZSBuZWVkcyB0byBiZSBmaWx0ZXJlZCBvdXQsIG90aGVyd2lzZSBpdCdsbFxuICAgICAgICAgICAgICAgIC8vIHNob3cgdXAgYXMgYD9wYXJhbT11bmRlZmluZWRgXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoW18sIHZhbHVlXSkgPT4gdmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAvLyBhcnJheSB2YWx1ZXMgbmVlZCBzcGVjaWFsIHN5bnRheFxuICAgICAgICAgICAgICAgIC5tYXAoKFtuYW1lLCB2YWx1ZV0pID0+IFtuYW1lLCBBcnJheS5pc0FycmF5KHZhbHVlKSA/IGB7JHt2YWx1ZS5qb2luKCcsJyl9fWAgOiBgJHt2YWx1ZX1gXSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICAgICAgYm9keSA9IGFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHRoaXMuaGVhZGVycyk7XG4gICAgICAgIGlmIChjb3VudCkge1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoJ1ByZWZlcicsIGBjb3VudD0ke2NvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWFOYW1lLFxuICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgIGZldGNoOiAoX2EgPSB0aGlzLmZldGNoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmZXRjaCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUG9zdGdyZXN0Q2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0Q2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRzbGliXzEiLCJyZXF1aXJlIiwiUG9zdGdyZXN0UXVlcnlCdWlsZGVyXzEiLCJfX2ltcG9ydERlZmF1bHQiLCJQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEiLCJQb3N0Z3Jlc3RDbGllbnQiLCJjb25zdHJ1Y3RvciIsInVybCIsImhlYWRlcnMiLCJzY2hlbWEiLCJmZXRjaCIsIkhlYWRlcnMiLCJzY2hlbWFOYW1lIiwiZnJvbSIsInJlbGF0aW9uIiwiVVJMIiwiZGVmYXVsdCIsInJwYyIsImZuIiwiYXJncyIsImhlYWQiLCJnZXQiLCJjb3VudCIsIl9hIiwibWV0aG9kIiwiYm9keSIsImVudHJpZXMiLCJmaWx0ZXIiLCJfIiwidW5kZWZpbmVkIiwibWFwIiwibmFtZSIsIkFycmF5IiwiaXNBcnJheSIsImpvaW4iLCJmb3JFYWNoIiwic2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwic2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js":
/*!************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/**\n * Error format\n *\n * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n */ class PostgrestError extends Error {\n    constructor(context){\n        super(context.message);\n        this.name = \"PostgrestError\";\n        this.details = context.details;\n        this.hint = context.hint;\n        this.code = context.code;\n    }\n}\nexports[\"default\"] = PostgrestError; //# sourceMappingURL=PostgrestError.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3RDs7OztDQUlDLEdBQ0QsTUFBTUMsdUJBQXVCQztJQUN6QkMsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0EsUUFBUUMsT0FBTztRQUNyQixJQUFJLENBQUNDLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ0MsT0FBTyxHQUFHSCxRQUFRRyxPQUFPO1FBQzlCLElBQUksQ0FBQ0MsSUFBSSxHQUFHSixRQUFRSSxJQUFJO1FBQ3hCLElBQUksQ0FBQ0MsSUFBSSxHQUFHTCxRQUFRSyxJQUFJO0lBQzVCO0FBQ0o7QUFDQVYsa0JBQWUsR0FBR0UsZ0JBQ2xCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9janMvUG9zdGdyZXN0RXJyb3IuanM/MTNlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogRXJyb3IgZm9ybWF0XG4gKlxuICoge0BsaW5rIGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWw/aGlnaGxpZ2h0PW9wdGlvbnMjZXJyb3JzLWFuZC1odHRwLXN0YXR1cy1jb2Rlc31cbiAqL1xuY2xhc3MgUG9zdGdyZXN0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICBzdXBlcihjb250ZXh0Lm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUG9zdGdyZXN0RXJyb3InO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBjb250ZXh0LmRldGFpbHM7XG4gICAgICAgIHRoaXMuaGludCA9IGNvbnRleHQuaGludDtcbiAgICAgICAgdGhpcy5jb2RlID0gY29udGV4dC5jb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBvc3RncmVzdEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0RXJyb3IuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUG9zdGdyZXN0RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY29udGV4dCIsIm1lc3NhZ2UiLCJuYW1lIiwiZGV0YWlscyIsImhpbnQiLCJjb2RlIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\nconst PostgrestTransformBuilder_1 = tslib_1.__importDefault(__webpack_require__(/*! ./PostgrestTransformBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js\"));\nconst PostgrestReservedCharsRegexp = new RegExp(\"[,()]\");\nclass PostgrestFilterBuilder extends PostgrestTransformBuilder_1.default {\n    /**\n     * Match only rows where `column` is equal to `value`.\n     *\n     * To check if the value of `column` is NULL, you should use `.is()` instead.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */ eq(column, value) {\n        this.url.searchParams.append(column, `eq.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is not equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */ neq(column, value) {\n        this.url.searchParams.append(column, `neq.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is greater than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */ gt(column, value) {\n        this.url.searchParams.append(column, `gt.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is greater than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */ gte(column, value) {\n        this.url.searchParams.append(column, `gte.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is less than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */ lt(column, value) {\n        this.url.searchParams.append(column, `lt.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is less than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */ lte(column, value) {\n        this.url.searchParams.append(column, `lte.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */ like(column, pattern) {\n        this.url.searchParams.append(column, `like.${pattern}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */ likeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `like(all).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */ likeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `like(any).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches `pattern` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */ ilike(column, pattern) {\n        this.url.searchParams.append(column, `ilike.${pattern}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches all of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */ ilikeAllOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(all).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` matches any of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */ ilikeAnyOf(column, patterns) {\n        this.url.searchParams.append(column, `ilike(any).{${patterns.join(\",\")}}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` IS `value`.\n     *\n     * For non-boolean columns, this is only relevant for checking if the value of\n     * `column` is NULL by setting `value` to `null`.\n     *\n     * For boolean columns, you can also set `value` to `true` or `false` and it\n     * will behave the same way as `.eq()`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */ is(column, value) {\n        this.url.searchParams.append(column, `is.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows where `column` is included in the `values` array.\n     *\n     * @param column - The column to filter on\n     * @param values - The values array to filter with\n     */ in(column, values) {\n        const cleanedValues = Array.from(new Set(values)).map((s)=>{\n            // handle postgrest reserved characters\n            // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n            if (typeof s === \"string\" && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`;\n            else return `${s}`;\n        }).join(\",\");\n        this.url.searchParams.append(column, `in.(${cleanedValues})`);\n        return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * `column` contains every element appearing in `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */ contains(column, value) {\n        if (typeof value === \"string\") {\n            // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n            // keep it simple and accept a string\n            this.url.searchParams.append(column, `cs.${value}`);\n        } else if (Array.isArray(value)) {\n            // array\n            this.url.searchParams.append(column, `cs.{${value.join(\",\")}}`);\n        } else {\n            // json\n            this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * every element appearing in `column` is contained by `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */ containedBy(column, value) {\n        if (typeof value === \"string\") {\n            // range\n            this.url.searchParams.append(column, `cd.${value}`);\n        } else if (Array.isArray(value)) {\n            // array\n            this.url.searchParams.append(column, `cd.{${value.join(\",\")}}`);\n        } else {\n            // json\n            this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is greater than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */ rangeGt(column, range) {\n        this.url.searchParams.append(column, `sr.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or greater than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */ rangeGte(column, range) {\n        this.url.searchParams.append(column, `nxl.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is less than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */ rangeLt(column, range) {\n        this.url.searchParams.append(column, `sl.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or less than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */ rangeLte(column, range) {\n        this.url.searchParams.append(column, `nxr.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for range columns. Match only rows where `column` is\n     * mutually exclusive to `range` and there can be no element between the two\n     * ranges.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */ rangeAdjacent(column, range) {\n        this.url.searchParams.append(column, `adj.${range}`);\n        return this;\n    }\n    /**\n     * Only relevant for array and range columns. Match only rows where\n     * `column` and `value` have an element in common.\n     *\n     * @param column - The array or range column to filter on\n     * @param value - The array or range value to filter with\n     */ overlaps(column, value) {\n        if (typeof value === \"string\") {\n            // range\n            this.url.searchParams.append(column, `ov.${value}`);\n        } else {\n            // array\n            this.url.searchParams.append(column, `ov.{${value.join(\",\")}}`);\n        }\n        return this;\n    }\n    /**\n     * Only relevant for text and tsvector columns. Match only rows where\n     * `column` matches the query string in `query`.\n     *\n     * @param column - The text or tsvector column to filter on\n     * @param query - The query text to match with\n     * @param options - Named parameters\n     * @param options.config - The text search configuration to use\n     * @param options.type - Change how the `query` text is interpreted\n     */ textSearch(column, query, { config, type } = {}) {\n        let typePart = \"\";\n        if (type === \"plain\") {\n            typePart = \"pl\";\n        } else if (type === \"phrase\") {\n            typePart = \"ph\";\n        } else if (type === \"websearch\") {\n            typePart = \"w\";\n        }\n        const configPart = config === undefined ? \"\" : `(${config})`;\n        this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`);\n        return this;\n    }\n    /**\n     * Match only rows where each column in `query` keys is equal to its\n     * associated value. Shorthand for multiple `.eq()`s.\n     *\n     * @param query - The object to filter with, with column names as keys mapped\n     * to their filter values\n     */ match(query) {\n        Object.entries(query).forEach(([column, value])=>{\n            this.url.searchParams.append(column, `eq.${value}`);\n        });\n        return this;\n    }\n    /**\n     * Match only rows which doesn't satisfy the filter.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to be negated to filter with, following\n     * PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */ not(column, operator, value) {\n        this.url.searchParams.append(column, `not.${operator}.${value}`);\n        return this;\n    }\n    /**\n     * Match only rows which satisfy at least one of the filters.\n     *\n     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure it's properly sanitized.\n     *\n     * It's currently not possible to do an `.or()` filter across multiple tables.\n     *\n     * @param filters - The filters to use, following PostgREST syntax\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to filter on referenced tables\n     * instead of the parent table\n     * @param options.foreignTable - Deprecated, use `referencedTable` instead\n     */ or(filters, { foreignTable, referencedTable = foreignTable } = {}) {\n        const key = referencedTable ? `${referencedTable}.or` : \"or\";\n        this.url.searchParams.append(key, `(${filters})`);\n        return this;\n    }\n    /**\n     * Match only rows which satisfy the filter. This is an escape hatch - you\n     * should use the specific filter methods wherever possible.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to filter with, following PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */ filter(column, operator, value) {\n        this.url.searchParams.append(column, `${operator}.${value}`);\n        return this;\n    }\n}\nexports[\"default\"] = PostgrestFilterBuilder; //# sourceMappingURL=PostgrestFilterBuilder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLHVEQUFPO0FBQy9CLE1BQU1DLDhCQUE4QkYsUUFBUUcsZUFBZSxDQUFDRixtQkFBT0EsQ0FBQyxzSEFBNkI7QUFDakcsTUFBTUcsK0JBQStCLElBQUlDLE9BQU87QUFDaEQsTUFBTUMsK0JBQStCSiw0QkFBNEJLLE9BQU87SUFDcEU7Ozs7Ozs7S0FPQyxHQUNEQyxHQUFHQyxNQUFNLEVBQUVWLEtBQUssRUFBRTtRQUNkLElBQUksQ0FBQ1csR0FBRyxDQUFDQyxZQUFZLENBQUNDLE1BQU0sQ0FBQ0gsUUFBUSxDQUFDLEdBQUcsRUFBRVYsTUFBTSxDQUFDO1FBQ2xELE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7O0tBS0MsR0FDRGMsSUFBSUosTUFBTSxFQUFFVixLQUFLLEVBQUU7UUFDZixJQUFJLENBQUNXLEdBQUcsQ0FBQ0MsWUFBWSxDQUFDQyxNQUFNLENBQUNILFFBQVEsQ0FBQyxJQUFJLEVBQUVWLE1BQU0sQ0FBQztRQUNuRCxPQUFPLElBQUk7SUFDZjtJQUNBOzs7OztLQUtDLEdBQ0RlLEdBQUdMLE1BQU0sRUFBRVYsS0FBSyxFQUFFO1FBQ2QsSUFBSSxDQUFDVyxHQUFHLENBQUNDLFlBQVksQ0FBQ0MsTUFBTSxDQUFDSCxRQUFRLENBQUMsR0FBRyxFQUFFVixNQUFNLENBQUM7UUFDbEQsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7S0FLQyxHQUNEZ0IsSUFBSU4sTUFBTSxFQUFFVixLQUFLLEVBQUU7UUFDZixJQUFJLENBQUNXLEdBQUcsQ0FBQ0MsWUFBWSxDQUFDQyxNQUFNLENBQUNILFFBQVEsQ0FBQyxJQUFJLEVBQUVWLE1BQU0sQ0FBQztRQUNuRCxPQUFPLElB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T0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7Ozs7Ozs7O0tBWUMsR0FDRDRELElBQUlsRCxNQUFNLEVBQUVtRCxRQUFRLEVBQUU3RCxLQUFLLEVBQUU7UUFDekIsSUFBSSxDQUFDVyxHQUFHLENBQUNDLFlBQVksQ0FBQ0MsTUFBTSxDQUFDSCxRQUFRLENBQUMsSUFBSSxFQUFFbUQsU0FBUyxDQUFDLEVBQUU3RCxNQUFNLENBQUM7UUFDL0QsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7Ozs7Ozs7Ozs7S0FjQyxHQUNEOEQsR0FBR0MsT0FBTyxFQUFFLEVBQUVDLFlBQVksRUFBRUMsa0JBQWtCRCxZQUFZLEVBQUcsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUNoRSxNQUFNRSxNQUFNRCxrQkFBa0IsQ0FBQyxFQUFFQSxnQkFBZ0IsR0FBRyxDQUFDLEdBQUc7UUFDeEQsSUFBSSxDQUFDdEQsR0FBRyxDQUFDQyxZQUFZLENBQUNDLE1BQU0sQ0FBQ3FELEtBQUssQ0FBQyxDQUFDLEVBQUVILFFBQVEsQ0FBQyxDQUFDO1FBQ2hELE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7Ozs7Ozs7OztLQVlDLEdBQ0RJLE9BQU96RCxNQUFNLEVBQUVtRCxRQUFRLEVBQUU3RCxLQUFLLEVBQUU7UUFDNUIsSUFBSSxDQUFDVyxHQUFHLENBQUNDLFlBQVksQ0FBQ0MsTUFBTSxDQUFDSCxRQUFRLENBQUMsRUFBRW1ELFNBQVMsQ0FBQyxFQUFFN0QsTUFBTSxDQUFDO1FBQzNELE9BQU8sSUFBSTtJQUNmO0FBQ0o7QUFDQUQsa0JBQWUsR0FBR1Esd0JBQ2xCLGtEQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9janMvUG9zdGdyZXN0RmlsdGVyQnVpbGRlci5qcz8wZjE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmNvbnN0IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJcIikpO1xuY29uc3QgUG9zdGdyZXN0UmVzZXJ2ZWRDaGFyc1JlZ2V4cCA9IG5ldyBSZWdFeHAoJ1ssKCldJyk7XG5jbGFzcyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyIGV4dGVuZHMgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcl8xLmRlZmF1bHQge1xuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBlcXVhbCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogVG8gY2hlY2sgaWYgdGhlIHZhbHVlIG9mIGBjb2x1bW5gIGlzIE5VTEwsIHlvdSBzaG91bGQgdXNlIGAuaXMoKWAgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIGVxKGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBlcS4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIG5vdCBlcXVhbCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgbmVxKGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBuZXEuJHt2YWx1ZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIGd0KGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBndC4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgZ3RlKGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBndGUuJHt2YWx1ZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBpcyBsZXNzIHRoYW4gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIGx0KGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsdC4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgbHRlKGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsdGUuJHt2YWx1ZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGBwYXR0ZXJuYCBjYXNlLXNlbnNpdGl2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHBhdHRlcm4gLSBUaGUgcGF0dGVybiB0byBtYXRjaCB3aXRoXG4gICAgICovXG4gICAgbGlrZShjb2x1bW4sIHBhdHRlcm4pIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBsaWtlLiR7cGF0dGVybn1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFsbCBvZiBgcGF0dGVybnNgIGNhc2Utc2Vuc2l0aXZlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gcGF0dGVybnMgLSBUaGUgcGF0dGVybnMgdG8gbWF0Y2ggd2l0aFxuICAgICAqL1xuICAgIGxpa2VBbGxPZihjb2x1bW4sIHBhdHRlcm5zKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgbGlrZShhbGwpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgbWF0Y2hlcyBhbnkgb2YgYHBhdHRlcm5zYCBjYXNlLXNlbnNpdGl2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcbiAgICAgKi9cbiAgICBsaWtlQW55T2YoY29sdW1uLCBwYXR0ZXJucykge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGxpa2UoYW55KS57JHtwYXR0ZXJucy5qb2luKCcsJyl9fWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYHBhdHRlcm5gIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBwYXR0ZXJuIC0gVGhlIHBhdHRlcm4gdG8gbWF0Y2ggd2l0aFxuICAgICAqL1xuICAgIGlsaWtlKGNvbHVtbiwgcGF0dGVybikge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGlsaWtlLiR7cGF0dGVybn1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGVyZSBgY29sdW1uYCBtYXRjaGVzIGFsbCBvZiBgcGF0dGVybnNgIGNhc2UtaW5zZW5zaXRpdmVseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBwYXR0ZXJucyAtIFRoZSBwYXR0ZXJucyB0byBtYXRjaCB3aXRoXG4gICAgICovXG4gICAgaWxpa2VBbGxPZihjb2x1bW4sIHBhdHRlcm5zKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgaWxpa2UoYWxsKS57JHtwYXR0ZXJucy5qb2luKCcsJyl9fWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIG1hdGNoZXMgYW55IG9mIGBwYXR0ZXJuc2AgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHBhdHRlcm5zIC0gVGhlIHBhdHRlcm5zIHRvIG1hdGNoIHdpdGhcbiAgICAgKi9cbiAgICBpbGlrZUFueU9mKGNvbHVtbiwgcGF0dGVybnMpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpbGlrZShhbnkpLnske3BhdHRlcm5zLmpvaW4oJywnKX19YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgYGNvbHVtbmAgSVMgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEZvciBub24tYm9vbGVhbiBjb2x1bW5zLCB0aGlzIGlzIG9ubHkgcmVsZXZhbnQgZm9yIGNoZWNraW5nIGlmIHRoZSB2YWx1ZSBvZlxuICAgICAqIGBjb2x1bW5gIGlzIE5VTEwgYnkgc2V0dGluZyBgdmFsdWVgIHRvIGBudWxsYC5cbiAgICAgKlxuICAgICAqIEZvciBib29sZWFuIGNvbHVtbnMsIHlvdSBjYW4gYWxzbyBzZXQgYHZhbHVlYCB0byBgdHJ1ZWAgb3IgYGZhbHNlYCBhbmQgaXRcbiAgICAgKiB3aWxsIGJlaGF2ZSB0aGUgc2FtZSB3YXkgYXMgYC5lcSgpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIGlzKGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBpcy4ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzIGluY2x1ZGVkIGluIHRoZSBgdmFsdWVzYCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIGFycmF5IHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgaW4oY29sdW1uLCB2YWx1ZXMpIHtcbiAgICAgICAgY29uc3QgY2xlYW5lZFZhbHVlcyA9IEFycmF5LmZyb20obmV3IFNldCh2YWx1ZXMpKVxuICAgICAgICAgICAgLm1hcCgocykgPT4ge1xuICAgICAgICAgICAgLy8gaGFuZGxlIHBvc3RncmVzdCByZXNlcnZlZCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAvLyBodHRwczovL3Bvc3RncmVzdC5vcmcvZW4vdjcuMC4wL2FwaS5odG1sI3Jlc2VydmVkLWNoYXJhY3RlcnNcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcyA9PT0gJ3N0cmluZycgJiYgUG9zdGdyZXN0UmVzZXJ2ZWRDaGFyc1JlZ2V4cC50ZXN0KHMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBgXCIke3N9XCJgO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBgJHtzfWA7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignLCcpO1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGluLigke2NsZWFuZWRWYWx1ZXN9KWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IganNvbmIsIGFycmF5LCBhbmQgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAgICogYGNvbHVtbmAgY29udGFpbnMgZXZlcnkgZWxlbWVudCBhcHBlYXJpbmcgaW4gYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBjb250YWlucyhjb2x1bW4sIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyByYW5nZSB0eXBlcyBjYW4gYmUgaW5jbHVzaXZlICdbJywgJ10nIG9yIGV4Y2x1c2l2ZSAnKCcsICcpJyBzbyBqdXN0XG4gICAgICAgICAgICAvLyBrZWVwIGl0IHNpbXBsZSBhbmQgYWNjZXB0IGEgc3RyaW5nXG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNzLiR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIC8vIGFycmF5XG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNzLnske3ZhbHVlLmpvaW4oJywnKX19YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBqc29uXG4gICAgICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGNzLiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciBqc29uYiwgYXJyYXksIGFuZCByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmVcbiAgICAgKiBldmVyeSBlbGVtZW50IGFwcGVhcmluZyBpbiBgY29sdW1uYCBpcyBjb250YWluZWQgYnkgYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUganNvbmIsIGFycmF5LCBvciByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIGpzb25iLCBhcnJheSwgb3IgcmFuZ2UgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBjb250YWluZWRCeShjb2x1bW4sIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyByYW5nZVxuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjZC4ke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAvLyBhcnJheVxuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjZC57JHt2YWx1ZS5qb2luKCcsJyl9fWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8ganNvblxuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBjZC4ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICAgKiBgY29sdW1uYCBpcyBncmVhdGVyIHRoYW4gYW55IGVsZW1lbnQgaW4gYHJhbmdlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIHJhbmdlR3QoY29sdW1uLCByYW5nZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYHNyLiR7cmFuZ2V9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuICAgICAqIGBjb2x1bW5gIGlzIGVpdGhlciBjb250YWluZWQgaW4gYHJhbmdlYCBvciBncmVhdGVyIHRoYW4gYW55IGVsZW1lbnQgaW5cbiAgICAgKiBgcmFuZ2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgcmFuZ2VHdGUoY29sdW1uLCByYW5nZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG54bC4ke3JhbmdlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGV2ZXJ5IGVsZW1lbnQgaW5cbiAgICAgKiBgY29sdW1uYCBpcyBsZXNzIHRoYW4gYW55IGVsZW1lbnQgaW4gYHJhbmdlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIHJhbmdlTHQoY29sdW1uLCByYW5nZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYHNsLiR7cmFuZ2V9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmx5IHJlbGV2YW50IGZvciByYW5nZSBjb2x1bW5zLiBNYXRjaCBvbmx5IHJvd3Mgd2hlcmUgZXZlcnkgZWxlbWVudCBpblxuICAgICAqIGBjb2x1bW5gIGlzIGVpdGhlciBjb250YWluZWQgaW4gYHJhbmdlYCBvciBsZXNzIHRoYW4gYW55IGVsZW1lbnQgaW5cbiAgICAgKiBgcmFuZ2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSByYW5nZSBjb2x1bW4gdG8gZmlsdGVyIG9uXG4gICAgICogQHBhcmFtIHJhbmdlIC0gVGhlIHJhbmdlIHRvIGZpbHRlciB3aXRoXG4gICAgICovXG4gICAgcmFuZ2VMdGUoY29sdW1uLCByYW5nZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYG54ci4ke3JhbmdlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgcmFuZ2UgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlIGBjb2x1bW5gIGlzXG4gICAgICogbXV0dWFsbHkgZXhjbHVzaXZlIHRvIGByYW5nZWAgYW5kIHRoZXJlIGNhbiBiZSBubyBlbGVtZW50IGJldHdlZW4gdGhlIHR3b1xuICAgICAqIHJhbmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgcmFuZ2UgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSByYW5nZSAtIFRoZSByYW5nZSB0byBmaWx0ZXIgd2l0aFxuICAgICAqL1xuICAgIHJhbmdlQWRqYWNlbnQoY29sdW1uLCByYW5nZSkge1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYGFkai4ke3JhbmdlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgYXJyYXkgYW5kIHJhbmdlIGNvbHVtbnMuIE1hdGNoIG9ubHkgcm93cyB3aGVyZVxuICAgICAqIGBjb2x1bW5gIGFuZCBgdmFsdWVgIGhhdmUgYW4gZWxlbWVudCBpbiBjb21tb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGFycmF5IG9yIHJhbmdlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgYXJyYXkgb3IgcmFuZ2UgdmFsdWUgdG8gZmlsdGVyIHdpdGhcbiAgICAgKi9cbiAgICBvdmVybGFwcyhjb2x1bW4sIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyByYW5nZVxuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBvdi4ke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYXJyYXlcbiAgICAgICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgb3YueyR7dmFsdWUuam9pbignLCcpfX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT25seSByZWxldmFudCBmb3IgdGV4dCBhbmQgdHN2ZWN0b3IgY29sdW1ucy4gTWF0Y2ggb25seSByb3dzIHdoZXJlXG4gICAgICogYGNvbHVtbmAgbWF0Y2hlcyB0aGUgcXVlcnkgc3RyaW5nIGluIGBxdWVyeWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIHRleHQgb3IgdHN2ZWN0b3IgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBxdWVyeSAtIFRoZSBxdWVyeSB0ZXh0IHRvIG1hdGNoIHdpdGhcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb25maWcgLSBUaGUgdGV4dCBzZWFyY2ggY29uZmlndXJhdGlvbiB0byB1c2VcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50eXBlIC0gQ2hhbmdlIGhvdyB0aGUgYHF1ZXJ5YCB0ZXh0IGlzIGludGVycHJldGVkXG4gICAgICovXG4gICAgdGV4dFNlYXJjaChjb2x1bW4sIHF1ZXJ5LCB7IGNvbmZpZywgdHlwZSB9ID0ge30pIHtcbiAgICAgICAgbGV0IHR5cGVQYXJ0ID0gJyc7XG4gICAgICAgIGlmICh0eXBlID09PSAncGxhaW4nKSB7XG4gICAgICAgICAgICB0eXBlUGFydCA9ICdwbCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3BocmFzZScpIHtcbiAgICAgICAgICAgIHR5cGVQYXJ0ID0gJ3BoJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnd2Vic2VhcmNoJykge1xuICAgICAgICAgICAgdHlwZVBhcnQgPSAndyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uZmlnUGFydCA9IGNvbmZpZyA9PT0gdW5kZWZpbmVkID8gJycgOiBgKCR7Y29uZmlnfSlgO1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGNvbHVtbiwgYCR7dHlwZVBhcnR9ZnRzJHtjb25maWdQYXJ0fS4ke3F1ZXJ5fWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWF0Y2ggb25seSByb3dzIHdoZXJlIGVhY2ggY29sdW1uIGluIGBxdWVyeWAga2V5cyBpcyBlcXVhbCB0byBpdHNcbiAgICAgKiBhc3NvY2lhdGVkIHZhbHVlLiBTaG9ydGhhbmQgZm9yIG11bHRpcGxlIGAuZXEoKWBzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIG9iamVjdCB0byBmaWx0ZXIgd2l0aCwgd2l0aCBjb2x1bW4gbmFtZXMgYXMga2V5cyBtYXBwZWRcbiAgICAgKiB0byB0aGVpciBmaWx0ZXIgdmFsdWVzXG4gICAgICovXG4gICAgbWF0Y2gocXVlcnkpIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocXVlcnkpLmZvckVhY2goKFtjb2x1bW4sIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBlcS4ke3ZhbHVlfWApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBkb2Vzbid0IHNhdGlzZnkgdGhlIGZpbHRlci5cbiAgICAgKlxuICAgICAqIFVubGlrZSBtb3N0IGZpbHRlcnMsIGBvcGVhcmF0b3JgIGFuZCBgdmFsdWVgIGFyZSB1c2VkIGFzLWlzIGFuZCBuZWVkIHRvXG4gICAgICogZm9sbG93IFtQb3N0Z1JFU1RcbiAgICAgKiBzeW50YXhdKGh0dHBzOi8vcG9zdGdyZXN0Lm9yZy9lbi9zdGFibGUvYXBpLmh0bWwjb3BlcmF0b3JzKS4gWW91IGFsc28gbmVlZFxuICAgICAqIHRvIG1ha2Ugc3VyZSB0aGV5IGFyZSBwcm9wZXJseSBzYW5pdGl6ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29sdW1uIC0gVGhlIGNvbHVtbiB0byBmaWx0ZXIgb25cbiAgICAgKiBAcGFyYW0gb3BlcmF0b3IgLSBUaGUgb3BlcmF0b3IgdG8gYmUgbmVnYXRlZCB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nXG4gICAgICogUG9zdGdSRVNUIHN5bnRheFxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcbiAgICAgKi9cbiAgICBub3QoY29sdW1uLCBvcGVyYXRvciwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChjb2x1bW4sIGBub3QuJHtvcGVyYXRvcn0uJHt2YWx1ZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hdGNoIG9ubHkgcm93cyB3aGljaCBzYXRpc2Z5IGF0IGxlYXN0IG9uZSBvZiB0aGUgZmlsdGVycy5cbiAgICAgKlxuICAgICAqIFVubGlrZSBtb3N0IGZpbHRlcnMsIGBmaWx0ZXJzYCBpcyB1c2VkIGFzLWlzIGFuZCBuZWVkcyB0byBmb2xsb3cgW1Bvc3RnUkVTVFxuICAgICAqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG4gICAgICogdG8gbWFrZSBzdXJlIGl0J3MgcHJvcGVybHkgc2FuaXRpemVkLlxuICAgICAqXG4gICAgICogSXQncyBjdXJyZW50bHkgbm90IHBvc3NpYmxlIHRvIGRvIGFuIGAub3IoKWAgZmlsdGVyIGFjcm9zcyBtdWx0aXBsZSB0YWJsZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmlsdGVycyAtIFRoZSBmaWx0ZXJzIHRvIHVzZSwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBmaWx0ZXIgb24gcmVmZXJlbmNlZCB0YWJsZXNcbiAgICAgKiBpbnN0ZWFkIG9mIHRoZSBwYXJlbnQgdGFibGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5mb3JlaWduVGFibGUgLSBEZXByZWNhdGVkLCB1c2UgYHJlZmVyZW5jZWRUYWJsZWAgaW5zdGVhZFxuICAgICAqL1xuICAgIG9yKGZpbHRlcnMsIHsgZm9yZWlnblRhYmxlLCByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBrZXkgPSByZWZlcmVuY2VkVGFibGUgPyBgJHtyZWZlcmVuY2VkVGFibGV9Lm9yYCA6ICdvcic7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBgKCR7ZmlsdGVyc30pYCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXRjaCBvbmx5IHJvd3Mgd2hpY2ggc2F0aXNmeSB0aGUgZmlsdGVyLiBUaGlzIGlzIGFuIGVzY2FwZSBoYXRjaCAtIHlvdVxuICAgICAqIHNob3VsZCB1c2UgdGhlIHNwZWNpZmljIGZpbHRlciBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLlxuICAgICAqXG4gICAgICogVW5saWtlIG1vc3QgZmlsdGVycywgYG9wZWFyYXRvcmAgYW5kIGB2YWx1ZWAgYXJlIHVzZWQgYXMtaXMgYW5kIG5lZWQgdG9cbiAgICAgKiBmb2xsb3cgW1Bvc3RnUkVTVFxuICAgICAqIHN5bnRheF0oaHR0cHM6Ly9wb3N0Z3Jlc3Qub3JnL2VuL3N0YWJsZS9hcGkuaHRtbCNvcGVyYXRvcnMpLiBZb3UgYWxzbyBuZWVkXG4gICAgICogdG8gbWFrZSBzdXJlIHRoZXkgYXJlIHByb3Blcmx5IHNhbml0aXplZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW4gLSBUaGUgY29sdW1uIHRvIGZpbHRlciBvblxuICAgICAqIEBwYXJhbSBvcGVyYXRvciAtIFRoZSBvcGVyYXRvciB0byBmaWx0ZXIgd2l0aCwgZm9sbG93aW5nIFBvc3RnUkVTVCBzeW50YXhcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gZmlsdGVyIHdpdGgsIGZvbGxvd2luZyBQb3N0Z1JFU1Qgc3ludGF4XG4gICAgICovXG4gICAgZmlsdGVyKGNvbHVtbiwgb3BlcmF0b3IsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoY29sdW1uLCBgJHtvcGVyYXRvcn0uJHt2YWx1ZX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUG9zdGdyZXN0RmlsdGVyQnVpbGRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvc3RncmVzdEZpbHRlckJ1aWxkZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidHNsaWJfMSIsInJlcXVpcmUiLCJQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXzEiLCJfX2ltcG9ydERlZmF1bHQiLCJQb3N0Z3Jlc3RSZXNlcnZlZENoYXJzUmVnZXhwIiwiUmVnRXhwIiwiUG9zdGdyZXN0RmlsdGVyQnVpbGRlciIsImRlZmF1bHQiLCJlcSIsImNvbHVtbiIsInVybCIsInNlYXJjaFBhcmFtcyIsImFwcGVuZCIsIm5lcSIsImd0IiwiZ3RlIiwibHQiLCJsdGUiLCJsaWtlIiwicGF0dGVybiIsImxpa2VBbGxPZiIsInBhdHRlcm5zIiwiam9pbiIsImxpa2VBbnlPZiIsImlsaWtlIiwiaWxpa2VBbGxPZiIsImlsaWtlQW55T2YiLCJpcyIsImluIiwidmFsdWVzIiwiY2xlYW5lZFZhbHVlcyIsIkFycmF5IiwiZnJvbSIsIlNldCIsIm1hcCIsInMiLCJ0ZXN0IiwiY29udGFpbnMiLCJpc0FycmF5IiwiSlNPTiIsInN0cmluZ2lmeSIsImNvbnRhaW5lZEJ5IiwicmFuZ2VHdCIsInJhbmdlIiwicmFuZ2VHdGUiLCJyYW5nZUx0IiwicmFuZ2VMdGUiLCJyYW5nZUFkamFjZW50Iiwib3ZlcmxhcHMiLCJ0ZXh0U2VhcmNoIiwicXVlcnkiLCJjb25maWciLCJ0eXBlIiwidHlwZVBhcnQiLCJjb25maWdQYXJ0IiwidW5kZWZpbmVkIiwibWF0Y2giLCJlbnRyaWVzIiwiZm9yRWFjaCIsIm5vdCIsIm9wZXJhdG9yIiwib3IiLCJmaWx0ZXJzIiwiZm9yZWlnblRhYmxlIiwicmVmZXJlbmNlZFRhYmxlIiwia2V5IiwiZmlsdGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\nconst PostgrestFilterBuilder_1 = tslib_1.__importDefault(__webpack_require__(/*! ./PostgrestFilterBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\"));\nclass PostgrestQueryBuilder {\n    constructor(url, { headers = {}, schema, fetch: fetch1 }){\n        this.url = url;\n        this.headers = new Headers(headers);\n        this.schema = schema;\n        this.fetch = fetch1;\n    }\n    /**\n     * Perform a SELECT query on the table or view.\n     *\n     * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n     *\n     * @param options - Named parameters\n     *\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     *\n     * @param options.count - Count algorithm to use to count rows in the table or view.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */ select(columns, options) {\n        const { head = false, count } = options !== null && options !== void 0 ? options : {};\n        const method = head ? \"HEAD\" : \"GET\";\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c)=>{\n            if (/\\s/.test(c) && !quoted) {\n                return \"\";\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        }).join(\"\");\n        this.url.searchParams.set(\"select\", cleanedColumns);\n        if (count) {\n            this.headers.append(\"Prefer\", `count=${count}`);\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: this.fetch\n        });\n    }\n    /**\n     * Perform an INSERT into the table or view.\n     *\n     * By default, inserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to insert. Pass an object to insert a single row\n     * or an array to insert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count inserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. Only applies for bulk\n     * inserts.\n     */ insert(values, { count, defaultToNull = true } = {}) {\n        var _a;\n        const method = \"POST\";\n        if (count) {\n            this.headers.append(\"Prefer\", `count=${count}`);\n        }\n        if (!defaultToNull) {\n            this.headers.append(\"Prefer\", `missing=default`);\n        }\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [\n                    ...new Set(columns)\n                ].map((column)=>`\"${column}\"`);\n                this.url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n            }\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch\n        });\n    }\n    /**\n     * Perform an UPSERT on the table or view. Depending on the column(s) passed\n     * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n     * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n     * exist, or if it does exist, perform an alternative action depending on\n     * `ignoreDuplicates`.\n     *\n     * By default, upserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to upsert with. Pass an object to upsert a\n     * single row or an array to upsert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n     * duplicate rows are determined. Two rows are duplicates if all the\n     * `onConflict` columns are equal.\n     *\n     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n     * `false`, duplicate rows are merged with existing rows.\n     *\n     * @param options.count - Count algorithm to use to count upserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. This only applies when\n     * inserting new rows, not when merging with existing rows under\n     * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n     */ upsert(values, { onConflict, ignoreDuplicates = false, count, defaultToNull = true } = {}) {\n        var _a;\n        const method = \"POST\";\n        this.headers.append(\"Prefer\", `resolution=${ignoreDuplicates ? \"ignore\" : \"merge\"}-duplicates`);\n        if (onConflict !== undefined) this.url.searchParams.set(\"on_conflict\", onConflict);\n        if (count) {\n            this.headers.append(\"Prefer\", `count=${count}`);\n        }\n        if (!defaultToNull) {\n            this.headers.append(\"Prefer\", \"missing=default\");\n        }\n        if (Array.isArray(values)) {\n            const columns = values.reduce((acc, x)=>acc.concat(Object.keys(x)), []);\n            if (columns.length > 0) {\n                const uniqueColumns = [\n                    ...new Set(columns)\n                ].map((column)=>`\"${column}\"`);\n                this.url.searchParams.set(\"columns\", uniqueColumns.join(\",\"));\n            }\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch\n        });\n    }\n    /**\n     * Perform an UPDATE on the table or view.\n     *\n     * By default, updated rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param values - The values to update with\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count updated rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */ update(values, { count } = {}) {\n        var _a;\n        const method = \"PATCH\";\n        if (count) {\n            this.headers.append(\"Prefer\", `count=${count}`);\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            body: values,\n            fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch\n        });\n    }\n    /**\n     * Perform a DELETE on the table or view.\n     *\n     * By default, deleted rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count deleted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */ delete({ count } = {}) {\n        var _a;\n        const method = \"DELETE\";\n        if (count) {\n            this.headers.append(\"Prefer\", `count=${count}`);\n        }\n        return new PostgrestFilterBuilder_1.default({\n            method,\n            url: this.url,\n            headers: this.headers,\n            schema: this.schema,\n            fetch: (_a = this.fetch) !== null && _a !== void 0 ? _a : fetch\n        });\n    }\n}\nexports[\"default\"] = PostgrestQueryBuilder; //# sourceMappingURL=PostgrestQueryBuilder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsVUFBVUMsbUJBQU9BLENBQUMsdURBQU87QUFDL0IsTUFBTUMsMkJBQTJCRixRQUFRRyxlQUFlLENBQUNGLG1CQUFPQSxDQUFDLGdIQUEwQjtBQUMzRixNQUFNRztJQUNGQyxZQUFZQyxHQUFHLEVBQUUsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRUMsTUFBTSxFQUFFQyxPQUFBQSxNQUFLLEVBQUcsQ0FBRTtRQUMvQyxJQUFJLENBQUNILEdBQUcsR0FBR0E7UUFDWCxJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJRyxRQUFRSDtRQUMzQixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLEtBQUssR0FBR0E7SUFDakI7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FvQkMsR0FDREUsT0FBT0MsT0FBTyxFQUFFQyxPQUFPLEVBQUU7UUFDckIsTUFBTSxFQUFFQyxPQUFPLEtBQUssRUFBRUMsS0FBSyxFQUFFLEdBQUdGLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUlBLFVBQVUsQ0FBQztRQUNwRixNQUFNRyxTQUFTRixPQUFPLFNBQVM7UUFDL0Isd0NBQXdDO1FBQ3hDLElBQUlHLFNBQVM7UUFDYixNQUFNQyxpQkFBaUIsQ0FBQ04sWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSUEsVUFBVSxHQUFFLEVBQ3hFTyxLQUFLLENBQUMsSUFDTkMsR0FBRyxDQUFDLENBQUNDO1lBQ04sSUFBSSxLQUFLQyxJQUFJLENBQUNELE1BQU0sQ0FBQ0osUUFBUTtnQkFDekIsT0FBTztZQUNYO1lBQ0EsSUFBSUksTUFBTSxLQUFLO2dCQUNYSixTQUFTLENBQUNBO1lBQ2Q7WUFDQSxPQUFPSTtRQUNYLEdBQ0tF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QixLQUFLLE1BQU0sUUFBUXNCLE9BQU8sS0FBSyxJQUFJQSxLQUFLdEI7UUFDOUQ7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FrQkMsR0FDRHdDLE9BQU8sRUFBRWxDLEtBQUssRUFBRyxHQUFHLENBQUMsQ0FBQyxFQUFFO1FBQ3BCLElBQUlnQjtRQUNKLE1BQU1mLFNBQVM7UUFDZixJQUFJRCxPQUFPO1lBQ1AsSUFBSSxDQUFDUixPQUFPLENBQUNtQixNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRVgsTUFBTSxDQUFDO1FBQ2xEO1FBQ0EsT0FBTyxJQUFJYix5QkFBeUJ5QixPQUFPLENBQUM7WUFDeENYO1lBQ0FWLEtBQUssSUFBSSxDQUFDQSxHQUFHO1lBQ2JDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCQyxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQkMsT0FBTyxDQUFDc0IsS0FBSyxJQUFJLENBQUN0QixLQUFLLE1BQU0sUUFBUXNCLE9BQU8sS0FBSyxJQUFJQSxLQUFLdEI7UUFDOUQ7SUFDSjtBQUNKO0FBQ0FYLGtCQUFlLEdBQUdNLHVCQUNsQixpREFBaUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL1Bvc3RncmVzdFF1ZXJ5QnVpbGRlci5qcz8yNWM2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmNvbnN0IFBvc3RncmVzdEZpbHRlckJ1aWxkZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEZpbHRlckJ1aWxkZXJcIikpO1xuY2xhc3MgUG9zdGdyZXN0UXVlcnlCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIHsgaGVhZGVycyA9IHt9LCBzY2hlbWEsIGZldGNoLCB9KSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSBmZXRjaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIFNFTEVDVCBxdWVyeSBvbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2x1bW5zIC0gVGhlIGNvbHVtbnMgdG8gcmV0cmlldmUsIHNlcGFyYXRlZCBieSBjb21tYXMuIENvbHVtbnMgY2FuIGJlIHJlbmFtZWQgd2hlbiByZXR1cm5lZCB3aXRoIGBjdXN0b21OYW1lOmNvbHVtbk5hbWVgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYWQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIGBkYXRhYCB3aWxsIG5vdCBiZSByZXR1cm5lZC5cbiAgICAgKiBVc2VmdWwgaWYgeW91IG9ubHkgbmVlZCB0aGUgY291bnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb3VudCAtIENvdW50IGFsZ29yaXRobSB0byB1c2UgdG8gY291bnQgcm93cyBpbiB0aGUgdGFibGUgb3Igdmlldy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICovXG4gICAgc2VsZWN0KGNvbHVtbnMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBoZWFkID0gZmFsc2UsIGNvdW50IH0gPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gaGVhZCA/ICdIRUFEJyA6ICdHRVQnO1xuICAgICAgICAvLyBSZW1vdmUgd2hpdGVzcGFjZXMgZXhjZXB0IHdoZW4gcXVvdGVkXG4gICAgICAgIGxldCBxdW90ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2xlYW5lZENvbHVtbnMgPSAoY29sdW1ucyAhPT0gbnVsbCAmJiBjb2x1bW5zICE9PSB2b2lkIDAgPyBjb2x1bW5zIDogJyonKVxuICAgICAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAgICAgLm1hcCgoYykgPT4ge1xuICAgICAgICAgICAgaWYgKC9cXHMvLnRlc3QoYykgJiYgIXF1b3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgcXVvdGVkID0gIXF1b3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KCdzZWxlY3QnLCBjbGVhbmVkQ29sdW1ucyk7XG4gICAgICAgIGlmIChjb3VudCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLmFwcGVuZCgnUHJlZmVyJywgYGNvdW50PSR7Y291bnR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhbiBJTlNFUlQgaW50byB0aGUgdGFibGUgb3Igdmlldy5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIGluc2VydGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuICAgICAqIHdpdGggYC5zZWxlY3QoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byBpbnNlcnQuIFBhc3MgYW4gb2JqZWN0IHRvIGluc2VydCBhIHNpbmdsZSByb3dcbiAgICAgKiBvciBhbiBhcnJheSB0byBpbnNlcnQgbXVsdGlwbGUgcm93cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGluc2VydGVkIHJvd3MuXG4gICAgICpcbiAgICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAgICogaG9vZC5cbiAgICAgKlxuICAgICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICAgKlxuICAgICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICAgKiBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdFRvTnVsbCAtIE1ha2UgbWlzc2luZyBmaWVsZHMgZGVmYXVsdCB0byBgbnVsbGAuXG4gICAgICogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIE9ubHkgYXBwbGllcyBmb3IgYnVsa1xuICAgICAqIGluc2VydHMuXG4gICAgICovXG4gICAgaW5zZXJ0KHZhbHVlcywgeyBjb3VudCwgZGVmYXVsdFRvTnVsbCA9IHRydWUsIH0gPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuYXBwZW5kKCdQcmVmZXInLCBgY291bnQ9JHtjb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZmF1bHRUb051bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5hcHBlbmQoJ1ByZWZlcicsIGBtaXNzaW5nPWRlZmF1bHRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBjb2x1bW5zID0gdmFsdWVzLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MuY29uY2F0KE9iamVjdC5rZXlzKHgpKSwgW10pO1xuICAgICAgICAgICAgaWYgKGNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuaXF1ZUNvbHVtbnMgPSBbLi4ubmV3IFNldChjb2x1bW5zKV0ubWFwKChjb2x1bW4pID0+IGBcIiR7Y29sdW1ufVwiYCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldCgnY29sdW1ucycsIHVuaXF1ZUNvbHVtbnMuam9pbignLCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXJfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgICAgICAgZmV0Y2g6IChfYSA9IHRoaXMuZmV0Y2gpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZldGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhbiBVUFNFUlQgb24gdGhlIHRhYmxlIG9yIHZpZXcuIERlcGVuZGluZyBvbiB0aGUgY29sdW1uKHMpIHBhc3NlZFxuICAgICAqIHRvIGBvbkNvbmZsaWN0YCwgYC51cHNlcnQoKWAgYWxsb3dzIHlvdSB0byBwZXJmb3JtIHRoZSBlcXVpdmFsZW50IG9mXG4gICAgICogYC5pbnNlcnQoKWAgaWYgYSByb3cgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBgb25Db25mbGljdGAgY29sdW1ucyBkb2Vzbid0XG4gICAgICogZXhpc3QsIG9yIGlmIGl0IGRvZXMgZXhpc3QsIHBlcmZvcm0gYW4gYWx0ZXJuYXRpdmUgYWN0aW9uIGRlcGVuZGluZyBvblxuICAgICAqIGBpZ25vcmVEdXBsaWNhdGVzYC5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHVwc2VydGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuICAgICAqIHdpdGggYC5zZWxlY3QoKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHZhbHVlcyB0byB1cHNlcnQgd2l0aC4gUGFzcyBhbiBvYmplY3QgdG8gdXBzZXJ0IGFcbiAgICAgKiBzaW5nbGUgcm93IG9yIGFuIGFycmF5IHRvIHVwc2VydCBtdWx0aXBsZSByb3dzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbkNvbmZsaWN0IC0gQ29tbWEtc2VwYXJhdGVkIFVOSVFVRSBjb2x1bW4ocykgdG8gc3BlY2lmeSBob3dcbiAgICAgKiBkdXBsaWNhdGUgcm93cyBhcmUgZGV0ZXJtaW5lZC4gVHdvIHJvd3MgYXJlIGR1cGxpY2F0ZXMgaWYgYWxsIHRoZVxuICAgICAqIGBvbkNvbmZsaWN0YCBjb2x1bW5zIGFyZSBlcXVhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZXMgLSBJZiBgdHJ1ZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBpZ25vcmVkLiBJZlxuICAgICAqIGBmYWxzZWAsIGR1cGxpY2F0ZSByb3dzIGFyZSBtZXJnZWQgd2l0aCBleGlzdGluZyByb3dzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IHVwc2VydGVkIHJvd3MuXG4gICAgICpcbiAgICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAgICogaG9vZC5cbiAgICAgKlxuICAgICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICAgKlxuICAgICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICAgKiBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdFRvTnVsbCAtIE1ha2UgbWlzc2luZyBmaWVsZHMgZGVmYXVsdCB0byBgbnVsbGAuXG4gICAgICogT3RoZXJ3aXNlLCB1c2UgdGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBjb2x1bW4uIFRoaXMgb25seSBhcHBsaWVzIHdoZW5cbiAgICAgKiBpbnNlcnRpbmcgbmV3IHJvd3MsIG5vdCB3aGVuIG1lcmdpbmcgd2l0aCBleGlzdGluZyByb3dzIHVuZGVyXG4gICAgICogYGlnbm9yZUR1cGxpY2F0ZXM6IGZhbHNlYC4gVGhpcyBhbHNvIG9ubHkgYXBwbGllcyB3aGVuIGRvaW5nIGJ1bGsgdXBzZXJ0cy5cbiAgICAgKi9cbiAgICB1cHNlcnQodmFsdWVzLCB7IG9uQ29uZmxpY3QsIGlnbm9yZUR1cGxpY2F0ZXMgPSBmYWxzZSwgY291bnQsIGRlZmF1bHRUb051bGwgPSB0cnVlLCB9ID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBtZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIHRoaXMuaGVhZGVycy5hcHBlbmQoJ1ByZWZlcicsIGByZXNvbHV0aW9uPSR7aWdub3JlRHVwbGljYXRlcyA/ICdpZ25vcmUnIDogJ21lcmdlJ30tZHVwbGljYXRlc2ApO1xuICAgICAgICBpZiAob25Db25mbGljdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldCgnb25fY29uZmxpY3QnLCBvbkNvbmZsaWN0KTtcbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuYXBwZW5kKCdQcmVmZXInLCBgY291bnQ9JHtjb3VudH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRlZmF1bHRUb051bGwpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5hcHBlbmQoJ1ByZWZlcicsICdtaXNzaW5nPWRlZmF1bHQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBjb2x1bW5zID0gdmFsdWVzLnJlZHVjZSgoYWNjLCB4KSA9PiBhY2MuY29uY2F0KE9iamVjdC5rZXlzKHgpKSwgW10pO1xuICAgICAgICAgICAgaWYgKGNvbHVtbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuaXF1ZUNvbHVtbnMgPSBbLi4ubmV3IFNldChjb2x1bW5zKV0ubWFwKChjb2x1bW4pID0+IGBcIiR7Y29sdW1ufVwiYCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldCgnY29sdW1ucycsIHVuaXF1ZUNvbHVtbnMuam9pbignLCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBvc3RncmVzdEZpbHRlckJ1aWxkZXJfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgYm9keTogdmFsdWVzLFxuICAgICAgICAgICAgZmV0Y2g6IChfYSA9IHRoaXMuZmV0Y2gpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZldGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhbiBVUERBVEUgb24gdGhlIHRhYmxlIG9yIHZpZXcuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCB1cGRhdGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuICAgICAqIHdpdGggYC5zZWxlY3QoKWAgYWZ0ZXIgZmlsdGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZXMgLSBUaGUgdmFsdWVzIHRvIHVwZGF0ZSB3aXRoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCB1cGRhdGVkIHJvd3MuXG4gICAgICpcbiAgICAgKiBgXCJleGFjdFwiYDogRXhhY3QgYnV0IHNsb3cgY291bnQgYWxnb3JpdGhtLiBQZXJmb3JtcyBhIGBDT1VOVCgqKWAgdW5kZXIgdGhlXG4gICAgICogaG9vZC5cbiAgICAgKlxuICAgICAqIGBcInBsYW5uZWRcImA6IEFwcHJveGltYXRlZCBidXQgZmFzdCBjb3VudCBhbGdvcml0aG0uIFVzZXMgdGhlIFBvc3RncmVzXG4gICAgICogc3RhdGlzdGljcyB1bmRlciB0aGUgaG9vZC5cbiAgICAgKlxuICAgICAqIGBcImVzdGltYXRlZFwiYDogVXNlcyBleGFjdCBjb3VudCBmb3IgbG93IG51bWJlcnMgYW5kIHBsYW5uZWQgY291bnQgZm9yIGhpZ2hcbiAgICAgKiBudW1iZXJzLlxuICAgICAqL1xuICAgIHVwZGF0ZSh2YWx1ZXMsIHsgY291bnQsIH0gPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdQQVRDSCc7XG4gICAgICAgIGlmIChjb3VudCkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLmFwcGVuZCgnUHJlZmVyJywgYGNvdW50PSR7Y291bnR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIGJvZHk6IHZhbHVlcyxcbiAgICAgICAgICAgIGZldGNoOiAoX2EgPSB0aGlzLmZldGNoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmZXRjaCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBERUxFVEUgb24gdGhlIHRhYmxlIG9yIHZpZXcuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBkZWxldGVkIHJvd3MgYXJlIG5vdCByZXR1cm5lZC4gVG8gcmV0dXJuIGl0LCBjaGFpbiB0aGUgY2FsbFxuICAgICAqIHdpdGggYC5zZWxlY3QoKWAgYWZ0ZXIgZmlsdGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTmFtZWQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY291bnQgLSBDb3VudCBhbGdvcml0aG0gdG8gdXNlIHRvIGNvdW50IGRlbGV0ZWQgcm93cy5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICovXG4gICAgZGVsZXRlKHsgY291bnQsIH0gPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdERUxFVEUnO1xuICAgICAgICBpZiAoY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5hcHBlbmQoJ1ByZWZlcicsIGBjb3VudD0ke2NvdW50fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgdXJsOiB0aGlzLnVybCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEsXG4gICAgICAgICAgICBmZXRjaDogKF9hID0gdGhpcy5mZXRjaCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmV0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvc3RncmVzdFF1ZXJ5QnVpbGRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0c2xpYl8xIiwicmVxdWlyZSIsIlBvc3RncmVzdEZpbHRlckJ1aWxkZXJfMSIsIl9faW1wb3J0RGVmYXVsdCIsIlBvc3RncmVzdFF1ZXJ5QnVpbGRlciIsImNvbnN0cnVjdG9yIiwidXJsIiwiaGVhZGVycyIsInNjaGVtYSIsImZldGNoIiwiSGVhZGVycyIsInNlbGVjdCIsImNvbHVtbnMiLCJvcHRpb25zIiwiaGVhZCIsImNvdW50IiwibWV0aG9kIiwicXVvdGVkIiwiY2xlYW5lZENvbHVtbnMiLCJzcGxpdCIsIm1hcCIsImMiLCJ0ZXN0Iiwiam9pbiIsInNlYXJjaFBhcmFtcyIsInNldCIsImFwcGVuZCIsImRlZmF1bHQiLCJpbnNlcnQiLCJ2YWx1ZXMiLCJkZWZhdWx0VG9OdWxsIiwiX2EiLCJBcnJheSIsImlzQXJyYXkiLCJyZWR1Y2UiLCJhY2MiLCJ4IiwiY29uY2F0Iiwia2V5cyIsImxlbmd0aCIsInVuaXF1ZUNvbHVtbnMiLCJTZXQiLCJjb2x1bW4iLCJib2R5IiwidXBzZXJ0Iiwib25Db25mbGljdCIsImlnbm9yZUR1cGxpY2F0ZXMiLCJ1bmRlZmluZWQiLCJ1cGRhdGUiLCJkZWxldGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\nconst PostgrestBuilder_1 = tslib_1.__importDefault(__webpack_require__(/*! ./PostgrestBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js\"));\nclass PostgrestTransformBuilder extends PostgrestBuilder_1.default {\n    /**\n     * Perform a SELECT on the query result.\n     *\n     * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n     * return modified rows. By calling this method, modified rows are returned in\n     * `data`.\n     *\n     * @param columns - The columns to retrieve, separated by commas\n     */ select(columns) {\n        // Remove whitespaces except when quoted\n        let quoted = false;\n        const cleanedColumns = (columns !== null && columns !== void 0 ? columns : \"*\").split(\"\").map((c)=>{\n            if (/\\s/.test(c) && !quoted) {\n                return \"\";\n            }\n            if (c === '\"') {\n                quoted = !quoted;\n            }\n            return c;\n        }).join(\"\");\n        this.url.searchParams.set(\"select\", cleanedColumns);\n        this.headers.append(\"Prefer\", \"return=representation\");\n        return this;\n    }\n    /**\n     * Order the query result by `column`.\n     *\n     * You can call this method multiple times to order by multiple columns.\n     *\n     * You can order referenced tables, but it only affects the ordering of the\n     * parent table if you use `!inner` in the query.\n     *\n     * @param column - The column to order by\n     * @param options - Named parameters\n     * @param options.ascending - If `true`, the result will be in ascending order\n     * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n     * `null`s appear last.\n     * @param options.referencedTable - Set this to order a referenced table by\n     * its columns\n     * @param options.foreignTable - Deprecated, use `options.referencedTable`\n     * instead\n     */ order(column, { ascending = true, nullsFirst, foreignTable, referencedTable = foreignTable } = {}) {\n        const key = referencedTable ? `${referencedTable}.order` : \"order\";\n        const existingOrder = this.url.searchParams.get(key);\n        this.url.searchParams.set(key, `${existingOrder ? `${existingOrder},` : \"\"}${column}.${ascending ? \"asc\" : \"desc\"}${nullsFirst === undefined ? \"\" : nullsFirst ? \".nullsfirst\" : \".nullslast\"}`);\n        return this;\n    }\n    /**\n     * Limit the query result by `count`.\n     *\n     * @param count - The maximum number of rows to return\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to limit rows of referenced\n     * tables instead of the parent table\n     * @param options.foreignTable - Deprecated, use `options.referencedTable`\n     * instead\n     */ limit(count, { foreignTable, referencedTable = foreignTable } = {}) {\n        const key = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n        this.url.searchParams.set(key, `${count}`);\n        return this;\n    }\n    /**\n     * Limit the query result by starting at an offset `from` and ending at the offset `to`.\n     * Only records within this range are returned.\n     * This respects the query order and if there is no order clause the range could behave unexpectedly.\n     * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n     * and fourth rows of the query.\n     *\n     * @param from - The starting index from which to limit the result\n     * @param to - The last index to which to limit the result\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to limit rows of referenced\n     * tables instead of the parent table\n     * @param options.foreignTable - Deprecated, use `options.referencedTable`\n     * instead\n     */ range(from, to, { foreignTable, referencedTable = foreignTable } = {}) {\n        const keyOffset = typeof referencedTable === \"undefined\" ? \"offset\" : `${referencedTable}.offset`;\n        const keyLimit = typeof referencedTable === \"undefined\" ? \"limit\" : `${referencedTable}.limit`;\n        this.url.searchParams.set(keyOffset, `${from}`);\n        // Range is inclusive, so add 1\n        this.url.searchParams.set(keyLimit, `${to - from + 1}`);\n        return this;\n    }\n    /**\n     * Set the AbortSignal for the fetch request.\n     *\n     * @param signal - The AbortSignal to use for the fetch request\n     */ abortSignal(signal) {\n        this.signal = signal;\n        return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n     * returns an error.\n     */ single() {\n        this.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n        return this;\n    }\n    /**\n     * Return `data` as a single object instead of an array of objects.\n     *\n     * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n     * this returns an error.\n     */ maybeSingle() {\n        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n        if (this.method === \"GET\") {\n            this.headers.set(\"Accept\", \"application/json\");\n        } else {\n            this.headers.set(\"Accept\", \"application/vnd.pgrst.object+json\");\n        }\n        this.isMaybeSingle = true;\n        return this;\n    }\n    /**\n     * Return `data` as a string in CSV format.\n     */ csv() {\n        this.headers.set(\"Accept\", \"text/csv\");\n        return this;\n    }\n    /**\n     * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n     */ geojson() {\n        this.headers.set(\"Accept\", \"application/geo+json\");\n        return this;\n    }\n    /**\n     * Return `data` as the EXPLAIN plan for the query.\n     *\n     * You need to enable the\n     * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n     * setting before using this method.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.analyze - If `true`, the query will be executed and the\n     * actual run time will be returned\n     *\n     * @param options.verbose - If `true`, the query identifier will be returned\n     * and `data` will include the output columns of the query\n     *\n     * @param options.settings - If `true`, include information on configuration\n     * parameters that affect query planning\n     *\n     * @param options.buffers - If `true`, include information on buffer usage\n     *\n     * @param options.wal - If `true`, include information on WAL record generation\n     *\n     * @param options.format - The format of the output, can be `\"text\"` (default)\n     * or `\"json\"`\n     */ explain({ analyze = false, verbose = false, settings = false, buffers = false, wal = false, format = \"text\" } = {}) {\n        var _a;\n        const options = [\n            analyze ? \"analyze\" : null,\n            verbose ? \"verbose\" : null,\n            settings ? \"settings\" : null,\n            buffers ? \"buffers\" : null,\n            wal ? \"wal\" : null\n        ].filter(Boolean).join(\"|\");\n        // An Accept header can carry multiple media types but postgrest-js always sends one\n        const forMediatype = (_a = this.headers.get(\"Accept\")) !== null && _a !== void 0 ? _a : \"application/json\";\n        this.headers.set(\"Accept\", `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`);\n        if (format === \"json\") {\n            return this;\n        } else {\n            return this;\n        }\n    }\n    /**\n     * Rollback the query.\n     *\n     * `data` will still be returned, but the query is not committed.\n     */ rollback() {\n        this.headers.append(\"Prefer\", \"tx=rollback\");\n        return this;\n    }\n    /**\n     * Override the type of the returned `data`.\n     *\n     * @typeParam NewResult - The new result type to override with\n     * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n     */ returns() {\n        return this;\n    }\n    /**\n     * Set the maximum number of rows that can be affected by the query.\n     * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\n     *\n     * @param value - The maximum number of rows that can be affected\n     */ maxAffected(value) {\n        this.headers.append(\"Prefer\", \"handling=strict\");\n        this.headers.append(\"Prefer\", `max-affected=${value}`);\n        return this;\n    }\n}\nexports[\"default\"] = PostgrestTransformBuilder; //# sourceMappingURL=PostgrestTransformBuilder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFVBQVVDLG1CQUFPQSxDQUFDLHVEQUFPO0FBQy9CLE1BQU1DLHFCQUFxQkYsUUFBUUcsZUFBZSxDQUFDRixtQkFBT0EsQ0FBQyxvR0FBb0I7QUFDL0UsTUFBTUcsa0NBQWtDRixtQkFBbUJHLE9BQU87SUFDOUQ7Ozs7Ozs7O0tBUUMsR0FDREMsT0FBT0MsT0FBTyxFQUFFO1FBQ1osd0NBQXdDO1FBQ3hDLElBQUlDLFNBQVM7UUFDYixNQUFNQyxpQkFBaUIsQ0FBQ0YsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSUEsVUFBVSxHQUFFLEVBQ3hFRyxLQUFLLENBQUMsSUFDTkMsR0FBRyxDQUFDLENBQUNDO1lBQ04sSUFBSSxLQUFLQyxJQUFJLENBQUNELE1BQU0sQ0FBQ0osUUFBUTtnQkFDekIsT0FBTztZQUNYO1lBQ0EsSUFBSUksTUFBTSxLQUFLO2dCQUNYSixTQUFTLENBQUNBO1lBQ2Q7WUFDQSxPQUFPSTtRQUNYLEdBQ0tFLElBQUksQ0FBQztRQUNWLElBQUksQ0FBQ0MsR0FBRyxDQUFDQyxZQUFZLENBQUNDLEdBQUcsQ0FBQyxVQUFVUjtRQUNwQyxJQUFJLENBQUNTLE9BQU8sQ0FBQ0MsTUFBTSxDQUFDLFVBQVU7UUFDOUIsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FpQkMsR0FDREMsTUFBTUMsTUFBTSxFQUFFLEVBQUVDLFlBQVksSUFBSSxFQUFFQyxVQUFVLEVBQUVDLFlBQVksRUFBRUMsa0JBQWtCRCxZQUFZLEVBQUcsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUNoRyxNQUFNRSxNQUFNRCxrQkFBa0IsQ0FBQyxFQUFFQSxnQkFBZ0IsTUFBTSxDQUFDLEdBQUc7UUFD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QVcsYUFBYTtZQUN4QkMsVUFBVSxZQUFZO1lBQ3RCQyxNQUFNLFFBQVE7U0FDakIsQ0FDSUksTUFBTSxDQUFDQyxTQUNQekMsSUFBSSxDQUFDO1FBQ1Ysb0ZBQW9GO1FBQ3BGLE1BQU0wQyxlQUFlLENBQUNKLEtBQUssSUFBSSxDQUFDbEMsT0FBTyxDQUFDVSxHQUFHLENBQUMsU0FBUSxNQUFPLFFBQVF3QixPQUFPLEtBQUssSUFBSUEsS0FBSztRQUN4RixJQUFJLENBQUNsQyxPQUFPLENBQUNELEdBQUcsQ0FBQyxVQUFVLENBQUMsMkJBQTJCLEVBQUVrQyxPQUFPLE9BQU8sRUFBRUssYUFBYSxXQUFXLEVBQUVILFFBQVEsQ0FBQyxDQUFDO1FBQzdHLElBQUlGLFdBQVcsUUFBUTtZQUNuQixPQUFPLElBQUk7UUFDZixPQUNLO1lBQ0QsT0FBTyxJQUFJO1FBQ2Y7SUFDSjtJQUNBOzs7O0tBSUMsR0FDRE0sV0FBVztRQUNQLElBQUksQ0FBQ3ZDLE9BQU8sQ0FBQ0MsTUFBTSxDQUFDLFVBQVU7UUFDOUIsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7S0FLQyxHQUNEdUMsVUFBVTtRQUNOLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7O0tBS0MsR0FDREMsWUFBWTVELEtBQUssRUFBRTtRQUNmLElBQUksQ0FBQ21CLE9BQU8sQ0FBQ0MsTUFBTSxDQUFDLFVBQVU7UUFDOUIsSUFBSSxDQUFDRCxPQUFPLENBQUNDLE1BQU0sQ0FBQyxVQUFVLENBQUMsYUFBYSxFQUFFcEIsTUFBTSxDQUFDO1FBQ3JELE9BQU8sSUFBSTtJQUNmO0FBQ0o7QUFDQUQsa0JBQWUsR0FBR00sMkJBQ2xCLHFEQUFxRCIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMvZGlzdC9janMvUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlci5qcz81ZjMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcbmNvbnN0IFBvc3RncmVzdEJ1aWxkZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEJ1aWxkZXJcIikpO1xuY2xhc3MgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlciBleHRlbmRzIFBvc3RncmVzdEJ1aWxkZXJfMS5kZWZhdWx0IHtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgU0VMRUNUIG9uIHRoZSBxdWVyeSByZXN1bHQuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBgLmluc2VydCgpYCwgYC51cGRhdGUoKWAsIGAudXBzZXJ0KClgLCBhbmQgYC5kZWxldGUoKWAgZG8gbm90XG4gICAgICogcmV0dXJuIG1vZGlmaWVkIHJvd3MuIEJ5IGNhbGxpbmcgdGhpcyBtZXRob2QsIG1vZGlmaWVkIHJvd3MgYXJlIHJldHVybmVkIGluXG4gICAgICogYGRhdGFgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbnMgLSBUaGUgY29sdW1ucyB0byByZXRyaWV2ZSwgc2VwYXJhdGVkIGJ5IGNvbW1hc1xuICAgICAqL1xuICAgIHNlbGVjdChjb2x1bW5zKSB7XG4gICAgICAgIC8vIFJlbW92ZSB3aGl0ZXNwYWNlcyBleGNlcHQgd2hlbiBxdW90ZWRcbiAgICAgICAgbGV0IHF1b3RlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjbGVhbmVkQ29sdW1ucyA9IChjb2x1bW5zICE9PSBudWxsICYmIGNvbHVtbnMgIT09IHZvaWQgMCA/IGNvbHVtbnMgOiAnKicpXG4gICAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgICAubWFwKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoL1xccy8udGVzdChjKSAmJiAhcXVvdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMgPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICBxdW90ZWQgPSAhcXVvdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgIHRoaXMudXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3NlbGVjdCcsIGNsZWFuZWRDb2x1bW5zKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzLmFwcGVuZCgnUHJlZmVyJywgJ3JldHVybj1yZXByZXNlbnRhdGlvbicpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3JkZXIgdGhlIHF1ZXJ5IHJlc3VsdCBieSBgY29sdW1uYC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gY2FsbCB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcyB0byBvcmRlciBieSBtdWx0aXBsZSBjb2x1bW5zLlxuICAgICAqXG4gICAgICogWW91IGNhbiBvcmRlciByZWZlcmVuY2VkIHRhYmxlcywgYnV0IGl0IG9ubHkgYWZmZWN0cyB0aGUgb3JkZXJpbmcgb2YgdGhlXG4gICAgICogcGFyZW50IHRhYmxlIGlmIHlvdSB1c2UgYCFpbm5lcmAgaW4gdGhlIHF1ZXJ5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbHVtbiAtIFRoZSBjb2x1bW4gdG8gb3JkZXIgYnlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hc2NlbmRpbmcgLSBJZiBgdHJ1ZWAsIHRoZSByZXN1bHQgd2lsbCBiZSBpbiBhc2NlbmRpbmcgb3JkZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5udWxsc0ZpcnN0IC0gSWYgYHRydWVgLCBgbnVsbGBzIGFwcGVhciBmaXJzdC4gSWYgYGZhbHNlYCxcbiAgICAgKiBgbnVsbGBzIGFwcGVhciBsYXN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZSAtIFNldCB0aGlzIHRvIG9yZGVyIGEgcmVmZXJlbmNlZCB0YWJsZSBieVxuICAgICAqIGl0cyBjb2x1bW5zXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcbiAgICAgKiBpbnN0ZWFkXG4gICAgICovXG4gICAgb3JkZXIoY29sdW1uLCB7IGFzY2VuZGluZyA9IHRydWUsIG51bGxzRmlyc3QsIGZvcmVpZ25UYWJsZSwgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcmVmZXJlbmNlZFRhYmxlID8gYCR7cmVmZXJlbmNlZFRhYmxlfS5vcmRlcmAgOiAnb3JkZXInO1xuICAgICAgICBjb25zdCBleGlzdGluZ09yZGVyID0gdGhpcy51cmwuc2VhcmNoUGFyYW1zLmdldChrZXkpO1xuICAgICAgICB0aGlzLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgYCR7ZXhpc3RpbmdPcmRlciA/IGAke2V4aXN0aW5nT3JkZXJ9LGAgOiAnJ30ke2NvbHVtbn0uJHthc2NlbmRpbmcgPyAnYXNjJyA6ICdkZXNjJ30ke251bGxzRmlyc3QgPT09IHVuZGVmaW5lZCA/ICcnIDogbnVsbHNGaXJzdCA/ICcubnVsbHNmaXJzdCcgOiAnLm51bGxzbGFzdCd9YCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaW1pdCB0aGUgcXVlcnkgcmVzdWx0IGJ5IGBjb3VudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY291bnQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0byByZXR1cm5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE5hbWVkIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWZlcmVuY2VkVGFibGUgLSBTZXQgdGhpcyB0byBsaW1pdCByb3dzIG9mIHJlZmVyZW5jZWRcbiAgICAgKiB0YWJsZXMgaW5zdGVhZCBvZiB0aGUgcGFyZW50IHRhYmxlXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZm9yZWlnblRhYmxlIC0gRGVwcmVjYXRlZCwgdXNlIGBvcHRpb25zLnJlZmVyZW5jZWRUYWJsZWBcbiAgICAgKiBpbnN0ZWFkXG4gICAgICovXG4gICAgbGltaXQoY291bnQsIHsgZm9yZWlnblRhYmxlLCByZWZlcmVuY2VkVGFibGUgPSBmb3JlaWduVGFibGUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBrZXkgPSB0eXBlb2YgcmVmZXJlbmNlZFRhYmxlID09PSAndW5kZWZpbmVkJyA/ICdsaW1pdCcgOiBgJHtyZWZlcmVuY2VkVGFibGV9LmxpbWl0YDtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXksIGAke2NvdW50fWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGltaXQgdGhlIHF1ZXJ5IHJlc3VsdCBieSBzdGFydGluZyBhdCBhbiBvZmZzZXQgYGZyb21gIGFuZCBlbmRpbmcgYXQgdGhlIG9mZnNldCBgdG9gLlxuICAgICAqIE9ubHkgcmVjb3JkcyB3aXRoaW4gdGhpcyByYW5nZSBhcmUgcmV0dXJuZWQuXG4gICAgICogVGhpcyByZXNwZWN0cyB0aGUgcXVlcnkgb3JkZXIgYW5kIGlmIHRoZXJlIGlzIG5vIG9yZGVyIGNsYXVzZSB0aGUgcmFuZ2UgY291bGQgYmVoYXZlIHVuZXhwZWN0ZWRseS5cbiAgICAgKiBUaGUgYGZyb21gIGFuZCBgdG9gIHZhbHVlcyBhcmUgMC1iYXNlZCBhbmQgaW5jbHVzaXZlOiBgcmFuZ2UoMSwgMylgIHdpbGwgaW5jbHVkZSB0aGUgc2Vjb25kLCB0aGlyZFxuICAgICAqIGFuZCBmb3VydGggcm93cyBvZiB0aGUgcXVlcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbSAtIFRoZSBzdGFydGluZyBpbmRleCBmcm9tIHdoaWNoIHRvIGxpbWl0IHRoZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gdG8gLSBUaGUgbGFzdCBpbmRleCB0byB3aGljaCB0byBsaW1pdCB0aGUgcmVzdWx0XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVmZXJlbmNlZFRhYmxlIC0gU2V0IHRoaXMgdG8gbGltaXQgcm93cyBvZiByZWZlcmVuY2VkXG4gICAgICogdGFibGVzIGluc3RlYWQgb2YgdGhlIHBhcmVudCB0YWJsZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZvcmVpZ25UYWJsZSAtIERlcHJlY2F0ZWQsIHVzZSBgb3B0aW9ucy5yZWZlcmVuY2VkVGFibGVgXG4gICAgICogaW5zdGVhZFxuICAgICAqL1xuICAgIHJhbmdlKGZyb20sIHRvLCB7IGZvcmVpZ25UYWJsZSwgcmVmZXJlbmNlZFRhYmxlID0gZm9yZWlnblRhYmxlLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3Qga2V5T2Zmc2V0ID0gdHlwZW9mIHJlZmVyZW5jZWRUYWJsZSA9PT0gJ3VuZGVmaW5lZCcgPyAnb2Zmc2V0JyA6IGAke3JlZmVyZW5jZWRUYWJsZX0ub2Zmc2V0YDtcbiAgICAgICAgY29uc3Qga2V5TGltaXQgPSB0eXBlb2YgcmVmZXJlbmNlZFRhYmxlID09PSAndW5kZWZpbmVkJyA/ICdsaW1pdCcgOiBgJHtyZWZlcmVuY2VkVGFibGV9LmxpbWl0YDtcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXlPZmZzZXQsIGAke2Zyb219YCk7XG4gICAgICAgIC8vIFJhbmdlIGlzIGluY2x1c2l2ZSwgc28gYWRkIDFcbiAgICAgICAgdGhpcy51cmwuc2VhcmNoUGFyYW1zLnNldChrZXlMaW1pdCwgYCR7dG8gLSBmcm9tICsgMX1gKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgQWJvcnRTaWduYWwgZm9yIHRoZSBmZXRjaCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNpZ25hbCAtIFRoZSBBYm9ydFNpZ25hbCB0byB1c2UgZm9yIHRoZSBmZXRjaCByZXF1ZXN0XG4gICAgICovXG4gICAgYWJvcnRTaWduYWwoc2lnbmFsKSB7XG4gICAgICAgIHRoaXMuc2lnbmFsID0gc2lnbmFsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGBkYXRhYCBhcyBhIHNpbmdsZSBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheSBvZiBvYmplY3RzLlxuICAgICAqXG4gICAgICogUXVlcnkgcmVzdWx0IG11c3QgYmUgb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZSB0aGlzXG4gICAgICogcmV0dXJucyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBzaW5nbGUoKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi92bmQucGdyc3Qub2JqZWN0K2pzb24nKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBgZGF0YWAgYXMgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkgb2Ygb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIFF1ZXJ5IHJlc3VsdCBtdXN0IGJlIHplcm8gb3Igb25lIHJvdyAoZS5nLiB1c2luZyBgLmxpbWl0KDEpYCksIG90aGVyd2lzZVxuICAgICAqIHRoaXMgcmV0dXJucyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBtYXliZVNpbmdsZSgpIHtcbiAgICAgICAgLy8gVGVtcG9yYXJ5IHBhcnRpYWwgZml4IGZvciBodHRwczovL2dpdGh1Yi5jb20vc3VwYWJhc2UvcG9zdGdyZXN0LWpzL2lzc3Vlcy8zNjFcbiAgICAgICAgLy8gSXNzdWUgcGVyc2lzdHMgZS5nLiBmb3IgYC5pbnNlcnQoWy4uLl0pLnNlbGVjdCgpLm1heWJlU2luZ2xlKClgXG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vdm5kLnBncnN0Lm9iamVjdCtqc29uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc01heWJlU2luZ2xlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBgZGF0YWAgYXMgYSBzdHJpbmcgaW4gQ1NWIGZvcm1hdC5cbiAgICAgKi9cbiAgICBjc3YoKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0FjY2VwdCcsICd0ZXh0L2NzdicpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGBkYXRhYCBhcyBhbiBvYmplY3QgaW4gW0dlb0pTT05dKGh0dHBzOi8vZ2VvanNvbi5vcmcpIGZvcm1hdC5cbiAgICAgKi9cbiAgICBnZW9qc29uKCkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vZ2VvK2pzb24nKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBgZGF0YWAgYXMgdGhlIEVYUExBSU4gcGxhbiBmb3IgdGhlIHF1ZXJ5LlxuICAgICAqXG4gICAgICogWW91IG5lZWQgdG8gZW5hYmxlIHRoZVxuICAgICAqIFtkYl9wbGFuX2VuYWJsZWRdKGh0dHBzOi8vc3VwYWJhc2UuY29tL2RvY3MvZ3VpZGVzL2RhdGFiYXNlL2RlYnVnZ2luZy1wZXJmb3JtYW5jZSNlbmFibGluZy1leHBsYWluKVxuICAgICAqIHNldHRpbmcgYmVmb3JlIHVzaW5nIHRoaXMgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hbmFseXplIC0gSWYgYHRydWVgLCB0aGUgcXVlcnkgd2lsbCBiZSBleGVjdXRlZCBhbmQgdGhlXG4gICAgICogYWN0dWFsIHJ1biB0aW1lIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnZlcmJvc2UgLSBJZiBgdHJ1ZWAsIHRoZSBxdWVyeSBpZGVudGlmaWVyIHdpbGwgYmUgcmV0dXJuZWRcbiAgICAgKiBhbmQgYGRhdGFgIHdpbGwgaW5jbHVkZSB0aGUgb3V0cHV0IGNvbHVtbnMgb2YgdGhlIHF1ZXJ5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zZXR0aW5ncyAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBjb25maWd1cmF0aW9uXG4gICAgICogcGFyYW1ldGVycyB0aGF0IGFmZmVjdCBxdWVyeSBwbGFubmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYnVmZmVycyAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBidWZmZXIgdXNhZ2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLndhbCAtIElmIGB0cnVlYCwgaW5jbHVkZSBpbmZvcm1hdGlvbiBvbiBXQUwgcmVjb3JkIGdlbmVyYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmZvcm1hdCAtIFRoZSBmb3JtYXQgb2YgdGhlIG91dHB1dCwgY2FuIGJlIGBcInRleHRcImAgKGRlZmF1bHQpXG4gICAgICogb3IgYFwianNvblwiYFxuICAgICAqL1xuICAgIGV4cGxhaW4oeyBhbmFseXplID0gZmFsc2UsIHZlcmJvc2UgPSBmYWxzZSwgc2V0dGluZ3MgPSBmYWxzZSwgYnVmZmVycyA9IGZhbHNlLCB3YWwgPSBmYWxzZSwgZm9ybWF0ID0gJ3RleHQnLCB9ID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gW1xuICAgICAgICAgICAgYW5hbHl6ZSA/ICdhbmFseXplJyA6IG51bGwsXG4gICAgICAgICAgICB2ZXJib3NlID8gJ3ZlcmJvc2UnIDogbnVsbCxcbiAgICAgICAgICAgIHNldHRpbmdzID8gJ3NldHRpbmdzJyA6IG51bGwsXG4gICAgICAgICAgICBidWZmZXJzID8gJ2J1ZmZlcnMnIDogbnVsbCxcbiAgICAgICAgICAgIHdhbCA/ICd3YWwnIDogbnVsbCxcbiAgICAgICAgXVxuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgICAgLmpvaW4oJ3wnKTtcbiAgICAgICAgLy8gQW4gQWNjZXB0IGhlYWRlciBjYW4gY2FycnkgbXVsdGlwbGUgbWVkaWEgdHlwZXMgYnV0IHBvc3RncmVzdC1qcyBhbHdheXMgc2VuZHMgb25lXG4gICAgICAgIGNvbnN0IGZvck1lZGlhdHlwZSA9IChfYSA9IHRoaXMuaGVhZGVycy5nZXQoJ0FjY2VwdCcpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ0FjY2VwdCcsIGBhcHBsaWNhdGlvbi92bmQucGdyc3QucGxhbiske2Zvcm1hdH07IGZvcj1cIiR7Zm9yTWVkaWF0eXBlfVwiOyBvcHRpb25zPSR7b3B0aW9uc307YCk7XG4gICAgICAgIGlmIChmb3JtYXQgPT09ICdqc29uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSb2xsYmFjayB0aGUgcXVlcnkuXG4gICAgICpcbiAgICAgKiBgZGF0YWAgd2lsbCBzdGlsbCBiZSByZXR1cm5lZCwgYnV0IHRoZSBxdWVyeSBpcyBub3QgY29tbWl0dGVkLlxuICAgICAqL1xuICAgIHJvbGxiYWNrKCkge1xuICAgICAgICB0aGlzLmhlYWRlcnMuYXBwZW5kKCdQcmVmZXInLCAndHg9cm9sbGJhY2snKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoZSB0eXBlIG9mIHRoZSByZXR1cm5lZCBgZGF0YWAuXG4gICAgICpcbiAgICAgKiBAdHlwZVBhcmFtIE5ld1Jlc3VsdCAtIFRoZSBuZXcgcmVzdWx0IHR5cGUgdG8gb3ZlcnJpZGUgd2l0aFxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBvdmVycmlkZVR5cGVzPHlvdXJUeXBlLCB7IG1lcmdlOiBmYWxzZSB9PigpIG1ldGhvZCBhdCB0aGUgZW5kIG9mIHlvdXIgY2FsbCBjaGFpbiBpbnN0ZWFkXG4gICAgICovXG4gICAgcmV0dXJucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0aGF0IGNhbiBiZSBhZmZlY3RlZCBieSB0aGUgcXVlcnkuXG4gICAgICogT25seSBhdmFpbGFibGUgaW4gUG9zdGdSRVNUIHYxMysgYW5kIG9ubHkgd29ya3Mgd2l0aCBQQVRDSCBhbmQgREVMRVRFIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygcm93cyB0aGF0IGNhbiBiZSBhZmZlY3RlZFxuICAgICAqL1xuICAgIG1heEFmZmVjdGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5hcHBlbmQoJ1ByZWZlcicsICdoYW5kbGluZz1zdHJpY3QnKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzLmFwcGVuZCgnUHJlZmVyJywgYG1heC1hZmZlY3RlZD0ke3ZhbHVlfWApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0c2xpYl8xIiwicmVxdWlyZSIsIlBvc3RncmVzdEJ1aWxkZXJfMSIsIl9faW1wb3J0RGVmYXVsdCIsIlBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIiLCJkZWZhdWx0Iiwic2VsZWN0IiwiY29sdW1ucyIsInF1b3RlZCIsImNsZWFuZWRDb2x1bW5zIiwic3BsaXQiLCJtYXAiLCJjIiwidGVzdCIsImpvaW4iLCJ1cmwiLCJzZWFyY2hQYXJhbXMiLCJzZXQiLCJoZWFkZXJzIiwiYXBwZW5kIiwib3JkZXIiLCJjb2x1bW4iLCJhc2NlbmRpbmciLCJudWxsc0ZpcnN0IiwiZm9yZWlnblRhYmxlIiwicmVmZXJlbmNlZFRhYmxlIiwia2V5IiwiZXhpc3RpbmdPcmRlciIsImdldCIsInVuZGVmaW5lZCIsImxpbWl0IiwiY291bnQiLCJyYW5nZSIsImZyb20iLCJ0byIsImtleU9mZnNldCIsImtleUxpbWl0IiwiYWJvcnRTaWduYWwiLCJzaWduYWwiLCJzaW5nbGUiLCJtYXliZVNpbmdsZSIsIm1ldGhvZCIsImlzTWF5YmVTaW5nbGUiLCJjc3YiLCJnZW9qc29uIiwiZXhwbGFpbiIsImFuYWx5emUiLCJ2ZXJib3NlIiwic2V0dGluZ3MiLCJidWZmZXJzIiwid2FsIiwiZm9ybWF0IiwiX2EiLCJvcHRpb25zIiwiZmlsdGVyIiwiQm9vbGVhbiIsImZvck1lZGlhdHlwZSIsInJvbGxiYWNrIiwicmV0dXJucyIsIm1heEFmZmVjdGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/cjs/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.PostgrestError = exports.PostgrestBuilder = exports.PostgrestTransformBuilder = exports.PostgrestFilterBuilder = exports.PostgrestQueryBuilder = exports.PostgrestClient = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n// Always update wrapper.mjs when updating this file.\nconst PostgrestClient_1 = tslib_1.__importDefault(__webpack_require__(/*! ./PostgrestClient */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestClient.js\"));\nexports.PostgrestClient = PostgrestClient_1.default;\nconst PostgrestQueryBuilder_1 = tslib_1.__importDefault(__webpack_require__(/*! ./PostgrestQueryBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestQueryBuilder.js\"));\nexports.PostgrestQueryBuilder = PostgrestQueryBuilder_1.default;\nconst PostgrestFilterBuilder_1 = tslib_1.__importDefault(__webpack_require__(/*! ./PostgrestFilterBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestFilterBuilder.js\"));\nexports.PostgrestFilterBuilder = PostgrestFilterBuilder_1.default;\nconst PostgrestTransformBuilder_1 = tslib_1.__importDefault(__webpack_require__(/*! ./PostgrestTransformBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestTransformBuilder.js\"));\nexports.PostgrestTransformBuilder = PostgrestTransformBuilder_1.default;\nconst PostgrestBuilder_1 = tslib_1.__importDefault(__webpack_require__(/*! ./PostgrestBuilder */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestBuilder.js\"));\nexports.PostgrestBuilder = PostgrestBuilder_1.default;\nconst PostgrestError_1 = tslib_1.__importDefault(__webpack_require__(/*! ./PostgrestError */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/PostgrestError.js\"));\nexports.PostgrestError = PostgrestError_1.default;\nexports[\"default\"] = {\n    PostgrestClient: PostgrestClient_1.default,\n    PostgrestQueryBuilder: PostgrestQueryBuilder_1.default,\n    PostgrestFilterBuilder: PostgrestFilterBuilder_1.default,\n    PostgrestTransformBuilder: PostgrestTransformBuilder_1.default,\n    PostgrestBuilder: PostgrestBuilder_1.default,\n    PostgrestError: PostgrestError_1.default\n}; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2Nqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsc0JBQXNCLEdBQUdBLHdCQUF3QixHQUFHQSxpQ0FBaUMsR0FBR0EsOEJBQThCLEdBQUdBLDZCQUE2QixHQUFHQSx1QkFBdUIsR0FBRyxLQUFLO0FBQ3hMLE1BQU1RLFVBQVVDLG1CQUFPQSxDQUFDLHVEQUFPO0FBQy9CLHFEQUFxRDtBQUNyRCxNQUFNQyxvQkFBb0JGLFFBQVFHLGVBQWUsQ0FBQ0YsbUJBQU9BLENBQUMsa0dBQW1CO0FBQzdFVCx1QkFBdUIsR0FBR1Usa0JBQWtCRSxPQUFPO0FBQ25ELE1BQU1DLDBCQUEwQkwsUUFBUUcsZUFBZSxDQUFDRixtQkFBT0EsQ0FBQyw4R0FBeUI7QUFDekZULDZCQUE2QixHQUFHYSx3QkFBd0JELE9BQU87QUFDL0QsTUFBTUUsMkJBQTJCTixRQUFRRyxlQUFlLENBQUNGLG1CQUFPQSxDQUFDLGdIQUEwQjtBQUMzRlQsOEJBQThCLEdBQUdjLHlCQUF5QkYsT0FBTztBQUNqRSxNQUFNRyw4QkFBOEJQLFFBQVFHLGVBQWUsQ0FBQ0YsbUJBQU9BLENBQUMsc0hBQTZCO0FBQ2pHVCxpQ0FBaUMsR0FBR2UsNEJBQTRCSCxPQUFPO0FBQ3ZFLE1BQU1JLHFCQUFxQlIsUUFBUUcsZUFBZSxDQUFDRixtQkFBT0EsQ0FBQyxvR0FBb0I7QUFDL0VULHdCQUF3QixHQUFHZ0IsbUJBQW1CSixPQUFPO0FBQ3JELE1BQU1LLG1CQUFtQlQsUUFBUUcsZUFBZSxDQUFDRixtQkFBT0EsQ0FBQyxnR0FBa0I7QUFDM0VULHNCQUFzQixHQUFHaUIsaUJBQWlCTCxPQUFPO0FBQ2pEWixrQkFBZSxHQUFHO0lBQ2RPLGlCQUFpQkcsa0JBQWtCRSxPQUFPO0lBQzFDTix1QkFBdUJPLHdCQUF3QkQsT0FBTztJQUN0RFAsd0JBQXdCUyx5QkFBeUJGLE9BQU87SUFDeERSLDJCQUEyQlcsNEJBQTRCSCxPQUFPO0lBQzlEVCxrQkFBa0JhLG1CQUFtQkosT0FBTztJQUM1Q1YsZ0JBQWdCZSxpQkFBaUJMLE9BQU87QUFDNUMsR0FDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvY2pzL2luZGV4LmpzP2QzMTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvc3RncmVzdEVycm9yID0gZXhwb3J0cy5Qb3N0Z3Jlc3RCdWlsZGVyID0gZXhwb3J0cy5Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyID0gZXhwb3J0cy5Qb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyID0gZXhwb3J0cy5Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgPSBleHBvcnRzLlBvc3RncmVzdENsaWVudCA9IHZvaWQgMDtcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XG4vLyBBbHdheXMgdXBkYXRlIHdyYXBwZXIubWpzIHdoZW4gdXBkYXRpbmcgdGhpcyBmaWxlLlxuY29uc3QgUG9zdGdyZXN0Q2xpZW50XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RDbGllbnRcIikpO1xuZXhwb3J0cy5Qb3N0Z3Jlc3RDbGllbnQgPSBQb3N0Z3Jlc3RDbGllbnRfMS5kZWZhdWx0O1xuY29uc3QgUG9zdGdyZXN0UXVlcnlCdWlsZGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXJcIikpO1xuZXhwb3J0cy5Qb3N0Z3Jlc3RRdWVyeUJ1aWxkZXIgPSBQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXJfMS5kZWZhdWx0O1xuY29uc3QgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUG9zdGdyZXN0RmlsdGVyQnVpbGRlclwiKSk7XG5leHBvcnRzLlBvc3RncmVzdEZpbHRlckJ1aWxkZXIgPSBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdDtcbmNvbnN0IFBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJcIikpO1xuZXhwb3J0cy5Qb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyID0gUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcl8xLmRlZmF1bHQ7XG5jb25zdCBQb3N0Z3Jlc3RCdWlsZGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Qb3N0Z3Jlc3RCdWlsZGVyXCIpKTtcbmV4cG9ydHMuUG9zdGdyZXN0QnVpbGRlciA9IFBvc3RncmVzdEJ1aWxkZXJfMS5kZWZhdWx0O1xuY29uc3QgUG9zdGdyZXN0RXJyb3JfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1Bvc3RncmVzdEVycm9yXCIpKTtcbmV4cG9ydHMuUG9zdGdyZXN0RXJyb3IgPSBQb3N0Z3Jlc3RFcnJvcl8xLmRlZmF1bHQ7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgUG9zdGdyZXN0Q2xpZW50OiBQb3N0Z3Jlc3RDbGllbnRfMS5kZWZhdWx0LFxuICAgIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcjogUG9zdGdyZXN0UXVlcnlCdWlsZGVyXzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyOiBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyXzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyOiBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyXzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RCdWlsZGVyOiBQb3N0Z3Jlc3RCdWlsZGVyXzEuZGVmYXVsdCxcbiAgICBQb3N0Z3Jlc3RFcnJvcjogUG9zdGdyZXN0RXJyb3JfMS5kZWZhdWx0LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlBvc3RncmVzdEVycm9yIiwiUG9zdGdyZXN0QnVpbGRlciIsIlBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXIiLCJQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyIiwiUG9zdGdyZXN0UXVlcnlCdWlsZGVyIiwiUG9zdGdyZXN0Q2xpZW50IiwidHNsaWJfMSIsInJlcXVpcmUiLCJQb3N0Z3Jlc3RDbGllbnRfMSIsIl9faW1wb3J0RGVmYXVsdCIsImRlZmF1bHQiLCJQb3N0Z3Jlc3RRdWVyeUJ1aWxkZXJfMSIsIlBvc3RncmVzdEZpbHRlckJ1aWxkZXJfMSIsIlBvc3RncmVzdFRyYW5zZm9ybUJ1aWxkZXJfMSIsIlBvc3RncmVzdEJ1aWxkZXJfMSIsIlBvc3RncmVzdEVycm9yXzEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* binding */ REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* binding */ REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* binding */ REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* binding */ REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   \"default\": () => (/* binding */ RealtimeChannel)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_push__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/push */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js\");\n/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/timer */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\");\n/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RealtimePresence */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\");\n/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/transformers */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\");\n\n\n\n\n\n\nvar REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;\n(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT) {\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"] = \"*\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"] = \"INSERT\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"] = \"UPDATE\";\n    REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"] = \"DELETE\";\n})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT || (REALTIME_POSTGRES_CHANGES_LISTEN_EVENT = {}));\nvar REALTIME_LISTEN_TYPES;\n(function(REALTIME_LISTEN_TYPES) {\n    REALTIME_LISTEN_TYPES[\"BROADCAST\"] = \"broadcast\";\n    REALTIME_LISTEN_TYPES[\"PRESENCE\"] = \"presence\";\n    REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"] = \"postgres_changes\";\n    REALTIME_LISTEN_TYPES[\"SYSTEM\"] = \"system\";\n})(REALTIME_LISTEN_TYPES || (REALTIME_LISTEN_TYPES = {}));\nvar REALTIME_SUBSCRIBE_STATES;\n(function(REALTIME_SUBSCRIBE_STATES) {\n    REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"] = \"SUBSCRIBED\";\n    REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"] = \"TIMED_OUT\";\n    REALTIME_SUBSCRIBE_STATES[\"CLOSED\"] = \"CLOSED\";\n    REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"] = \"CHANNEL_ERROR\";\n})(REALTIME_SUBSCRIBE_STATES || (REALTIME_SUBSCRIBE_STATES = {}));\nconst REALTIME_CHANNEL_STATES = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES;\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */ class RealtimeChannel {\n    constructor(/** Topic name can be any string. */ topic, params = {\n        config: {}\n    }, socket){\n        var _a, _b;\n        this.topic = topic;\n        this.params = params;\n        this.socket = socket;\n        this.bindings = {};\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n        this.joinedOnce = false;\n        this.pushBuffer = [];\n        this.subTopic = topic.replace(/^realtime:/i, \"\");\n        this.params.config = Object.assign({\n            broadcast: {\n                ack: false,\n                self: false\n            },\n            presence: {\n                key: \"\",\n                enabled: false\n            },\n            private: false\n        }, params.config);\n        this.timeout = this.socket.timeout;\n        this.joinPush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.join, this.params, this.timeout);\n        this.rejoinTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_2__[\"default\"](()=>this._rejoinUntilConnected(), this.socket.reconnectAfterMs);\n        this.joinPush.receive(\"ok\", ()=>{\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;\n            this.rejoinTimer.reset();\n            this.pushBuffer.forEach((pushEvent)=>pushEvent.send());\n            this.pushBuffer = [];\n        });\n        this._onClose(()=>{\n            this.rejoinTimer.reset();\n            this.socket.log(\"channel\", `close ${this.topic} ${this._joinRef()}`);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n            this.socket._remove(this);\n        });\n        this._onError((reason)=>{\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log(\"channel\", `error ${this.topic}`, reason);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive(\"timeout\", ()=>{\n            if (!this._isJoining()) {\n                return;\n            }\n            this.socket.log(\"channel\", `timeout ${this.topic}`, this.joinPush.timeout);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this.joinPush.receive(\"error\", (reason)=>{\n            if (this._isLeaving() || this._isClosed()) {\n                return;\n            }\n            this.socket.log(\"channel\", `error ${this.topic}`, reason);\n            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n            this.rejoinTimer.scheduleTimeout();\n        });\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.reply, {}, (payload, ref)=>{\n            this._trigger(this._replyEventName(ref), payload);\n        });\n        this.presence = new _RealtimePresence__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this);\n        this.broadcastEndpointURL = (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_4__.httpEndpointURL)(this.socket.endPoint);\n        this.private = this.params.config.private || false;\n        if (!this.private && ((_b = (_a = this.params.config) === null || _a === void 0 ? void 0 : _a.broadcast) === null || _b === void 0 ? void 0 : _b.replay)) {\n            throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`;\n        }\n    }\n    /** Subscribe registers your client with the server */ subscribe(callback, timeout = this.timeout) {\n        var _a, _b, _c;\n        if (!this.socket.isConnected()) {\n            this.socket.connect();\n        }\n        if (this.state == _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed) {\n            const { config: { broadcast, presence, private: isPrivate } } = this.params;\n            const postgres_changes = (_b = (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.map((r)=>r.filter)) !== null && _b !== void 0 ? _b : [];\n            const presence_enabled = !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] && this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0 || ((_c = this.params.config.presence) === null || _c === void 0 ? void 0 : _c.enabled) === true;\n            const accessTokenPayload = {};\n            const config = {\n                broadcast,\n                presence: Object.assign(Object.assign({}, presence), {\n                    enabled: presence_enabled\n                }),\n                postgres_changes,\n                private: isPrivate\n            };\n            if (this.socket.accessTokenValue) {\n                accessTokenPayload.access_token = this.socket.accessTokenValue;\n            }\n            this._onError((e)=>callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e));\n            this._onClose(()=>callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CLOSED));\n            this.updateJoinPayload(Object.assign({\n                config\n            }, accessTokenPayload));\n            this.joinedOnce = true;\n            this._rejoin(timeout);\n            this.joinPush.receive(\"ok\", async ({ postgres_changes })=>{\n                var _a;\n                this.socket.setAuth();\n                if (postgres_changes === undefined) {\n                    callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                } else {\n                    const clientPostgresBindings = this.bindings.postgres_changes;\n                    const bindingsLen = (_a = clientPostgresBindings === null || clientPostgresBindings === void 0 ? void 0 : clientPostgresBindings.length) !== null && _a !== void 0 ? _a : 0;\n                    const newPostgresBindings = [];\n                    for(let i = 0; i < bindingsLen; i++){\n                        const clientPostgresBinding = clientPostgresBindings[i];\n                        const { filter: { event, schema, table, filter } } = clientPostgresBinding;\n                        const serverPostgresFilter = postgres_changes && postgres_changes[i];\n                        if (serverPostgresFilter && serverPostgresFilter.event === event && serverPostgresFilter.schema === schema && serverPostgresFilter.table === table && serverPostgresFilter.filter === filter) {\n                            newPostgresBindings.push(Object.assign(Object.assign({}, clientPostgresBinding), {\n                                id: serverPostgresFilter.id\n                            }));\n                        } else {\n                            this.unsubscribe();\n                            this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n                            callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(\"mismatch between server and client bindings for postgres changes\"));\n                            return;\n                        }\n                    }\n                    this.bindings.postgres_changes = newPostgresBindings;\n                    callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);\n                    return;\n                }\n            }).receive(\"error\", (error)=>{\n                this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.errored;\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(error).join(\", \") || \"error\")));\n                return;\n            }).receive(\"timeout\", ()=>{\n                callback === null || callback === void 0 ? void 0 : callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);\n                return;\n            });\n        }\n        return this;\n    }\n    presenceState() {\n        return this.presence.state;\n    }\n    async track(payload, opts = {}) {\n        return await this.send({\n            type: \"presence\",\n            event: \"track\",\n            payload\n        }, opts.timeout || this.timeout);\n    }\n    async untrack(opts = {}) {\n        return await this.send({\n            type: \"presence\",\n            event: \"untrack\"\n        }, opts);\n    }\n    on(type, filter, callback) {\n        if (this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined && type === REALTIME_LISTEN_TYPES.PRESENCE) {\n            this.socket.log(\"channel\", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);\n            this.unsubscribe().then(()=>this.subscribe());\n        }\n        return this._on(type, filter, callback);\n    }\n    /**\n     * Sends a broadcast message explicitly via REST API.\n     *\n     * This method always uses the REST API endpoint regardless of WebSocket connection state.\n     * Useful when you want to guarantee REST delivery or when gradually migrating from implicit REST fallback.\n     *\n     * @param event The name of the broadcast event\n     * @param payload Payload to be sent (required)\n     * @param opts Options including timeout\n     * @returns Promise resolving to object with success status, and error details if failed\n     */ async httpSend(event, payload, opts = {}) {\n        var _a;\n        const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : \"\";\n        if (payload === undefined || payload === null) {\n            return Promise.reject(\"Payload is required for httpSend()\");\n        }\n        const options = {\n            method: \"POST\",\n            headers: {\n                Authorization: authorization,\n                apikey: this.socket.apiKey ? this.socket.apiKey : \"\",\n                \"Content-Type\": \"application/json\"\n            },\n            body: JSON.stringify({\n                messages: [\n                    {\n                        topic: this.subTopic,\n                        event,\n                        payload: payload,\n                        private: this.private\n                    }\n                ]\n            })\n        };\n        const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n        if (response.status === 202) {\n            return {\n                success: true\n            };\n        }\n        let errorMessage = response.statusText;\n        try {\n            const errorBody = await response.json();\n            errorMessage = errorBody.error || errorBody.message || errorMessage;\n        } catch (_b) {}\n        return Promise.reject(new Error(errorMessage));\n    }\n    /**\n     * Sends a message into the channel.\n     *\n     * @param args Arguments to send to channel\n     * @param args.type The type of event to send\n     * @param args.event The name of the event being sent\n     * @param args.payload Payload to be sent\n     * @param opts Options to be used during the send process\n     */ async send(args, opts = {}) {\n        var _a, _b;\n        if (!this._canPush() && args.type === \"broadcast\") {\n            console.warn(\"Realtime send() is automatically falling back to REST API. \" + \"This behavior will be deprecated in the future. \" + \"Please use httpSend() explicitly for REST delivery.\");\n            const { event, payload: endpoint_payload } = args;\n            const authorization = this.socket.accessTokenValue ? `Bearer ${this.socket.accessTokenValue}` : \"\";\n            const options = {\n                method: \"POST\",\n                headers: {\n                    Authorization: authorization,\n                    apikey: this.socket.apiKey ? this.socket.apiKey : \"\",\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    messages: [\n                        {\n                            topic: this.subTopic,\n                            event,\n                            payload: endpoint_payload,\n                            private: this.private\n                        }\n                    ]\n                })\n            };\n            try {\n                const response = await this._fetchWithTimeout(this.broadcastEndpointURL, options, (_a = opts.timeout) !== null && _a !== void 0 ? _a : this.timeout);\n                await ((_b = response.body) === null || _b === void 0 ? void 0 : _b.cancel());\n                return response.ok ? \"ok\" : \"error\";\n            } catch (error) {\n                if (error.name === \"AbortError\") {\n                    return \"timed out\";\n                } else {\n                    return \"error\";\n                }\n            }\n        } else {\n            return new Promise((resolve)=>{\n                var _a, _b, _c;\n                const push = this._push(args.type, args, opts.timeout || this.timeout);\n                if (args.type === \"broadcast\" && !((_c = (_b = (_a = this.params) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.broadcast) === null || _c === void 0 ? void 0 : _c.ack)) {\n                    resolve(\"ok\");\n                }\n                push.receive(\"ok\", ()=>resolve(\"ok\"));\n                push.receive(\"error\", ()=>resolve(\"error\"));\n                push.receive(\"timeout\", ()=>resolve(\"timed out\"));\n            });\n        }\n    }\n    updateJoinPayload(payload) {\n        this.joinPush.updatePayload(payload);\n    }\n    /**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */ unsubscribe(timeout = this.timeout) {\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;\n        const onClose = ()=>{\n            this.socket.log(\"channel\", `leave ${this.topic}`);\n            this._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, \"leave\", this._joinRef());\n        };\n        this.joinPush.destroy();\n        let leavePush = null;\n        return new Promise((resolve)=>{\n            leavePush = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.leave, {}, timeout);\n            leavePush.receive(\"ok\", ()=>{\n                onClose();\n                resolve(\"ok\");\n            }).receive(\"timeout\", ()=>{\n                onClose();\n                resolve(\"timed out\");\n            }).receive(\"error\", ()=>{\n                resolve(\"error\");\n            });\n            leavePush.send();\n            if (!this._canPush()) {\n                leavePush.trigger(\"ok\", {});\n            }\n        }).finally(()=>{\n            leavePush === null || leavePush === void 0 ? void 0 : leavePush.destroy();\n        });\n    }\n    /**\n     * Teardown the channel.\n     *\n     * Destroys and stops related timers.\n     */ teardown() {\n        this.pushBuffer.forEach((push)=>push.destroy());\n        this.pushBuffer = [];\n        this.rejoinTimer.reset();\n        this.joinPush.destroy();\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n        this.bindings = {};\n    }\n    /** @internal */ async _fetchWithTimeout(url, options, timeout) {\n        const controller = new AbortController();\n        const id = setTimeout(()=>controller.abort(), timeout);\n        const response = await this.socket.fetch(url, Object.assign(Object.assign({}, options), {\n            signal: controller.signal\n        }));\n        clearTimeout(id);\n        return response;\n    }\n    /** @internal */ _push(event, payload, timeout = this.timeout) {\n        if (!this.joinedOnce) {\n            throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;\n        }\n        let pushEvent = new _lib_push__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, event, payload, timeout);\n        if (this._canPush()) {\n            pushEvent.send();\n        } else {\n            this._addToPushBuffer(pushEvent);\n        }\n        return pushEvent;\n    }\n    /** @internal */ _addToPushBuffer(pushEvent) {\n        pushEvent.startTimeout();\n        this.pushBuffer.push(pushEvent);\n        // Enforce buffer size limit\n        if (this.pushBuffer.length > _lib_constants__WEBPACK_IMPORTED_MODULE_0__.MAX_PUSH_BUFFER_SIZE) {\n            const removedPush = this.pushBuffer.shift();\n            if (removedPush) {\n                removedPush.destroy();\n                this.socket.log(\"channel\", `discarded push due to buffer overflow: ${removedPush.event}`, removedPush.payload);\n            }\n        }\n    }\n    /**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */ _onMessage(_event, payload, _ref) {\n        return payload;\n    }\n    /** @internal */ _isMember(topic) {\n        return this.topic === topic;\n    }\n    /** @internal */ _joinRef() {\n        return this.joinPush.ref;\n    }\n    /** @internal */ _trigger(type, payload, ref) {\n        var _a, _b;\n        const typeLower = type.toLocaleLowerCase();\n        const { close, error, leave, join } = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS;\n        const events = [\n            close,\n            error,\n            leave,\n            join\n        ];\n        if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n            return;\n        }\n        let handledPayload = this._onMessage(typeLower, payload, ref);\n        if (payload && !handledPayload) {\n            throw \"channel onMessage callbacks must return the payload, modified or unmodified\";\n        }\n        if ([\n            \"insert\",\n            \"update\",\n            \"delete\"\n        ].includes(typeLower)) {\n            (_a = this.bindings.postgres_changes) === null || _a === void 0 ? void 0 : _a.filter((bind)=>{\n                var _a, _b, _c;\n                return ((_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event) === \"*\" || ((_c = (_b = bind.filter) === null || _b === void 0 ? void 0 : _b.event) === null || _c === void 0 ? void 0 : _c.toLocaleLowerCase()) === typeLower;\n            }).map((bind)=>bind.callback(handledPayload, ref));\n        } else {\n            (_b = this.bindings[typeLower]) === null || _b === void 0 ? void 0 : _b.filter((bind)=>{\n                var _a, _b, _c, _d, _e, _f;\n                if ([\n                    \"broadcast\",\n                    \"presence\",\n                    \"postgres_changes\"\n                ].includes(typeLower)) {\n                    if (\"id\" in bind) {\n                        const bindId = bind.id;\n                        const bindEvent = (_a = bind.filter) === null || _a === void 0 ? void 0 : _a.event;\n                        return bindId && ((_b = payload.ids) === null || _b === void 0 ? void 0 : _b.includes(bindId)) && (bindEvent === \"*\" || (bindEvent === null || bindEvent === void 0 ? void 0 : bindEvent.toLocaleLowerCase()) === ((_c = payload.data) === null || _c === void 0 ? void 0 : _c.type.toLocaleLowerCase()));\n                    } else {\n                        const bindEvent = (_e = (_d = bind === null || bind === void 0 ? void 0 : bind.filter) === null || _d === void 0 ? void 0 : _d.event) === null || _e === void 0 ? void 0 : _e.toLocaleLowerCase();\n                        return bindEvent === \"*\" || bindEvent === ((_f = payload === null || payload === void 0 ? void 0 : payload.event) === null || _f === void 0 ? void 0 : _f.toLocaleLowerCase());\n                    }\n                } else {\n                    return bind.type.toLocaleLowerCase() === typeLower;\n                }\n            }).map((bind)=>{\n                if (typeof handledPayload === \"object\" && \"ids\" in handledPayload) {\n                    const postgresChanges = handledPayload.data;\n                    const { schema, table, commit_timestamp, type, errors } = postgresChanges;\n                    const enrichedPayload = {\n                        schema: schema,\n                        table: table,\n                        commit_timestamp: commit_timestamp,\n                        eventType: type,\n                        new: {},\n                        old: {},\n                        errors: errors\n                    };\n                    handledPayload = Object.assign(Object.assign({}, enrichedPayload), this._getPayloadRecords(postgresChanges));\n                }\n                bind.callback(handledPayload, ref);\n            });\n        }\n    }\n    /** @internal */ _isClosed() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.closed;\n    }\n    /** @internal */ _isJoined() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joined;\n    }\n    /** @internal */ _isJoining() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;\n    }\n    /** @internal */ _isLeaving() {\n        return this.state === _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.leaving;\n    }\n    /** @internal */ _replyEventName(ref) {\n        return `chan_reply_${ref}`;\n    }\n    /** @internal */ _on(type, filter, callback) {\n        const typeLower = type.toLocaleLowerCase();\n        const binding = {\n            type: typeLower,\n            filter: filter,\n            callback: callback\n        };\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower].push(binding);\n        } else {\n            this.bindings[typeLower] = [\n                binding\n            ];\n        }\n        return this;\n    }\n    /** @internal */ _off(type, filter) {\n        const typeLower = type.toLocaleLowerCase();\n        if (this.bindings[typeLower]) {\n            this.bindings[typeLower] = this.bindings[typeLower].filter((bind)=>{\n                var _a;\n                return !(((_a = bind.type) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) === typeLower && RealtimeChannel.isEqual(bind.filter, filter));\n            });\n        }\n        return this;\n    }\n    /** @internal */ static isEqual(obj1, obj2) {\n        if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n            return false;\n        }\n        for(const k in obj1){\n            if (obj1[k] !== obj2[k]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /** @internal */ _rejoinUntilConnected() {\n        this.rejoinTimer.scheduleTimeout();\n        if (this.socket.isConnected()) {\n            this._rejoin();\n        }\n    }\n    /**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */ _onClose(callback) {\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.close, {}, callback);\n    }\n    /**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */ _onError(callback) {\n        this._on(_lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_EVENTS.error, {}, (reason)=>callback(reason));\n    }\n    /**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */ _canPush() {\n        return this.socket.isConnected() && this._isJoined();\n    }\n    /** @internal */ _rejoin(timeout = this.timeout) {\n        if (this._isLeaving()) {\n            return;\n        }\n        this.socket._leaveOpenTopic(this.topic);\n        this.state = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.CHANNEL_STATES.joining;\n        this.joinPush.resend(timeout);\n    }\n    /** @internal */ _getPayloadRecords(payload) {\n        const records = {\n            new: {},\n            old: {}\n        };\n        if (payload.type === \"INSERT\" || payload.type === \"UPDATE\") {\n            records.new = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.record);\n        }\n        if (payload.type === \"UPDATE\" || payload.type === \"DELETE\") {\n            records.old = _lib_transformers__WEBPACK_IMPORTED_MODULE_4__.convertChangeData(payload.columns, payload.old_record);\n        }\n        return records;\n    }\n} //# sourceMappingURL=RealtimeChannel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lQ2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXVGO0FBQ3pEO0FBQ0U7QUFDa0I7QUFDQztBQUNFO0FBQzlDLElBQUlRLHVDQUF1QztBQUNqRCxVQUFVQSxzQ0FBc0M7SUFDN0NBLHNDQUFzQyxDQUFDLE1BQU0sR0FBRztJQUNoREEsc0NBQXNDLENBQUMsU0FBUyxHQUFHO0lBQ25EQSxzQ0FBc0MsQ0FBQyxTQUFTLEdBQUc7SUFDbkRBLHNDQUFzQyxDQUFDLFNBQVMsR0FBRztBQUN2RCxHQUFHQSwwQ0FBMkNBLENBQUFBLHlDQUF5QyxDQUFDO0FBQ2pGLElBQUlDLHNCQUFzQjtBQUNoQyxVQUFVQSxxQkFBcUI7SUFDNUJBLHFCQUFxQixDQUFDLFlBQVksR0FBRztJQUNyQ0EscUJBQXFCLENBQUMsV0FBVyxHQUFHO0lBQ3BDQSxxQkFBcUIsQ0FBQyxtQkFBbUIsR0FBRztJQUM1Q0EscUJBQXFCLENBQUMsU0FBUyxHQUFHO0FBQ3RDLEdBQUdBLHlCQUEwQkEsQ0FBQUEsd0JBQXdCLENBQUM7QUFDL0MsSUFBSUMsMEJBQTBCO0FBQ3BDLFVBQVVBLHlCQUF5QjtJQUNoQ0EseUJBQXlCLENBQUMsYUFBYSxHQUFHO0lBQzFDQSx5QkFBeUIsQ0FBQyxZQUFZLEdBQUc7SUFDekNBLHlCQUF5QixDQUFDLFNBQVMsR0FBRztJQUN0Q0EseUJBQXlCLENBQUMsZ0JBQWdCLEdBQUc7QUFDakQsR0FBR0EsNkJBQThCQSxDQUFBQSw0QkFBNEIsQ0FBQztBQUN2RCxNQUFNQywwQkFBMEJWLDBEQUFjQSxDQUFDO0FBQ3REOzs7O0NBSUMsR0FDYyxNQUFNVztJQUNqQkMsWUFDQSxrQ0FBa0MsR0FDbENDLEtBQUssRUFBRUMsU0FBUztRQUFFQyxRQUFRLENBQUM7SUFBRSxDQUFDLEVBQUVDLE1BQU0sQ0FBRTtRQUNwQyxJQUFJQyxJQUFJQztRQUNSLElB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b0QsSUFBSSxLQUFLLFVBQVU7WUFDeEQ4RixRQUFRYixHQUFHLEdBQUc1TCxnRUFBOEIsQ0FBQ3VELFFBQVFvSixPQUFPLEVBQUVwSixRQUFRc0osVUFBVTtRQUNwRjtRQUNBLE9BQU9KO0lBQ1g7QUFDSixFQUNBLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9SZWFsdGltZUNoYW5uZWwuanM/ZWM0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDSEFOTkVMX0VWRU5UUywgQ0hBTk5FTF9TVEFURVMsIE1BWF9QVVNIX0JVRkZFUl9TSVpFIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCBQdXNoIGZyb20gJy4vbGliL3B1c2gnO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vbGliL3RpbWVyJztcbmltcG9ydCBSZWFsdGltZVByZXNlbmNlIGZyb20gJy4vUmVhbHRpbWVQcmVzZW5jZSc7XG5pbXBvcnQgKiBhcyBUcmFuc2Zvcm1lcnMgZnJvbSAnLi9saWIvdHJhbnNmb3JtZXJzJztcbmltcG9ydCB7IGh0dHBFbmRwb2ludFVSTCB9IGZyb20gJy4vbGliL3RyYW5zZm9ybWVycyc7XG5leHBvcnQgdmFyIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UO1xuKGZ1bmN0aW9uIChSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCkge1xuICAgIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiQUxMXCJdID0gXCIqXCI7XG4gICAgUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlRbXCJJTlNFUlRcIl0gPSBcIklOU0VSVFwiO1xuICAgIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UW1wiVVBEQVRFXCJdID0gXCJVUERBVEVcIjtcbiAgICBSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVFtcIkRFTEVURVwiXSA9IFwiREVMRVRFXCI7XG59KShSRUFMVElNRV9QT1NUR1JFU19DSEFOR0VTX0xJU1RFTl9FVkVOVCB8fCAoUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQgPSB7fSkpO1xuZXhwb3J0IHZhciBSRUFMVElNRV9MSVNURU5fVFlQRVM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX0xJU1RFTl9UWVBFUykge1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIkJST0FEQ0FTVFwiXSA9IFwiYnJvYWRjYXN0XCI7XG4gICAgUkVBTFRJTUVfTElTVEVOX1RZUEVTW1wiUFJFU0VOQ0VcIl0gPSBcInByZXNlbmNlXCI7XG4gICAgUkVBTFRJTUVfTElTVEVOX1RZUEVTW1wiUE9TVEdSRVNfQ0hBTkdFU1wiXSA9IFwicG9zdGdyZXNfY2hhbmdlc1wiO1xuICAgIFJFQUxUSU1FX0xJU1RFTl9UWVBFU1tcIlNZU1RFTVwiXSA9IFwic3lzdGVtXCI7XG59KShSRUFMVElNRV9MSVNURU5fVFlQRVMgfHwgKFJFQUxUSU1FX0xJU1RFTl9UWVBFUyA9IHt9KSk7XG5leHBvcnQgdmFyIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMpIHtcbiAgICBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTW1wiU1VCU0NSSUJFRFwiXSA9IFwiU1VCU0NSSUJFRFwiO1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJUSU1FRF9PVVRcIl0gPSBcIlRJTUVEX09VVFwiO1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJDTE9TRURcIl0gPSBcIkNMT1NFRFwiO1xuICAgIFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVNbXCJDSEFOTkVMX0VSUk9SXCJdID0gXCJDSEFOTkVMX0VSUk9SXCI7XG59KShSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTIHx8IChSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTID0ge30pKTtcbmV4cG9ydCBjb25zdCBSRUFMVElNRV9DSEFOTkVMX1NUQVRFUyA9IENIQU5ORUxfU1RBVEVTO1xuLyoqIEEgY2hhbm5lbCBpcyB0aGUgYmFzaWMgYnVpbGRpbmcgYmxvY2sgb2YgUmVhbHRpbWVcbiAqIGFuZCBuYXJyb3dzIHRoZSBzY29wZSBvZiBkYXRhIGZsb3cgdG8gc3Vic2NyaWJlZCBjbGllbnRzLlxuICogWW91IGNhbiB0aGluayBvZiBhIGNoYW5uZWwgYXMgYSBjaGF0cm9vbSB3aGVyZSBwYXJ0aWNpcGFudHMgYXJlIGFibGUgdG8gc2VlIHdobydzIG9ubGluZVxuICogYW5kIHNlbmQgYW5kIHJlY2VpdmUgbWVzc2FnZXMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWx0aW1lQ2hhbm5lbCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqIFRvcGljIG5hbWUgY2FuIGJlIGFueSBzdHJpbmcuICovXG4gICAgdG9waWMsIHBhcmFtcyA9IHsgY29uZmlnOiB7fSB9LCBzb2NrZXQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy50b3BpYyA9IHRvcGljO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICAgICAgdGhpcy5qb2luZWRPbmNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHVzaEJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnN1YlRvcGljID0gdG9waWMucmVwbGFjZSgvXnJlYWx0aW1lOi9pLCAnJyk7XG4gICAgICAgIHRoaXMucGFyYW1zLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgYnJvYWRjYXN0OiB7IGFjazogZmFsc2UsIHNlbGY6IGZhbHNlIH0sXG4gICAgICAgICAgICBwcmVzZW5jZTogeyBrZXk6ICcnLCBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgICAgICAgcHJpdmF0ZTogZmFsc2UsXG4gICAgICAgIH0sIHBhcmFtcy5jb25maWcpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aGlzLnNvY2tldC50aW1lb3V0O1xuICAgICAgICB0aGlzLmpvaW5QdXNoID0gbmV3IFB1c2godGhpcywgQ0hBTk5FTF9FVkVOVFMuam9pbiwgdGhpcy5wYXJhbXMsIHRoaXMudGltZW91dCk7XG4gICAgICAgIHRoaXMucmVqb2luVGltZXIgPSBuZXcgVGltZXIoKCkgPT4gdGhpcy5fcmVqb2luVW50aWxDb25uZWN0ZWQoKSwgdGhpcy5zb2NrZXQucmVjb25uZWN0QWZ0ZXJNcyk7XG4gICAgICAgIHRoaXMuam9pblB1c2gucmVjZWl2ZSgnb2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuam9pbmVkO1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5wdXNoQnVmZmVyLmZvckVhY2goKHB1c2hFdmVudCkgPT4gcHVzaEV2ZW50LnNlbmQoKSk7XG4gICAgICAgICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29uQ2xvc2UoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGNsb3NlICR7dGhpcy50b3BpY30gJHt0aGlzLl9qb2luUmVmKCl9YCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuX3JlbW92ZSh0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX29uRXJyb3IoKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTGVhdmluZygpIHx8IHRoaXMuX2lzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgZXJyb3IgJHt0aGlzLnRvcGljfWAsIHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzSm9pbmluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYHRpbWVvdXQgJHt0aGlzLnRvcGljfWAsIHRoaXMuam9pblB1c2gudGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmpvaW5QdXNoLnJlY2VpdmUoJ2Vycm9yJywgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTGVhdmluZygpIHx8IHRoaXMuX2lzQ2xvc2VkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgZXJyb3IgJHt0aGlzLnRvcGljfWAsIHJlYXNvbik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgIHRoaXMucmVqb2luVGltZXIuc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9vbihDSEFOTkVMX0VWRU5UUy5yZXBseSwge30sIChwYXlsb2FkLCByZWYpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIodGhpcy5fcmVwbHlFdmVudE5hbWUocmVmKSwgcGF5bG9hZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByZXNlbmNlID0gbmV3IFJlYWx0aW1lUHJlc2VuY2UodGhpcyk7XG4gICAgICAgIHRoaXMuYnJvYWRjYXN0RW5kcG9pbnRVUkwgPSBodHRwRW5kcG9pbnRVUkwodGhpcy5zb2NrZXQuZW5kUG9pbnQpO1xuICAgICAgICB0aGlzLnByaXZhdGUgPSB0aGlzLnBhcmFtcy5jb25maWcucHJpdmF0ZSB8fCBmYWxzZTtcbiAgICAgICAgaWYgKCF0aGlzLnByaXZhdGUgJiYgKChfYiA9IChfYSA9IHRoaXMucGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJyb2FkY2FzdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlcGxheSkpIHtcbiAgICAgICAgICAgIHRocm93IGB0cmllZCB0byB1c2UgcmVwbGF5IG9uIHB1YmxpYyBjaGFubmVsICcke3RoaXMudG9waWN9Jy4gSXQgbXVzdCBiZSBhIHByaXZhdGUgY2hhbm5lbC5gO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBTdWJzY3JpYmUgcmVnaXN0ZXJzIHlvdXIgY2xpZW50IHdpdGggdGhlIHNlcnZlciAqL1xuICAgIHN1YnNjcmliZShjYWxsYmFjaywgdGltZW91dCA9IHRoaXMudGltZW91dCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKCF0aGlzLnNvY2tldC5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT0gQ0hBTk5FTF9TVEFURVMuY2xvc2VkKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNvbmZpZzogeyBicm9hZGNhc3QsIHByZXNlbmNlLCBwcml2YXRlOiBpc1ByaXZhdGUgfSwgfSA9IHRoaXMucGFyYW1zO1xuICAgICAgICAgICAgY29uc3QgcG9zdGdyZXNfY2hhbmdlcyA9IChfYiA9IChfYSA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgocikgPT4gci5maWx0ZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXNlbmNlX2VuYWJsZWQgPSAoISF0aGlzLmJpbmRpbmdzW1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRV0gJiZcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzW1JFQUxUSU1FX0xJU1RFTl9UWVBFUy5QUkVTRU5DRV0ubGVuZ3RoID4gMCkgfHxcbiAgICAgICAgICAgICAgICAoKF9jID0gdGhpcy5wYXJhbXMuY29uZmlnLnByZXNlbmNlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZW5hYmxlZCkgPT09IHRydWU7XG4gICAgICAgICAgICBjb25zdCBhY2Nlc3NUb2tlblBheWxvYWQgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBicm9hZGNhc3QsXG4gICAgICAgICAgICAgICAgcHJlc2VuY2U6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJlc2VuY2UpLCB7IGVuYWJsZWQ6IHByZXNlbmNlX2VuYWJsZWQgfSksXG4gICAgICAgICAgICAgICAgcG9zdGdyZXNfY2hhbmdlcyxcbiAgICAgICAgICAgICAgICBwcml2YXRlOiBpc1ByaXZhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuc29ja2V0LmFjY2Vzc1Rva2VuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlblBheWxvYWQuYWNjZXNzX3Rva2VuID0gdGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoKGUpID0+IGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNIQU5ORUxfRVJST1IsIGUpKTtcbiAgICAgICAgICAgIHRoaXMuX29uQ2xvc2UoKCkgPT4gY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuQ0xPU0VEKSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUpvaW5QYXlsb2FkKE9iamVjdC5hc3NpZ24oeyBjb25maWcgfSwgYWNjZXNzVG9rZW5QYXlsb2FkKSk7XG4gICAgICAgICAgICB0aGlzLmpvaW5lZE9uY2UgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVqb2luKHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5qb2luUHVzaFxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdvaycsIGFzeW5jICh7IHBvc3RncmVzX2NoYW5nZXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5zZXRBdXRoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBvc3RncmVzX2NoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5TVUJTQ1JJQkVEKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50UG9zdGdyZXNCaW5kaW5ncyA9IHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZGluZ3NMZW4gPSAoX2EgPSBjbGllbnRQb3N0Z3Jlc0JpbmRpbmdzID09PSBudWxsIHx8IGNsaWVudFBvc3RncmVzQmluZGluZ3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNsaWVudFBvc3RncmVzQmluZGluZ3MubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQb3N0Z3Jlc0JpbmRpbmdzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluZGluZ3NMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50UG9zdGdyZXNCaW5kaW5nID0gY2xpZW50UG9zdGdyZXNCaW5kaW5nc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmlsdGVyOiB7IGV2ZW50LCBzY2hlbWEsIHRhYmxlLCBmaWx0ZXIgfSwgfSA9IGNsaWVudFBvc3RncmVzQmluZGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcnZlclBvc3RncmVzRmlsdGVyID0gcG9zdGdyZXNfY2hhbmdlcyAmJiBwb3N0Z3Jlc19jaGFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcnZlclBvc3RncmVzRmlsdGVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyUG9zdGdyZXNGaWx0ZXIuZXZlbnQgPT09IGV2ZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyUG9zdGdyZXNGaWx0ZXIuc2NoZW1hID09PSBzY2hlbWEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci50YWJsZSA9PT0gdGFibGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJQb3N0Z3Jlc0ZpbHRlci5maWx0ZXIgPT09IGZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Bvc3RncmVzQmluZGluZ3MucHVzaChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNsaWVudFBvc3RncmVzQmluZGluZyksIHsgaWQ6IHNlcnZlclBvc3RncmVzRmlsdGVyLmlkIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ0hBTk5FTF9TVEFURVMuZXJyb3JlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5DSEFOTkVMX0VSUk9SLCBuZXcgRXJyb3IoJ21pc21hdGNoIGJldHdlZW4gc2VydmVyIGFuZCBjbGllbnQgYmluZGluZ3MgZm9yIHBvc3RncmVzIGNoYW5nZXMnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZGluZ3MucG9zdGdyZXNfY2hhbmdlcyA9IG5ld1Bvc3RncmVzQmluZGluZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKFJFQUxUSU1FX1NVQlNDUklCRV9TVEFURVMuU1VCU0NSSUJFRCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5lcnJvcmVkO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLkNIQU5ORUxfRVJST1IsIG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShPYmplY3QudmFsdWVzKGVycm9yKS5qb2luKCcsICcpIHx8ICdlcnJvcicpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUy5USU1FRF9PVVQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBwcmVzZW5jZVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVzZW5jZS5zdGF0ZTtcbiAgICB9XG4gICAgYXN5bmMgdHJhY2socGF5bG9hZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgICAgIGV2ZW50OiAndHJhY2snLFxuICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgfSwgb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dCk7XG4gICAgfVxuICAgIGFzeW5jIHVudHJhY2sob3B0cyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnNlbmQoe1xuICAgICAgICAgICAgdHlwZTogJ3ByZXNlbmNlJyxcbiAgICAgICAgICAgIGV2ZW50OiAndW50cmFjaycsXG4gICAgICAgIH0sIG9wdHMpO1xuICAgIH1cbiAgICBvbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luZWQgJiYgdHlwZSA9PT0gUkVBTFRJTUVfTElTVEVOX1RZUEVTLlBSRVNFTkNFKSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5sb2coJ2NoYW5uZWwnLCBgcmVzdWJzY3JpYmUgdG8gJHt0aGlzLnRvcGljfSBkdWUgdG8gY2hhbmdlIGluIHByZXNlbmNlIGNhbGxiYWNrcyBvbiBqb2luZWQgY2hhbm5lbGApO1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpLnRoZW4oKCkgPT4gdGhpcy5zdWJzY3JpYmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX29uKHR5cGUsIGZpbHRlciwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGJyb2FkY2FzdCBtZXNzYWdlIGV4cGxpY2l0bHkgdmlhIFJFU1QgQVBJLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWx3YXlzIHVzZXMgdGhlIFJFU1QgQVBJIGVuZHBvaW50IHJlZ2FyZGxlc3Mgb2YgV2ViU29ja2V0IGNvbm5lY3Rpb24gc3RhdGUuXG4gICAgICogVXNlZnVsIHdoZW4geW91IHdhbnQgdG8gZ3VhcmFudGVlIFJFU1QgZGVsaXZlcnkgb3Igd2hlbiBncmFkdWFsbHkgbWlncmF0aW5nIGZyb20gaW1wbGljaXQgUkVTVCBmYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgbmFtZSBvZiB0aGUgYnJvYWRjYXN0IGV2ZW50XG4gICAgICogQHBhcmFtIHBheWxvYWQgUGF5bG9hZCB0byBiZSBzZW50IChyZXF1aXJlZClcbiAgICAgKiBAcGFyYW0gb3B0cyBPcHRpb25zIGluY2x1ZGluZyB0aW1lb3V0XG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gb2JqZWN0IHdpdGggc3VjY2VzcyBzdGF0dXMsIGFuZCBlcnJvciBkZXRhaWxzIGlmIGZhaWxlZFxuICAgICAqL1xuICAgIGFzeW5jIGh0dHBTZW5kKGV2ZW50LCBwYXlsb2FkLCBvcHRzID0ge30pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uID0gdGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZVxuICAgICAgICAgICAgPyBgQmVhcmVyICR7dGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZX1gXG4gICAgICAgICAgICA6ICcnO1xuICAgICAgICBpZiAocGF5bG9hZCA9PT0gdW5kZWZpbmVkIHx8IHBheWxvYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnUGF5bG9hZCBpcyByZXF1aXJlZCBmb3IgaHR0cFNlbmQoKScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgICAgIGFwaWtleTogdGhpcy5zb2NrZXQuYXBpS2V5ID8gdGhpcy5zb2NrZXQuYXBpS2V5IDogJycsXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9waWM6IHRoaXMuc3ViVG9waWMsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcml2YXRlOiB0aGlzLnByaXZhdGUsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX2ZldGNoV2l0aFRpbWVvdXQodGhpcy5icm9hZGNhc3RFbmRwb2ludFVSTCwgb3B0aW9ucywgKF9hID0gb3B0cy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnRpbWVvdXQpO1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gcmVzcG9uc2Uuc3RhdHVzVGV4dDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yQm9keSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yQm9keS5lcnJvciB8fCBlcnJvckJvZHkubWVzc2FnZSB8fCBlcnJvck1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9iKSB7IH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIGludG8gdGhlIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyBBcmd1bWVudHMgdG8gc2VuZCB0byBjaGFubmVsXG4gICAgICogQHBhcmFtIGFyZ3MudHlwZSBUaGUgdHlwZSBvZiBldmVudCB0byBzZW5kXG4gICAgICogQHBhcmFtIGFyZ3MuZXZlbnQgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IGJlaW5nIHNlbnRcbiAgICAgKiBAcGFyYW0gYXJncy5wYXlsb2FkIFBheWxvYWQgdG8gYmUgc2VudFxuICAgICAqIEBwYXJhbSBvcHRzIE9wdGlvbnMgdG8gYmUgdXNlZCBkdXJpbmcgdGhlIHNlbmQgcHJvY2Vzc1xuICAgICAqL1xuICAgIGFzeW5jIHNlbmQoYXJncywgb3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghdGhpcy5fY2FuUHVzaCgpICYmIGFyZ3MudHlwZSA9PT0gJ2Jyb2FkY2FzdCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUmVhbHRpbWUgc2VuZCgpIGlzIGF1dG9tYXRpY2FsbHkgZmFsbGluZyBiYWNrIHRvIFJFU1QgQVBJLiAnICtcbiAgICAgICAgICAgICAgICAnVGhpcyBiZWhhdmlvciB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIGZ1dHVyZS4gJyArXG4gICAgICAgICAgICAgICAgJ1BsZWFzZSB1c2UgaHR0cFNlbmQoKSBleHBsaWNpdGx5IGZvciBSRVNUIGRlbGl2ZXJ5LicpO1xuICAgICAgICAgICAgY29uc3QgeyBldmVudCwgcGF5bG9hZDogZW5kcG9pbnRfcGF5bG9hZCB9ID0gYXJncztcbiAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb24gPSB0aGlzLnNvY2tldC5hY2Nlc3NUb2tlblZhbHVlXG4gICAgICAgICAgICAgICAgPyBgQmVhcmVyICR7dGhpcy5zb2NrZXQuYWNjZXNzVG9rZW5WYWx1ZX1gXG4gICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBhdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBhcGlrZXk6IHRoaXMuc29ja2V0LmFwaUtleSA/IHRoaXMuc29ja2V0LmFwaUtleSA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljOiB0aGlzLnN1YlRvcGljLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGVuZHBvaW50X3BheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZTogdGhpcy5wcml2YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fZmV0Y2hXaXRoVGltZW91dCh0aGlzLmJyb2FkY2FzdEVuZHBvaW50VVJMLCBvcHRpb25zLCAoX2EgPSBvcHRzLnRpbWVvdXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfYiA9IHJlc3BvbnNlLmJvZHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYW5jZWwoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rID8gJ29rJyA6ICdlcnJvcic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndGltZWQgb3V0JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZXJyb3InO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIGNvbnN0IHB1c2ggPSB0aGlzLl9wdXNoKGFyZ3MudHlwZSwgYXJncywgb3B0cy50aW1lb3V0IHx8IHRoaXMudGltZW91dCk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MudHlwZSA9PT0gJ2Jyb2FkY2FzdCcgJiYgISgoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJyb2FkY2FzdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgnb2snKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHVzaC5yZWNlaXZlKCdvaycsICgpID0+IHJlc29sdmUoJ29rJykpO1xuICAgICAgICAgICAgICAgIHB1c2gucmVjZWl2ZSgnZXJyb3InLCAoKSA9PiByZXNvbHZlKCdlcnJvcicpKTtcbiAgICAgICAgICAgICAgICBwdXNoLnJlY2VpdmUoJ3RpbWVvdXQnLCAoKSA9PiByZXNvbHZlKCd0aW1lZCBvdXQnKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVKb2luUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMuam9pblB1c2gudXBkYXRlUGF5bG9hZChwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVhdmVzIHRoZSBjaGFubmVsLlxuICAgICAqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gc2VydmVyIGV2ZW50cywgYW5kIGluc3RydWN0cyBjaGFubmVsIHRvIHRlcm1pbmF0ZSBvbiBzZXJ2ZXIuXG4gICAgICogVHJpZ2dlcnMgb25DbG9zZSgpIGhvb2tzLlxuICAgICAqXG4gICAgICogVG8gcmVjZWl2ZSBsZWF2ZSBhY2tub3dsZWRnZW1lbnRzLCB1c2UgdGhlIGEgYHJlY2VpdmVgIGhvb2sgdG8gYmluZCB0byB0aGUgc2VydmVyIGFjaywgaWU6XG4gICAgICogY2hhbm5lbC51bnN1YnNjcmliZSgpLnJlY2VpdmUoXCJva1wiLCAoKSA9PiBhbGVydChcImxlZnQhXCIpIClcbiAgICAgKi9cbiAgICB1bnN1YnNjcmliZSh0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nO1xuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGxlYXZlICR7dGhpcy50b3BpY31gKTtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuY2xvc2UsICdsZWF2ZScsIHRoaXMuX2pvaW5SZWYoKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuam9pblB1c2guZGVzdHJveSgpO1xuICAgICAgICBsZXQgbGVhdmVQdXNoID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBsZWF2ZVB1c2ggPSBuZXcgUHVzaCh0aGlzLCBDSEFOTkVMX0VWRU5UUy5sZWF2ZSwge30sIHRpbWVvdXQpO1xuICAgICAgICAgICAgbGVhdmVQdXNoXG4gICAgICAgICAgICAgICAgLnJlY2VpdmUoJ29rJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCdvaycpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVjZWl2ZSgndGltZW91dCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgndGltZWQgb3V0Jyk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5yZWNlaXZlKCdlcnJvcicsICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCdlcnJvcicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZWF2ZVB1c2guc2VuZCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYW5QdXNoKCkpIHtcbiAgICAgICAgICAgICAgICBsZWF2ZVB1c2gudHJpZ2dlcignb2snLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgbGVhdmVQdXNoID09PSBudWxsIHx8IGxlYXZlUHVzaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVhdmVQdXNoLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlYXJkb3duIHRoZSBjaGFubmVsLlxuICAgICAqXG4gICAgICogRGVzdHJveXMgYW5kIHN0b3BzIHJlbGF0ZWQgdGltZXJzLlxuICAgICAqL1xuICAgIHRlYXJkb3duKCkge1xuICAgICAgICB0aGlzLnB1c2hCdWZmZXIuZm9yRWFjaCgocHVzaCkgPT4gcHVzaC5kZXN0cm95KCkpO1xuICAgICAgICB0aGlzLnB1c2hCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5yZWpvaW5UaW1lci5yZXNldCgpO1xuICAgICAgICB0aGlzLmpvaW5QdXNoLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmNsb3NlZDtcbiAgICAgICAgdGhpcy5iaW5kaW5ncyA9IHt9O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgYXN5bmMgX2ZldGNoV2l0aFRpbWVvdXQodXJsLCBvcHRpb25zLCB0aW1lb3V0KSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IGlkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuc29ja2V0LmZldGNoKHVybCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsIH0pKTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3B1c2goZXZlbnQsIHBheWxvYWQsIHRpbWVvdXQgPSB0aGlzLnRpbWVvdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmpvaW5lZE9uY2UpIHtcbiAgICAgICAgICAgIHRocm93IGB0cmllZCB0byBwdXNoICcke2V2ZW50fScgdG8gJyR7dGhpcy50b3BpY30nIGJlZm9yZSBqb2luaW5nLiBVc2UgY2hhbm5lbC5zdWJzY3JpYmUoKSBiZWZvcmUgcHVzaGluZyBldmVudHNgO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwdXNoRXZlbnQgPSBuZXcgUHVzaCh0aGlzLCBldmVudCwgcGF5bG9hZCwgdGltZW91dCk7XG4gICAgICAgIGlmICh0aGlzLl9jYW5QdXNoKCkpIHtcbiAgICAgICAgICAgIHB1c2hFdmVudC5zZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb1B1c2hCdWZmZXIocHVzaEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVzaEV2ZW50O1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2FkZFRvUHVzaEJ1ZmZlcihwdXNoRXZlbnQpIHtcbiAgICAgICAgcHVzaEV2ZW50LnN0YXJ0VGltZW91dCgpO1xuICAgICAgICB0aGlzLnB1c2hCdWZmZXIucHVzaChwdXNoRXZlbnQpO1xuICAgICAgICAvLyBFbmZvcmNlIGJ1ZmZlciBzaXplIGxpbWl0XG4gICAgICAgIGlmICh0aGlzLnB1c2hCdWZmZXIubGVuZ3RoID4gTUFYX1BVU0hfQlVGRkVSX1NJWkUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRQdXNoID0gdGhpcy5wdXNoQnVmZmVyLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZFB1c2gpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkUHVzaC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQubG9nKCdjaGFubmVsJywgYGRpc2NhcmRlZCBwdXNoIGR1ZSB0byBidWZmZXIgb3ZlcmZsb3c6ICR7cmVtb3ZlZFB1c2guZXZlbnR9YCwgcmVtb3ZlZFB1c2gucGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGFibGUgbWVzc2FnZSBob29rXG4gICAgICpcbiAgICAgKiBSZWNlaXZlcyBhbGwgZXZlbnRzIGZvciBzcGVjaWFsaXplZCBtZXNzYWdlIGhhbmRsaW5nIGJlZm9yZSBkaXNwYXRjaGluZyB0byB0aGUgY2hhbm5lbCBjYWxsYmFja3MuXG4gICAgICogTXVzdCByZXR1cm4gdGhlIHBheWxvYWQsIG1vZGlmaWVkIG9yIHVubW9kaWZpZWQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfb25NZXNzYWdlKF9ldmVudCwgcGF5bG9hZCwgX3JlZikge1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pc01lbWJlcih0b3BpYykge1xuICAgICAgICByZXR1cm4gdGhpcy50b3BpYyA9PT0gdG9waWM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfam9pblJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuam9pblB1c2gucmVmO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3RyaWdnZXIodHlwZSwgcGF5bG9hZCwgcmVmKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgeyBjbG9zZSwgZXJyb3IsIGxlYXZlLCBqb2luIH0gPSBDSEFOTkVMX0VWRU5UUztcbiAgICAgICAgY29uc3QgZXZlbnRzID0gW2Nsb3NlLCBlcnJvciwgbGVhdmUsIGpvaW5dO1xuICAgICAgICBpZiAocmVmICYmIGV2ZW50cy5pbmRleE9mKHR5cGVMb3dlcikgPj0gMCAmJiByZWYgIT09IHRoaXMuX2pvaW5SZWYoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoYW5kbGVkUGF5bG9hZCA9IHRoaXMuX29uTWVzc2FnZSh0eXBlTG93ZXIsIHBheWxvYWQsIHJlZik7XG4gICAgICAgIGlmIChwYXlsb2FkICYmICFoYW5kbGVkUGF5bG9hZCkge1xuICAgICAgICAgICAgdGhyb3cgJ2NoYW5uZWwgb25NZXNzYWdlIGNhbGxiYWNrcyBtdXN0IHJldHVybiB0aGUgcGF5bG9hZCwgbW9kaWZpZWQgb3IgdW5tb2RpZmllZCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFsnaW5zZXJ0JywgJ3VwZGF0ZScsICdkZWxldGUnXS5pbmNsdWRlcyh0eXBlTG93ZXIpKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmJpbmRpbmdzLnBvc3RncmVzX2NoYW5nZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIoKGJpbmQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICByZXR1cm4gKChfYSA9IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXZlbnQpID09PSAnKicgfHwgKChfYyA9IChfYiA9IGJpbmQuZmlsdGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZXZlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy50b0xvY2FsZUxvd2VyQ2FzZSgpKSA9PT0gdHlwZUxvd2VyO1xuICAgICAgICAgICAgfSkubWFwKChiaW5kKSA9PiBiaW5kLmNhbGxiYWNrKGhhbmRsZWRQYXlsb2FkLCByZWYpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIChfYiA9IHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgICAgIGlmIChbJ2Jyb2FkY2FzdCcsICdwcmVzZW5jZScsICdwb3N0Z3Jlc19jaGFuZ2VzJ10uaW5jbHVkZXModHlwZUxvd2VyKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJ2lkJyBpbiBiaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiaW5kSWQgPSBiaW5kLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmluZEV2ZW50ID0gKF9hID0gYmluZC5maWx0ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ldmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoYmluZElkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYiA9IHBheWxvYWQuaWRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaW5jbHVkZXMoYmluZElkKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYmluZEV2ZW50ID09PSAnKicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJpbmRFdmVudCA9PT0gbnVsbCB8fCBiaW5kRXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJpbmRFdmVudC50b0xvY2FsZUxvd2VyQ2FzZSgpKSA9PT0gKChfYyA9IHBheWxvYWQuZGF0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRFdmVudCA9IChfZSA9IChfZCA9IGJpbmQgPT09IG51bGwgfHwgYmluZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmluZC5maWx0ZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5ldmVudCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmluZEV2ZW50ID09PSAnKicgfHwgYmluZEV2ZW50ID09PSAoKF9mID0gcGF5bG9hZCA9PT0gbnVsbCB8fCBwYXlsb2FkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXlsb2FkLmV2ZW50KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YudG9Mb2NhbGVMb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiaW5kLnR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKSA9PT0gdHlwZUxvd2VyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLm1hcCgoYmluZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlZFBheWxvYWQgPT09ICdvYmplY3QnICYmICdpZHMnIGluIGhhbmRsZWRQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3RncmVzQ2hhbmdlcyA9IGhhbmRsZWRQYXlsb2FkLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hLCB0YWJsZSwgY29tbWl0X3RpbWVzdGFtcCwgdHlwZSwgZXJyb3JzIH0gPSBwb3N0Z3Jlc0NoYW5nZXM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVucmljaGVkUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0X3RpbWVzdGFtcDogY29tbWl0X3RpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50VHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldzoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGQ6IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZWRQYXlsb2FkID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbnJpY2hlZFBheWxvYWQpLCB0aGlzLl9nZXRQYXlsb2FkUmVjb3Jkcyhwb3N0Z3Jlc0NoYW5nZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmluZC5jYWxsYmFjayhoYW5kbGVkUGF5bG9hZCwgcmVmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5jbG9zZWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNKb2luZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5qb2luZWQ7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfaXNKb2luaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gQ0hBTk5FTF9TVEFURVMuam9pbmluZztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9pc0xlYXZpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlID09PSBDSEFOTkVMX1NUQVRFUy5sZWF2aW5nO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3JlcGx5RXZlbnROYW1lKHJlZikge1xuICAgICAgICByZXR1cm4gYGNoYW5fcmVwbHlfJHtyZWZ9YDtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbih0eXBlLCBmaWx0ZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgYmluZGluZyA9IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVMb3dlcixcbiAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmRpbmdzW3R5cGVMb3dlcl0ucHVzaChiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSA9IFtiaW5kaW5nXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vZmYodHlwZSwgZmlsdGVyKSB7XG4gICAgICAgIGNvbnN0IHR5cGVMb3dlciA9IHR5cGUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuYmluZGluZ3NbdHlwZUxvd2VyXSkge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdID0gdGhpcy5iaW5kaW5nc1t0eXBlTG93ZXJdLmZpbHRlcigoYmluZCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gISgoKF9hID0gYmluZC50eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb2NhbGVMb3dlckNhc2UoKSkgPT09IHR5cGVMb3dlciAmJlxuICAgICAgICAgICAgICAgICAgICBSZWFsdGltZUNoYW5uZWwuaXNFcXVhbChiaW5kLmZpbHRlciwgZmlsdGVyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBpc0VxdWFsKG9iajEsIG9iajIpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9iajEpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrIGluIG9iajEpIHtcbiAgICAgICAgICAgIGlmIChvYmoxW2tdICE9PSBvYmoyW2tdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3Jlam9pblVudGlsQ29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLnJlam9pblRpbWVyLnNjaGVkdWxlVGltZW91dCgpO1xuICAgICAgICBpZiAodGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVqb2luKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNoYW5uZWwgY2xvc2VzLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX29uQ2xvc2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMuY2xvc2UsIHt9LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjaGFubmVsIGVuY291bnRlcmVzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX29uRXJyb3IoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb24oQ0hBTk5FTF9FVkVOVFMuZXJyb3IsIHt9LCAocmVhc29uKSA9PiBjYWxsYmFjayhyZWFzb24pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNvY2tldCBpcyBjb25uZWN0ZWQgYW5kIHRoZSBjaGFubmVsIGhhcyBiZWVuIGpvaW5lZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9jYW5QdXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXQuaXNDb25uZWN0ZWQoKSAmJiB0aGlzLl9pc0pvaW5lZCgpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX3Jlam9pbih0aW1lb3V0ID0gdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0xlYXZpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc29ja2V0Ll9sZWF2ZU9wZW5Ub3BpYyh0aGlzLnRvcGljKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IENIQU5ORUxfU1RBVEVTLmpvaW5pbmc7XG4gICAgICAgIHRoaXMuam9pblB1c2gucmVzZW5kKHRpbWVvdXQpO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX2dldFBheWxvYWRSZWNvcmRzKHBheWxvYWQpIHtcbiAgICAgICAgY29uc3QgcmVjb3JkcyA9IHtcbiAgICAgICAgICAgIG5ldzoge30sXG4gICAgICAgICAgICBvbGQ6IHt9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAocGF5bG9hZC50eXBlID09PSAnSU5TRVJUJyB8fCBwYXlsb2FkLnR5cGUgPT09ICdVUERBVEUnKSB7XG4gICAgICAgICAgICByZWNvcmRzLm5ldyA9IFRyYW5zZm9ybWVycy5jb252ZXJ0Q2hhbmdlRGF0YShwYXlsb2FkLmNvbHVtbnMsIHBheWxvYWQucmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF5bG9hZC50eXBlID09PSAnVVBEQVRFJyB8fCBwYXlsb2FkLnR5cGUgPT09ICdERUxFVEUnKSB7XG4gICAgICAgICAgICByZWNvcmRzLm9sZCA9IFRyYW5zZm9ybWVycy5jb252ZXJ0Q2hhbmdlRGF0YShwYXlsb2FkLmNvbHVtbnMsIHBheWxvYWQub2xkX3JlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlY29yZHM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmVhbHRpbWVDaGFubmVsLmpzLm1hcCJdLCJuYW1lcyI6WyJDSEFOTkVMX0VWRU5UUyIsIkNIQU5ORUxfU1RBVEVTIiwiTUFYX1BVU0hfQlVGRkVSX1NJWkUiLCJQdXNoIiwiVGltZXIiLCJSZWFsdGltZVByZXNlbmNlIiwiVHJhbnNmb3JtZXJzIiwiaHR0cEVuZHBvaW50VVJMIiwiUkVBTFRJTUVfUE9TVEdSRVNfQ0hBTkdFU19MSVNURU5fRVZFTlQiLCJSRUFMVElNRV9MSVNURU5fVFlQRVMiLCJSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTIiwiUkVBTFRJTUVfQ0hBTk5FTF9TVEFURVMiLCJSZWFsdGltZUNoYW5uZWwiLCJjb25zdHJ1Y3RvciIsInRvcGljIiwicGFyYW1zIiwiY29uZmlnIiwic29ja2V0IiwiX2EiLCJfYiIsImJpbmRpbmdzIiwic3RhdGUiLCJjbG9zZWQiLCJqb2luZWRPbmNlIiwicHVzaEJ1ZmZlciIsInN1YlRvcGljIiwicmVwbGFjZSIsIk9iamVjdCIsImFzc2lnbiIsImJyb2FkY2FzdCIsImFjayIsInNlbGYiLCJwcmVzZW5jZSIsImtleSIsImVuYWJsZWQiLCJwcml2YXRlIiwidGltZW91dCIsImpvaW5QdXNoIiwiam9pbiIsInJlam9pblRpbWVyIiwiX3Jlam9pblVudGlsQ29ubmVjdGVkIiwicmVjb25uZWN0QWZ0ZXJNcyIsInJlY2VpdmUiLCJqb2luZWQiLCJyZXNldCIsImZvckVhY2giLCJwdXNoRXZlbnQiLCJzZW5kIiwiX29uQ2xvc2UiLCJsb2ciLCJfam9pblJlZiIsIl9yZW1vdmUiLCJfb25FcnJvciIsInJlYXNvbiIsIl9pc0xlYXZpbmciLCJfaXNDbG9zZWQiLCJlcnJvcmVkIiwic2NoZWR1bGVUaW1lb3V0IiwiX2lzSm9pbmluZyIsIl9vbiIsInJlcGx5IiwicGF5bG9hZCIsInJlZiIsIl90cmlnZ2VyIiwiX3JlcGx5RXZlbnROYW1lIiwiYnJvYWRjYXN0RW5kcG9pbnRVUkwiLCJlbmRQb2ludCIsInJlcGxheSIsInN1YnNjcmliZSIsImNhbGxiYWNrIiwiX2MiLCJpc0Nvbm5lY3RlZCIsImNvbm5lY3QiLCJpc1ByaXZhdGUiLCJwb3N0Z3Jlc19jaGFuZ2VzIiwibWFwIiwiciIsImZpbHRlciIsInByZXNlbmNlX2VuYWJsZWQiLCJQUkVTRU5DRSIsImxlbmd0aCIsImFjY2Vzc1Rva2VuUGF5bG9hZCIsImFjY2Vzc1Rva2VuVmFsdWUiLCJhY2Nlc3NfdG9rZW4iLCJlIiwiQ0hBTk5FTF9FUlJPUiIsIkNMT1NFRCIsInVwZGF0ZUpvaW5QYXlsb2FkIiwiX3Jlam9pbiIsInNldEF1dGgiLCJ1bmRlZmluZWQiLCJTVUJTQ1JJQkVEIiwiY2xpZW50UG9zdGdyZXNCaW5kaW5ncyIsImJpbmRpbmdzTGVuIiwibmV3UG9zdGdyZXNCaW5kaW5ncyIsImkiLCJjbGllbnRQb3N0Z3Jlc0JpbmRpbmciLCJldmVudCIsInNjaGVtYSIsInRhYmxlIiwic2VydmVyUG9zdGdyZXNGaWx0ZXIiLCJwdXNoIiwiaWQiLCJ1bnN1YnNjcmliZSIsIkVycm9yIiwiZXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwidmFsdWVzIiwiVElNRURfT1VUIiwicHJlc2VuY2VTdGF0ZSIsInRyYWNrIiwib3B0cyIsInR5cGUiLCJ1bnRyYWNrIiwib24iLCJ0aGVuIiwiaHR0cFNlbmQiLCJhdXRob3JpemF0aW9uIiwiUHJvbWlzZSIsInJlamVjdCIsIm9wdGlvbnMiLCJtZXRob2QiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsImFwaWtleSIsImFwaUtleSIsImJvZHkiLCJtZXNzYWdlcyIsInJlc3BvbnNlIiwiX2ZldGNoV2l0aFRpbWVvdXQiLCJzdGF0dXMiLCJzdWNjZXNzIiwiZXJyb3JNZXNzYWdlIiwic3RhdHVzVGV4dCIsImVycm9yQm9keSIsImpzb24iLCJtZXNzYWdlIiwiYXJncyIsIl9jYW5QdXNoIiwiY29uc29sZSIsIndhcm4iLCJlbmRwb2ludF9wYXlsb2FkIiwiY2FuY2VsIiwib2siLCJuYW1lIiwicmVzb2x2ZSIsIl9wdXNoIiwidXBkYXRlUGF5bG9hZCIsImxlYXZpbmciLCJvbkNsb3NlIiwiY2xvc2UiLCJkZXN0cm95IiwibGVhdmVQdXNoIiwibGVhdmUiLCJ0cmlnZ2VyIiwiZmluYWxseSIsInRlYXJkb3duIiwidXJsIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInNldFRpbWVvdXQiLCJhYm9ydCIsImZldGNoIiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0IiwiX2FkZFRvUHVzaEJ1ZmZlciIsInN0YXJ0VGltZW91dCIsInJlbW92ZWRQdXNoIiwic2hpZnQiLCJfb25NZXNzYWdlIiwiX2V2ZW50IiwiX3JlZiIsIl9pc01lbWJlciIsInR5cGVMb3dlciIsInRvTG9jYWxlTG93ZXJDYXNlIiwiZXZlbnRzIiwiaW5kZXhPZiIsImhhbmRsZWRQYXlsb2FkIiwiaW5jbHVkZXMiLCJiaW5kIiwiX2QiLCJfZSIsIl9mIiwiYmluZElkIiwiYmluZEV2ZW50IiwiaWRzIiwiZGF0YSIsInBvc3RncmVzQ2hhbmdlcyIsImNvbW1pdF90aW1lc3RhbXAiLCJlcnJvcnMiLCJlbnJpY2hlZFBheWxvYWQiLCJldmVudFR5cGUiLCJuZXciLCJvbGQiLCJfZ2V0UGF5bG9hZFJlY29yZHMiLCJfaXNKb2luZWQiLCJqb2luaW5nIiwiYmluZGluZyIsIl9vZmYiLCJpc0VxdWFsIiwib2JqMSIsIm9iajIiLCJrZXlzIiwiayIsIl9sZWF2ZU9wZW5Ub3BpYyIsInJlc2VuZCIsInJlY29yZHMiLCJjb252ZXJ0Q2hhbmdlRGF0YSIsImNvbHVtbnMiLCJyZWNvcmQiLCJvbGRfcmVjb3JkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RealtimeClient)\n/* harmony export */ });\n/* harmony import */ var _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/websocket-factory */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_serializer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/serializer */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\");\n/* harmony import */ var _lib_timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/timer */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\");\n/* harmony import */ var _lib_transformers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/transformers */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\");\n/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RealtimeChannel */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\");\n\n\n\n\n\n\nconst noop = ()=>{};\n// Connection-related constants\nconst CONNECTION_TIMEOUTS = {\n    HEARTBEAT_INTERVAL: 25000,\n    RECONNECT_DELAY: 10,\n    HEARTBEAT_TIMEOUT_FALLBACK: 100\n};\nconst RECONNECT_INTERVALS = [\n    1000,\n    2000,\n    5000,\n    10000\n];\nconst DEFAULT_RECONNECT_FALLBACK = 10000;\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`;\nclass RealtimeClient {\n    /**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.heartbeatCallback The optional function to handle heartbeat status.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.logLevel Sets the log level for Realtime\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n     */ constructor(endPoint, options){\n        var _a;\n        this.accessTokenValue = null;\n        this.apiKey = null;\n        this.channels = new Array();\n        this.endPoint = \"\";\n        this.httpEndpoint = \"\";\n        /** @deprecated headers cannot be set on websocket connections */ this.headers = {};\n        this.params = {};\n        this.timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_TIMEOUT;\n        this.transport = null;\n        this.heartbeatIntervalMs = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.heartbeatTimer = undefined;\n        this.pendingHeartbeatRef = null;\n        this.heartbeatCallback = noop;\n        this.ref = 0;\n        this.reconnectTimer = null;\n        this.logger = noop;\n        this.conn = null;\n        this.sendBuffer = [];\n        this.serializer = new _lib_serializer__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        this.stateChangeCallbacks = {\n            open: [],\n            close: [],\n            error: [],\n            message: []\n        };\n        this.accessToken = null;\n        this._connectionState = \"disconnected\";\n        this._wasManualDisconnect = false;\n        this._authPromise = null;\n        /**\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\n         *\n         * @internal\n         */ this._resolveFetch = (customFetch)=>{\n            let _fetch;\n            if (customFetch) {\n                _fetch = customFetch;\n            } else if (typeof fetch === \"undefined\") {\n                // Node.js environment without native fetch\n                _fetch = (...args)=>Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\", 23)).then(({ default: fetch1 })=>fetch1(...args)).catch((error)=>{\n                        throw new Error(`Failed to load @supabase/node-fetch: ${error.message}. ` + `This is required for HTTP requests in Node.js environments without native fetch.`);\n                    });\n            } else {\n                _fetch = fetch;\n            }\n            return (...args)=>_fetch(...args);\n        };\n        // Validate required parameters\n        if (!((_a = options === null || options === void 0 ? void 0 : options.params) === null || _a === void 0 ? void 0 : _a.apikey)) {\n            throw new Error(\"API key is required to connect to Realtime\");\n        }\n        this.apiKey = options.params.apikey;\n        // Initialize endpoint URLs\n        this.endPoint = `${endPoint}/${_lib_constants__WEBPACK_IMPORTED_MODULE_1__.TRANSPORTS.websocket}`;\n        this.httpEndpoint = (0,_lib_transformers__WEBPACK_IMPORTED_MODULE_4__.httpEndpointURL)(endPoint);\n        this._initializeOptions(options);\n        this._setupReconnectionTimer();\n        this.fetch = this._resolveFetch(options === null || options === void 0 ? void 0 : options.fetch);\n    }\n    /**\n     * Connects the socket, unless already connected.\n     */ connect() {\n        // Skip if already connecting, disconnecting, or connected\n        if (this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected()) {\n            return;\n        }\n        this._setConnectionState(\"connecting\");\n        this._setAuthSafely(\"connect\");\n        // Establish WebSocket connection\n        if (this.transport) {\n            // Use custom transport if provided\n            this.conn = new this.transport(this.endpointURL());\n        } else {\n            // Try to use native WebSocket\n            try {\n                this.conn = _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createWebSocket(this.endpointURL());\n            } catch (error) {\n                this._setConnectionState(\"disconnected\");\n                const errorMessage = error.message;\n                // Provide helpful error message based on environment\n                if (errorMessage.includes(\"Node.js\")) {\n                    throw new Error(`${errorMessage}\\n\\n` + \"To use Realtime in Node.js, you need to provide a WebSocket implementation:\\n\\n\" + \"Option 1: Use Node.js 22+ which has native WebSocket support\\n\" + 'Option 2: Install and provide the \"ws\" package:\\n\\n' + \"  npm install ws\\n\\n\" + '  import ws from \"ws\"\\n' + \"  const client = new RealtimeClient(url, {\\n\" + \"    ...options,\\n\" + \"    transport: ws\\n\" + \"  })\");\n                }\n                throw new Error(`WebSocket not available: ${errorMessage}`);\n            }\n        }\n        this._setupConnectionHandlers();\n    }\n    /**\n     * Returns the URL of the websocket.\n     * @returns string The URL of the websocket.\n     */ endpointURL() {\n        return this._appendParams(this.endPoint, Object.assign({}, this.params, {\n            vsn: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.VSN\n        }));\n    }\n    /**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */ disconnect(code, reason) {\n        if (this.isDisconnecting()) {\n            return;\n        }\n        this._setConnectionState(\"disconnecting\", true);\n        if (this.conn) {\n            // Setup fallback timer to prevent hanging in disconnecting state\n            const fallbackTimer = setTimeout(()=>{\n                this._setConnectionState(\"disconnected\");\n            }, 100);\n            this.conn.onclose = ()=>{\n                clearTimeout(fallbackTimer);\n                this._setConnectionState(\"disconnected\");\n            };\n            // Close the WebSocket connection\n            if (code) {\n                this.conn.close(code, reason !== null && reason !== void 0 ? reason : \"\");\n            } else {\n                this.conn.close();\n            }\n            this._teardownConnection();\n        } else {\n            this._setConnectionState(\"disconnected\");\n        }\n    }\n    /**\n     * Returns all created channels\n     */ getChannels() {\n        return this.channels;\n    }\n    /**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */ async removeChannel(channel) {\n        const status = await channel.unsubscribe();\n        if (this.channels.length === 0) {\n            this.disconnect();\n        }\n        return status;\n    }\n    /**\n     * Unsubscribes and removes all channels\n     */ async removeAllChannels() {\n        const values_1 = await Promise.all(this.channels.map((channel)=>channel.unsubscribe()));\n        this.channels = [];\n        this.disconnect();\n        return values_1;\n    }\n    /**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */ log(kind, msg, data) {\n        this.logger(kind, msg, data);\n    }\n    /**\n     * Returns the current state of the socket.\n     */ connectionState() {\n        switch(this.conn && this.conn.readyState){\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.connecting:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Connecting;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.open:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Open;\n            case _lib_constants__WEBPACK_IMPORTED_MODULE_1__.SOCKET_STATES.closing:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Closing;\n            default:\n                return _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Closed;\n        }\n    }\n    /**\n     * Returns `true` is the connection is open.\n     */ isConnected() {\n        return this.connectionState() === _lib_constants__WEBPACK_IMPORTED_MODULE_1__.CONNECTION_STATE.Open;\n    }\n    /**\n     * Returns `true` if the connection is currently connecting.\n     */ isConnecting() {\n        return this._connectionState === \"connecting\";\n    }\n    /**\n     * Returns `true` if the connection is currently disconnecting.\n     */ isDisconnecting() {\n        return this._connectionState === \"disconnecting\";\n    }\n    channel(topic, params = {\n        config: {}\n    }) {\n        const realtimeTopic = `realtime:${topic}`;\n        const exists = this.getChannels().find((c)=>c.topic === realtimeTopic);\n        if (!exists) {\n            const chan = new _RealtimeChannel__WEBPACK_IMPORTED_MODULE_5__[\"default\"](`realtime:${topic}`, params, this);\n            this.channels.push(chan);\n            return chan;\n        } else {\n            return exists;\n        }\n    }\n    /**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */ push(data) {\n        const { topic, event, payload, ref } = data;\n        const callback = ()=>{\n            this.encode(data, (result)=>{\n                var _a;\n                (_a = this.conn) === null || _a === void 0 ? void 0 : _a.send(result);\n            });\n        };\n        this.log(\"push\", `${topic} ${event} (${ref})`, payload);\n        if (this.isConnected()) {\n            callback();\n        } else {\n            this.sendBuffer.push(callback);\n        }\n    }\n    /**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\n     *\n     * On callback used, it will set the value of the token internal to the client.\n     *\n     * @param token A JWT string to override the token set on the client.\n     */ async setAuth(token = null) {\n        this._authPromise = this._performAuth(token);\n        try {\n            await this._authPromise;\n        } finally{\n            this._authPromise = null;\n        }\n    }\n    /**\n     * Sends a heartbeat message if the socket is connected.\n     */ async sendHeartbeat() {\n        var _a;\n        if (!this.isConnected()) {\n            try {\n                this.heartbeatCallback(\"disconnected\");\n            } catch (e) {\n                this.log(\"error\", \"error in heartbeat callback\", e);\n            }\n            return;\n        }\n        // Handle heartbeat timeout and force reconnection if needed\n        if (this.pendingHeartbeatRef) {\n            this.pendingHeartbeatRef = null;\n            this.log(\"transport\", \"heartbeat timeout. Attempting to re-establish connection\");\n            try {\n                this.heartbeatCallback(\"timeout\");\n            } catch (e) {\n                this.log(\"error\", \"error in heartbeat callback\", e);\n            }\n            // Force reconnection after heartbeat timeout\n            this._wasManualDisconnect = false;\n            (_a = this.conn) === null || _a === void 0 ? void 0 : _a.close(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.WS_CLOSE_NORMAL, \"heartbeat timeout\");\n            setTimeout(()=>{\n                var _a;\n                if (!this.isConnected()) {\n                    (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n                }\n            }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);\n            return;\n        }\n        // Send heartbeat message to server\n        this.pendingHeartbeatRef = this._makeRef();\n        this.push({\n            topic: \"phoenix\",\n            event: \"heartbeat\",\n            payload: {},\n            ref: this.pendingHeartbeatRef\n        });\n        try {\n            this.heartbeatCallback(\"sent\");\n        } catch (e) {\n            this.log(\"error\", \"error in heartbeat callback\", e);\n        }\n        this._setAuthSafely(\"heartbeat\");\n    }\n    onHeartbeat(callback) {\n        this.heartbeatCallback = callback;\n    }\n    /**\n     * Flushes send buffer\n     */ flushSendBuffer() {\n        if (this.isConnected() && this.sendBuffer.length > 0) {\n            this.sendBuffer.forEach((callback)=>callback());\n            this.sendBuffer = [];\n        }\n    }\n    /**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */ _makeRef() {\n        let newRef = this.ref + 1;\n        if (newRef === this.ref) {\n            this.ref = 0;\n        } else {\n            this.ref = newRef;\n        }\n        return this.ref.toString();\n    }\n    /**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */ _leaveOpenTopic(topic) {\n        let dupChannel = this.channels.find((c)=>c.topic === topic && (c._isJoined() || c._isJoining()));\n        if (dupChannel) {\n            this.log(\"transport\", `leaving duplicate topic \"${topic}\"`);\n            dupChannel.unsubscribe();\n        }\n    }\n    /**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */ _remove(channel) {\n        this.channels = this.channels.filter((c)=>c.topic !== channel.topic);\n    }\n    /** @internal */ _onConnMessage(rawMessage) {\n        this.decode(rawMessage.data, (msg)=>{\n            // Handle heartbeat responses\n            if (msg.topic === \"phoenix\" && msg.event === \"phx_reply\") {\n                try {\n                    this.heartbeatCallback(msg.payload.status === \"ok\" ? \"ok\" : \"error\");\n                } catch (e) {\n                    this.log(\"error\", \"error in heartbeat callback\", e);\n                }\n            }\n            // Handle pending heartbeat reference cleanup\n            if (msg.ref && msg.ref === this.pendingHeartbeatRef) {\n                this.pendingHeartbeatRef = null;\n            }\n            // Log incoming message\n            const { topic, event, payload, ref } = msg;\n            const refString = ref ? `(${ref})` : \"\";\n            const status = payload.status || \"\";\n            this.log(\"receive\", `${status} ${topic} ${event} ${refString}`.trim(), payload);\n            // Route message to appropriate channels\n            this.channels.filter((channel)=>channel._isMember(topic)).forEach((channel)=>channel._trigger(event, payload, ref));\n            this._triggerStateCallbacks(\"message\", msg);\n        });\n    }\n    /**\n     * Clear specific timer\n     * @internal\n     */ _clearTimer(timer) {\n        var _a;\n        if (timer === \"heartbeat\" && this.heartbeatTimer) {\n            clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = undefined;\n        } else if (timer === \"reconnect\") {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.reset();\n        }\n    }\n    /**\n     * Clear all timers\n     * @internal\n     */ _clearAllTimers() {\n        this._clearTimer(\"heartbeat\");\n        this._clearTimer(\"reconnect\");\n    }\n    /**\n     * Setup connection handlers for WebSocket events\n     * @internal\n     */ _setupConnectionHandlers() {\n        if (!this.conn) return;\n        // Set binary type if supported (browsers and most WebSocket implementations)\n        if (\"binaryType\" in this.conn) {\n            ;\n            this.conn.binaryType = \"arraybuffer\";\n        }\n        this.conn.onopen = ()=>this._onConnOpen();\n        this.conn.onerror = (error)=>this._onConnError(error);\n        this.conn.onmessage = (event)=>this._onConnMessage(event);\n        this.conn.onclose = (event)=>this._onConnClose(event);\n    }\n    /**\n     * Teardown connection and cleanup resources\n     * @internal\n     */ _teardownConnection() {\n        if (this.conn) {\n            this.conn.onopen = null;\n            this.conn.onerror = null;\n            this.conn.onmessage = null;\n            this.conn.onclose = null;\n            this.conn = null;\n        }\n        this._clearAllTimers();\n        this.channels.forEach((channel)=>channel.teardown());\n    }\n    /** @internal */ _onConnOpen() {\n        this._setConnectionState(\"connected\");\n        this.log(\"transport\", `connected to ${this.endpointURL()}`);\n        this.flushSendBuffer();\n        this._clearTimer(\"reconnect\");\n        if (!this.worker) {\n            this._startHeartbeat();\n        } else {\n            if (!this.workerRef) {\n                this._startWorkerHeartbeat();\n            }\n        }\n        this._triggerStateCallbacks(\"open\");\n    }\n    /** @internal */ _startHeartbeat() {\n        this.heartbeatTimer && clearInterval(this.heartbeatTimer);\n        this.heartbeatTimer = setInterval(()=>this.sendHeartbeat(), this.heartbeatIntervalMs);\n    }\n    /** @internal */ _startWorkerHeartbeat() {\n        if (this.workerUrl) {\n            this.log(\"worker\", `starting worker for from ${this.workerUrl}`);\n        } else {\n            this.log(\"worker\", `starting default worker`);\n        }\n        const objectUrl = this._workerObjectUrl(this.workerUrl);\n        this.workerRef = new Worker(objectUrl);\n        this.workerRef.onerror = (error)=>{\n            this.log(\"worker\", \"worker error\", error.message);\n            this.workerRef.terminate();\n        };\n        this.workerRef.onmessage = (event)=>{\n            if (event.data.event === \"keepAlive\") {\n                this.sendHeartbeat();\n            }\n        };\n        this.workerRef.postMessage({\n            event: \"start\",\n            interval: this.heartbeatIntervalMs\n        });\n    }\n    /** @internal */ _onConnClose(event) {\n        var _a;\n        this._setConnectionState(\"disconnected\");\n        this.log(\"transport\", \"close\", event);\n        this._triggerChanError();\n        this._clearTimer(\"heartbeat\");\n        // Only schedule reconnection if it wasn't a manual disconnect\n        if (!this._wasManualDisconnect) {\n            (_a = this.reconnectTimer) === null || _a === void 0 ? void 0 : _a.scheduleTimeout();\n        }\n        this._triggerStateCallbacks(\"close\", event);\n    }\n    /** @internal */ _onConnError(error) {\n        this._setConnectionState(\"disconnected\");\n        this.log(\"transport\", `${error}`);\n        this._triggerChanError();\n        this._triggerStateCallbacks(\"error\", error);\n    }\n    /** @internal */ _triggerChanError() {\n        this.channels.forEach((channel)=>channel._trigger(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.CHANNEL_EVENTS.error));\n    }\n    /** @internal */ _appendParams(url, params) {\n        if (Object.keys(params).length === 0) {\n            return url;\n        }\n        const prefix = url.match(/\\?/) ? \"&\" : \"?\";\n        const query = new URLSearchParams(params);\n        return `${url}${prefix}${query}`;\n    }\n    _workerObjectUrl(url) {\n        let result_url;\n        if (url) {\n            result_url = url;\n        } else {\n            const blob = new Blob([\n                WORKER_SCRIPT\n            ], {\n                type: \"application/javascript\"\n            });\n            result_url = URL.createObjectURL(blob);\n        }\n        return result_url;\n    }\n    /**\n     * Set connection state with proper state management\n     * @internal\n     */ _setConnectionState(state, manual = false) {\n        this._connectionState = state;\n        if (state === \"connecting\") {\n            this._wasManualDisconnect = false;\n        } else if (state === \"disconnecting\") {\n            this._wasManualDisconnect = manual;\n        }\n    }\n    /**\n     * Perform the actual auth operation\n     * @internal\n     */ async _performAuth(token = null) {\n        let tokenToSend;\n        if (token) {\n            tokenToSend = token;\n        } else if (this.accessToken) {\n            // Always call the accessToken callback to get fresh token\n            tokenToSend = await this.accessToken();\n        } else {\n            tokenToSend = this.accessTokenValue;\n        }\n        if (this.accessTokenValue != tokenToSend) {\n            this.accessTokenValue = tokenToSend;\n            this.channels.forEach((channel)=>{\n                const payload = {\n                    access_token: tokenToSend,\n                    version: _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_VERSION\n                };\n                tokenToSend && channel.updateJoinPayload(payload);\n                if (channel.joinedOnce && channel._isJoined()) {\n                    channel._push(_lib_constants__WEBPACK_IMPORTED_MODULE_1__.CHANNEL_EVENTS.access_token, {\n                        access_token: tokenToSend\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Wait for any in-flight auth operations to complete\n     * @internal\n     */ async _waitForAuthIfNeeded() {\n        if (this._authPromise) {\n            await this._authPromise;\n        }\n    }\n    /**\n     * Safely call setAuth with standardized error handling\n     * @internal\n     */ _setAuthSafely(context = \"general\") {\n        this.setAuth().catch((e)=>{\n            this.log(\"error\", `error setting auth in ${context}`, e);\n        });\n    }\n    /**\n     * Trigger state change callbacks with proper error handling\n     * @internal\n     */ _triggerStateCallbacks(event, data) {\n        try {\n            this.stateChangeCallbacks[event].forEach((callback)=>{\n                try {\n                    callback(data);\n                } catch (e) {\n                    this.log(\"error\", `error in ${event} callback`, e);\n                }\n            });\n        } catch (e) {\n            this.log(\"error\", `error triggering ${event} callbacks`, e);\n        }\n    }\n    /**\n     * Setup reconnection timer with proper configuration\n     * @internal\n     */ _setupReconnectionTimer() {\n        this.reconnectTimer = new _lib_timer__WEBPACK_IMPORTED_MODULE_3__[\"default\"](async ()=>{\n            setTimeout(async ()=>{\n                await this._waitForAuthIfNeeded();\n                if (!this.isConnected()) {\n                    this.connect();\n                }\n            }, CONNECTION_TIMEOUTS.RECONNECT_DELAY);\n        }, this.reconnectAfterMs);\n    }\n    /**\n     * Initialize client options with defaults\n     * @internal\n     */ _initializeOptions(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        // Set defaults\n        this.transport = (_a = options === null || options === void 0 ? void 0 : options.transport) !== null && _a !== void 0 ? _a : null;\n        this.timeout = (_b = options === null || options === void 0 ? void 0 : options.timeout) !== null && _b !== void 0 ? _b : _lib_constants__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_TIMEOUT;\n        this.heartbeatIntervalMs = (_c = options === null || options === void 0 ? void 0 : options.heartbeatIntervalMs) !== null && _c !== void 0 ? _c : CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;\n        this.worker = (_d = options === null || options === void 0 ? void 0 : options.worker) !== null && _d !== void 0 ? _d : false;\n        this.accessToken = (_e = options === null || options === void 0 ? void 0 : options.accessToken) !== null && _e !== void 0 ? _e : null;\n        this.heartbeatCallback = (_f = options === null || options === void 0 ? void 0 : options.heartbeatCallback) !== null && _f !== void 0 ? _f : noop;\n        // Handle special cases\n        if (options === null || options === void 0 ? void 0 : options.params) this.params = options.params;\n        if (options === null || options === void 0 ? void 0 : options.logger) this.logger = options.logger;\n        if ((options === null || options === void 0 ? void 0 : options.logLevel) || (options === null || options === void 0 ? void 0 : options.log_level)) {\n            this.logLevel = options.logLevel || options.log_level;\n            this.params = Object.assign(Object.assign({}, this.params), {\n                log_level: this.logLevel\n            });\n        }\n        // Set up functions with defaults\n        this.reconnectAfterMs = (_g = options === null || options === void 0 ? void 0 : options.reconnectAfterMs) !== null && _g !== void 0 ? _g : (tries)=>{\n            return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK;\n        };\n        this.encode = (_h = options === null || options === void 0 ? void 0 : options.encode) !== null && _h !== void 0 ? _h : (payload, callback)=>{\n            return callback(JSON.stringify(payload));\n        };\n        this.decode = (_j = options === null || options === void 0 ? void 0 : options.decode) !== null && _j !== void 0 ? _j : this.serializer.decode.bind(this.serializer);\n        // Handle worker setup\n        if (this.worker) {\n            if (false) {}\n            this.workerUrl = options === null || options === void 0 ? void 0 : options.workerUrl;\n        }\n    }\n} //# sourceMappingURL=RealtimeClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBdUQ7QUFDZ0c7QUFDN0c7QUFDVjtBQUNxQjtBQUNMO0FBQ2hELE1BQU1hLE9BQU8sS0FBUTtBQUNyQiwrQkFBK0I7QUFDL0IsTUFBTUMsc0JBQXNCO0lBQ3hCQyxvQkFBb0I7SUFDcEJDLGlCQUFpQjtJQUNqQkMsNEJBQTRCO0FBQ2hDO0FBQ0EsTUFBTUMsc0JBQXNCO0lBQUM7SUFBTTtJQUFNO0lBQU07Q0FBTTtBQUNyRCxNQUFNQyw2QkFBNkI7QUFDbkMsTUFBTUMsZ0JBQWdCLENBQUM7Ozs7O0tBS2xCLENBQUM7QUFDUyxNQUFNQztJQUNqQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBa0JDLEdBQ0RDLFlBQVlDLFFBQVEsRUFBRUMsT0FBTyxDQUFFO1FBQzNCLElBQUlDO1FBQ0osSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRztRQUN4QixJQUFJLENBQUNDLE1BQU0sR0FBRztRQUNkLElBQUksQ0FBQ0MsUUFBUSxHQUFHLElBQUlDO1FBQ3BCLElBQUksQ0FBQ04sUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ08sWUFBWSxHQUFHO1FBQ3BCLCtEQUErRCxHQUMvRCxJQUFJLENBQUNDLE9BQU8sR0FBRyxDQUFDO1FBQ2hCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLENBQUM7UUFDZixJQUFJLENBQUNDLE9BQU8sR0FBRzdCLDJEQUFlQTtRQUM5QixJQUFJLENBQUM4QixTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBR3JCLG9CQUFvQkMsa0JBQWtCO1FBQ2pFLElBQUksQ0FBQ3FCLGNBQWMsR0FBR0M7UUFDdEIsSUFBSSxDQUFDQyxtQkFBbUIsR0FBRztRQUMzQixJQUFJLENBQUNDLGlCQUFpQixHQUFHMUI7UUFDekIsSUFBSSxDQUFDMkIsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDQyxj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T0FBTyxLQUFLLElBQUlBLEtBQU0sQ0FBQ0s7WUFDakgsT0FBT25NLG1CQUFtQixDQUFDbU0sUUFBUSxFQUFFLElBQUlsTTtRQUM3QztRQUNKLElBQUksQ0FBQzBHLE1BQU0sR0FDUCxDQUFDb0YsS0FBS3pMLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRcUcsTUFBTSxNQUFNLFFBQVFvRixPQUFPLEtBQUssSUFBSUEsS0FBTSxDQUFDdEYsU0FBU0M7WUFDaEgsT0FBT0EsU0FBUzBGLEtBQUtDLFNBQVMsQ0FBQzVGO1FBQ25DO1FBQ0osSUFBSSxDQUFDeUIsTUFBTSxHQUFHLENBQUM4RCxLQUFLMUwsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVE0SCxNQUFNLE1BQU0sUUFBUThELE9BQU8sS0FBSyxJQUFJQSxLQUFLLElBQUksQ0FBQ3JLLFVBQVUsQ0FBQ3VHLE1BQU0sQ0FBQ29FLElBQUksQ0FBQyxJQUFJLENBQUMzSyxVQUFVO1FBQ2xLLHNCQUFzQjtRQUN0QixJQUFJLElBQUksQ0FBQzBILE1BQU0sRUFBRTtZQUNiLElBQUksS0FBK0MsRUFBRSxFQUVwRDtZQUNELElBQUksQ0FBQ0ssU0FBUyxHQUFHcEosWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFvSixTQUFTO1FBQ3hGO0lBQ0o7QUFDSixFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9SZWFsdGltZUNsaWVudC5qcz82YjZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBXZWJTb2NrZXRGYWN0b3J5IGZyb20gJy4vbGliL3dlYnNvY2tldC1mYWN0b3J5JztcbmltcG9ydCB7IENIQU5ORUxfRVZFTlRTLCBDT05ORUNUSU9OX1NUQVRFLCBERUZBVUxUX1ZFUlNJT04sIERFRkFVTFRfVElNRU9VVCwgU09DS0VUX1NUQVRFUywgVFJBTlNQT1JUUywgVlNOLCBXU19DTE9TRV9OT1JNQUwsIH0gZnJvbSAnLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCBTZXJpYWxpemVyIGZyb20gJy4vbGliL3NlcmlhbGl6ZXInO1xuaW1wb3J0IFRpbWVyIGZyb20gJy4vbGliL3RpbWVyJztcbmltcG9ydCB7IGh0dHBFbmRwb2ludFVSTCB9IGZyb20gJy4vbGliL3RyYW5zZm9ybWVycyc7XG5pbXBvcnQgUmVhbHRpbWVDaGFubmVsIGZyb20gJy4vUmVhbHRpbWVDaGFubmVsJztcbmNvbnN0IG5vb3AgPSAoKSA9PiB7IH07XG4vLyBDb25uZWN0aW9uLXJlbGF0ZWQgY29uc3RhbnRzXG5jb25zdCBDT05ORUNUSU9OX1RJTUVPVVRTID0ge1xuICAgIEhFQVJUQkVBVF9JTlRFUlZBTDogMjUwMDAsXG4gICAgUkVDT05ORUNUX0RFTEFZOiAxMCxcbiAgICBIRUFSVEJFQVRfVElNRU9VVF9GQUxMQkFDSzogMTAwLFxufTtcbmNvbnN0IFJFQ09OTkVDVF9JTlRFUlZBTFMgPSBbMTAwMCwgMjAwMCwgNTAwMCwgMTAwMDBdO1xuY29uc3QgREVGQVVMVF9SRUNPTk5FQ1RfRkFMTEJBQ0sgPSAxMDAwMDtcbmNvbnN0IFdPUktFUl9TQ1JJUFQgPSBgXG4gIGFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChlKSA9PiB7XG4gICAgaWYgKGUuZGF0YS5ldmVudCA9PT0gXCJzdGFydFwiKSB7XG4gICAgICBzZXRJbnRlcnZhbCgoKSA9PiBwb3N0TWVzc2FnZSh7IGV2ZW50OiBcImtlZXBBbGl2ZVwiIH0pLCBlLmRhdGEuaW50ZXJ2YWwpO1xuICAgIH1cbiAgfSk7YDtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlYWx0aW1lQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgU29ja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGVuZFBvaW50IFRoZSBzdHJpbmcgV2ViU29ja2V0IGVuZHBvaW50LCBpZSwgXCJ3czovL2V4YW1wbGUuY29tL3NvY2tldFwiLCBcIndzczovL2V4YW1wbGUuY29tXCIsIFwiL3NvY2tldFwiIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICAgICAqIEBwYXJhbSBodHRwRW5kcG9pbnQgVGhlIHN0cmluZyBIVFRQIGVuZHBvaW50LCBpZSwgXCJodHRwczovL2V4YW1wbGUuY29tXCIsIFwiL1wiIChpbmhlcml0ZWQgaG9zdCAmIHByb3RvY29sKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zcG9ydCBUaGUgV2Vic29ja2V0IFRyYW5zcG9ydCwgZm9yIGV4YW1wbGUgV2ViU29ja2V0LiBUaGlzIGNhbiBiZSBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvblxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRpbWVvdXQgVGhlIGRlZmF1bHQgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gdHJpZ2dlciBwdXNoIHRpbWVvdXRzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnBhcmFtcyBUaGUgb3B0aW9uYWwgcGFyYW1zIHRvIHBhc3Mgd2hlbiBjb25uZWN0aW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYWRlcnMgRGVwcmVjYXRlZDogaGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIHdlYnNvY2tldCBjb25uZWN0aW9ucyBhbmQgdGhpcyBvcHRpb24gd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhcnRiZWF0SW50ZXJ2YWxNcyBUaGUgbWlsbGlzZWMgaW50ZXJ2YWwgdG8gc2VuZCBhIGhlYXJ0YmVhdCBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmhlYXJ0YmVhdENhbGxiYWNrIFRoZSBvcHRpb25hbCBmdW5jdGlvbiB0byBoYW5kbGUgaGVhcnRiZWF0IHN0YXR1cy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5sb2dnZXIgVGhlIG9wdGlvbmFsIGZ1bmN0aW9uIGZvciBzcGVjaWFsaXplZCBsb2dnaW5nLCBpZTogbG9nZ2VyOiAoa2luZCwgbXNnLCBkYXRhKSA9PiB7IGNvbnNvbGUubG9nKGAke2tpbmR9OiAke21zZ31gLCBkYXRhKSB9XG4gICAgICogQHBhcmFtIG9wdGlvbnMubG9nTGV2ZWwgU2V0cyB0aGUgbG9nIGxldmVsIGZvciBSZWFsdGltZVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmVuY29kZSBUaGUgZnVuY3Rpb24gdG8gZW5jb2RlIG91dGdvaW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBKU09OOiAocGF5bG9hZCwgY2FsbGJhY2spID0+IGNhbGxiYWNrKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRlY29kZSBUaGUgZnVuY3Rpb24gdG8gZGVjb2RlIGluY29taW5nIG1lc3NhZ2VzLiBEZWZhdWx0cyB0byBTZXJpYWxpemVyJ3MgZGVjb2RlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlY29ubmVjdEFmdGVyTXMgaGUgb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBtaWxsc2VjIHJlY29ubmVjdCBpbnRlcnZhbC4gRGVmYXVsdHMgdG8gc3RlcHBlZCBiYWNrb2ZmIG9mZi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy53b3JrZXIgVXNlIFdlYiBXb3JrZXIgdG8gc2V0IGEgc2lkZSBmbG93LiBEZWZhdWx0cyB0byBmYWxzZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy53b3JrZXJVcmwgVGhlIFVSTCBvZiB0aGUgd29ya2VyIHNjcmlwdC4gRGVmYXVsdHMgdG8gaHR0cHM6Ly9yZWFsdGltZS5zdXBhYmFzZS5jb20vd29ya2VyLmpzIHRoYXQgaW5jbHVkZXMgYSBoZWFydGJlYXQgZXZlbnQgY2FsbCB0byBrZWVwIHRoZSBjb25uZWN0aW9uIGFsaXZlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGVuZFBvaW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlblZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcGlLZXkgPSBudWxsO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gbmV3IEFycmF5KCk7XG4gICAgICAgIHRoaXMuZW5kUG9pbnQgPSAnJztcbiAgICAgICAgdGhpcy5odHRwRW5kcG9pbnQgPSAnJztcbiAgICAgICAgLyoqIEBkZXByZWNhdGVkIGhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiB3ZWJzb2NrZXQgY29ubmVjdGlvbnMgKi9cbiAgICAgICAgdGhpcy5oZWFkZXJzID0ge307XG4gICAgICAgIHRoaXMucGFyYW1zID0ge307XG4gICAgICAgIHRoaXMudGltZW91dCA9IERFRkFVTFRfVElNRU9VVDtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMgPSBDT05ORUNUSU9OX1RJTUVPVVRTLkhFQVJUQkVBVF9JTlRFUlZBTDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wZW5kaW5nSGVhcnRiZWF0UmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIHRoaXMucmVmID0gMDtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbm9vcDtcbiAgICAgICAgdGhpcy5jb25uID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuc2VyaWFsaXplciA9IG5ldyBTZXJpYWxpemVyKCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBvcGVuOiBbXSxcbiAgICAgICAgICAgIGNsb3NlOiBbXSxcbiAgICAgICAgICAgIGVycm9yOiBbXSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRlID0gJ2Rpc2Nvbm5lY3RlZCc7XG4gICAgICAgIHRoaXMuX3dhc01hbnVhbERpc2Nvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYXV0aFByb21pc2UgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIGVpdGhlciBjdXN0b20gZmV0Y2gsIGlmIHByb3ZpZGVkLCBvciBkZWZhdWx0IGZldGNoIHRvIG1ha2UgSFRUUCByZXF1ZXN0c1xuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuICAgICAgICAgICAgbGV0IF9mZXRjaDtcbiAgICAgICAgICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICAgICAgICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIC8vIE5vZGUuanMgZW52aXJvbm1lbnQgd2l0aG91dCBuYXRpdmUgZmV0Y2hcbiAgICAgICAgICAgICAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT4gaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcpXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCh7IGRlZmF1bHQ6IGZldGNoIH0pID0+IGZldGNoKC4uLmFyZ3MpKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgQHN1cGFiYXNlL25vZGUtZmV0Y2g6ICR7ZXJyb3IubWVzc2FnZX0uIGAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYFRoaXMgaXMgcmVxdWlyZWQgZm9yIEhUVFAgcmVxdWVzdHMgaW4gTm9kZS5qcyBlbnZpcm9ubWVudHMgd2l0aG91dCBuYXRpdmUgZmV0Y2guYCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfZmV0Y2ggPSBmZXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBWYWxpZGF0ZSByZXF1aXJlZCBwYXJhbWV0ZXJzXG4gICAgICAgIGlmICghKChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcGlrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FQSSBrZXkgaXMgcmVxdWlyZWQgdG8gY29ubmVjdCB0byBSZWFsdGltZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gb3B0aW9ucy5wYXJhbXMuYXBpa2V5O1xuICAgICAgICAvLyBJbml0aWFsaXplIGVuZHBvaW50IFVSTHNcbiAgICAgICAgdGhpcy5lbmRQb2ludCA9IGAke2VuZFBvaW50fS8ke1RSQU5TUE9SVFMud2Vic29ja2V0fWA7XG4gICAgICAgIHRoaXMuaHR0cEVuZHBvaW50ID0gaHR0cEVuZHBvaW50VVJMKGVuZFBvaW50KTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3NldHVwUmVjb25uZWN0aW9uVGltZXIoKTtcbiAgICAgICAgdGhpcy5mZXRjaCA9IHRoaXMuX3Jlc29sdmVGZXRjaChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmV0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyB0aGUgc29ja2V0LCB1bmxlc3MgYWxyZWFkeSBjb25uZWN0ZWQuXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgLy8gU2tpcCBpZiBhbHJlYWR5IGNvbm5lY3RpbmcsIGRpc2Nvbm5lY3RpbmcsIG9yIGNvbm5lY3RlZFxuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RpbmcoKSB8fFxuICAgICAgICAgICAgdGhpcy5pc0Rpc2Nvbm5lY3RpbmcoKSB8fFxuICAgICAgICAgICAgKHRoaXMuY29ubiAhPT0gbnVsbCAmJiB0aGlzLmlzQ29ubmVjdGVkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdjb25uZWN0aW5nJyk7XG4gICAgICAgIHRoaXMuX3NldEF1dGhTYWZlbHkoJ2Nvbm5lY3QnKTtcbiAgICAgICAgLy8gRXN0YWJsaXNoIFdlYlNvY2tldCBjb25uZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgLy8gVXNlIGN1c3RvbSB0cmFuc3BvcnQgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgIHRoaXMuY29ubiA9IG5ldyB0aGlzLnRyYW5zcG9ydCh0aGlzLmVuZHBvaW50VVJMKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHVzZSBuYXRpdmUgV2ViU29ja2V0XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubiA9IFdlYlNvY2tldEZhY3RvcnkuY3JlYXRlV2ViU29ja2V0KHRoaXMuZW5kcG9pbnRVUkwoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgLy8gUHJvdmlkZSBoZWxwZnVsIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gZW52aXJvbm1lbnRcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JNZXNzYWdlLmluY2x1ZGVzKCdOb2RlLmpzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2Vycm9yTWVzc2FnZX1cXG5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdUbyB1c2UgUmVhbHRpbWUgaW4gTm9kZS5qcywgeW91IG5lZWQgdG8gcHJvdmlkZSBhIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbjpcXG5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcHRpb24gMTogVXNlIE5vZGUuanMgMjIrIHdoaWNoIGhhcyBuYXRpdmUgV2ViU29ja2V0IHN1cHBvcnRcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdPcHRpb24gMjogSW5zdGFsbCBhbmQgcHJvdmlkZSB0aGUgXCJ3c1wiIHBhY2thZ2U6XFxuXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICBucG0gaW5zdGFsbCB3c1xcblxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAgaW1wb3J0IHdzIGZyb20gXCJ3c1wiXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICBjb25zdCBjbGllbnQgPSBuZXcgUmVhbHRpbWVDbGllbnQodXJsLCB7XFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICAgIC4uLm9wdGlvbnMsXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnICAgIHRyYW5zcG9ydDogd3NcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgIH0pJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV2ViU29ja2V0IG5vdCBhdmFpbGFibGU6ICR7ZXJyb3JNZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldHVwQ29ubmVjdGlvbkhhbmRsZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFVSTCBvZiB0aGUgd2Vic29ja2V0LlxuICAgICAqIEByZXR1cm5zIHN0cmluZyBUaGUgVVJMIG9mIHRoZSB3ZWJzb2NrZXQuXG4gICAgICovXG4gICAgZW5kcG9pbnRVUkwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBlbmRQYXJhbXModGhpcy5lbmRQb2ludCwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXJhbXMsIHsgdnNuOiBWU04gfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvZGUgQSBudW1lcmljIHN0YXR1cyBjb2RlIHRvIHNlbmQgb24gZGlzY29ubmVjdC5cbiAgICAgKiBAcGFyYW0gcmVhc29uIEEgY3VzdG9tIHJlYXNvbiBmb3IgdGhlIGRpc2Nvbm5lY3QuXG4gICAgICovXG4gICAgZGlzY29ubmVjdChjb2RlLCByZWFzb24pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNjb25uZWN0aW5nKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RpbmcnLCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubikge1xuICAgICAgICAgICAgLy8gU2V0dXAgZmFsbGJhY2sgdGltZXIgdG8gcHJldmVudCBoYW5naW5nIGluIGRpc2Nvbm5lY3Rpbmcgc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChmYWxsYmFja1RpbWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENsb3NlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICAgICAgICAgICAgaWYgKGNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm4uY2xvc2UoY29kZSwgcmVhc29uICE9PSBudWxsICYmIHJlYXNvbiAhPT0gdm9pZCAwID8gcmVhc29uIDogJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90ZWFyZG93bkNvbm5lY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldENvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgY3JlYXRlZCBjaGFubmVsc1xuICAgICAqL1xuICAgIGdldENoYW5uZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFubmVscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIGEgc2luZ2xlIGNoYW5uZWxcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBBIFJlYWx0aW1lQ2hhbm5lbCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUNoYW5uZWwoY2hhbm5lbCkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBhd2FpdCBjaGFubmVsLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIGFsbCBjaGFubmVsc1xuICAgICAqL1xuICAgIGFzeW5jIHJlbW92ZUFsbENoYW5uZWxzKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXNfMSA9IGF3YWl0IFByb21pc2UuYWxsKHRoaXMuY2hhbm5lbHMubWFwKChjaGFubmVsKSA9PiBjaGFubmVsLnVuc3Vic2NyaWJlKCkpKTtcbiAgICAgICAgdGhpcy5jaGFubmVscyA9IFtdO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlc18xO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dzIHRoZSBtZXNzYWdlLlxuICAgICAqXG4gICAgICogRm9yIGN1c3RvbWl6ZWQgbG9nZ2luZywgYHRoaXMubG9nZ2VyYCBjYW4gYmUgb3ZlcnJpZGRlbi5cbiAgICAgKi9cbiAgICBsb2coa2luZCwgbXNnLCBkYXRhKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyKGtpbmQsIG1zZywgZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHNvY2tldC5cbiAgICAgKi9cbiAgICBjb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5jb25uICYmIHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFNPQ0tFVF9TVEFURVMuY29ubmVjdGluZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ09OTkVDVElPTl9TVEFURS5Db25uZWN0aW5nO1xuICAgICAgICAgICAgY2FzZSBTT0NLRVRfU1RBVEVTLm9wZW46XG4gICAgICAgICAgICAgICAgcmV0dXJuIENPTk5FQ1RJT05fU1RBVEUuT3BlbjtcbiAgICAgICAgICAgIGNhc2UgU09DS0VUX1NUQVRFUy5jbG9zaW5nOlxuICAgICAgICAgICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLkNsb3Npbmc7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBDT05ORUNUSU9OX1NUQVRFLkNsb3NlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpcyB0aGUgY29ubmVjdGlvbiBpcyBvcGVuLlxuICAgICAqL1xuICAgIGlzQ29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uU3RhdGUoKSA9PT0gQ09OTkVDVElPTl9TVEFURS5PcGVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgY29ubmVjdGlvbiBpcyBjdXJyZW50bHkgY29ubmVjdGluZy5cbiAgICAgKi9cbiAgICBpc0Nvbm5lY3RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPT09ICdjb25uZWN0aW5nJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvbm5lY3Rpb24gaXMgY3VycmVudGx5IGRpc2Nvbm5lY3RpbmcuXG4gICAgICovXG4gICAgaXNEaXNjb25uZWN0aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblN0YXRlID09PSAnZGlzY29ubmVjdGluZyc7XG4gICAgfVxuICAgIGNoYW5uZWwodG9waWMsIHBhcmFtcyA9IHsgY29uZmlnOiB7fSB9KSB7XG4gICAgICAgIGNvbnN0IHJlYWx0aW1lVG9waWMgPSBgcmVhbHRpbWU6JHt0b3BpY31gO1xuICAgICAgICBjb25zdCBleGlzdHMgPSB0aGlzLmdldENoYW5uZWxzKCkuZmluZCgoYykgPT4gYy50b3BpYyA9PT0gcmVhbHRpbWVUb3BpYyk7XG4gICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuID0gbmV3IFJlYWx0aW1lQ2hhbm5lbChgcmVhbHRpbWU6JHt0b3BpY31gLCBwYXJhbXMsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jaGFubmVscy5wdXNoKGNoYW4pO1xuICAgICAgICAgICAgcmV0dXJuIGNoYW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2ggb3V0IGEgbWVzc2FnZSBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBzb2NrZXQgaXMgbm90IGNvbm5lY3RlZCwgdGhlIG1lc3NhZ2UgZ2V0cyBlbnF1ZXVlZCB3aXRoaW4gYSBsb2NhbCBidWZmZXIsIGFuZCBzZW50IG91dCB3aGVuIGEgY29ubmVjdGlvbiBpcyBuZXh0IGVzdGFibGlzaGVkLlxuICAgICAqL1xuICAgIHB1c2goZGF0YSkge1xuICAgICAgICBjb25zdCB7IHRvcGljLCBldmVudCwgcGF5bG9hZCwgcmVmIH0gPSBkYXRhO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5jb2RlKGRhdGEsIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5jb25uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZChyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9nKCdwdXNoJywgYCR7dG9waWN9ICR7ZXZlbnR9ICgke3JlZn0pYCwgcGF5bG9hZCk7XG4gICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgSldUIGFjY2VzcyB0b2tlbiB1c2VkIGZvciBjaGFubmVsIHN1YnNjcmlwdGlvbiBhdXRob3JpemF0aW9uIGFuZCBSZWFsdGltZSBSTFMuXG4gICAgICpcbiAgICAgKiBJZiBwYXJhbSBpcyBudWxsIGl0IHdpbGwgdXNlIHRoZSBgYWNjZXNzVG9rZW5gIGNhbGxiYWNrIGZ1bmN0aW9uIG9yIHRoZSB0b2tlbiBzZXQgb24gdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIE9uIGNhbGxiYWNrIHVzZWQsIGl0IHdpbGwgc2V0IHRoZSB2YWx1ZSBvZiB0aGUgdG9rZW4gaW50ZXJuYWwgdG8gdGhlIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbiBBIEpXVCBzdHJpbmcgdG8gb3ZlcnJpZGUgdGhlIHRva2VuIHNldCBvbiB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIGFzeW5jIHNldEF1dGgodG9rZW4gPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2F1dGhQcm9taXNlID0gdGhpcy5fcGVyZm9ybUF1dGgodG9rZW4pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fYXV0aFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9hdXRoUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBoZWFydGJlYXQgbWVzc2FnZSBpZiB0aGUgc29ja2V0IGlzIGNvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBhc3luYyBzZW5kSGVhcnRiZWF0KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2soJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCAnZXJyb3IgaW4gaGVhcnRiZWF0IGNhbGxiYWNrJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIGhlYXJ0YmVhdCB0aW1lb3V0IGFuZCBmb3JjZSByZWNvbm5lY3Rpb24gaWYgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgJ2hlYXJ0YmVhdCB0aW1lb3V0LiBBdHRlbXB0aW5nIHRvIHJlLWVzdGFibGlzaCBjb25uZWN0aW9uJyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0Q2FsbGJhY2soJ3RpbWVvdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgJ2Vycm9yIGluIGhlYXJ0YmVhdCBjYWxsYmFjaycsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9yY2UgcmVjb25uZWN0aW9uIGFmdGVyIGhlYXJ0YmVhdCB0aW1lb3V0XG4gICAgICAgICAgICB0aGlzLl93YXNNYW51YWxEaXNjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmNvbm4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZShXU19DTE9TRV9OT1JNQUwsICdoZWFydGJlYXQgdGltZW91dCcpO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucmVjb25uZWN0VGltZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBDT05ORUNUSU9OX1RJTUVPVVRTLkhFQVJUQkVBVF9USU1FT1VUX0ZBTExCQUNLKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZW5kIGhlYXJ0YmVhdCBtZXNzYWdlIHRvIHNlcnZlclxuICAgICAgICB0aGlzLnBlbmRpbmdIZWFydGJlYXRSZWYgPSB0aGlzLl9tYWtlUmVmKCk7XG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICB0b3BpYzogJ3Bob2VuaXgnLFxuICAgICAgICAgICAgZXZlbnQ6ICdoZWFydGJlYXQnLFxuICAgICAgICAgICAgcGF5bG9hZDoge30sXG4gICAgICAgICAgICByZWY6IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZixcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmhlYXJ0YmVhdENhbGxiYWNrKCdzZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsICdlcnJvciBpbiBoZWFydGJlYXQgY2FsbGJhY2snLCBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRBdXRoU2FmZWx5KCdoZWFydGJlYXQnKTtcbiAgICB9XG4gICAgb25IZWFydGJlYXQoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIHNlbmQgYnVmZmVyXG4gICAgICovXG4gICAgZmx1c2hTZW5kQnVmZmVyKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCgpICYmIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKCkpO1xuICAgICAgICAgICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBuZXh0IG1lc3NhZ2UgcmVmLCBhY2NvdW50aW5nIGZvciBvdmVyZmxvd3NcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF9tYWtlUmVmKCkge1xuICAgICAgICBsZXQgbmV3UmVmID0gdGhpcy5yZWYgKyAxO1xuICAgICAgICBpZiAobmV3UmVmID09PSB0aGlzLnJlZikge1xuICAgICAgICAgICAgdGhpcy5yZWYgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWYgPSBuZXdSZWY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVmLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gY2hhbm5lbHMgd2l0aCB0aGUgc3BlY2lmaWVkIHRvcGljLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2xlYXZlT3BlblRvcGljKHRvcGljKSB7XG4gICAgICAgIGxldCBkdXBDaGFubmVsID0gdGhpcy5jaGFubmVscy5maW5kKChjKSA9PiBjLnRvcGljID09PSB0b3BpYyAmJiAoYy5faXNKb2luZWQoKSB8fCBjLl9pc0pvaW5pbmcoKSkpO1xuICAgICAgICBpZiAoZHVwQ2hhbm5lbCkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsIGBsZWF2aW5nIGR1cGxpY2F0ZSB0b3BpYyBcIiR7dG9waWN9XCJgKTtcbiAgICAgICAgICAgIGR1cENoYW5uZWwudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc3Vic2NyaXB0aW9uIGZyb20gdGhlIHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFubmVsIEFuIG9wZW4gc3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3JlbW92ZShjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSB0aGlzLmNoYW5uZWxzLmZpbHRlcigoYykgPT4gYy50b3BpYyAhPT0gY2hhbm5lbC50b3BpYyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfb25Db25uTWVzc2FnZShyYXdNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuZGVjb2RlKHJhd01lc3NhZ2UuZGF0YSwgKG1zZykgPT4ge1xuICAgICAgICAgICAgLy8gSGFuZGxlIGhlYXJ0YmVhdCByZXNwb25zZXNcbiAgICAgICAgICAgIGlmIChtc2cudG9waWMgPT09ICdwaG9lbml4JyAmJiBtc2cuZXZlbnQgPT09ICdwaHhfcmVwbHknKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjayhtc2cucGF5bG9hZC5zdGF0dXMgPT09ICdvaycgPyAnb2snIDogJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKCdlcnJvcicsICdlcnJvciBpbiBoZWFydGJlYXQgY2FsbGJhY2snLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgcGVuZGluZyBoZWFydGJlYXQgcmVmZXJlbmNlIGNsZWFudXBcbiAgICAgICAgICAgIGlmIChtc2cucmVmICYmIG1zZy5yZWYgPT09IHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0hlYXJ0YmVhdFJlZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMb2cgaW5jb21pbmcgbWVzc2FnZVxuICAgICAgICAgICAgY29uc3QgeyB0b3BpYywgZXZlbnQsIHBheWxvYWQsIHJlZiB9ID0gbXNnO1xuICAgICAgICAgICAgY29uc3QgcmVmU3RyaW5nID0gcmVmID8gYCgke3JlZn0pYCA6ICcnO1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gcGF5bG9hZC5zdGF0dXMgfHwgJyc7XG4gICAgICAgICAgICB0aGlzLmxvZygncmVjZWl2ZScsIGAke3N0YXR1c30gJHt0b3BpY30gJHtldmVudH0gJHtyZWZTdHJpbmd9YC50cmltKCksIHBheWxvYWQpO1xuICAgICAgICAgICAgLy8gUm91dGUgbWVzc2FnZSB0byBhcHByb3ByaWF0ZSBjaGFubmVsc1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGNoYW5uZWwpID0+IGNoYW5uZWwuX2lzTWVtYmVyKHRvcGljKSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoY2hhbm5lbCkgPT4gY2hhbm5lbC5fdHJpZ2dlcihldmVudCwgcGF5bG9hZCwgcmVmKSk7XG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyU3RhdGVDYWxsYmFja3MoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXIgc3BlY2lmaWMgdGltZXJcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfY2xlYXJUaW1lcih0aW1lcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aW1lciA9PT0gJ2hlYXJ0YmVhdCcgJiYgdGhpcy5oZWFydGJlYXRUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGltZXIgPT09ICdyZWNvbm5lY3QnKSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnJlY29ubmVjdFRpbWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgdGltZXJzXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX2NsZWFyQWxsVGltZXJzKCkge1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVyKCdoZWFydGJlYXQnKTtcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lcigncmVjb25uZWN0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHVwIGNvbm5lY3Rpb24gaGFuZGxlcnMgZm9yIFdlYlNvY2tldCBldmVudHNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfc2V0dXBDb25uZWN0aW9uSGFuZGxlcnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBTZXQgYmluYXJ5IHR5cGUgaWYgc3VwcG9ydGVkIChicm93c2VycyBhbmQgbW9zdCBXZWJTb2NrZXQgaW1wbGVtZW50YXRpb25zKVxuICAgICAgICBpZiAoJ2JpbmFyeVR5cGUnIGluIHRoaXMuY29ubikge1xuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdGhpcy5jb25uLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSAoKSA9PiB0aGlzLl9vbkNvbm5PcGVuKCk7XG4gICAgICAgIHRoaXMuY29ubi5vbmVycm9yID0gKGVycm9yKSA9PiB0aGlzLl9vbkNvbm5FcnJvcihlcnJvcik7XG4gICAgICAgIHRoaXMuY29ubi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHRoaXMuX29uQ29ubk1lc3NhZ2UoZXZlbnQpO1xuICAgICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IChldmVudCkgPT4gdGhpcy5fb25Db25uQ2xvc2UoZXZlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZWFyZG93biBjb25uZWN0aW9uIGFuZCBjbGVhbnVwIHJlc291cmNlc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIF90ZWFyZG93bkNvbm5lY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm4pIHtcbiAgICAgICAgICAgIHRoaXMuY29ubi5vbm9wZW4gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb25uLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb25uLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbm4ub25jbG9zZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmNvbm4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsZWFyQWxsVGltZXJzKCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHMuZm9yRWFjaCgoY2hhbm5lbCkgPT4gY2hhbm5lbC50ZWFyZG93bigpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbkNvbm5PcGVuKCkge1xuICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Nvbm5lY3RlZCcpO1xuICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgYGNvbm5lY3RlZCB0byAke3RoaXMuZW5kcG9pbnRVUkwoKX1gKTtcbiAgICAgICAgdGhpcy5mbHVzaFNlbmRCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lcigncmVjb25uZWN0Jyk7XG4gICAgICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0SGVhcnRiZWF0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMud29ya2VyUmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRXb3JrZXJIZWFydGJlYXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90cmlnZ2VyU3RhdGVDYWxsYmFja3MoJ29wZW4nKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9zdGFydEhlYXJ0YmVhdCgpIHtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRUaW1lciAmJiBjbGVhckludGVydmFsKHRoaXMuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5zZW5kSGVhcnRiZWF0KCksIHRoaXMuaGVhcnRiZWF0SW50ZXJ2YWxNcyk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfc3RhcnRXb3JrZXJIZWFydGJlYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtlclVybCkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3dvcmtlcicsIGBzdGFydGluZyB3b3JrZXIgZm9yIGZyb20gJHt0aGlzLndvcmtlclVybH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nKCd3b3JrZXInLCBgc3RhcnRpbmcgZGVmYXVsdCB3b3JrZXJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYmplY3RVcmwgPSB0aGlzLl93b3JrZXJPYmplY3RVcmwodGhpcy53b3JrZXJVcmwpO1xuICAgICAgICB0aGlzLndvcmtlclJlZiA9IG5ldyBXb3JrZXIob2JqZWN0VXJsKTtcbiAgICAgICAgdGhpcy53b3JrZXJSZWYub25lcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coJ3dvcmtlcicsICd3b3JrZXIgZXJyb3InLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMud29ya2VyUmVmLnRlcm1pbmF0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlclJlZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5kYXRhLmV2ZW50ID09PSAna2VlcEFsaXZlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZEhlYXJ0YmVhdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlclJlZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBldmVudDogJ3N0YXJ0JyxcbiAgICAgICAgICAgIGludGVydmFsOiB0aGlzLmhlYXJ0YmVhdEludGVydmFsTXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgX29uQ29ubkNsb3NlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5fc2V0Q29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgdGhpcy5sb2coJ3RyYW5zcG9ydCcsICdjbG9zZScsIGV2ZW50KTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5FcnJvcigpO1xuICAgICAgICB0aGlzLl9jbGVhclRpbWVyKCdoZWFydGJlYXQnKTtcbiAgICAgICAgLy8gT25seSBzY2hlZHVsZSByZWNvbm5lY3Rpb24gaWYgaXQgd2Fzbid0IGEgbWFudWFsIGRpc2Nvbm5lY3RcbiAgICAgICAgaWYgKCF0aGlzLl93YXNNYW51YWxEaXNjb25uZWN0KSB7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnJlY29ubmVjdFRpbWVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2NoZWR1bGVUaW1lb3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJpZ2dlclN0YXRlQ2FsbGJhY2tzKCdjbG9zZScsIGV2ZW50KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9vbkNvbm5FcnJvcihlcnJvcikge1xuICAgICAgICB0aGlzLl9zZXRDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICB0aGlzLmxvZygndHJhbnNwb3J0JywgYCR7ZXJyb3J9YCk7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJDaGFuRXJyb3IoKTtcbiAgICAgICAgdGhpcy5fdHJpZ2dlclN0YXRlQ2FsbGJhY2tzKCdlcnJvcicsIGVycm9yKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF90cmlnZ2VyQ2hhbkVycm9yKCkge1xuICAgICAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IGNoYW5uZWwuX3RyaWdnZXIoQ0hBTk5FTF9FVkVOVFMuZXJyb3IpKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIF9hcHBlbmRQYXJhbXModXJsLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHVybC5tYXRjaCgvXFw/LykgPyAnJicgOiAnPyc7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhwYXJhbXMpO1xuICAgICAgICByZXR1cm4gYCR7dXJsfSR7cHJlZml4fSR7cXVlcnl9YDtcbiAgICB9XG4gICAgX3dvcmtlck9iamVjdFVybCh1cmwpIHtcbiAgICAgICAgbGV0IHJlc3VsdF91cmw7XG4gICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgIHJlc3VsdF91cmwgPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW1dPUktFUl9TQ1JJUFRdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KTtcbiAgICAgICAgICAgIHJlc3VsdF91cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRfdXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgY29ubmVjdGlvbiBzdGF0ZSB3aXRoIHByb3BlciBzdGF0ZSBtYW5hZ2VtZW50XG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3NldENvbm5lY3Rpb25TdGF0ZShzdGF0ZSwgbWFudWFsID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdGlvblN0YXRlID0gc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl93YXNNYW51YWxEaXNjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgdGhpcy5fd2FzTWFudWFsRGlzY29ubmVjdCA9IG1hbnVhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIHRoZSBhY3R1YWwgYXV0aCBvcGVyYXRpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyBfcGVyZm9ybUF1dGgodG9rZW4gPSBudWxsKSB7XG4gICAgICAgIGxldCB0b2tlblRvU2VuZDtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICB0b2tlblRvU2VuZCA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIEFsd2F5cyBjYWxsIHRoZSBhY2Nlc3NUb2tlbiBjYWxsYmFjayB0byBnZXQgZnJlc2ggdG9rZW5cbiAgICAgICAgICAgIHRva2VuVG9TZW5kID0gYXdhaXQgdGhpcy5hY2Nlc3NUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9rZW5Ub1NlbmQgPSB0aGlzLmFjY2Vzc1Rva2VuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW5WYWx1ZSAhPSB0b2tlblRvU2VuZCkge1xuICAgICAgICAgICAgdGhpcy5hY2Nlc3NUb2tlblZhbHVlID0gdG9rZW5Ub1NlbmQ7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxzLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NfdG9rZW46IHRva2VuVG9TZW5kLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBERUZBVUxUX1ZFUlNJT04sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0b2tlblRvU2VuZCAmJiBjaGFubmVsLnVwZGF0ZUpvaW5QYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFubmVsLmpvaW5lZE9uY2UgJiYgY2hhbm5lbC5faXNKb2luZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsLl9wdXNoKENIQU5ORUxfRVZFTlRTLmFjY2Vzc190b2tlbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiB0b2tlblRvU2VuZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2FpdCBmb3IgYW55IGluLWZsaWdodCBhdXRoIG9wZXJhdGlvbnMgdG8gY29tcGxldGVcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhc3luYyBfd2FpdEZvckF1dGhJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F1dGhQcm9taXNlKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9hdXRoUHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYWZlbHkgY2FsbCBzZXRBdXRoIHdpdGggc3RhbmRhcmRpemVkIGVycm9yIGhhbmRsaW5nXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgX3NldEF1dGhTYWZlbHkoY29udGV4dCA9ICdnZW5lcmFsJykge1xuICAgICAgICB0aGlzLnNldEF1dGgoKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgYGVycm9yIHNldHRpbmcgYXV0aCBpbiAke2NvbnRleHR9YCwgZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIHN0YXRlIGNoYW5nZSBjYWxsYmFja3Mgd2l0aCBwcm9wZXIgZXJyb3IgaGFuZGxpbmdcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfdHJpZ2dlclN0YXRlQ2FsbGJhY2tzKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlQ2FsbGJhY2tzW2V2ZW50XS5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZygnZXJyb3InLCBgZXJyb3IgaW4gJHtldmVudH0gY2FsbGJhY2tgLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5sb2coJ2Vycm9yJywgYGVycm9yIHRyaWdnZXJpbmcgJHtldmVudH0gY2FsbGJhY2tzYCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0dXAgcmVjb25uZWN0aW9uIHRpbWVyIHdpdGggcHJvcGVyIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfc2V0dXBSZWNvbm5lY3Rpb25UaW1lcigpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lciA9IG5ldyBUaW1lcihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl93YWl0Rm9yQXV0aElmTmVlZGVkKCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgQ09OTkVDVElPTl9USU1FT1VUUy5SRUNPTk5FQ1RfREVMQVkpO1xuICAgICAgICB9LCB0aGlzLnJlY29ubmVjdEFmdGVyTXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGNsaWVudCBvcHRpb25zIHdpdGggZGVmYXVsdHNcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcbiAgICAgICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgICAgIHRoaXMudHJhbnNwb3J0ID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zcG9ydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRpbWVvdXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IERFRkFVTFRfVElNRU9VVDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbE1zID1cbiAgICAgICAgICAgIChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFydGJlYXRJbnRlcnZhbE1zKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBDT05ORUNUSU9OX1RJTUVPVVRTLkhFQVJUQkVBVF9JTlRFUlZBTDtcbiAgICAgICAgdGhpcy53b3JrZXIgPSAoX2QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud29ya2VyKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hY2Nlc3NUb2tlbikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbnVsbDtcbiAgICAgICAgdGhpcy5oZWFydGJlYXRDYWxsYmFjayA9IChfZiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFydGJlYXRDYWxsYmFjaykgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogbm9vcDtcbiAgICAgICAgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZXNcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpXG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IG9wdGlvbnMucGFyYW1zO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvZ2dlcilcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gb3B0aW9ucy5sb2dnZXI7XG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvZ0xldmVsKSB8fCAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxvZ19sZXZlbCkpIHtcbiAgICAgICAgICAgIHRoaXMubG9nTGV2ZWwgPSBvcHRpb25zLmxvZ0xldmVsIHx8IG9wdGlvbnMubG9nX2xldmVsO1xuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGFyYW1zKSwgeyBsb2dfbGV2ZWw6IHRoaXMubG9nTGV2ZWwgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHVwIGZ1bmN0aW9ucyB3aXRoIGRlZmF1bHRzXG4gICAgICAgIHRoaXMucmVjb25uZWN0QWZ0ZXJNcyA9XG4gICAgICAgICAgICAoX2cgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVjb25uZWN0QWZ0ZXJNcykgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogKCh0cmllcykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBSRUNPTk5FQ1RfSU5URVJWQUxTW3RyaWVzIC0gMV0gfHwgREVGQVVMVF9SRUNPTk5FQ1RfRkFMTEJBQ0s7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbmNvZGUgPVxuICAgICAgICAgICAgKF9oID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVuY29kZSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogKChwYXlsb2FkLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWNvZGUgPSAoX2ogPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVjb2RlKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiB0aGlzLnNlcmlhbGl6ZXIuZGVjb2RlLmJpbmQodGhpcy5zZXJpYWxpemVyKTtcbiAgICAgICAgLy8gSGFuZGxlIHdvcmtlciBzZXR1cFxuICAgICAgICBpZiAodGhpcy53b3JrZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93Lldvcmtlcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViIFdvcmtlciBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndvcmtlclVybCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53b3JrZXJVcmw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFsdGltZUNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiV2ViU29ja2V0RmFjdG9yeSIsIkNIQU5ORUxfRVZFTlRTIiwiQ09OTkVDVElPTl9TVEFURSIsIkRFRkFVTFRfVkVSU0lPTiIsIkRFRkFVTFRfVElNRU9VVCIsIlNPQ0tFVF9TVEFURVMiLCJUUkFOU1BPUlRTIiwiVlNOIiwiV1NfQ0xPU0VfTk9STUFMIiwiU2VyaWFsaXplciIsIlRpbWVyIiwiaHR0cEVuZHBvaW50VVJMIiwiUmVhbHRpbWVDaGFubmVsIiwibm9vcCIsIkNPTk5FQ1RJT05fVElNRU9VVFMiLCJIRUFSVEJFQVRfSU5URVJWQUwiLCJSRUNPTk5FQ1RfREVMQVkiLCJIRUFSVEJFQVRfVElNRU9VVF9GQUxMQkFDSyIsIlJFQ09OTkVDVF9JTlRFUlZBTFMiLCJERUZBVUxUX1JFQ09OTkVDVF9GQUxMQkFDSyIsIldPUktFUl9TQ1JJUFQiLCJSZWFsdGltZUNsaWVudCIsImNvbnN0cnVjdG9yIiwiZW5kUG9pbnQiLCJvcHRpb25zIiwiX2EiLCJhY2Nlc3NUb2tlblZhbHVlIiwiYXBpS2V5IiwiY2hhbm5lbHMiLCJBcnJheSIsImh0dHBFbmRwb2ludCIsImhlYWRlcnMiLCJwYXJhbXMiLCJ0aW1lb3V0IiwidHJhbnNwb3J0IiwiaGVhcnRiZWF0SW50ZXJ2YWxNcyIsImhlYXJ0YmVhdFRpbWVyIiwidW5kZWZpbmVkIiwicGVuZGluZ0hlYXJ0YmVhdFJlZiIsImhlYXJ0YmVhdENhbGxiYWNrIiwicmVmIiwicmVjb25uZWN0VGltZXIiLCJsb2dnZXIiLCJjb25uIiwic2VuZEJ1ZmZlciIsInNlcmlhbGl6ZXIiLCJzdGF0ZUNoYW5nZUNhbGxiYWNrcyIsIm9wZW4iLCJjbG9zZSIsImVycm9yIiwibWVzc2FnZSIsImFjY2Vzc1Rva2VuIiwiX2Nvbm5lY3Rpb25TdGF0ZSIsIl93YXNNYW51YWxEaXNjb25uZWN0IiwiX2F1dGhQcm9taXNlIiwiX3Jlc29sdmVGZXRjaCIsImN1c3RvbUZldGNoIiwiX2ZldGNoIiwiZmV0Y2giLCJhcmdzIiwidGhlbiIsImRlZmF1bHQiLCJjYXRjaCIsIkVycm9yIiwiYXBpa2V5Iiwid2Vic29ja2V0IiwiX2luaXRpYWxpemVPcHRpb25zIiwiX3NldHVwUmVjb25uZWN0aW9uVGltZXIiLCJjb25uZWN0IiwiaXNDb25uZWN0aW5nIiwiaXNEaXNjb25uZWN0aW5nIiwiaXNDb25uZWN0ZWQiLCJfc2V0Q29ubmVjdGlvblN0YXRlIiwiX3NldEF1dGhTYWZlbHkiLCJlbmRwb2ludFVSTCIsImNyZWF0ZVdlYlNvY2tldCIsImVycm9yTWVzc2FnZSIsImluY2x1ZGVzIiwiX3NldHVwQ29ubmVjdGlvbkhhbmRsZXJzIiwiX2FwcGVuZFBhcmFtcyIsIk9iamVjdCIsImFzc2lnbiIsInZzbiIsImRpc2Nvbm5lY3QiLCJjb2RlIiwicmVhc29uIiwiZmFsbGJhY2tUaW1lciIsInNldFRpbWVvdXQiLCJvbmNsb3NlIiwiY2xlYXJUaW1lb3V0IiwiX3RlYXJkb3duQ29ubmVjdGlvbiIsImdldENoYW5uZWxzIiwicmVtb3ZlQ2hhbm5lbCIsImNoYW5uZWwiLCJzdGF0dXMiLCJ1bnN1YnNjcmliZSIsImxlbmd0aCIsInJlbW92ZUFsbENoYW5uZWxzIiwidmFsdWVzXzEiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwibG9nIiwia2luZCIsIm1zZyIsImRhdGEiLCJjb25uZWN0aW9uU3RhdGUiLCJyZWFkeVN0YXRlIiwiY29ubmVjdGluZyIsIkNvbm5lY3RpbmciLCJPcGVuIiwiY2xvc2luZyIsIkNsb3NpbmciLCJDbG9zZWQiLCJ0b3BpYyIsImNvbmZpZyIsInJlYWx0aW1lVG9waWMiLCJleGlzdHMiLCJmaW5kIiwiYyIsImNoYW4iLCJwdXNoIiwiZXZlbnQiLCJwYXlsb2FkIiwiY2FsbGJhY2siLCJlbmNvZGUiLCJyZXN1bHQiLCJzZW5kIiwic2V0QXV0aCIsInRva2VuIiwiX3BlcmZvcm1BdXRoIiwic2VuZEhlYXJ0YmVhdCIsImUiLCJzY2hlZHVsZVRpbWVvdXQiLCJfbWFrZVJlZiIsIm9uSGVhcnRiZWF0IiwiZmx1c2hTZW5kQnVmZmVyIiwiZm9yRWFjaCIsIm5ld1JlZiIsInRvU3RyaW5nIiwiX2xlYXZlT3BlblRvcGljIiwiZHVwQ2hhbm5lbCIsIl9pc0pvaW5lZCIsIl9pc0pvaW5pbmciLCJfcmVtb3ZlIiwiZmlsdGVyIiwiX29uQ29ubk1lc3NhZ2UiLCJyYXdNZXNzYWdlIiwiZGVjb2RlIiwicmVmU3RyaW5nIiwidHJpbSIsIl9pc01lbWJlciIsIl90cmlnZ2VyIiwiX3RyaWdnZXJTdGF0ZUNhbGxiYWNrcyIsIl9jbGVhclRpbWVyIiwidGltZXIiLCJjbGVhckludGVydmFsIiwicmVzZXQiLCJfY2xlYXJBbGxUaW1lcnMiLCJiaW5hcnlUeXBlIiwib25vcGVuIiwiX29uQ29ubk9wZW4iLCJvbmVycm9yIiwiX29uQ29ubkVycm9yIiwib25tZXNzYWdlIiwiX29uQ29ubkNsb3NlIiwidGVhcmRvd24iLCJ3b3JrZXIiLCJfc3RhcnRIZWFydGJlYXQiLCJ3b3JrZXJSZWYiLCJfc3RhcnRXb3JrZXJIZWFydGJlYXQiLCJzZXRJbnRlcnZhbCIsIndvcmtlclVybCIsIm9iamVjdFVybCIsIl93b3JrZXJPYmplY3RVcmwiLCJXb3JrZXIiLCJ0ZXJtaW5hdGUiLCJwb3N0TWVzc2FnZSIsImludGVydmFsIiwiX3RyaWdnZXJDaGFuRXJyb3IiLCJ1cmwiLCJrZXlzIiwicHJlZml4IiwibWF0Y2giLCJxdWVyeSIsIlVSTFNlYXJjaFBhcmFtcyIsInJlc3VsdF91cmwiLCJibG9iIiwiQmxvYiIsInR5cGUiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJzdGF0ZSIsIm1hbnVhbCIsInRva2VuVG9TZW5kIiwiYWNjZXNzX3Rva2VuIiwidmVyc2lvbiIsInVwZGF0ZUpvaW5QYXlsb2FkIiwiam9pbmVkT25jZSIsIl9wdXNoIiwiX3dhaXRGb3JBdXRoSWZOZWVkZWQiLCJjb250ZXh0IiwicmVjb25uZWN0QWZ0ZXJNcyIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiX2YiLCJfZyIsIl9oIiwiX2oiLCJsb2dMZXZlbCIsImxvZ19sZXZlbCIsInRyaWVzIiwiSlNPTiIsInN0cmluZ2lmeSIsImJpbmQiLCJ3aW5kb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* binding */ REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   \"default\": () => (/* binding */ RealtimePresence)\n/* harmony export */ });\n/*\n  This file draws heavily from https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/assets/js/phoenix/presence.js\n  License: https://github.com/phoenixframework/phoenix/blob/d344ec0a732ab4ee204215b31de69cf4be72e3bf/LICENSE.md\n*/ var REALTIME_PRESENCE_LISTEN_EVENTS;\n(function(REALTIME_PRESENCE_LISTEN_EVENTS) {\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"SYNC\"] = \"sync\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"JOIN\"] = \"join\";\n    REALTIME_PRESENCE_LISTEN_EVENTS[\"LEAVE\"] = \"leave\";\n})(REALTIME_PRESENCE_LISTEN_EVENTS || (REALTIME_PRESENCE_LISTEN_EVENTS = {}));\nclass RealtimePresence {\n    /**\n     * Initializes the Presence.\n     *\n     * @param channel - The RealtimeChannel\n     * @param opts - The options,\n     *        for example `{events: {state: 'state', diff: 'diff'}}`\n     */ constructor(channel, opts){\n        this.channel = channel;\n        this.state = {};\n        this.pendingDiffs = [];\n        this.joinRef = null;\n        this.enabled = false;\n        this.caller = {\n            onJoin: ()=>{},\n            onLeave: ()=>{},\n            onSync: ()=>{}\n        };\n        const events = (opts === null || opts === void 0 ? void 0 : opts.events) || {\n            state: \"presence_state\",\n            diff: \"presence_diff\"\n        };\n        this.channel._on(events.state, {}, (newState)=>{\n            const { onJoin, onLeave, onSync } = this.caller;\n            this.joinRef = this.channel._joinRef();\n            this.state = RealtimePresence.syncState(this.state, newState, onJoin, onLeave);\n            this.pendingDiffs.forEach((diff)=>{\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n            });\n            this.pendingDiffs = [];\n            onSync();\n        });\n        this.channel._on(events.diff, {}, (diff)=>{\n            const { onJoin, onLeave, onSync } = this.caller;\n            if (this.inPendingSyncState()) {\n                this.pendingDiffs.push(diff);\n            } else {\n                this.state = RealtimePresence.syncDiff(this.state, diff, onJoin, onLeave);\n                onSync();\n            }\n        });\n        this.onJoin((key, currentPresences, newPresences)=>{\n            this.channel._trigger(\"presence\", {\n                event: \"join\",\n                key,\n                currentPresences,\n                newPresences\n            });\n        });\n        this.onLeave((key, currentPresences, leftPresences)=>{\n            this.channel._trigger(\"presence\", {\n                event: \"leave\",\n                key,\n                currentPresences,\n                leftPresences\n            });\n        });\n        this.onSync(()=>{\n            this.channel._trigger(\"presence\", {\n                event: \"sync\"\n            });\n        });\n    }\n    /**\n     * Used to sync the list of presences on the server with the\n     * client's state.\n     *\n     * An optional `onJoin` and `onLeave` callback can be provided to\n     * react to changes in the client's local presences across\n     * disconnects and reconnects with the server.\n     *\n     * @internal\n     */ static syncState(currentState, newState, onJoin, onLeave) {\n        const state = this.cloneDeep(currentState);\n        const transformedState = this.transformState(newState);\n        const joins = {};\n        const leaves = {};\n        this.map(state, (key, presences)=>{\n            if (!transformedState[key]) {\n                leaves[key] = presences;\n            }\n        });\n        this.map(transformedState, (key, newPresences)=>{\n            const currentPresences = state[key];\n            if (currentPresences) {\n                const newPresenceRefs = newPresences.map((m)=>m.presence_ref);\n                const curPresenceRefs = currentPresences.map((m)=>m.presence_ref);\n                const joinedPresences = newPresences.filter((m)=>curPresenceRefs.indexOf(m.presence_ref) < 0);\n                const leftPresences = currentPresences.filter((m)=>newPresenceRefs.indexOf(m.presence_ref) < 0);\n                if (joinedPresences.length > 0) {\n                    joins[key] = joinedPresences;\n                }\n                if (leftPresences.length > 0) {\n                    leaves[key] = leftPresences;\n                }\n            } else {\n                joins[key] = newPresences;\n            }\n        });\n        return this.syncDiff(state, {\n            joins,\n            leaves\n        }, onJoin, onLeave);\n    }\n    /**\n     * Used to sync a diff of presence join and leave events from the\n     * server, as they happen.\n     *\n     * Like `syncState`, `syncDiff` accepts optional `onJoin` and\n     * `onLeave` callbacks to react to a user joining or leaving from a\n     * device.\n     *\n     * @internal\n     */ static syncDiff(state, diff, onJoin, onLeave) {\n        const { joins, leaves } = {\n            joins: this.transformState(diff.joins),\n            leaves: this.transformState(diff.leaves)\n        };\n        if (!onJoin) {\n            onJoin = ()=>{};\n        }\n        if (!onLeave) {\n            onLeave = ()=>{};\n        }\n        this.map(joins, (key, newPresences)=>{\n            var _a;\n            const currentPresences = (_a = state[key]) !== null && _a !== void 0 ? _a : [];\n            state[key] = this.cloneDeep(newPresences);\n            if (currentPresences.length > 0) {\n                const joinedPresenceRefs = state[key].map((m)=>m.presence_ref);\n                const curPresences = currentPresences.filter((m)=>joinedPresenceRefs.indexOf(m.presence_ref) < 0);\n                state[key].unshift(...curPresences);\n            }\n            onJoin(key, currentPresences, newPresences);\n        });\n        this.map(leaves, (key, leftPresences)=>{\n            let currentPresences = state[key];\n            if (!currentPresences) return;\n            const presenceRefsToRemove = leftPresences.map((m)=>m.presence_ref);\n            currentPresences = currentPresences.filter((m)=>presenceRefsToRemove.indexOf(m.presence_ref) < 0);\n            state[key] = currentPresences;\n            onLeave(key, currentPresences, leftPresences);\n            if (currentPresences.length === 0) delete state[key];\n        });\n        return state;\n    }\n    /** @internal */ static map(obj, func) {\n        return Object.getOwnPropertyNames(obj).map((key)=>func(key, obj[key]));\n    }\n    /**\n     * Remove 'metas' key\n     * Change 'phx_ref' to 'presence_ref'\n     * Remove 'phx_ref' and 'phx_ref_prev'\n     *\n     * @example\n     * // returns {\n     *  abc123: [\n     *    { presence_ref: '2', user_id: 1 },\n     *    { presence_ref: '3', user_id: 2 }\n     *  ]\n     * }\n     * RealtimePresence.transformState({\n     *  abc123: {\n     *    metas: [\n     *      { phx_ref: '2', phx_ref_prev: '1' user_id: 1 },\n     *      { phx_ref: '3', user_id: 2 }\n     *    ]\n     *  }\n     * })\n     *\n     * @internal\n     */ static transformState(state) {\n        state = this.cloneDeep(state);\n        return Object.getOwnPropertyNames(state).reduce((newState, key)=>{\n            const presences = state[key];\n            if (\"metas\" in presences) {\n                newState[key] = presences.metas.map((presence)=>{\n                    presence[\"presence_ref\"] = presence[\"phx_ref\"];\n                    delete presence[\"phx_ref\"];\n                    delete presence[\"phx_ref_prev\"];\n                    return presence;\n                });\n            } else {\n                newState[key] = presences;\n            }\n            return newState;\n        }, {});\n    }\n    /** @internal */ static cloneDeep(obj) {\n        return JSON.parse(JSON.stringify(obj));\n    }\n    /** @internal */ onJoin(callback) {\n        this.caller.onJoin = callback;\n    }\n    /** @internal */ onLeave(callback) {\n        this.caller.onLeave = callback;\n    }\n    /** @internal */ onSync(callback) {\n        this.caller.onSync = callback;\n    }\n    /** @internal */ inPendingSyncState() {\n        return !this.joinRef || this.joinRef !== this.channel._joinRef();\n    }\n} //# sourceMappingURL=RealtimePresence.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lUHJlc2VuY2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7O0FBR0EsR0FDTyxJQUFJQSxnQ0FBZ0M7QUFDMUMsVUFBVUEsK0JBQStCO0lBQ3RDQSwrQkFBK0IsQ0FBQyxPQUFPLEdBQUc7SUFDMUNBLCtCQUErQixDQUFDLE9BQU8sR0FBRztJQUMxQ0EsK0JBQStCLENBQUMsUUFBUSxHQUFHO0FBQy9DLEdBQUdBLG1DQUFvQ0EsQ0FBQUEsa0NBQWtDLENBQUM7QUFDM0QsTUFBTUM7SUFDakI7Ozs7OztLQU1DLEdBQ0RDLFlBQVlDLE9BQU8sRUFBRUMsSUFBSSxDQUFFO1FBQ3ZCLElBQUksQ0FBQ0QsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0UsS0FBSyxHQUFHLENBQUM7UUFDZCxJQUFJLENBQUNDLFlBQVksR0FBRyxFQUFFO1FBQ3RCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLE1BQU0sR0FBRztZQUNWQyxRQUFRLEtBQVE7WUFDaEJDLFNBQVMsS0FBUTtZQUNqQkMsUUFBUSxLQUFRO1FBQ3BCO1FBQ0EsTUFBTUMsU0FBUyxDQUFDVCxTQUFTLFFBQVFBLFNBQVMsS0FBSyxJQUFJLEtBQUssSUFBSUEsS0FBS1MsTUFBTSxLQUFLO1lBQ3hFUixPQUFPO1lBQ1BTLE1BQU07UUFDVjtRQUNBLElBQUksQ0FBQ1gsT0FBTyxDQUFDWSxHQUFHLENBQUNGLE9BQU9SLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQ1c7WUFDaEMsTUFBTSxFQUFFTixNQUFNLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDSCxNQUFNO1lBQy9DLElBQUksQ0FBQ0YsT0FBTyxHQUFHLElBQUksQ0FBQ0osT0FBTyxDQUFDYyxRQUFRO1lBQ3BDLElBQUksQ0FBQ1osS0FBSyxHQUFHSixp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QkFDMUIsT0FBT0EsUUFBUSxDQUFDLGVBQWU7b0JBQy9CLE9BQU9BO2dCQUNYO1lBQ0osT0FDSztnQkFDRHhDLFFBQVEsQ0FBQ08sSUFBSSxHQUFHYTtZQUNwQjtZQUNBLE9BQU9wQjtRQUNYLEdBQUcsQ0FBQztJQUNSO0lBQ0EsY0FBYyxHQUNkLE9BQU9jLFVBQVVvQixHQUFHLEVBQUU7UUFDbEIsT0FBT08sS0FBS0MsS0FBSyxDQUFDRCxLQUFLRSxTQUFTLENBQUNUO0lBQ3JDO0lBQ0EsY0FBYyxHQUNkeEMsT0FBT2tELFFBQVEsRUFBRTtRQUNiLElBQUksQ0FBQ25ELE1BQU0sQ0FBQ0MsTUFBTSxHQUFHa0Q7SUFDekI7SUFDQSxjQUFjLEdBQ2RqRCxRQUFRaUQsUUFBUSxFQUFFO1FBQ2QsSUFBSSxDQUFDbkQsTUFBTSxDQUFDRSxPQUFPLEdBQUdpRDtJQUMxQjtJQUNBLGNBQWMsR0FDZGhELE9BQU9nRCxRQUFRLEVBQUU7UUFDYixJQUFJLENBQUNuRCxNQUFNLENBQUNHLE1BQU0sR0FBR2dEO0lBQ3pCO0lBQ0EsY0FBYyxHQUNkdkMscUJBQXFCO1FBQ2pCLE9BQU8sQ0FBQyxJQUFJLENBQUNkLE9BQU8sSUFBSSxJQUFJLENBQUNBLE9BQU8sS0FBSyxJQUFJLENBQUNKLE9BQU8sQ0FBQ2MsUUFBUTtJQUNsRTtBQUNKLEVBQ0EsNENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL1JlYWx0aW1lUHJlc2VuY2UuanM/Y2VjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBUaGlzIGZpbGUgZHJhd3MgaGVhdmlseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9kMzQ0ZWMwYTczMmFiNGVlMjA0MjE1YjMxZGU2OWNmNGJlNzJlM2JmL2Fzc2V0cy9qcy9waG9lbml4L3ByZXNlbmNlLmpzXG4gIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9kMzQ0ZWMwYTczMmFiNGVlMjA0MjE1YjMxZGU2OWNmNGJlNzJlM2JmL0xJQ0VOU0UubWRcbiovXG5leHBvcnQgdmFyIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFM7XG4oZnVuY3Rpb24gKFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMpIHtcbiAgICBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTW1wiU1lOQ1wiXSA9IFwic3luY1wiO1xuICAgIFJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFNbXCJKT0lOXCJdID0gXCJqb2luXCI7XG4gICAgUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UU1tcIkxFQVZFXCJdID0gXCJsZWF2ZVwiO1xufSkoUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyB8fCAoUkVBTFRJTUVfUFJFU0VOQ0VfTElTVEVOX0VWRU5UUyA9IHt9KSk7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWFsdGltZVByZXNlbmNlIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgUHJlc2VuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCAtIFRoZSBSZWFsdGltZUNoYW5uZWxcbiAgICAgKiBAcGFyYW0gb3B0cyAtIFRoZSBvcHRpb25zLFxuICAgICAqICAgICAgICBmb3IgZXhhbXBsZSBge2V2ZW50czoge3N0YXRlOiAnc3RhdGUnLCBkaWZmOiAnZGlmZid9fWBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBvcHRzKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7fTtcbiAgICAgICAgdGhpcy5wZW5kaW5nRGlmZnMgPSBbXTtcbiAgICAgICAgdGhpcy5qb2luUmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FsbGVyID0ge1xuICAgICAgICAgICAgb25Kb2luOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICBvbkxlYXZlOiAoKSA9PiB7IH0sXG4gICAgICAgICAgICBvblN5bmM6ICgpID0+IHsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXZlbnRzID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5ldmVudHMpIHx8IHtcbiAgICAgICAgICAgIHN0YXRlOiAncHJlc2VuY2Vfc3RhdGUnLFxuICAgICAgICAgICAgZGlmZjogJ3ByZXNlbmNlX2RpZmYnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5zdGF0ZSwge30sIChuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbkpvaW4sIG9uTGVhdmUsIG9uU3luYyB9ID0gdGhpcy5jYWxsZXI7XG4gICAgICAgICAgICB0aGlzLmpvaW5SZWYgPSB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBSZWFsdGltZVByZXNlbmNlLnN5bmNTdGF0ZSh0aGlzLnN0YXRlLCBuZXdTdGF0ZSwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0RpZmZzLmZvckVhY2goKGRpZmYpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gUmVhbHRpbWVQcmVzZW5jZS5zeW5jRGlmZih0aGlzLnN0YXRlLCBkaWZmLCBvbkpvaW4sIG9uTGVhdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcyA9IFtdO1xuICAgICAgICAgICAgb25TeW5jKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNoYW5uZWwuX29uKGV2ZW50cy5kaWZmLCB7fSwgKGRpZmYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25Kb2luLCBvbkxlYXZlLCBvblN5bmMgfSA9IHRoaXMuY2FsbGVyO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5QZW5kaW5nU3luY1N0YXRlKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdEaWZmcy5wdXNoKGRpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFJlYWx0aW1lUHJlc2VuY2Uuc3luY0RpZmYodGhpcy5zdGF0ZSwgZGlmZiwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICAgICAgICAgICAgICBvblN5bmMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub25Kb2luKChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIG5ld1ByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHtcbiAgICAgICAgICAgICAgICBldmVudDogJ2pvaW4nLFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJlc2VuY2VzLFxuICAgICAgICAgICAgICAgIG5ld1ByZXNlbmNlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbkxlYXZlKChrZXksIGN1cnJlbnRQcmVzZW5jZXMsIGxlZnRQcmVzZW5jZXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcigncHJlc2VuY2UnLCB7XG4gICAgICAgICAgICAgICAgZXZlbnQ6ICdsZWF2ZScsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIGN1cnJlbnRQcmVzZW5jZXMsXG4gICAgICAgICAgICAgICAgbGVmdFByZXNlbmNlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vblN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsLl90cmlnZ2VyKCdwcmVzZW5jZScsIHsgZXZlbnQ6ICdzeW5jJyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc3luYyB0aGUgbGlzdCBvZiBwcmVzZW5jZXMgb24gdGhlIHNlcnZlciB3aXRoIHRoZVxuICAgICAqIGNsaWVudCdzIHN0YXRlLlxuICAgICAqXG4gICAgICogQW4gb3B0aW9uYWwgYG9uSm9pbmAgYW5kIGBvbkxlYXZlYCBjYWxsYmFjayBjYW4gYmUgcHJvdmlkZWQgdG9cbiAgICAgKiByZWFjdCB0byBjaGFuZ2VzIGluIHRoZSBjbGllbnQncyBsb2NhbCBwcmVzZW5jZXMgYWNyb3NzXG4gICAgICogZGlzY29ubmVjdHMgYW5kIHJlY29ubmVjdHMgd2l0aCB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIHN5bmNTdGF0ZShjdXJyZW50U3RhdGUsIG5ld1N0YXRlLCBvbkpvaW4sIG9uTGVhdmUpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmNsb25lRGVlcChjdXJyZW50U3RhdGUpO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFN0YXRlID0gdGhpcy50cmFuc2Zvcm1TdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGpvaW5zID0ge307XG4gICAgICAgIGNvbnN0IGxlYXZlcyA9IHt9O1xuICAgICAgICB0aGlzLm1hcChzdGF0ZSwgKGtleSwgcHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRyYW5zZm9ybWVkU3RhdGVba2V5XSkge1xuICAgICAgICAgICAgICAgIGxlYXZlc1trZXldID0gcHJlc2VuY2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXAodHJhbnNmb3JtZWRTdGF0ZSwgKGtleSwgbmV3UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UHJlc2VuY2VzID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UHJlc2VuY2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UHJlc2VuY2VSZWZzID0gbmV3UHJlc2VuY2VzLm1hcCgobSkgPT4gbS5wcmVzZW5jZV9yZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1clByZXNlbmNlUmVmcyA9IGN1cnJlbnRQcmVzZW5jZXMubWFwKChtKSA9PiBtLnByZXNlbmNlX3JlZik7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9pbmVkUHJlc2VuY2VzID0gbmV3UHJlc2VuY2VzLmZpbHRlcigobSkgPT4gY3VyUHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFByZXNlbmNlcyA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBuZXdQcmVzZW5jZVJlZnMuaW5kZXhPZihtLnByZXNlbmNlX3JlZikgPCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoam9pbmVkUHJlc2VuY2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgam9pbnNba2V5XSA9IGpvaW5lZFByZXNlbmNlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxlZnRQcmVzZW5jZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBsZWF2ZXNba2V5XSA9IGxlZnRQcmVzZW5jZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgam9pbnNba2V5XSA9IG5ld1ByZXNlbmNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN5bmNEaWZmKHN0YXRlLCB7IGpvaW5zLCBsZWF2ZXMgfSwgb25Kb2luLCBvbkxlYXZlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBzeW5jIGEgZGlmZiBvZiBwcmVzZW5jZSBqb2luIGFuZCBsZWF2ZSBldmVudHMgZnJvbSB0aGVcbiAgICAgKiBzZXJ2ZXIsIGFzIHRoZXkgaGFwcGVuLlxuICAgICAqXG4gICAgICogTGlrZSBgc3luY1N0YXRlYCwgYHN5bmNEaWZmYCBhY2NlcHRzIG9wdGlvbmFsIGBvbkpvaW5gIGFuZFxuICAgICAqIGBvbkxlYXZlYCBjYWxsYmFja3MgdG8gcmVhY3QgdG8gYSB1c2VyIGpvaW5pbmcgb3IgbGVhdmluZyBmcm9tIGFcbiAgICAgKiBkZXZpY2UuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgc3luY0RpZmYoc3RhdGUsIGRpZmYsIG9uSm9pbiwgb25MZWF2ZSkge1xuICAgICAgICBjb25zdCB7IGpvaW5zLCBsZWF2ZXMgfSA9IHtcbiAgICAgICAgICAgIGpvaW5zOiB0aGlzLnRyYW5zZm9ybVN0YXRlKGRpZmYuam9pbnMpLFxuICAgICAgICAgICAgbGVhdmVzOiB0aGlzLnRyYW5zZm9ybVN0YXRlKGRpZmYubGVhdmVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFvbkpvaW4pIHtcbiAgICAgICAgICAgIG9uSm9pbiA9ICgpID0+IHsgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9uTGVhdmUpIHtcbiAgICAgICAgICAgIG9uTGVhdmUgPSAoKSA9PiB7IH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXAoam9pbnMsIChrZXksIG5ld1ByZXNlbmNlcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFByZXNlbmNlcyA9IChfYSA9IHN0YXRlW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgc3RhdGVba2V5XSA9IHRoaXMuY2xvbmVEZWVwKG5ld1ByZXNlbmNlcyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFByZXNlbmNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgam9pbmVkUHJlc2VuY2VSZWZzID0gc3RhdGVba2V5XS5tYXAoKG0pID0+IG0ucHJlc2VuY2VfcmVmKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJQcmVzZW5jZXMgPSBjdXJyZW50UHJlc2VuY2VzLmZpbHRlcigobSkgPT4gam9pbmVkUHJlc2VuY2VSZWZzLmluZGV4T2YobS5wcmVzZW5jZV9yZWYpIDwgMCk7XG4gICAgICAgICAgICAgICAgc3RhdGVba2V5XS51bnNoaWZ0KC4uLmN1clByZXNlbmNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkpvaW4oa2V5LCBjdXJyZW50UHJlc2VuY2VzLCBuZXdQcmVzZW5jZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXAobGVhdmVzLCAoa2V5LCBsZWZ0UHJlc2VuY2VzKSA9PiB7XG4gICAgICAgICAgICBsZXQgY3VycmVudFByZXNlbmNlcyA9IHN0YXRlW2tleV07XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRQcmVzZW5jZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcHJlc2VuY2VSZWZzVG9SZW1vdmUgPSBsZWZ0UHJlc2VuY2VzLm1hcCgobSkgPT4gbS5wcmVzZW5jZV9yZWYpO1xuICAgICAgICAgICAgY3VycmVudFByZXNlbmNlcyA9IGN1cnJlbnRQcmVzZW5jZXMuZmlsdGVyKChtKSA9PiBwcmVzZW5jZVJlZnNUb1JlbW92ZS5pbmRleE9mKG0ucHJlc2VuY2VfcmVmKSA8IDApO1xuICAgICAgICAgICAgc3RhdGVba2V5XSA9IGN1cnJlbnRQcmVzZW5jZXM7XG4gICAgICAgICAgICBvbkxlYXZlKGtleSwgY3VycmVudFByZXNlbmNlcywgbGVmdFByZXNlbmNlcyk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFByZXNlbmNlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgbWFwKG9iaiwgZnVuYykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5tYXAoKGtleSkgPT4gZnVuYyhrZXksIG9ialtrZXldKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSAnbWV0YXMnIGtleVxuICAgICAqIENoYW5nZSAncGh4X3JlZicgdG8gJ3ByZXNlbmNlX3JlZidcbiAgICAgKiBSZW1vdmUgJ3BoeF9yZWYnIGFuZCAncGh4X3JlZl9wcmV2J1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAvLyByZXR1cm5zIHtcbiAgICAgKiAgYWJjMTIzOiBbXG4gICAgICogICAgeyBwcmVzZW5jZV9yZWY6ICcyJywgdXNlcl9pZDogMSB9LFxuICAgICAqICAgIHsgcHJlc2VuY2VfcmVmOiAnMycsIHVzZXJfaWQ6IDIgfVxuICAgICAqICBdXG4gICAgICogfVxuICAgICAqIFJlYWx0aW1lUHJlc2VuY2UudHJhbnNmb3JtU3RhdGUoe1xuICAgICAqICBhYmMxMjM6IHtcbiAgICAgKiAgICBtZXRhczogW1xuICAgICAqICAgICAgeyBwaHhfcmVmOiAnMicsIHBoeF9yZWZfcHJldjogJzEnIHVzZXJfaWQ6IDEgfSxcbiAgICAgKiAgICAgIHsgcGh4X3JlZjogJzMnLCB1c2VyX2lkOiAyIH1cbiAgICAgKiAgICBdXG4gICAgICogIH1cbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy5jbG9uZURlZXAoc3RhdGUpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc3RhdGUpLnJlZHVjZSgobmV3U3RhdGUsIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJlc2VuY2VzID0gc3RhdGVba2V5XTtcbiAgICAgICAgICAgIGlmICgnbWV0YXMnIGluIHByZXNlbmNlcykge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlW2tleV0gPSBwcmVzZW5jZXMubWV0YXMubWFwKChwcmVzZW5jZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZVsncHJlc2VuY2VfcmVmJ10gPSBwcmVzZW5jZVsncGh4X3JlZiddO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcHJlc2VuY2VbJ3BoeF9yZWYnXTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHByZXNlbmNlWydwaHhfcmVmX3ByZXYnXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXNlbmNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhdGVba2V5XSA9IHByZXNlbmNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgfSwge30pO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgc3RhdGljIGNsb25lRGVlcChvYmopIHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbkpvaW4oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYWxsZXIub25Kb2luID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBvbkxlYXZlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbGVyLm9uTGVhdmUgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIG9uU3luYyhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxlci5vblN5bmMgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGluUGVuZGluZ1N5bmNTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmpvaW5SZWYgfHwgdGhpcy5qb2luUmVmICE9PSB0aGlzLmNoYW5uZWwuX2pvaW5SZWYoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFsdGltZVByZXNlbmNlLmpzLm1hcCJdLCJuYW1lcyI6WyJSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTIiwiUmVhbHRpbWVQcmVzZW5jZSIsImNvbnN0cnVjdG9yIiwiY2hhbm5lbCIsIm9wdHMiLCJzdGF0ZSIsInBlbmRpbmdEaWZmcyIsImpvaW5SZWYiLCJlbmFibGVkIiwiY2FsbGVyIiwib25Kb2luIiwib25MZWF2ZSIsIm9uU3luYyIsImV2ZW50cyIsImRpZmYiLCJfb24iLCJuZXdTdGF0ZSIsIl9qb2luUmVmIiwic3luY1N0YXRlIiwiZm9yRWFjaCIsInN5bmNEaWZmIiwiaW5QZW5kaW5nU3luY1N0YXRlIiwicHVzaCIsImtleSIsImN1cnJlbnRQcmVzZW5jZXMiLCJuZXdQcmVzZW5jZXMiLCJfdHJpZ2dlciIsImV2ZW50IiwibGVmdFByZXNlbmNlcyIsImN1cnJlbnRTdGF0ZSIsImNsb25lRGVlcCIsInRyYW5zZm9ybWVkU3RhdGUiLCJ0cmFuc2Zvcm1TdGF0ZSIsImpvaW5zIiwibGVhdmVzIiwibWFwIiwicHJlc2VuY2VzIiwibmV3UHJlc2VuY2VSZWZzIiwibSIsInByZXNlbmNlX3JlZiIsImN1clByZXNlbmNlUmVmcyIsImpvaW5lZFByZXNlbmNlcyIsImZpbHRlciIsImluZGV4T2YiLCJsZW5ndGgiLCJfYSIsImpvaW5lZFByZXNlbmNlUmVmcyIsImN1clByZXNlbmNlcyIsInVuc2hpZnQiLCJwcmVzZW5jZVJlZnNUb1JlbW92ZSIsIm9iaiIsImZ1bmMiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwicmVkdWNlIiwibWV0YXMiLCJwcmVzZW5jZSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsImNhbGxiYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__.REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__.REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   RealtimeChannel: () => (/* reexport safe */ _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   RealtimeClient: () => (/* reexport safe */ _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   RealtimePresence: () => (/* reexport safe */ _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   WebSocketFactory: () => (/* reexport safe */ _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _RealtimeClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RealtimeClient */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeClient.js\");\n/* harmony import */ var _RealtimeChannel__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RealtimeChannel */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimeChannel.js\");\n/* harmony import */ var _RealtimePresence__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RealtimePresence */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/RealtimePresence.js\");\n/* harmony import */ var _lib_websocket_factory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket-factory */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js\");\n\n\n\n\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDMEg7QUFDaEY7QUFDakM7QUFDNkssQ0FDcE8saUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2luZGV4LmpzPzU1NWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWx0aW1lQ2xpZW50IGZyb20gJy4vUmVhbHRpbWVDbGllbnQnO1xuaW1wb3J0IFJlYWx0aW1lQ2hhbm5lbCwgeyBSRUFMVElNRV9MSVNURU5fVFlQRVMsIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULCBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLCBSRUFMVElNRV9DSEFOTkVMX1NUQVRFUywgfSBmcm9tICcuL1JlYWx0aW1lQ2hhbm5lbCc7XG5pbXBvcnQgUmVhbHRpbWVQcmVzZW5jZSwgeyBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLCB9IGZyb20gJy4vUmVhbHRpbWVQcmVzZW5jZSc7XG5pbXBvcnQgV2ViU29ja2V0RmFjdG9yeSBmcm9tICcuL2xpYi93ZWJzb2NrZXQtZmFjdG9yeSc7XG5leHBvcnQgeyBSZWFsdGltZVByZXNlbmNlLCBSZWFsdGltZUNoYW5uZWwsIFJlYWx0aW1lQ2xpZW50LCBSRUFMVElNRV9MSVNURU5fVFlQRVMsIFJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5ULCBSRUFMVElNRV9QUkVTRU5DRV9MSVNURU5fRVZFTlRTLCBSRUFMVElNRV9TVUJTQ1JJQkVfU1RBVEVTLCBSRUFMVElNRV9DSEFOTkVMX1NUQVRFUywgV2ViU29ja2V0RmFjdG9yeSwgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJSZWFsdGltZUNsaWVudCIsIlJlYWx0aW1lQ2hhbm5lbCIsIlJFQUxUSU1FX0xJU1RFTl9UWVBFUyIsIlJFQUxUSU1FX1BPU1RHUkVTX0NIQU5HRVNfTElTVEVOX0VWRU5UIiwiUkVBTFRJTUVfU1VCU0NSSUJFX1NUQVRFUyIsIlJFQUxUSU1FX0NIQU5ORUxfU1RBVEVTIiwiUmVhbHRpbWVQcmVzZW5jZSIsIlJFQUxUSU1FX1BSRVNFTkNFX0xJU1RFTl9FVkVOVFMiLCJXZWJTb2NrZXRGYWN0b3J5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CHANNEL_EVENTS: () => (/* binding */ CHANNEL_EVENTS),\n/* harmony export */   CHANNEL_STATES: () => (/* binding */ CHANNEL_STATES),\n/* harmony export */   CONNECTION_STATE: () => (/* binding */ CONNECTION_STATE),\n/* harmony export */   DEFAULT_TIMEOUT: () => (/* binding */ DEFAULT_TIMEOUT),\n/* harmony export */   DEFAULT_VERSION: () => (/* binding */ DEFAULT_VERSION),\n/* harmony export */   MAX_PUSH_BUFFER_SIZE: () => (/* binding */ MAX_PUSH_BUFFER_SIZE),\n/* harmony export */   SOCKET_STATES: () => (/* binding */ SOCKET_STATES),\n/* harmony export */   TRANSPORTS: () => (/* binding */ TRANSPORTS),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   VSN: () => (/* binding */ VSN),\n/* harmony export */   WS_CLOSE_NORMAL: () => (/* binding */ WS_CLOSE_NORMAL)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js\");\n\nconst DEFAULT_VERSION = `realtime-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`;\nconst VSN = \"1.0.0\";\nconst VERSION = _version__WEBPACK_IMPORTED_MODULE_0__.version;\nconst DEFAULT_TIMEOUT = 10000;\nconst WS_CLOSE_NORMAL = 1000;\nconst MAX_PUSH_BUFFER_SIZE = 100;\nvar SOCKET_STATES;\n(function(SOCKET_STATES) {\n    SOCKET_STATES[SOCKET_STATES[\"connecting\"] = 0] = \"connecting\";\n    SOCKET_STATES[SOCKET_STATES[\"open\"] = 1] = \"open\";\n    SOCKET_STATES[SOCKET_STATES[\"closing\"] = 2] = \"closing\";\n    SOCKET_STATES[SOCKET_STATES[\"closed\"] = 3] = \"closed\";\n})(SOCKET_STATES || (SOCKET_STATES = {}));\nvar CHANNEL_STATES;\n(function(CHANNEL_STATES) {\n    CHANNEL_STATES[\"closed\"] = \"closed\";\n    CHANNEL_STATES[\"errored\"] = \"errored\";\n    CHANNEL_STATES[\"joined\"] = \"joined\";\n    CHANNEL_STATES[\"joining\"] = \"joining\";\n    CHANNEL_STATES[\"leaving\"] = \"leaving\";\n})(CHANNEL_STATES || (CHANNEL_STATES = {}));\nvar CHANNEL_EVENTS;\n(function(CHANNEL_EVENTS) {\n    CHANNEL_EVENTS[\"close\"] = \"phx_close\";\n    CHANNEL_EVENTS[\"error\"] = \"phx_error\";\n    CHANNEL_EVENTS[\"join\"] = \"phx_join\";\n    CHANNEL_EVENTS[\"reply\"] = \"phx_reply\";\n    CHANNEL_EVENTS[\"leave\"] = \"phx_leave\";\n    CHANNEL_EVENTS[\"access_token\"] = \"access_token\";\n})(CHANNEL_EVENTS || (CHANNEL_EVENTS = {}));\nvar TRANSPORTS;\n(function(TRANSPORTS) {\n    TRANSPORTS[\"websocket\"] = \"websocket\";\n})(TRANSPORTS || (TRANSPORTS = {}));\nvar CONNECTION_STATE;\n(function(CONNECTION_STATE) {\n    CONNECTION_STATE[\"Connecting\"] = \"connecting\";\n    CONNECTION_STATE[\"Open\"] = \"open\";\n    CONNECTION_STATE[\"Closing\"] = \"closing\";\n    CONNECTION_STATE[\"Closed\"] = \"closed\";\n})(CONNECTION_STATE || (CONNECTION_STATE = {})); //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQzdCLE1BQU1DLGtCQUFrQixDQUFDLFlBQVksRUFBRUQsNkNBQU9BLENBQUMsQ0FBQyxDQUFDO0FBQ2pELE1BQU1FLE1BQU0sUUFBUTtBQUNwQixNQUFNQyxVQUFVSCw2Q0FBT0EsQ0FBQztBQUN4QixNQUFNSSxrQkFBa0IsTUFBTTtBQUM5QixNQUFNQyxrQkFBa0IsS0FBSztBQUM3QixNQUFNQyx1QkFBdUIsSUFBSTtBQUNqQyxJQUFJQyxjQUFjO0FBQ3hCLFVBQVVBLGFBQWE7SUFDcEJBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDakRBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7SUFDM0NBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDOUNBLGFBQWEsQ0FBQ0EsYUFBYSxDQUFDLFNBQVMsR0FBRyxFQUFFLEdBQUc7QUFDakQsR0FBR0EsaUJBQWtCQSxDQUFBQSxnQkFBZ0IsQ0FBQztBQUMvQixJQUFJQyxlQUFlO0FBQ3pCLFVBQVVBLGNBQWM7SUFDckJBLGNBQWMsQ0FBQyxTQUFTLEdBQUc7SUFDM0JBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxTQUFTLEdBQUc7SUFDM0JBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7SUFDNUJBLGNBQWMsQ0FBQyxVQUFVLEdBQUc7QUFDaEMsR0FBR0Esa0JBQW1CQSxDQUFBQSxpQkFBaUIsQ0FBQztBQUNqQyxJQUFJQyxlQUFlO0FBQ3pCLFVBQVVBLGNBQWM7SUFDckJBLGNBQWMsQ0FBQyxRQUFRLEdBQUc7SUFDMUJBLGNBQWMsQ0FBQyxRQUFRLEdBQUc7SUFDMUJBLGNBQWMsQ0FBQyxPQUFPLEdBQUc7SUFDekJBLGNBQWMsQ0FBQyxRQUFRLEdBQUc7SUFDMUJBLGNBQWMsQ0FBQyxRQUFRLEdBQUc7SUFDMUJBLGNBQWMsQ0FBQyxlQUFlLEdBQUc7QUFDckMsR0FBR0Esa0JBQW1CQSxDQUFBQSxpQkFBaUIsQ0FBQztBQUNqQyxJQUFJQyxXQUFXO0FBQ3JCLFVBQVVBLFVBQVU7SUFDakJBLFVBQVUsQ0FBQyxZQUFZLEdBQUc7QUFDOUIsR0FBR0EsY0FBZUEsQ0FBQUEsYUFBYSxDQUFDO0FBQ3pCLElBQUlDLGlCQUFpQjtBQUMzQixVQUFVQSxnQkFBZ0I7SUFDdkJBLGdCQUFnQixDQUFDLGFBQWEsR0FBRztJQUNqQ0EsZ0JBQWdCLENBQUMsT0FBTyxHQUFHO0lBQzNCQSxnQkFBZ0IsQ0FBQyxVQUFVLEdBQUc7SUFDOUJBLGdCQUFnQixDQUFDLFNBQVMsR0FBRztBQUNqQyxHQUFHQSxvQkFBcUJBLENBQUFBLG1CQUFtQixDQUFDLEtBQzVDLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9saWIvY29uc3RhbnRzLmpzP2FjMTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7XG5leHBvcnQgY29uc3QgREVGQVVMVF9WRVJTSU9OID0gYHJlYWx0aW1lLWpzLyR7dmVyc2lvbn1gO1xuZXhwb3J0IGNvbnN0IFZTTiA9ICcxLjAuMCc7XG5leHBvcnQgY29uc3QgVkVSU0lPTiA9IHZlcnNpb247XG5leHBvcnQgY29uc3QgREVGQVVMVF9USU1FT1VUID0gMTAwMDA7XG5leHBvcnQgY29uc3QgV1NfQ0xPU0VfTk9STUFMID0gMTAwMDtcbmV4cG9ydCBjb25zdCBNQVhfUFVTSF9CVUZGRVJfU0laRSA9IDEwMDtcbmV4cG9ydCB2YXIgU09DS0VUX1NUQVRFUztcbihmdW5jdGlvbiAoU09DS0VUX1NUQVRFUykge1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcImNvbm5lY3RpbmdcIl0gPSAwXSA9IFwiY29ubmVjdGluZ1wiO1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcIm9wZW5cIl0gPSAxXSA9IFwib3BlblwiO1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcImNsb3NpbmdcIl0gPSAyXSA9IFwiY2xvc2luZ1wiO1xuICAgIFNPQ0tFVF9TVEFURVNbU09DS0VUX1NUQVRFU1tcImNsb3NlZFwiXSA9IDNdID0gXCJjbG9zZWRcIjtcbn0pKFNPQ0tFVF9TVEFURVMgfHwgKFNPQ0tFVF9TVEFURVMgPSB7fSkpO1xuZXhwb3J0IHZhciBDSEFOTkVMX1NUQVRFUztcbihmdW5jdGlvbiAoQ0hBTk5FTF9TVEFURVMpIHtcbiAgICBDSEFOTkVMX1NUQVRFU1tcImNsb3NlZFwiXSA9IFwiY2xvc2VkXCI7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJlcnJvcmVkXCJdID0gXCJlcnJvcmVkXCI7XG4gICAgQ0hBTk5FTF9TVEFURVNbXCJqb2luZWRcIl0gPSBcImpvaW5lZFwiO1xuICAgIENIQU5ORUxfU1RBVEVTW1wiam9pbmluZ1wiXSA9IFwiam9pbmluZ1wiO1xuICAgIENIQU5ORUxfU1RBVEVTW1wibGVhdmluZ1wiXSA9IFwibGVhdmluZ1wiO1xufSkoQ0hBTk5FTF9TVEFURVMgfHwgKENIQU5ORUxfU1RBVEVTID0ge30pKTtcbmV4cG9ydCB2YXIgQ0hBTk5FTF9FVkVOVFM7XG4oZnVuY3Rpb24gKENIQU5ORUxfRVZFTlRTKSB7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJjbG9zZVwiXSA9IFwicGh4X2Nsb3NlXCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJlcnJvclwiXSA9IFwicGh4X2Vycm9yXCI7XG4gICAgQ0hBTk5FTF9FVkVOVFNbXCJqb2luXCJdID0gXCJwaHhfam9pblwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wicmVwbHlcIl0gPSBcInBoeF9yZXBseVwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wibGVhdmVcIl0gPSBcInBoeF9sZWF2ZVwiO1xuICAgIENIQU5ORUxfRVZFTlRTW1wiYWNjZXNzX3Rva2VuXCJdID0gXCJhY2Nlc3NfdG9rZW5cIjtcbn0pKENIQU5ORUxfRVZFTlRTIHx8IChDSEFOTkVMX0VWRU5UUyA9IHt9KSk7XG5leHBvcnQgdmFyIFRSQU5TUE9SVFM7XG4oZnVuY3Rpb24gKFRSQU5TUE9SVFMpIHtcbiAgICBUUkFOU1BPUlRTW1wid2Vic29ja2V0XCJdID0gXCJ3ZWJzb2NrZXRcIjtcbn0pKFRSQU5TUE9SVFMgfHwgKFRSQU5TUE9SVFMgPSB7fSkpO1xuZXhwb3J0IHZhciBDT05ORUNUSU9OX1NUQVRFO1xuKGZ1bmN0aW9uIChDT05ORUNUSU9OX1NUQVRFKSB7XG4gICAgQ09OTkVDVElPTl9TVEFURVtcIkNvbm5lY3RpbmdcIl0gPSBcImNvbm5lY3RpbmdcIjtcbiAgICBDT05ORUNUSU9OX1NUQVRFW1wiT3BlblwiXSA9IFwib3BlblwiO1xuICAgIENPTk5FQ1RJT05fU1RBVEVbXCJDbG9zaW5nXCJdID0gXCJjbG9zaW5nXCI7XG4gICAgQ09OTkVDVElPTl9TVEFURVtcIkNsb3NlZFwiXSA9IFwiY2xvc2VkXCI7XG59KShDT05ORUNUSU9OX1NUQVRFIHx8IChDT05ORUNUSU9OX1NUQVRFID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiXSwibmFtZXMiOlsidmVyc2lvbiIsIkRFRkFVTFRfVkVSU0lPTiIsIlZTTiIsIlZFUlNJT04iLCJERUZBVUxUX1RJTUVPVVQiLCJXU19DTE9TRV9OT1JNQUwiLCJNQVhfUFVTSF9CVUZGRVJfU0laRSIsIlNPQ0tFVF9TVEFURVMiLCJDSEFOTkVMX1NUQVRFUyIsIkNIQU5ORUxfRVZFTlRTIiwiVFJBTlNQT1JUUyIsIkNPTk5FQ1RJT05fU1RBVEUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/push.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Push)\n/* harmony export */ });\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/constants */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/constants.js\");\n\nclass Push {\n    /**\n     * Initializes the Push\n     *\n     * @param channel The Channel\n     * @param event The event, for example `\"phx_join\"`\n     * @param payload The payload, for example `{user_id: 123}`\n     * @param timeout The push timeout in milliseconds\n     */ constructor(channel, event, payload = {}, timeout = _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TIMEOUT){\n        this.channel = channel;\n        this.event = event;\n        this.payload = payload;\n        this.timeout = timeout;\n        this.sent = false;\n        this.timeoutTimer = undefined;\n        this.ref = \"\";\n        this.receivedResp = null;\n        this.recHooks = [];\n        this.refEvent = null;\n    }\n    resend(timeout) {\n        this.timeout = timeout;\n        this._cancelRefEvent();\n        this.ref = \"\";\n        this.refEvent = null;\n        this.receivedResp = null;\n        this.sent = false;\n        this.send();\n    }\n    send() {\n        if (this._hasReceived(\"timeout\")) {\n            return;\n        }\n        this.startTimeout();\n        this.sent = true;\n        this.channel.socket.push({\n            topic: this.channel.topic,\n            event: this.event,\n            payload: this.payload,\n            ref: this.ref,\n            join_ref: this.channel._joinRef()\n        });\n    }\n    updatePayload(payload) {\n        this.payload = Object.assign(Object.assign({}, this.payload), payload);\n    }\n    receive(status, callback) {\n        var _a;\n        if (this._hasReceived(status)) {\n            callback((_a = this.receivedResp) === null || _a === void 0 ? void 0 : _a.response);\n        }\n        this.recHooks.push({\n            status,\n            callback\n        });\n        return this;\n    }\n    startTimeout() {\n        if (this.timeoutTimer) {\n            return;\n        }\n        this.ref = this.channel.socket._makeRef();\n        this.refEvent = this.channel._replyEventName(this.ref);\n        const callback = (payload)=>{\n            this._cancelRefEvent();\n            this._cancelTimeout();\n            this.receivedResp = payload;\n            this._matchReceive(payload);\n        };\n        this.channel._on(this.refEvent, {}, callback);\n        this.timeoutTimer = setTimeout(()=>{\n            this.trigger(\"timeout\", {});\n        }, this.timeout);\n    }\n    trigger(status, response) {\n        if (this.refEvent) this.channel._trigger(this.refEvent, {\n            status,\n            response\n        });\n    }\n    destroy() {\n        this._cancelRefEvent();\n        this._cancelTimeout();\n    }\n    _cancelRefEvent() {\n        if (!this.refEvent) {\n            return;\n        }\n        this.channel._off(this.refEvent, {});\n    }\n    _cancelTimeout() {\n        clearTimeout(this.timeoutTimer);\n        this.timeoutTimer = undefined;\n    }\n    _matchReceive({ status, response }) {\n        this.recHooks.filter((h)=>h.status === status).forEach((h)=>h.callback(response));\n    }\n    _hasReceived(status) {\n        return this.receivedResp && this.receivedResp.status === status;\n    }\n} //# sourceMappingURL=push.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9wdXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW1EO0FBQ3BDLE1BQU1DO0lBQ2pCOzs7Ozs7O0tBT0MsR0FDREMsWUFBWUMsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUVDLFVBQVVOLDJEQUFlLENBQUU7UUFDakUsSUFBSSxDQUFDRyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLFlBQVksR0FBR0M7UUFDcEIsSUFBSSxDQUFDQyxHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNDLFlBQVksR0FBRztRQUNwQixJQUFJLENBQUNDLFFBQVEsR0FBRyxFQUFFO1FBQ2xCLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ3BCO0lBQ0FDLE9BQU9SLE9BQU8sRUFBRTtRQUNaLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ1MsZUFBZTtRQUNwQixJQUFJLENBQUNMLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0csUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0YsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0osSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDUyxJQUFJO0lBQ2I7SUFDQUEsT0FBTztRQUNILElBQUksSUFBSSxDQUFDQyxZQUFZLENBQUMsWUFBWTtZQUM5QjtRQUNKO1FBQ0EsSUFBSSxDQUFDQyxZQUFZO1FBQ2pCLElBQUksQ0FBQ1gsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDSixPQUFPLENBQUNnQixNQUFNLENBQUNDLElBQUksQ0FBQztZQUNyQkMsT0FBTyxJQUFJLENBQUNsQixPQUFPLENBQUNrQixLQUFLO1lBQ3pCakIsT0FBTyxJQUFJLENBQUNBLEtBQUs7WUFDakJDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCSyxLQUFLLElBQUksQ0FBQ0EsR0FBRztZQUNiWSxVQUFVLElBQUksQ0FBQ25CLE9BQU8sQ0FBQ29CLFFBQVE7UUFDbkM7SUFDSjtJQUNBQyxjQUFjbkIsT0FBTyxFQUFFO1FBQ25CLElBQUksQ0FBQ0EsT0FBTyxHQUFHb0IsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQ3JCLE9BQU8sR0FBR0E7SUFDbEU7SUFDQXNCLFFBQVFDLE1BQU0sRUFBRUMsUUFBUSxFQUFFO1FBQ3RCLElBQUlDO1FBQ0osSUFBSSxJQUFJLENBQUNiLFlBQVksQ0FBQ1csU0FBUztZQUMzQkMsU0FBUyxDQUFDQyxLQUFLLElBQUksQ0FBQ25CLFlBQVksTUFBTSxRQUFRbUIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHQyxRQUFRO1FBQ3RGO1FBQ0EsSUFBSSxDQUFDbkIsUUFBUSxDQUFDUSxJQUFJLENBQUM7WUFBRVE7WUFBUUM7UUFBUztRQUN0QyxPQUFPLElBQUk7SUFDZjtJQUNBWCxlQUFlO1FBQ1gsSUFBSSxJQUFJLENBQUNWLFlBQVksRUFBRTtZQUNuQjtRQUNKO1FBQ0EsSUFBSSxDQUFDRSxHQUFHLEdBQUcsSUFBSSxDQUFDUCxPQUFPLENBQUNnQixNQUFNLENBQUNhLFFBQVE7UUFDdkMsSUFBSSxDQUFDbkIsUUFBUSxHQUFHLElBQUksQ0FBQ1YsT0FBTyxDQUFDOEIsZUFBZSxDQUFDLElBQUksQ0FBQ3ZCLEdBQUc7UUFDckQsTUFBTW1CLFdBQVcsQ0FBQ3hCO1lBQ2QsSUFBSSxDQUFDVSxlQUFlO1lBQ3BCLElBQUksQ0FBQ21CLGNBQWM7WUFDbkIsSUFBSSxDQUFDdkIsWUFBWSxHQUFHTjtZQUNwQixJQUFJLENBQUM4QixhQUFhLENBQUM5QjtRQUN2QjtRQUNBLElBQUksQ0FBQ0YsT0FBTyxDQUFDaUMsR0FBRyxDQUFDLElBQUksQ0FBQ3ZCLFFBQVEsRUFBRSxDQUFDLEdBQUdnQjtRQUNwQyxJQUFJLENBQUNyQixZQUFZLEdBQUc2QixXQUFXO1lBQzNCLElBQUksQ0FBQ0MsT0FBTyxDQUFDLFdBQVcsQ0FBQztRQUM3QixHQUFHLElBQUksQ0FBQ2hDLE9BQU87SUFDbkI7SUFDQWdDLFFBQVFWLE1BQU0sRUFBRUcsUUFBUSxFQUFFO1FBQ3RCLElBQUksSUFBSSxDQUFDbEIsUUFBUSxFQUNiLElBQUksQ0FBQ1YsT0FBTyxDQUFDb0MsUUFBUSxDQUFDLElBQUksQ0FBQzFCLFFBQVEsRUFBRTtZQUFFZTtZQUFRRztRQUFTO0lBQ2hFO0lBQ0FTLFVBQVU7UUFDTixJQUFJLENBQUN6QixlQUFlO1FBQ3BCLElBQUksQ0FBQ21CLGNBQWM7SUFDdkI7SUFDQW5CLGtCQUFrQjtRQUNkLElBQUksQ0FBQyxJQUFJLENBQUNGLFFBQVEsRUFBRTtZQUNoQjtRQUNKO1FBQ0EsSUFBSSxDQUFDVixPQUFPLENBQUNzQyxJQUFJLENBQUMsSUFBSSxDQUFDNUIsUUFBUSxFQUFFLENBQUM7SUFDdEM7SUFDQXFCLGlCQUFpQjtRQUNiUSxhQUFhLElBQUksQ0FBQ2xDLFlBQVk7UUFDOUIsSUFBSSxDQUFDQSxZQUFZLEdBQUdDO0lBQ3hCO0lBQ0EwQixjQUFjLEVBQUVQLE1BQU0sRUFBRUcsUUFBUSxFQUFFLEVBQUU7UUFDaEMsSUFBSSxDQUFDbkIsUUFBUSxDQUFDK0IsTUFBTSxDQUFDLENBQUNDLElBQU1BLEVBQUVoQixNQUFNLEtBQUtBLFFBQVFpQixPQUFPLENBQUMsQ0FBQ0QsSUFBTUEsRUFBRWYsUUFBUSxDQUFDRTtJQUMvRTtJQUNBZCxhQUFhVyxNQUFNLEVBQUU7UUFDakIsT0FBTyxJQUFJLENBQUNqQixZQUFZLElBQUksSUFBSSxDQUFDQSxZQUFZLENBQUNpQixNQUFNLEtBQUtBO0lBQzdEO0FBQ0osRUFDQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3B1c2guanM/NDQ4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBERUZBVUxUX1RJTUVPVVQgfSBmcm9tICcuLi9saWIvY29uc3RhbnRzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFB1c2gge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBQdXNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbm5lbCBUaGUgQ2hhbm5lbFxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQsIGZvciBleGFtcGxlIGBcInBoeF9qb2luXCJgXG4gICAgICogQHBhcmFtIHBheWxvYWQgVGhlIHBheWxvYWQsIGZvciBleGFtcGxlIGB7dXNlcl9pZDogMTIzfWBcbiAgICAgKiBAcGFyYW0gdGltZW91dCBUaGUgcHVzaCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIGV2ZW50LCBwYXlsb2FkID0ge30sIHRpbWVvdXQgPSBERUZBVUxUX1RJTUVPVVQpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgICAgICB0aGlzLnNlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50aW1lb3V0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVmID0gJyc7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZWNIb29rcyA9IFtdO1xuICAgICAgICB0aGlzLnJlZkV2ZW50ID0gbnVsbDtcbiAgICB9XG4gICAgcmVzZW5kKHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgdGhpcy5fY2FuY2VsUmVmRXZlbnQoKTtcbiAgICAgICAgdGhpcy5yZWYgPSAnJztcbiAgICAgICAgdGhpcy5yZWZFdmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVjZWl2ZWRSZXNwID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VuZCgpO1xuICAgIH1cbiAgICBzZW5kKCkge1xuICAgICAgICBpZiAodGhpcy5faGFzUmVjZWl2ZWQoJ3RpbWVvdXQnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuc2VudCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5zb2NrZXQucHVzaCh7XG4gICAgICAgICAgICB0b3BpYzogdGhpcy5jaGFubmVsLnRvcGljLFxuICAgICAgICAgICAgZXZlbnQ6IHRoaXMuZXZlbnQsXG4gICAgICAgICAgICBwYXlsb2FkOiB0aGlzLnBheWxvYWQsXG4gICAgICAgICAgICByZWY6IHRoaXMucmVmLFxuICAgICAgICAgICAgam9pbl9yZWY6IHRoaXMuY2hhbm5lbC5fam9pblJlZigpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgICAgIHRoaXMucGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXlsb2FkKSwgcGF5bG9hZCk7XG4gICAgfVxuICAgIHJlY2VpdmUoc3RhdHVzLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLl9oYXNSZWNlaXZlZChzdGF0dXMpKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygoX2EgPSB0aGlzLnJlY2VpdmVkUmVzcCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlY0hvb2tzLnB1c2goeyBzdGF0dXMsIGNhbGxiYWNrIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RhcnRUaW1lb3V0KCkge1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0VGltZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZiA9IHRoaXMuY2hhbm5lbC5zb2NrZXQuX21ha2VSZWYoKTtcbiAgICAgICAgdGhpcy5yZWZFdmVudCA9IHRoaXMuY2hhbm5lbC5fcmVwbHlFdmVudE5hbWUodGhpcy5yZWYpO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxSZWZFdmVudCgpO1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsVGltZW91dCgpO1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZlZFJlc3AgPSBwYXlsb2FkO1xuICAgICAgICAgICAgdGhpcy5fbWF0Y2hSZWNlaXZlKHBheWxvYWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNoYW5uZWwuX29uKHRoaXMucmVmRXZlbnQsIHt9LCBjYWxsYmFjayk7XG4gICAgICAgIHRoaXMudGltZW91dFRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RpbWVvdXQnLCB7fSk7XG4gICAgICAgIH0sIHRoaXMudGltZW91dCk7XG4gICAgfVxuICAgIHRyaWdnZXIoc3RhdHVzLCByZXNwb25zZSkge1xuICAgICAgICBpZiAodGhpcy5yZWZFdmVudClcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5fdHJpZ2dlcih0aGlzLnJlZkV2ZW50LCB7IHN0YXR1cywgcmVzcG9uc2UgfSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2NhbmNlbFJlZkV2ZW50KCk7XG4gICAgICAgIHRoaXMuX2NhbmNlbFRpbWVvdXQoKTtcbiAgICB9XG4gICAgX2NhbmNlbFJlZkV2ZW50KCkge1xuICAgICAgICBpZiAoIXRoaXMucmVmRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5uZWwuX29mZih0aGlzLnJlZkV2ZW50LCB7fSk7XG4gICAgfVxuICAgIF9jYW5jZWxUaW1lb3V0KCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0VGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgX21hdGNoUmVjZWl2ZSh7IHN0YXR1cywgcmVzcG9uc2UgfSkge1xuICAgICAgICB0aGlzLnJlY0hvb2tzLmZpbHRlcigoaCkgPT4gaC5zdGF0dXMgPT09IHN0YXR1cykuZm9yRWFjaCgoaCkgPT4gaC5jYWxsYmFjayhyZXNwb25zZSkpO1xuICAgIH1cbiAgICBfaGFzUmVjZWl2ZWQoc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY2VpdmVkUmVzcCAmJiB0aGlzLnJlY2VpdmVkUmVzcC5zdGF0dXMgPT09IHN0YXR1cztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdXNoLmpzLm1hcCJdLCJuYW1lcyI6WyJERUZBVUxUX1RJTUVPVVQiLCJQdXNoIiwiY29uc3RydWN0b3IiLCJjaGFubmVsIiwiZXZlbnQiLCJwYXlsb2FkIiwidGltZW91dCIsInNlbnQiLCJ0aW1lb3V0VGltZXIiLCJ1bmRlZmluZWQiLCJyZWYiLCJyZWNlaXZlZFJlc3AiLCJyZWNIb29rcyIsInJlZkV2ZW50IiwicmVzZW5kIiwiX2NhbmNlbFJlZkV2ZW50Iiwic2VuZCIsIl9oYXNSZWNlaXZlZCIsInN0YXJ0VGltZW91dCIsInNvY2tldCIsInB1c2giLCJ0b3BpYyIsImpvaW5fcmVmIiwiX2pvaW5SZWYiLCJ1cGRhdGVQYXlsb2FkIiwiT2JqZWN0IiwiYXNzaWduIiwicmVjZWl2ZSIsInN0YXR1cyIsImNhbGxiYWNrIiwiX2EiLCJyZXNwb25zZSIsIl9tYWtlUmVmIiwiX3JlcGx5RXZlbnROYW1lIiwiX2NhbmNlbFRpbWVvdXQiLCJfbWF0Y2hSZWNlaXZlIiwiX29uIiwic2V0VGltZW91dCIsInRyaWdnZXIiLCJfdHJpZ2dlciIsImRlc3Ryb3kiLCJfb2ZmIiwiY2xlYXJUaW1lb3V0IiwiZmlsdGVyIiwiaCIsImZvckVhY2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/push.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Serializer)\n/* harmony export */ });\n// This file draws heavily from https://github.com/phoenixframework/phoenix/commit/cf098e9cf7a44ee6479d31d911a97d3c7430c6fe\n// License: https://github.com/phoenixframework/phoenix/blob/master/LICENSE.md\nclass Serializer {\n    constructor(){\n        this.HEADER_LENGTH = 1;\n    }\n    decode(rawPayload, callback) {\n        if (rawPayload.constructor === ArrayBuffer) {\n            return callback(this._binaryDecode(rawPayload));\n        }\n        if (typeof rawPayload === \"string\") {\n            return callback(JSON.parse(rawPayload));\n        }\n        return callback({});\n    }\n    _binaryDecode(buffer) {\n        const view = new DataView(buffer);\n        const decoder = new TextDecoder();\n        return this._decodeBroadcast(buffer, view, decoder);\n    }\n    _decodeBroadcast(buffer, view, decoder) {\n        const topicSize = view.getUint8(1);\n        const eventSize = view.getUint8(2);\n        let offset = this.HEADER_LENGTH + 2;\n        const topic = decoder.decode(buffer.slice(offset, offset + topicSize));\n        offset = offset + topicSize;\n        const event = decoder.decode(buffer.slice(offset, offset + eventSize));\n        offset = offset + eventSize;\n        const data = JSON.parse(decoder.decode(buffer.slice(offset, buffer.byteLength)));\n        return {\n            ref: null,\n            topic: topic,\n            event: event,\n            payload: data\n        };\n    }\n} //# sourceMappingURL=serializer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi9zZXJpYWxpemVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSwySEFBMkg7QUFDM0gsOEVBQThFO0FBQy9ELE1BQU1BO0lBQ2pCQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxhQUFhLEdBQUc7SUFDekI7SUFDQUMsT0FBT0MsVUFBVSxFQUFFQyxRQUFRLEVBQUU7UUFDekIsSUFBSUQsV0FBV0gsV0FBVyxLQUFLSyxhQUFhO1lBQ3hDLE9BQU9ELFNBQVMsSUFBSSxDQUFDRSxhQUFhLENBQUNIO1FBQ3ZDO1FBQ0EsSUFBSSxPQUFPQSxlQUFlLFVBQVU7WUFDaEMsT0FBT0MsU0FBU0csS0FBS0MsS0FBSyxDQUFDTDtRQUMvQjtRQUNBLE9BQU9DLFNBQVMsQ0FBQztJQUNyQjtJQUNBRSxjQUFjRyxNQUFNLEVBQUU7UUFDbEIsTUFBTUMsT0FBTyxJQUFJQyxTQUFTRjtRQUMxQixNQUFNRyxVQUFVLElBQUlDO1FBQ3BCLE9BQU8sSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0wsUUFBUUMsTUFBTUU7SUFDL0M7SUFDQUUsaUJBQWlCTCxNQUFNLEVBQUVDLElBQUksRUFBRUUsT0FBTyxFQUFFO1FBQ3BDLE1BQU1HLFlBQVlMLEtBQUtNLFFBQVEsQ0FBQztRQUNoQyxNQUFNQyxZQUFZUCxLQUFLTSxRQUFRLENBQUM7UUFDaEMsSUFBSUUsU0FBUyxJQUFJLENBQUNqQixhQUFhLEdBQUc7UUFDbEMsTUFBTWtCLFFBQVFQLFFBQVFWLE1BQU0sQ0FBQ08sT0FBT1csS0FBSyxDQUFDRixRQUFRQSxTQUFTSDtRQUMzREcsU0FBU0EsU0FBU0g7UUFDbEIsTUFBTU0sUUFBUVQsUUFBUVYsTUFBTSxDQUFDTyxPQUFPVyxLQUFLLENBQUNGLFFBQVFBLFNBQVNEO1FBQzNEQyxTQUFTQSxTQUFTRDtRQUNsQixNQUFNSyxPQUFPZixLQUFLQyxLQUFLLENBQUNJLFFBQVFWLE1BQU0sQ0FBQ08sT0FBT1csS0FBSyxDQUFDRixRQUFRVCxPQUFPYyxVQUFVO1FBQzdFLE9BQU87WUFBRUMsS0FBSztZQUFNTCxPQUFPQTtZQUFPRSxPQUFPQTtZQUFPSSxTQUFTSDtRQUFLO0lBQ2xFO0FBQ0osRUFDQSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3NlcmlhbGl6ZXIuanM/ODFkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIGZpbGUgZHJhd3MgaGVhdmlseSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvY29tbWl0L2NmMDk4ZTljZjdhNDRlZTY0NzlkMzFkOTExYTk3ZDNjNzQzMGM2ZmVcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9waG9lbml4ZnJhbWV3b3JrL3Bob2VuaXgvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZFxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2VyaWFsaXplciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuSEVBREVSX0xFTkdUSCA9IDE7XG4gICAgfVxuICAgIGRlY29kZShyYXdQYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAocmF3UGF5bG9hZC5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9iaW5hcnlEZWNvZGUocmF3UGF5bG9hZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcmF3UGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhKU09OLnBhcnNlKHJhd1BheWxvYWQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soe30pO1xuICAgIH1cbiAgICBfYmluYXJ5RGVjb2RlKGJ1ZmZlcikge1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZUJyb2FkY2FzdChidWZmZXIsIHZpZXcsIGRlY29kZXIpO1xuICAgIH1cbiAgICBfZGVjb2RlQnJvYWRjYXN0KGJ1ZmZlciwgdmlldywgZGVjb2Rlcikge1xuICAgICAgICBjb25zdCB0b3BpY1NpemUgPSB2aWV3LmdldFVpbnQ4KDEpO1xuICAgICAgICBjb25zdCBldmVudFNpemUgPSB2aWV3LmdldFVpbnQ4KDIpO1xuICAgICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5IRUFERVJfTEVOR1RIICsgMjtcbiAgICAgICAgY29uc3QgdG9waWMgPSBkZWNvZGVyLmRlY29kZShidWZmZXIuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0b3BpY1NpemUpKTtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgdG9waWNTaXplO1xuICAgICAgICBjb25zdCBldmVudCA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIG9mZnNldCArIGV2ZW50U2l6ZSkpO1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyBldmVudFNpemU7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGRlY29kZXIuZGVjb2RlKGJ1ZmZlci5zbGljZShvZmZzZXQsIGJ1ZmZlci5ieXRlTGVuZ3RoKSkpO1xuICAgICAgICByZXR1cm4geyByZWY6IG51bGwsIHRvcGljOiB0b3BpYywgZXZlbnQ6IGV2ZW50LCBwYXlsb2FkOiBkYXRhIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VyaWFsaXplci5qcy5tYXAiXSwibmFtZXMiOlsiU2VyaWFsaXplciIsImNvbnN0cnVjdG9yIiwiSEVBREVSX0xFTkdUSCIsImRlY29kZSIsInJhd1BheWxvYWQiLCJjYWxsYmFjayIsIkFycmF5QnVmZmVyIiwiX2JpbmFyeURlY29kZSIsIkpTT04iLCJwYXJzZSIsImJ1ZmZlciIsInZpZXciLCJEYXRhVmlldyIsImRlY29kZXIiLCJUZXh0RGVjb2RlciIsIl9kZWNvZGVCcm9hZGNhc3QiLCJ0b3BpY1NpemUiLCJnZXRVaW50OCIsImV2ZW50U2l6ZSIsIm9mZnNldCIsInRvcGljIiwic2xpY2UiLCJldmVudCIsImRhdGEiLCJieXRlTGVuZ3RoIiwicmVmIiwicGF5bG9hZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/serializer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/timer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Timer)\n/* harmony export */ });\n/**\n * Creates a timer that accepts a `timerCalc` function to perform calculated timeout retries, such as exponential backoff.\n *\n * @example\n *    let reconnectTimer = new Timer(() => this.connect(), function(tries){\n *      return [1000, 5000, 10000][tries - 1] || 10000\n *    })\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n *    reconnectTimer.scheduleTimeout() // fires after 5000\n *    reconnectTimer.reset()\n *    reconnectTimer.scheduleTimeout() // fires after 1000\n */ class Timer {\n    constructor(callback, timerCalc){\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n        this.timer = undefined;\n        this.tries = 0;\n        this.callback = callback;\n        this.timerCalc = timerCalc;\n    }\n    reset() {\n        this.tries = 0;\n        clearTimeout(this.timer);\n        this.timer = undefined;\n    }\n    // Cancels any previous scheduleTimeout and schedules callback\n    scheduleTimeout() {\n        clearTimeout(this.timer);\n        this.timer = setTimeout(()=>{\n            this.tries = this.tries + 1;\n            this.callback();\n        }, this.timerCalc(this.tries + 1));\n    }\n} //# sourceMappingURL=timer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi90aW1lci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7Ozs7Ozs7Ozs7O0NBV0MsR0FDYyxNQUFNQTtJQUNqQkMsWUFBWUMsUUFBUSxFQUFFQyxTQUFTLENBQUU7UUFDN0IsSUFBSSxDQUFDRCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0MsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLEtBQUssR0FBR0M7UUFDYixJQUFJLENBQUNDLEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0osUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLFNBQVMsR0FBR0E7SUFDckI7SUFDQUksUUFBUTtRQUNKLElBQUksQ0FBQ0QsS0FBSyxHQUFHO1FBQ2JFLGFBQWEsSUFBSSxDQUFDSixLQUFLO1FBQ3ZCLElBQUksQ0FBQ0EsS0FBSyxHQUFHQztJQUNqQjtJQUNBLDhEQUE4RDtJQUM5REksa0JBQWtCO1FBQ2RELGFBQWEsSUFBSSxDQUFDSixLQUFLO1FBQ3ZCLElBQUksQ0FBQ0EsS0FBSyxHQUFHTSxXQUFXO1lBQ3BCLElBQUksQ0FBQ0osS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSyxHQUFHO1lBQzFCLElBQUksQ0FBQ0osUUFBUTtRQUNqQixHQUFHLElBQUksQ0FBQ0MsU0FBUyxDQUFDLElBQUksQ0FBQ0csS0FBSyxHQUFHO0lBQ25DO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcmVhbHRpbWUtanMvZGlzdC9tb2R1bGUvbGliL3RpbWVyLmpzPzExNWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDcmVhdGVzIGEgdGltZXIgdGhhdCBhY2NlcHRzIGEgYHRpbWVyQ2FsY2AgZnVuY3Rpb24gdG8gcGVyZm9ybSBjYWxjdWxhdGVkIHRpbWVvdXQgcmV0cmllcywgc3VjaCBhcyBleHBvbmVudGlhbCBiYWNrb2ZmLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICBsZXQgcmVjb25uZWN0VGltZXIgPSBuZXcgVGltZXIoKCkgPT4gdGhpcy5jb25uZWN0KCksIGZ1bmN0aW9uKHRyaWVzKXtcbiAqICAgICAgcmV0dXJuIFsxMDAwLCA1MDAwLCAxMDAwMF1bdHJpZXMgLSAxXSB8fCAxMDAwMFxuICogICAgfSlcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDUwMDBcbiAqICAgIHJlY29ubmVjdFRpbWVyLnJlc2V0KClcbiAqICAgIHJlY29ubmVjdFRpbWVyLnNjaGVkdWxlVGltZW91dCgpIC8vIGZpcmVzIGFmdGVyIDEwMDBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGltZXIge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCB0aW1lckNhbGMpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLnRpbWVyQ2FsYyA9IHRpbWVyQ2FsYztcbiAgICAgICAgdGhpcy50aW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50cmllcyA9IDA7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy50aW1lckNhbGMgPSB0aW1lckNhbGM7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnRyaWVzID0gMDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBDYW5jZWxzIGFueSBwcmV2aW91cyBzY2hlZHVsZVRpbWVvdXQgYW5kIHNjaGVkdWxlcyBjYWxsYmFja1xuICAgIHNjaGVkdWxlVGltZW91dCgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyaWVzID0gdGhpcy50cmllcyArIDE7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICAgIH0sIHRoaXMudGltZXJDYWxjKHRoaXMudHJpZXMgKyAxKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXIuanMubWFwIl0sIm5hbWVzIjpbIlRpbWVyIiwiY29uc3RydWN0b3IiLCJjYWxsYmFjayIsInRpbWVyQ2FsYyIsInRpbWVyIiwidW5kZWZpbmVkIiwidHJpZXMiLCJyZXNldCIsImNsZWFyVGltZW91dCIsInNjaGVkdWxlVGltZW91dCIsInNldFRpbWVvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/timer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgresTypes: () => (/* binding */ PostgresTypes),\n/* harmony export */   convertCell: () => (/* binding */ convertCell),\n/* harmony export */   convertChangeData: () => (/* binding */ convertChangeData),\n/* harmony export */   convertColumn: () => (/* binding */ convertColumn),\n/* harmony export */   httpEndpointURL: () => (/* binding */ httpEndpointURL),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toJson: () => (/* binding */ toJson),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toTimestampString: () => (/* binding */ toTimestampString)\n/* harmony export */ });\n/**\n * Helpers to convert the change Payload into native JS types.\n */ // Adapted from epgsql (src/epgsql_binary.erl), this module licensed under\n// 3-clause BSD found here: https://raw.githubusercontent.com/epgsql/epgsql/devel/LICENSE\nvar PostgresTypes;\n(function(PostgresTypes) {\n    PostgresTypes[\"abstime\"] = \"abstime\";\n    PostgresTypes[\"bool\"] = \"bool\";\n    PostgresTypes[\"date\"] = \"date\";\n    PostgresTypes[\"daterange\"] = \"daterange\";\n    PostgresTypes[\"float4\"] = \"float4\";\n    PostgresTypes[\"float8\"] = \"float8\";\n    PostgresTypes[\"int2\"] = \"int2\";\n    PostgresTypes[\"int4\"] = \"int4\";\n    PostgresTypes[\"int4range\"] = \"int4range\";\n    PostgresTypes[\"int8\"] = \"int8\";\n    PostgresTypes[\"int8range\"] = \"int8range\";\n    PostgresTypes[\"json\"] = \"json\";\n    PostgresTypes[\"jsonb\"] = \"jsonb\";\n    PostgresTypes[\"money\"] = \"money\";\n    PostgresTypes[\"numeric\"] = \"numeric\";\n    PostgresTypes[\"oid\"] = \"oid\";\n    PostgresTypes[\"reltime\"] = \"reltime\";\n    PostgresTypes[\"text\"] = \"text\";\n    PostgresTypes[\"time\"] = \"time\";\n    PostgresTypes[\"timestamp\"] = \"timestamp\";\n    PostgresTypes[\"timestamptz\"] = \"timestamptz\";\n    PostgresTypes[\"timetz\"] = \"timetz\";\n    PostgresTypes[\"tsrange\"] = \"tsrange\";\n    PostgresTypes[\"tstzrange\"] = \"tstzrange\";\n})(PostgresTypes || (PostgresTypes = {}));\n/**\n * Takes an array of columns and an object of string values then converts each string value\n * to its mapped type.\n *\n * @param {{name: String, type: String}[]} columns\n * @param {Object} record\n * @param {Object} options The map of various options that can be applied to the mapper\n * @param {Array} options.skipTypes The array of types that should not be converted\n *\n * @example convertChangeData([{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age:'33'}, {})\n * //=>{ first_name: 'Paul', age: 33 }\n */ const convertChangeData = (columns, record, options = {})=>{\n    var _a;\n    const skipTypes = (_a = options.skipTypes) !== null && _a !== void 0 ? _a : [];\n    if (!record) {\n        return {};\n    }\n    return Object.keys(record).reduce((acc, rec_key)=>{\n        acc[rec_key] = convertColumn(rec_key, columns, record, skipTypes);\n        return acc;\n    }, {});\n};\n/**\n * Converts the value of an individual column.\n *\n * @param {String} columnName The column that you want to convert\n * @param {{name: String, type: String}[]} columns All of the columns\n * @param {Object} record The map of string values\n * @param {Array} skipTypes An array of types that should not be converted\n * @return {object} Useless information\n *\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, [])\n * //=> 33\n * @example convertColumn('age', [{name: 'first_name', type: 'text'}, {name: 'age', type: 'int4'}], {first_name: 'Paul', age: '33'}, ['int4'])\n * //=> \"33\"\n */ const convertColumn = (columnName, columns, record, skipTypes)=>{\n    const column = columns.find((x)=>x.name === columnName);\n    const colType = column === null || column === void 0 ? void 0 : column.type;\n    const value = record[columnName];\n    if (colType && !skipTypes.includes(colType)) {\n        return convertCell(colType, value);\n    }\n    return noop(value);\n};\n/**\n * If the value of the cell is `null`, returns null.\n * Otherwise converts the string value to the correct type.\n * @param {String} type A postgres column type\n * @param {String} value The cell value\n *\n * @example convertCell('bool', 't')\n * //=> true\n * @example convertCell('int8', '10')\n * //=> 10\n * @example convertCell('_int4', '{1,2,3,4}')\n * //=> [1,2,3,4]\n */ const convertCell = (type, value)=>{\n    // if data type is an array\n    if (type.charAt(0) === \"_\") {\n        const dataType = type.slice(1, type.length);\n        return toArray(value, dataType);\n    }\n    // If not null, convert to correct type.\n    switch(type){\n        case PostgresTypes.bool:\n            return toBoolean(value);\n        case PostgresTypes.float4:\n        case PostgresTypes.float8:\n        case PostgresTypes.int2:\n        case PostgresTypes.int4:\n        case PostgresTypes.int8:\n        case PostgresTypes.numeric:\n        case PostgresTypes.oid:\n            return toNumber(value);\n        case PostgresTypes.json:\n        case PostgresTypes.jsonb:\n            return toJson(value);\n        case PostgresTypes.timestamp:\n            return toTimestampString(value); // Format to be consistent with PostgREST\n        case PostgresTypes.abstime:\n        case PostgresTypes.date:\n        case PostgresTypes.daterange:\n        case PostgresTypes.int4range:\n        case PostgresTypes.int8range:\n        case PostgresTypes.money:\n        case PostgresTypes.reltime:\n        case PostgresTypes.text:\n        case PostgresTypes.time:\n        case PostgresTypes.timestamptz:\n        case PostgresTypes.timetz:\n        case PostgresTypes.tsrange:\n        case PostgresTypes.tstzrange:\n            return noop(value);\n        default:\n            // Return the value for remaining types\n            return noop(value);\n    }\n};\nconst noop = (value)=>{\n    return value;\n};\nconst toBoolean = (value)=>{\n    switch(value){\n        case \"t\":\n            return true;\n        case \"f\":\n            return false;\n        default:\n            return value;\n    }\n};\nconst toNumber = (value)=>{\n    if (typeof value === \"string\") {\n        const parsedValue = parseFloat(value);\n        if (!Number.isNaN(parsedValue)) {\n            return parsedValue;\n        }\n    }\n    return value;\n};\nconst toJson = (value)=>{\n    if (typeof value === \"string\") {\n        try {\n            return JSON.parse(value);\n        } catch (error) {\n            console.log(`JSON parse error: ${error}`);\n            return value;\n        }\n    }\n    return value;\n};\n/**\n * Converts a Postgres Array into a native JS array\n *\n * @example toArray('{}', 'int4')\n * //=> []\n * @example toArray('{\"[2021-01-01,2021-12-31)\",\"(2021-01-01,2021-12-32]\"}', 'daterange')\n * //=> ['[2021-01-01,2021-12-31)', '(2021-01-01,2021-12-32]']\n * @example toArray([1,2,3,4], 'int4')\n * //=> [1,2,3,4]\n */ const toArray = (value, type)=>{\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    const lastIdx = value.length - 1;\n    const closeBrace = value[lastIdx];\n    const openBrace = value[0];\n    // Confirm value is a Postgres array by checking curly brackets\n    if (openBrace === \"{\" && closeBrace === \"}\") {\n        let arr;\n        const valTrim = value.slice(1, lastIdx);\n        // TODO: find a better solution to separate Postgres array data\n        try {\n            arr = JSON.parse(\"[\" + valTrim + \"]\");\n        } catch (_) {\n            // WARNING: splitting on comma does not cover all edge cases\n            arr = valTrim ? valTrim.split(\",\") : [];\n        }\n        return arr.map((val)=>convertCell(type, val));\n    }\n    return value;\n};\n/**\n * Fixes timestamp to be ISO-8601. Swaps the space between the date and time for a 'T'\n * See https://github.com/supabase/supabase/issues/18\n *\n * @example toTimestampString('2019-09-10 00:00:00')\n * //=> '2019-09-10T00:00:00'\n */ const toTimestampString = (value)=>{\n    if (typeof value === \"string\") {\n        return value.replace(\" \", \"T\");\n    }\n    return value;\n};\nconst httpEndpointURL = (socketUrl)=>{\n    const wsUrl = new URL(socketUrl);\n    wsUrl.protocol = wsUrl.protocol.replace(/^ws/i, \"http\");\n    wsUrl.pathname = wsUrl.pathname.replace(/\\/+$/, \"\") // remove all trailing slashes\n    .replace(/\\/socket\\/websocket$/i, \"\") // remove the socket/websocket path\n    .replace(/\\/socket$/i, \"\") // remove the socket path\n    .replace(/\\/websocket$/i, \"\"); // remove the websocket path\n    if (wsUrl.pathname === \"\" || wsUrl.pathname === \"/\") {\n        wsUrl.pathname = \"/api/broadcast\";\n    } else {\n        wsUrl.pathname = wsUrl.pathname + \"/api/broadcast\";\n    }\n    return wsUrl.href;\n}; //# sourceMappingURL=transformers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi90cmFuc2Zvcm1lcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBQ0QsMEVBQTBFO0FBQzFFLHlGQUF5RjtBQUNsRixJQUFJQSxjQUFjO0FBQ3hCLFVBQVVBLGFBQWE7SUFDcEJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxTQUFTLEdBQUc7SUFDMUJBLGFBQWEsQ0FBQyxTQUFTLEdBQUc7SUFDMUJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxRQUFRLEdBQUc7SUFDekJBLGFBQWEsQ0FBQyxRQUFRLEdBQUc7SUFDekJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxNQUFNLEdBQUc7SUFDdkJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxPQUFPLEdBQUc7SUFDeEJBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7SUFDN0JBLGFBQWEsQ0FBQyxjQUFjLEdBQUc7SUFDL0JBLGFBQWEsQ0FBQyxTQUFTLEdBQUc7SUFDMUJBLGFBQWEsQ0FBQyxVQUFVLEdBQUc7SUFDM0JBLGFBQWEsQ0FBQyxZQUFZLEdBQUc7QUFDakMsR0FBR0EsaUJBQWtCQSxDQUFBQSxnQkFBZ0IsQ0FBQztBQUN0Qzs7Ozs7Ozs7Ozs7Q0FXQyxH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SUFDOUIsSUFBSSxPQUFPQSxVQUFVLFVBQVU7UUFDM0IsT0FBT0EsTUFBTXVELE9BQU8sQ0FBQyxLQUFLO0lBQzlCO0lBQ0EsT0FBT3ZEO0FBQ1gsRUFBRTtBQUNLLE1BQU13RCxrQkFBa0IsQ0FBQ0M7SUFDNUIsTUFBTUMsUUFBUSxJQUFJQyxJQUFJRjtJQUN0QkMsTUFBTUUsUUFBUSxHQUFHRixNQUFNRSxRQUFRLENBQUNMLE9BQU8sQ0FBQyxRQUFRO0lBQ2hERyxNQUFNRyxRQUFRLEdBQUdILE1BQU1HLFFBQVEsQ0FDMUJOLE9BQU8sQ0FBQyxRQUFRLElBQUksOEJBQThCO0tBQ2xEQSxPQUFPLENBQUMseUJBQXlCLElBQUksbUNBQW1DO0tBQ3hFQSxPQUFPLENBQUMsY0FBYyxJQUFJLHlCQUF5QjtLQUNuREEsT0FBTyxDQUFDLGlCQUFpQixLQUFLLDRCQUE0QjtJQUMvRCxJQUFJRyxNQUFNRyxRQUFRLEtBQUssTUFBTUgsTUFBTUcsUUFBUSxLQUFLLEtBQUs7UUFDakRILE1BQU1HLFFBQVEsR0FBRztJQUNyQixPQUNLO1FBQ0RILE1BQU1HLFFBQVEsR0FBR0gsTUFBTUcsUUFBUSxHQUFHO0lBQ3RDO0lBQ0EsT0FBT0gsTUFBTUksSUFBSTtBQUNyQixFQUFFLENBQ0Ysd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi90cmFuc2Zvcm1lcnMuanM/M2ZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEhlbHBlcnMgdG8gY29udmVydCB0aGUgY2hhbmdlIFBheWxvYWQgaW50byBuYXRpdmUgSlMgdHlwZXMuXG4gKi9cbi8vIEFkYXB0ZWQgZnJvbSBlcGdzcWwgKHNyYy9lcGdzcWxfYmluYXJ5LmVybCksIHRoaXMgbW9kdWxlIGxpY2Vuc2VkIHVuZGVyXG4vLyAzLWNsYXVzZSBCU0QgZm91bmQgaGVyZTogaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2VwZ3NxbC9lcGdzcWwvZGV2ZWwvTElDRU5TRVxuZXhwb3J0IHZhciBQb3N0Z3Jlc1R5cGVzO1xuKGZ1bmN0aW9uIChQb3N0Z3Jlc1R5cGVzKSB7XG4gICAgUG9zdGdyZXNUeXBlc1tcImFic3RpbWVcIl0gPSBcImFic3RpbWVcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiYm9vbFwiXSA9IFwiYm9vbFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJkYXRlXCJdID0gXCJkYXRlXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImRhdGVyYW5nZVwiXSA9IFwiZGF0ZXJhbmdlXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImZsb2F0NFwiXSA9IFwiZmxvYXQ0XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImZsb2F0OFwiXSA9IFwiZmxvYXQ4XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImludDJcIl0gPSBcImludDJcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wiaW50NFwiXSA9IFwiaW50NFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQ0cmFuZ2VcIl0gPSBcImludDRyYW5nZVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJpbnQ4XCJdID0gXCJpbnQ4XCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImludDhyYW5nZVwiXSA9IFwiaW50OHJhbmdlXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcImpzb25cIl0gPSBcImpzb25cIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1wianNvbmJcIl0gPSBcImpzb25iXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcIm1vbmV5XCJdID0gXCJtb25leVwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJudW1lcmljXCJdID0gXCJudW1lcmljXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcIm9pZFwiXSA9IFwib2lkXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInJlbHRpbWVcIl0gPSBcInJlbHRpbWVcIjtcbiAgICBQb3N0Z3Jlc1R5cGVzW1widGV4dFwiXSA9IFwidGV4dFwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0aW1lXCJdID0gXCJ0aW1lXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRpbWVzdGFtcFwiXSA9IFwidGltZXN0YW1wXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRpbWVzdGFtcHR6XCJdID0gXCJ0aW1lc3RhbXB0elwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0aW1ldHpcIl0gPSBcInRpbWV0elwiO1xuICAgIFBvc3RncmVzVHlwZXNbXCJ0c3JhbmdlXCJdID0gXCJ0c3JhbmdlXCI7XG4gICAgUG9zdGdyZXNUeXBlc1tcInRzdHpyYW5nZVwiXSA9IFwidHN0enJhbmdlXCI7XG59KShQb3N0Z3Jlc1R5cGVzIHx8IChQb3N0Z3Jlc1R5cGVzID0ge30pKTtcbi8qKlxuICogVGFrZXMgYW4gYXJyYXkgb2YgY29sdW1ucyBhbmQgYW4gb2JqZWN0IG9mIHN0cmluZyB2YWx1ZXMgdGhlbiBjb252ZXJ0cyBlYWNoIHN0cmluZyB2YWx1ZVxuICogdG8gaXRzIG1hcHBlZCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7e25hbWU6IFN0cmluZywgdHlwZTogU3RyaW5nfVtdfSBjb2x1bW5zXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjb3JkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgbWFwIG9mIHZhcmlvdXMgb3B0aW9ucyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIHRoZSBtYXBwZXJcbiAqIEBwYXJhbSB7QXJyYXl9IG9wdGlvbnMuc2tpcFR5cGVzIFRoZSBhcnJheSBvZiB0eXBlcyB0aGF0IHNob3VsZCBub3QgYmUgY29udmVydGVkXG4gKlxuICogQGV4YW1wbGUgY29udmVydENoYW5nZURhdGEoW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTonMzMnfSwge30pXG4gKiAvLz0+eyBmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogMzMgfVxuICovXG5leHBvcnQgY29uc3QgY29udmVydENoYW5nZURhdGEgPSAoY29sdW1ucywgcmVjb3JkLCBvcHRpb25zID0ge30pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc2tpcFR5cGVzID0gKF9hID0gb3B0aW9ucy5za2lwVHlwZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHJlY29yZCkucmVkdWNlKChhY2MsIHJlY19rZXkpID0+IHtcbiAgICAgICAgYWNjW3JlY19rZXldID0gY29udmVydENvbHVtbihyZWNfa2V5LCBjb2x1bW5zLCByZWNvcmQsIHNraXBUeXBlcyk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xufTtcbi8qKlxuICogQ29udmVydHMgdGhlIHZhbHVlIG9mIGFuIGluZGl2aWR1YWwgY29sdW1uLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2x1bW5OYW1lIFRoZSBjb2x1bW4gdGhhdCB5b3Ugd2FudCB0byBjb252ZXJ0XG4gKiBAcGFyYW0ge3tuYW1lOiBTdHJpbmcsIHR5cGU6IFN0cmluZ31bXX0gY29sdW1ucyBBbGwgb2YgdGhlIGNvbHVtbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWNvcmQgVGhlIG1hcCBvZiBzdHJpbmcgdmFsdWVzXG4gKiBAcGFyYW0ge0FycmF5fSBza2lwVHlwZXMgQW4gYXJyYXkgb2YgdHlwZXMgdGhhdCBzaG91bGQgbm90IGJlIGNvbnZlcnRlZFxuICogQHJldHVybiB7b2JqZWN0fSBVc2VsZXNzIGluZm9ybWF0aW9uXG4gKlxuICogQGV4YW1wbGUgY29udmVydENvbHVtbignYWdlJywgW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogJzMzJ30sIFtdKVxuICogLy89PiAzM1xuICogQGV4YW1wbGUgY29udmVydENvbHVtbignYWdlJywgW3tuYW1lOiAnZmlyc3RfbmFtZScsIHR5cGU6ICd0ZXh0J30sIHtuYW1lOiAnYWdlJywgdHlwZTogJ2ludDQnfV0sIHtmaXJzdF9uYW1lOiAnUGF1bCcsIGFnZTogJzMzJ30sIFsnaW50NCddKVxuICogLy89PiBcIjMzXCJcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRDb2x1bW4gPSAoY29sdW1uTmFtZSwgY29sdW1ucywgcmVjb3JkLCBza2lwVHlwZXMpID0+IHtcbiAgICBjb25zdCBjb2x1bW4gPSBjb2x1bW5zLmZpbmQoKHgpID0+IHgubmFtZSA9PT0gY29sdW1uTmFtZSk7XG4gICAgY29uc3QgY29sVHlwZSA9IGNvbHVtbiA9PT0gbnVsbCB8fCBjb2x1bW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbHVtbi50eXBlO1xuICAgIGNvbnN0IHZhbHVlID0gcmVjb3JkW2NvbHVtbk5hbWVdO1xuICAgIGlmIChjb2xUeXBlICYmICFza2lwVHlwZXMuaW5jbHVkZXMoY29sVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGNvbnZlcnRDZWxsKGNvbFR5cGUsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vb3AodmFsdWUpO1xufTtcbi8qKlxuICogSWYgdGhlIHZhbHVlIG9mIHRoZSBjZWxsIGlzIGBudWxsYCwgcmV0dXJucyBudWxsLlxuICogT3RoZXJ3aXNlIGNvbnZlcnRzIHRoZSBzdHJpbmcgdmFsdWUgdG8gdGhlIGNvcnJlY3QgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgcG9zdGdyZXMgY29sdW1uIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgY2VsbCB2YWx1ZVxuICpcbiAqIEBleGFtcGxlIGNvbnZlcnRDZWxsKCdib29sJywgJ3QnKVxuICogLy89PiB0cnVlXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnaW50OCcsICcxMCcpXG4gKiAvLz0+IDEwXG4gKiBAZXhhbXBsZSBjb252ZXJ0Q2VsbCgnX2ludDQnLCAnezEsMiwzLDR9JylcbiAqIC8vPT4gWzEsMiwzLDRdXG4gKi9cbmV4cG9ydCBjb25zdCBjb252ZXJ0Q2VsbCA9ICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgIC8vIGlmIGRhdGEgdHlwZSBpcyBhbiBhcnJheVxuICAgIGlmICh0eXBlLmNoYXJBdCgwKSA9PT0gJ18nKSB7XG4gICAgICAgIGNvbnN0IGRhdGFUeXBlID0gdHlwZS5zbGljZSgxLCB0eXBlLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB0b0FycmF5KHZhbHVlLCBkYXRhVHlwZSk7XG4gICAgfVxuICAgIC8vIElmIG5vdCBudWxsLCBjb252ZXJ0IHRvIGNvcnJlY3QgdHlwZS5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmJvb2w6XG4gICAgICAgICAgICByZXR1cm4gdG9Cb29sZWFuKHZhbHVlKTtcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmZsb2F0NDpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmZsb2F0ODpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmludDI6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5pbnQ0OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50ODpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLm51bWVyaWM6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5vaWQ6XG4gICAgICAgICAgICByZXR1cm4gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuanNvbjpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLmpzb25iOlxuICAgICAgICAgICAgcmV0dXJuIHRvSnNvbih2YWx1ZSk7XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50aW1lc3RhbXA6XG4gICAgICAgICAgICByZXR1cm4gdG9UaW1lc3RhbXBTdHJpbmcodmFsdWUpOyAvLyBGb3JtYXQgdG8gYmUgY29uc2lzdGVudCB3aXRoIFBvc3RnUkVTVFxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuYWJzdGltZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuZGF0ZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuZGF0ZXJhbmdlOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50NHJhbmdlOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMuaW50OHJhbmdlOlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMubW9uZXk6XG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy5yZWx0aW1lOiAvLyBUbyBhbGxvdyB1c2VycyB0byBjYXN0IGl0IGJhc2VkIG9uIFRpbWV6b25lXG4gICAgICAgIGNhc2UgUG9zdGdyZXNUeXBlcy50ZXh0OlxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZTogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudGltZXN0YW1wdHo6IC8vIFRvIGFsbG93IHVzZXJzIHRvIGNhc3QgaXQgYmFzZWQgb24gVGltZXpvbmVcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRpbWV0ejogLy8gVG8gYWxsb3cgdXNlcnMgdG8gY2FzdCBpdCBiYXNlZCBvbiBUaW1lem9uZVxuICAgICAgICBjYXNlIFBvc3RncmVzVHlwZXMudHNyYW5nZTpcbiAgICAgICAgY2FzZSBQb3N0Z3Jlc1R5cGVzLnRzdHpyYW5nZTpcbiAgICAgICAgICAgIHJldHVybiBub29wKHZhbHVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgdmFsdWUgZm9yIHJlbWFpbmluZyB0eXBlc1xuICAgICAgICAgICAgcmV0dXJuIG5vb3AodmFsdWUpO1xuICAgIH1cbn07XG5jb25zdCBub29wID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCB0b0Jvb2xlYW4gPSAodmFsdWUpID0+IHtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgdG9OdW1iZXIgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTihwYXJzZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IHRvSnNvbiA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgSlNPTiBwYXJzZSBlcnJvcjogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIFBvc3RncmVzIEFycmF5IGludG8gYSBuYXRpdmUgSlMgYXJyYXlcbiAqXG4gKiBAZXhhbXBsZSB0b0FycmF5KCd7fScsICdpbnQ0JylcbiAqIC8vPT4gW11cbiAqIEBleGFtcGxlIHRvQXJyYXkoJ3tcIlsyMDIxLTAxLTAxLDIwMjEtMTItMzEpXCIsXCIoMjAyMS0wMS0wMSwyMDIxLTEyLTMyXVwifScsICdkYXRlcmFuZ2UnKVxuICogLy89PiBbJ1syMDIxLTAxLTAxLDIwMjEtMTItMzEpJywgJygyMDIxLTAxLTAxLDIwMjEtMTItMzJdJ11cbiAqIEBleGFtcGxlIHRvQXJyYXkoWzEsMiwzLDRdLCAnaW50NCcpXG4gKiAvLz0+IFsxLDIsMyw0XVxuICovXG5leHBvcnQgY29uc3QgdG9BcnJheSA9ICh2YWx1ZSwgdHlwZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgbGFzdElkeCA9IHZhbHVlLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgY2xvc2VCcmFjZSA9IHZhbHVlW2xhc3RJZHhdO1xuICAgIGNvbnN0IG9wZW5CcmFjZSA9IHZhbHVlWzBdO1xuICAgIC8vIENvbmZpcm0gdmFsdWUgaXMgYSBQb3N0Z3JlcyBhcnJheSBieSBjaGVja2luZyBjdXJseSBicmFja2V0c1xuICAgIGlmIChvcGVuQnJhY2UgPT09ICd7JyAmJiBjbG9zZUJyYWNlID09PSAnfScpIHtcbiAgICAgICAgbGV0IGFycjtcbiAgICAgICAgY29uc3QgdmFsVHJpbSA9IHZhbHVlLnNsaWNlKDEsIGxhc3RJZHgpO1xuICAgICAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHNvbHV0aW9uIHRvIHNlcGFyYXRlIFBvc3RncmVzIGFycmF5IGRhdGFcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFyciA9IEpTT04ucGFyc2UoJ1snICsgdmFsVHJpbSArICddJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIC8vIFdBUk5JTkc6IHNwbGl0dGluZyBvbiBjb21tYSBkb2VzIG5vdCBjb3ZlciBhbGwgZWRnZSBjYXNlc1xuICAgICAgICAgICAgYXJyID0gdmFsVHJpbSA/IHZhbFRyaW0uc3BsaXQoJywnKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnIubWFwKCh2YWwpID0+IGNvbnZlcnRDZWxsKHR5cGUsIHZhbCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuLyoqXG4gKiBGaXhlcyB0aW1lc3RhbXAgdG8gYmUgSVNPLTg2MDEuIFN3YXBzIHRoZSBzcGFjZSBiZXR3ZWVuIHRoZSBkYXRlIGFuZCB0aW1lIGZvciBhICdUJ1xuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdXBhYmFzZS9zdXBhYmFzZS9pc3N1ZXMvMThcbiAqXG4gKiBAZXhhbXBsZSB0b1RpbWVzdGFtcFN0cmluZygnMjAxOS0wOS0xMCAwMDowMDowMCcpXG4gKiAvLz0+ICcyMDE5LTA5LTEwVDAwOjAwOjAwJ1xuICovXG5leHBvcnQgY29uc3QgdG9UaW1lc3RhbXBTdHJpbmcgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgnICcsICdUJyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5leHBvcnQgY29uc3QgaHR0cEVuZHBvaW50VVJMID0gKHNvY2tldFVybCkgPT4ge1xuICAgIGNvbnN0IHdzVXJsID0gbmV3IFVSTChzb2NrZXRVcmwpO1xuICAgIHdzVXJsLnByb3RvY29sID0gd3NVcmwucHJvdG9jb2wucmVwbGFjZSgvXndzL2ksICdodHRwJyk7XG4gICAgd3NVcmwucGF0aG5hbWUgPSB3c1VybC5wYXRobmFtZVxuICAgICAgICAucmVwbGFjZSgvXFwvKyQvLCAnJykgLy8gcmVtb3ZlIGFsbCB0cmFpbGluZyBzbGFzaGVzXG4gICAgICAgIC5yZXBsYWNlKC9cXC9zb2NrZXRcXC93ZWJzb2NrZXQkL2ksICcnKSAvLyByZW1vdmUgdGhlIHNvY2tldC93ZWJzb2NrZXQgcGF0aFxuICAgICAgICAucmVwbGFjZSgvXFwvc29ja2V0JC9pLCAnJykgLy8gcmVtb3ZlIHRoZSBzb2NrZXQgcGF0aFxuICAgICAgICAucmVwbGFjZSgvXFwvd2Vic29ja2V0JC9pLCAnJyk7IC8vIHJlbW92ZSB0aGUgd2Vic29ja2V0IHBhdGhcbiAgICBpZiAod3NVcmwucGF0aG5hbWUgPT09ICcnIHx8IHdzVXJsLnBhdGhuYW1lID09PSAnLycpIHtcbiAgICAgICAgd3NVcmwucGF0aG5hbWUgPSAnL2FwaS9icm9hZGNhc3QnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd3NVcmwucGF0aG5hbWUgPSB3c1VybC5wYXRobmFtZSArICcvYXBpL2Jyb2FkY2FzdCc7XG4gICAgfVxuICAgIHJldHVybiB3c1VybC5ocmVmO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybWVycy5qcy5tYXAiXSwibmFtZXMiOlsiUG9zdGdyZXNUeXBlcyIsImNvbnZlcnRDaGFuZ2VEYXRhIiwiY29sdW1ucyIsInJlY29yZCIsIm9wdGlvbnMiLCJfYSIsInNraXBUeXBlcyIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2MiLCJyZWNfa2V5IiwiY29udmVydENvbHVtbiIsImNvbHVtbk5hbWUiLCJjb2x1bW4iLCJmaW5kIiwieCIsIm5hbWUiLCJjb2xUeXBlIiwidHlwZSIsInZhbHVlIiwiaW5jbHVkZXMiLCJjb252ZXJ0Q2VsbCIsIm5vb3AiLCJjaGFyQXQiLCJkYXRhVHlwZSIsInNsaWNlIiwibGVuZ3RoIiwidG9BcnJheSIsImJvb2wiLCJ0b0Jvb2xlYW4iLCJmbG9hdDQiLCJmbG9hdDgiLCJpbnQyIiwiaW50NCIsImludDgiLCJudW1lcmljIiwib2lkIiwidG9OdW1iZXIiLCJqc29uIiwianNvbmIiLCJ0b0pzb24iLCJ0aW1lc3RhbXAiLCJ0b1RpbWVzdGFtcFN0cmluZyIsImFic3RpbWUiLCJkYXRlIiwiZGF0ZXJhbmdlIiwiaW50NHJhbmdlIiwiaW50OHJhbmdlIiwibW9uZXkiLCJyZWx0aW1lIiwidGV4dCIsInRpbWUiLCJ0aW1lc3RhbXB0eiIsInRpbWV0eiIsInRzcmFuZ2UiLCJ0c3R6cmFuZ2UiLCJwYXJzZWRWYWx1ZSIsInBhcnNlRmxvYXQiLCJOdW1iZXIiLCJpc05hTiIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiY29uc29sZSIsImxvZyIsImxhc3RJZHgiLCJjbG9zZUJyYWNlIiwib3BlbkJyYWNlIiwiYXJyIiwidmFsVHJpbSIsIl8iLCJzcGxpdCIsIm1hcCIsInZhbCIsInJlcGxhY2UiLCJodHRwRW5kcG9pbnRVUkwiLCJzb2NrZXRVcmwiLCJ3c1VybCIsIlVSTCIsInByb3RvY29sIiwicGF0aG5hbWUiLCJocmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/transformers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nconst version = \"2.78.0\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSw2RUFBNkU7QUFDN0UsZ0VBQWdFO0FBQ2hFLHVFQUF1RTtBQUN2RSxpRUFBaUU7QUFDakUsa0VBQWtFO0FBQ2xFLGlFQUFpRTtBQUMxRCxNQUFNQSxVQUFVLFNBQVMsQ0FDaEMsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi92ZXJzaW9uLmpzPzFmZDUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkgZHVyaW5nIHJlbGVhc2VzIGJ5IHNjcmlwdHMvdXBkYXRlLXZlcnNpb24tZmlsZXMudHNcbi8vIFRoaXMgZmlsZSBwcm92aWRlcyBydW50aW1lIGFjY2VzcyB0byB0aGUgcGFja2FnZSB2ZXJzaW9uIGZvcjpcbi8vIC0gSFRUUCByZXF1ZXN0IGhlYWRlcnMgKGUuZy4sIFgtQ2xpZW50LUluZm8gaGVhZGVyIGZvciBBUEkgcmVxdWVzdHMpXG4vLyAtIERlYnVnZ2luZyBhbmQgc3VwcG9ydCAoaWRlbnRpZnlpbmcgd2hpY2ggdmVyc2lvbiBpcyBydW5uaW5nKVxuLy8gLSBUZWxlbWV0cnkgYW5kIGxvZ2dpbmcgKHZlcnNpb24gcmVwb3J0aW5nIGluIGVycm9ycy9hbmFseXRpY3MpXG4vLyAtIEVuc3VyaW5nIGJ1aWxkIGFydGlmYWN0cyBtYXRjaCB0aGUgcHVibGlzaGVkIHBhY2thZ2UgdmVyc2lvblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi43OC4wJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WebSocketFactory: () => (/* binding */ WebSocketFactory),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass WebSocketFactory {\n    static detectEnvironment() {\n        var _a;\n        if (typeof WebSocket !== \"undefined\") {\n            return {\n                type: \"native\",\n                constructor: WebSocket\n            };\n        }\n        if (typeof globalThis !== \"undefined\" && typeof globalThis.WebSocket !== \"undefined\") {\n            return {\n                type: \"native\",\n                constructor: globalThis.WebSocket\n            };\n        }\n        if (typeof global !== \"undefined\" && typeof global.WebSocket !== \"undefined\") {\n            return {\n                type: \"native\",\n                constructor: global.WebSocket\n            };\n        }\n        if (typeof globalThis !== \"undefined\" && typeof globalThis.WebSocketPair !== \"undefined\" && typeof globalThis.WebSocket === \"undefined\") {\n            return {\n                type: \"cloudflare\",\n                error: \"Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.\",\n                workaround: \"Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime.\"\n            };\n        }\n        if (typeof globalThis !== \"undefined\" && globalThis.EdgeRuntime || typeof navigator !== \"undefined\" && ((_a = navigator.userAgent) === null || _a === void 0 ? void 0 : _a.includes(\"Vercel-Edge\"))) {\n            return {\n                type: \"unsupported\",\n                error: \"Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.\",\n                workaround: \"Use serverless functions or a different deployment target for WebSocket functionality.\"\n            };\n        }\n        if (typeof process !== \"undefined\") {\n            // Use dynamic property access to avoid Next.js Edge Runtime static analysis warnings\n            const processVersions = process[\"versions\"];\n            if (processVersions && processVersions[\"node\"]) {\n                // Remove 'v' prefix if present and parse the major version\n                const versionString = processVersions[\"node\"];\n                const nodeVersion = parseInt(versionString.replace(/^v/, \"\").split(\".\")[0]);\n                // Node.js 22+ should have native WebSocket\n                if (nodeVersion >= 22) {\n                    // Check if native WebSocket is available (should be in Node.js 22+)\n                    if (typeof globalThis.WebSocket !== \"undefined\") {\n                        return {\n                            type: \"native\",\n                            constructor: globalThis.WebSocket\n                        };\n                    }\n                    // If not available, user needs to provide it\n                    return {\n                        type: \"unsupported\",\n                        error: `Node.js ${nodeVersion} detected but native WebSocket not found.`,\n                        workaround: \"Provide a WebSocket implementation via the transport option.\"\n                    };\n                }\n                // Node.js < 22 doesn't have native WebSocket\n                return {\n                    type: \"unsupported\",\n                    error: `Node.js ${nodeVersion} detected without native WebSocket support.`,\n                    workaround: 'For Node.js < 22, install \"ws\" package and provide it via the transport option:\\n' + 'import ws from \"ws\"\\n' + \"new RealtimeClient(url, { transport: ws })\"\n                };\n            }\n        }\n        return {\n            type: \"unsupported\",\n            error: \"Unknown JavaScript runtime without WebSocket support.\",\n            workaround: \"Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation.\"\n        };\n    }\n    static getWebSocketConstructor() {\n        const env = this.detectEnvironment();\n        if (env.constructor) {\n            return env.constructor;\n        }\n        let errorMessage = env.error || \"WebSocket not supported in this environment.\";\n        if (env.workaround) {\n            errorMessage += `\\n\\nSuggested solution: ${env.workaround}`;\n        }\n        throw new Error(errorMessage);\n    }\n    static createWebSocket(url, protocols) {\n        const WS = this.getWebSocketConstructor();\n        return new WS(url, protocols);\n    }\n    static isWebSocketSupported() {\n        try {\n            const env = this.detectEnvironment();\n            return env.type === \"native\" || env.type === \"ws\";\n        } catch (_a) {\n            return false;\n        }\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WebSocketFactory); //# sourceMappingURL=websocket-factory.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3JlYWx0aW1lLWpzL2Rpc3QvbW9kdWxlL2xpYi93ZWJzb2NrZXQtZmFjdG9yeS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFPLE1BQU1BO0lBQ1QsT0FBT0Msb0JBQW9CO1FBQ3ZCLElBQUlDO1FBQ0osSUFBSSxPQUFPQyxjQUFjLGFBQWE7WUFDbEMsT0FBTztnQkFBRUMsTUFBTTtnQkFBVUMsYUFBYUY7WUFBVTtRQUNwRDtRQUNBLElBQUksT0FBT0csZUFBZSxlQUFlLE9BQU9BLFdBQVdILFNBQVMsS0FBSyxhQUFhO1lBQ2xGLE9BQU87Z0JBQUVDLE1BQU07Z0JBQVVDLGFBQWFDLFdBQVdILFNBQVM7WUFBQztRQUMvRDtRQUNBLElBQUksT0FBT0ksV0FBVyxlQUFlLE9BQU9BLE9BQU9KLFNBQVMsS0FBSyxhQUFhO1lBQzFFLE9BQU87Z0JBQUVDLE1BQU07Z0JBQVVDLGFBQWFFLE9BQU9KLFNBQVM7WUFBQztRQUMzRDtRQUNBLElBQUksT0FBT0csZUFBZSxlQUN0QixPQUFPQSxXQUFXRSxhQUFhLEtBQUssZUFDcEMsT0FBT0YsV0FBV0gsU0FBUyxLQUFLLGFBQWE7WUFDN0MsT0FBTztnQkFDSEMsTUFBTTtnQkFDTkssT0FBTztnQkFDUEMsWUFBWTtZQUNoQjtRQUNKO1FBQ0EsSUFBSSxPQUFRSixlQUFlLGVBQWVBLFdBQVdLLFdBQVcsSUFDM0QsT0FBT0MsY0FBYyxlQUFnQixFQUFDVixLQUFLVSxVQUFVQyxTQUFTLE1BQU0sUUFBUVgsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHWSxRQUFRLENBQUMsY0FBYSxHQUFLO1lBQ3BJLE9BQU87Z0JBQ0hWLE1BQU07Z0JBQ05LLE9BQU87Z0JBQ1BDLFlBQVk7WUFDaEI7UUFDSjtRQUNBLElBQUksT0FBT0ssWUFBWSxhQUFhO1lBQ2hDLHFGQUFxRjtZQUNyRixNQUFNQyxrQkFBa0JELE9BQU8sQ0FBQyxXQUFXO1lBQzNDLElBQUlDLG1CQUFtQkEsZUFBZSxDQUFDLE9BQU8sRUFBRTtnQkFDNUMsMkRBQTJEO2dCQUMzRCxNQUFNQyxnQkFBZ0JELGVBQWUsQ0FBQyxPQUFPO2dCQUM3QyxNQUFNRSxjQUFjQyxTQUFTRixjQUFjRyxPQUFPLENBQUMsTUFBTSxJQUFJQyxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQzFFLDJDQUEyQztnQkFDM0MsSUFBSUgsZUFBZSxJQUFJO29CQUNuQixvRUFBb0U7b0JBQ3BFLElBQUksT0FBT1osV0FBV0gsU0FBUyxLQUFLLGFBQWE7d0JBQzdDLE9BQU87NEJBQUVDLE1BQU07NEJBQVVDLGFBQWFDLFdBQVdILFNBQVM7d0JBQUM7b0JBQy9EO29CQUNBLDZDQUE2QztvQkFDN0MsT0FBTzt3QkFDSEMsTUFBTTt3QkFDTkssT0FBTyxDQUFDLFFBQVEsRUFBRVMsWUFBWSx5Q0FBeUMsQ0FBQzt3QkFDeEVSLFlBQVk7b0JBQ2hCO2dCQUNKO2dCQUNBLDZDQUE2QztnQkFDN0MsT0FBTztvQkFDSE4sTUFBTTtvQkFDTkssT0FBTyxDQUFDLFFBQVEsRUFBRVMsWUFBWSwyQ0FBMkMsQ0FBQztvQkFDMUVSLFlBQVksc0ZBQ1IsMEJBQ0E7Z0JBQ1I7WUFDSjtRQUNKO1FBQ0EsT0FBTztZQUNITixNQUFNO1lBQ05LLE9BQU87WUFDUEMsWUFBWTtRQUNoQjtJQUNKO0lBQ0EsT0FBT1ksMEJBQTBCO1FBQzdCLE1BQU1DLE1BQU0sSUFBSSxDQUFDdEIsaUJBQWlCO1FBQ2xDLElBQUlzQixJQUFJbEIsV0FBVyxFQUFFO1lBQ2pCLE9BQU9rQixJQUFJbEIsV0FBVztRQUMxQjtRQUNBLElBQUltQixlQUFlRCxJQUFJZCxLQUFLLElBQUk7UUFDaEMsSUFBSWMsSUFBSWIsVUFBVSxFQUFFO1lBQ2hCYyxnQkFBZ0IsQ0FBQyx3QkFBd0IsRUFBRUQsSUFBSWIsVUFBVSxDQUFDLENBQUM7UUFDL0Q7UUFDQSxNQUFNLElBQUllLE1BQU1EO0lBQ3BCO0lBQ0EsT0FBT0UsZ0JBQWdCQyxHQUFHLEVBQUVDLFNBQVMsRUFBRTtRQUNuQyxNQUFNQyxLQUFLLElBQUksQ0FBQ1AsdUJBQXVCO1FBQ3ZDLE9BQU8sSUFBSU8sR0FBR0YsS0FBS0M7SUFDdkI7SUFDQSxPQUFPRSx1QkFBdUI7UUFDMUIsSUFBSTtZQUNBLE1BQU1QLE1BQU0sSUFBSSxDQUFDdEIsaUJBQWlCO1lBQ2xDLE9BQU9zQixJQUFJbkIsSUFBSSxLQUFLLFlBQVltQixJQUFJbkIsSUFBSSxLQUFLO1FBQ2pELEVBQ0EsT0FBT0YsSUFBSTtZQUNQLE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQSxpRUFBZUYsZ0JBQWdCQSxFQUFDLENBQ2hDLDZDQUE2QyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9yZWFsdGltZS1qcy9kaXN0L21vZHVsZS9saWIvd2Vic29ja2V0LWZhY3RvcnkuanM/YTVhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgV2ViU29ja2V0RmFjdG9yeSB7XG4gICAgc3RhdGljIGRldGVjdEVudmlyb25tZW50KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ25hdGl2ZScsIGNvbnN0cnVjdG9yOiBXZWJTb2NrZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICduYXRpdmUnLCBjb25zdHJ1Y3RvcjogZ2xvYmFsVGhpcy5XZWJTb2NrZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbC5XZWJTb2NrZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnbmF0aXZlJywgY29uc3RydWN0b3I6IGdsb2JhbC5XZWJTb2NrZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2YgZ2xvYmFsVGhpcy5XZWJTb2NrZXRQYWlyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgdHlwZW9mIGdsb2JhbFRoaXMuV2ViU29ja2V0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2xvdWRmbGFyZScsXG4gICAgICAgICAgICAgICAgZXJyb3I6ICdDbG91ZGZsYXJlIFdvcmtlcnMgZGV0ZWN0ZWQuIFdlYlNvY2tldCBjbGllbnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluIENsb3VkZmxhcmUgV29ya2Vycy4nLFxuICAgICAgICAgICAgICAgIHdvcmthcm91bmQ6ICdVc2UgQ2xvdWRmbGFyZSBXb3JrZXJzIFdlYlNvY2tldCBBUEkgZm9yIHNlcnZlci1zaWRlIFdlYlNvY2tldCBoYW5kbGluZywgb3IgZGVwbG95IHRvIGEgZGlmZmVyZW50IHJ1bnRpbWUuJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcy5FZGdlUnVudGltZSkgfHxcbiAgICAgICAgICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gbmF2aWdhdG9yLnVzZXJBZ2VudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluY2x1ZGVzKCdWZXJjZWwtRWRnZScpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Vuc3VwcG9ydGVkJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogJ0VkZ2UgcnVudGltZSBkZXRlY3RlZCAoVmVyY2VsIEVkZ2UvTmV0bGlmeSBFZGdlKS4gV2ViU29ja2V0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiBlZGdlIGZ1bmN0aW9ucy4nLFxuICAgICAgICAgICAgICAgIHdvcmthcm91bmQ6ICdVc2Ugc2VydmVybGVzcyBmdW5jdGlvbnMgb3IgYSBkaWZmZXJlbnQgZGVwbG95bWVudCB0YXJnZXQgZm9yIFdlYlNvY2tldCBmdW5jdGlvbmFsaXR5LicsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIFVzZSBkeW5hbWljIHByb3BlcnR5IGFjY2VzcyB0byBhdm9pZCBOZXh0LmpzIEVkZ2UgUnVudGltZSBzdGF0aWMgYW5hbHlzaXMgd2FybmluZ3NcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NWZXJzaW9ucyA9IHByb2Nlc3NbJ3ZlcnNpb25zJ107XG4gICAgICAgICAgICBpZiAocHJvY2Vzc1ZlcnNpb25zICYmIHByb2Nlc3NWZXJzaW9uc1snbm9kZSddKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlICd2JyBwcmVmaXggaWYgcHJlc2VudCBhbmQgcGFyc2UgdGhlIG1ham9yIHZlcnNpb25cbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uU3RyaW5nID0gcHJvY2Vzc1ZlcnNpb25zWydub2RlJ107XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVZlcnNpb24gPSBwYXJzZUludCh2ZXJzaW9uU3RyaW5nLnJlcGxhY2UoL152LywgJycpLnNwbGl0KCcuJylbMF0pO1xuICAgICAgICAgICAgICAgIC8vIE5vZGUuanMgMjIrIHNob3VsZCBoYXZlIG5hdGl2ZSBXZWJTb2NrZXRcbiAgICAgICAgICAgICAgICBpZiAobm9kZVZlcnNpb24gPj0gMjIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgbmF0aXZlIFdlYlNvY2tldCBpcyBhdmFpbGFibGUgKHNob3VsZCBiZSBpbiBOb2RlLmpzIDIyKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLldlYlNvY2tldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICduYXRpdmUnLCBjb25zdHJ1Y3RvcjogZ2xvYmFsVGhpcy5XZWJTb2NrZXQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBub3QgYXZhaWxhYmxlLCB1c2VyIG5lZWRzIHRvIHByb3ZpZGUgaXRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1bnN1cHBvcnRlZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogYE5vZGUuanMgJHtub2RlVmVyc2lvbn0gZGV0ZWN0ZWQgYnV0IG5hdGl2ZSBXZWJTb2NrZXQgbm90IGZvdW5kLmAsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrYXJvdW5kOiAnUHJvdmlkZSBhIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbiB2aWEgdGhlIHRyYW5zcG9ydCBvcHRpb24uJyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm9kZS5qcyA8IDIyIGRvZXNuJ3QgaGF2ZSBuYXRpdmUgV2ViU29ja2V0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Vuc3VwcG9ydGVkJyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBOb2RlLmpzICR7bm9kZVZlcnNpb259IGRldGVjdGVkIHdpdGhvdXQgbmF0aXZlIFdlYlNvY2tldCBzdXBwb3J0LmAsXG4gICAgICAgICAgICAgICAgICAgIHdvcmthcm91bmQ6ICdGb3IgTm9kZS5qcyA8IDIyLCBpbnN0YWxsIFwid3NcIiBwYWNrYWdlIGFuZCBwcm92aWRlIGl0IHZpYSB0aGUgdHJhbnNwb3J0IG9wdGlvbjpcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpbXBvcnQgd3MgZnJvbSBcIndzXCJcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICduZXcgUmVhbHRpbWVDbGllbnQodXJsLCB7IHRyYW5zcG9ydDogd3MgfSknLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICd1bnN1cHBvcnRlZCcsXG4gICAgICAgICAgICBlcnJvcjogJ1Vua25vd24gSmF2YVNjcmlwdCBydW50aW1lIHdpdGhvdXQgV2ViU29ja2V0IHN1cHBvcnQuJyxcbiAgICAgICAgICAgIHdvcmthcm91bmQ6IFwiRW5zdXJlIHlvdSdyZSBydW5uaW5nIGluIGEgc3VwcG9ydGVkIGVudmlyb25tZW50IChicm93c2VyLCBOb2RlLmpzLCBEZW5vKSBvciBwcm92aWRlIGEgY3VzdG9tIFdlYlNvY2tldCBpbXBsZW1lbnRhdGlvbi5cIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGdldFdlYlNvY2tldENvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCBlbnYgPSB0aGlzLmRldGVjdEVudmlyb25tZW50KCk7XG4gICAgICAgIGlmIChlbnYuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlbnYuY29uc3RydWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGVudi5lcnJvciB8fCAnV2ViU29ja2V0IG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC4nO1xuICAgICAgICBpZiAoZW52Lndvcmthcm91bmQpIHtcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSArPSBgXFxuXFxuU3VnZ2VzdGVkIHNvbHV0aW9uOiAke2Vudi53b3JrYXJvdW5kfWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVXZWJTb2NrZXQodXJsLCBwcm90b2NvbHMpIHtcbiAgICAgICAgY29uc3QgV1MgPSB0aGlzLmdldFdlYlNvY2tldENvbnN0cnVjdG9yKCk7XG4gICAgICAgIHJldHVybiBuZXcgV1ModXJsLCBwcm90b2NvbHMpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNXZWJTb2NrZXRTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbnYgPSB0aGlzLmRldGVjdEVudmlyb25tZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gZW52LnR5cGUgPT09ICduYXRpdmUnIHx8IGVudi50eXBlID09PSAnd3MnO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgV2ViU29ja2V0RmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYnNvY2tldC1mYWN0b3J5LmpzLm1hcCJdLCJuYW1lcyI6WyJXZWJTb2NrZXRGYWN0b3J5IiwiZGV0ZWN0RW52aXJvbm1lbnQiLCJfYSIsIldlYlNvY2tldCIsInR5cGUiLCJjb25zdHJ1Y3RvciIsImdsb2JhbFRoaXMiLCJnbG9iYWwiLCJXZWJTb2NrZXRQYWlyIiwiZXJyb3IiLCJ3b3JrYXJvdW5kIiwiRWRnZVJ1bnRpbWUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJpbmNsdWRlcyIsInByb2Nlc3MiLCJwcm9jZXNzVmVyc2lvbnMiLCJ2ZXJzaW9uU3RyaW5nIiwibm9kZVZlcnNpb24iLCJwYXJzZUludCIsInJlcGxhY2UiLCJzcGxpdCIsImdldFdlYlNvY2tldENvbnN0cnVjdG9yIiwiZW52IiwiZXJyb3JNZXNzYWdlIiwiRXJyb3IiLCJjcmVhdGVXZWJTb2NrZXQiLCJ1cmwiLCJwcm90b2NvbHMiLCJXUyIsImlzV2ViU29ja2V0U3VwcG9ydGVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/realtime-js/dist/module/lib/websocket-factory.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/StorageClient.js":
/*!************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/StorageClient.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageClient: () => (/* binding */ StorageClient)\n/* harmony export */ });\n/* harmony import */ var _packages_StorageFileApi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./packages/StorageFileApi */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js\");\n/* harmony import */ var _packages_StorageBucketApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./packages/StorageBucketApi */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js\");\n/* harmony import */ var _packages_StorageAnalyticsApi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./packages/StorageAnalyticsApi */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StorageAnalyticsApi.js\");\n/* harmony import */ var _lib_vectors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/vectors */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/StorageVectorsClient.js\");\n\n\n\n\nclass StorageClient extends _packages_StorageBucketApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(url, headers = {}, fetch, opts){\n        super(url, headers, fetch, opts);\n    }\n    /**\n     * Perform file operation in a bucket.\n     *\n     * @param id The bucket id to operate on.\n     */ from(id) {\n        return new _packages_StorageFileApi__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.url, this.headers, id, this.fetch);\n    }\n    /**\n     * Access vector storage operations.\n     *\n     * @returns A StorageVectorsClient instance configured with the current storage settings.\n     */ get vectors() {\n        return new _lib_vectors__WEBPACK_IMPORTED_MODULE_2__.StorageVectorsClient(this.url + \"/vector\", {\n            headers: this.headers,\n            fetch: this.fetch\n        });\n    }\n    /**\n     * Access analytics storage operations using Iceberg tables.\n     *\n     * @returns A StorageAnalyticsApi instance configured with the current storage settings.\n     * @example\n     * ```typescript\n     * const client = createClient(url, key)\n     * const analytics = client.storage.analytics\n     *\n     * // Create an analytics bucket\n     * await analytics.createBucket('my-analytics-bucket')\n     *\n     * // List all analytics buckets\n     * const { data: buckets } = await analytics.listBuckets()\n     *\n     * // Delete an analytics bucket\n     * await analytics.deleteBucket('old-analytics-bucket')\n     * ```\n     */ get analytics() {\n        return new _packages_StorageAnalyticsApi__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.url + \"/iceberg\", this.headers, this.fetch);\n    }\n} //# sourceMappingURL=StorageClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvU3RvcmFnZUNsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF1RDtBQUNJO0FBQ007QUFDWjtBQUM5QyxNQUFNSSxzQkFBc0JILGtFQUFnQkE7SUFDL0NJLFlBQVlDLEdBQUcsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRUMsS0FBSyxFQUFFQyxJQUFJLENBQUU7UUFDeEMsS0FBSyxDQUFDSCxLQUFLQyxTQUFTQyxPQUFPQztJQUMvQjtJQUNBOzs7O0tBSUMsR0FDREMsS0FBS0MsRUFBRSxFQUFFO1FBQ0wsT0FBTyxJQUFJWCxnRUFBY0EsQ0FBQyxJQUFJLENBQUNNLEdBQUcsRUFBRSxJQUFJLENBQUNDLE9BQU8sRUFBRUksSUFBSSxJQUFJLENBQUNILEtBQUs7SUFDcEU7SUFDQTs7OztLQUlDLEdBQ0QsSUFBSUksVUFBVTtRQUNWLE9BQU8sSUFBSVQsOERBQW9CQSxDQUFDLElBQUksQ0FBQ0csR0FBRyxHQUFHLFdBQVc7WUFDbERDLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCQyxPQUFPLElBQUksQ0FBQ0EsS0FBSztRQUNyQjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQWtCQyxHQUNELElBQUlLLFlBQVk7UUFDWixPQUFPLElBQUlYLHFFQUFtQkEsQ0FBQyxJQUFJLENBQUNJLEdBQUcsR0FBRyxZQUFZLElBQUksQ0FBQ0MsT0FBTyxFQUFFLElBQUksQ0FBQ0MsS0FBSztJQUNsRjtBQUNKLEVBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvU3RvcmFnZUNsaWVudC5qcz9hOGNjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTdG9yYWdlRmlsZUFwaSBmcm9tICcuL3BhY2thZ2VzL1N0b3JhZ2VGaWxlQXBpJztcbmltcG9ydCBTdG9yYWdlQnVja2V0QXBpIGZyb20gJy4vcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaSc7XG5pbXBvcnQgU3RvcmFnZUFuYWx5dGljc0FwaSBmcm9tICcuL3BhY2thZ2VzL1N0b3JhZ2VBbmFseXRpY3NBcGknO1xuaW1wb3J0IHsgU3RvcmFnZVZlY3RvcnNDbGllbnQgfSBmcm9tICcuL2xpYi92ZWN0b3JzJztcbmV4cG9ydCBjbGFzcyBTdG9yYWdlQ2xpZW50IGV4dGVuZHMgU3RvcmFnZUJ1Y2tldEFwaSB7XG4gICAgY29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGZldGNoLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKHVybCwgaGVhZGVycywgZmV0Y2gsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGZpbGUgb3BlcmF0aW9uIGluIGEgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSBidWNrZXQgaWQgdG8gb3BlcmF0ZSBvbi5cbiAgICAgKi9cbiAgICBmcm9tKGlkKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RvcmFnZUZpbGVBcGkodGhpcy51cmwsIHRoaXMuaGVhZGVycywgaWQsIHRoaXMuZmV0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY2Nlc3MgdmVjdG9yIHN0b3JhZ2Ugb3BlcmF0aW9ucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgU3RvcmFnZVZlY3RvcnNDbGllbnQgaW5zdGFuY2UgY29uZmlndXJlZCB3aXRoIHRoZSBjdXJyZW50IHN0b3JhZ2Ugc2V0dGluZ3MuXG4gICAgICovXG4gICAgZ2V0IHZlY3RvcnMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RvcmFnZVZlY3RvcnNDbGllbnQodGhpcy51cmwgKyAnL3ZlY3RvcicsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWNjZXNzIGFuYWx5dGljcyBzdG9yYWdlIG9wZXJhdGlvbnMgdXNpbmcgSWNlYmVyZyB0YWJsZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIFN0b3JhZ2VBbmFseXRpY3NBcGkgaW5zdGFuY2UgY29uZmlndXJlZCB3aXRoIHRoZSBjdXJyZW50IHN0b3JhZ2Ugc2V0dGluZ3MuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgY2xpZW50ID0gY3JlYXRlQ2xpZW50KHVybCwga2V5KVxuICAgICAqIGNvbnN0IGFuYWx5dGljcyA9IGNsaWVudC5zdG9yYWdlLmFuYWx5dGljc1xuICAgICAqXG4gICAgICogLy8gQ3JlYXRlIGFuIGFuYWx5dGljcyBidWNrZXRcbiAgICAgKiBhd2FpdCBhbmFseXRpY3MuY3JlYXRlQnVja2V0KCdteS1hbmFseXRpY3MtYnVja2V0JylcbiAgICAgKlxuICAgICAqIC8vIExpc3QgYWxsIGFuYWx5dGljcyBidWNrZXRzXG4gICAgICogY29uc3QgeyBkYXRhOiBidWNrZXRzIH0gPSBhd2FpdCBhbmFseXRpY3MubGlzdEJ1Y2tldHMoKVxuICAgICAqXG4gICAgICogLy8gRGVsZXRlIGFuIGFuYWx5dGljcyBidWNrZXRcbiAgICAgKiBhd2FpdCBhbmFseXRpY3MuZGVsZXRlQnVja2V0KCdvbGQtYW5hbHl0aWNzLWJ1Y2tldCcpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGFuYWx5dGljcygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdG9yYWdlQW5hbHl0aWNzQXBpKHRoaXMudXJsICsgJy9pY2ViZXJnJywgdGhpcy5oZWFkZXJzLCB0aGlzLmZldGNoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdG9yYWdlQ2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJTdG9yYWdlRmlsZUFwaSIsIlN0b3JhZ2VCdWNrZXRBcGkiLCJTdG9yYWdlQW5hbHl0aWNzQXBpIiwiU3RvcmFnZVZlY3RvcnNDbGllbnQiLCJTdG9yYWdlQ2xpZW50IiwiY29uc3RydWN0b3IiLCJ1cmwiLCJoZWFkZXJzIiwiZmV0Y2giLCJvcHRzIiwiZnJvbSIsImlkIiwidmVjdG9ycyIsImFuYWx5dGljcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/StorageClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/constants.js":
/*!************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/constants.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/version.js\");\n\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `storage-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`\n}; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFvQztBQUM3QixNQUFNQyxrQkFBa0I7SUFDM0IsaUJBQWlCLENBQUMsV0FBVyxFQUFFRCw2Q0FBT0EsQ0FBQyxDQUFDO0FBQzVDLEVBQUUsQ0FDRixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvY29uc3RhbnRzLmpzPzc5OTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7XG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0ge1xuICAgICdYLUNsaWVudC1JbmZvJzogYHN0b3JhZ2UtanMvJHt2ZXJzaW9ufWAsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIiwiREVGQVVMVF9IRUFERVJTIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/errors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageApiError: () => (/* binding */ StorageApiError),\n/* harmony export */   StorageError: () => (/* binding */ StorageError),\n/* harmony export */   StorageUnknownError: () => (/* binding */ StorageUnknownError),\n/* harmony export */   isStorageError: () => (/* binding */ isStorageError)\n/* harmony export */ });\nclass StorageError extends Error {\n    constructor(message){\n        super(message);\n        this.__isStorageError = true;\n        this.name = \"StorageError\";\n    }\n}\nfunction isStorageError(error) {\n    return typeof error === \"object\" && error !== null && \"__isStorageError\" in error;\n}\nclass StorageApiError extends StorageError {\n    constructor(message, status, statusCode){\n        super(message);\n        this.name = \"StorageApiError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            statusCode: this.statusCode\n        };\n    }\n}\nclass StorageUnknownError extends StorageError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"StorageUnknownError\";\n        this.originalError = originalError;\n    }\n} //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQU8sTUFBTUEscUJBQXFCQztJQUM5QkMsWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUNDLGdCQUFnQixHQUFHO1FBQ3hCLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDTyxTQUFTQyxlQUFlQyxLQUFLO0lBQ2hDLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEsc0JBQXNCQTtBQUNoRjtBQUNPLE1BQU1DLHdCQUF3QlI7SUFDakNFLFlBQVlDLE9BQU8sRUFBRU0sTUFBTSxFQUFFQyxVQUFVLENBQUU7UUFDckMsS0FBSyxDQUFDUDtRQUNOLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDSSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxVQUFVLEdBQUdBO0lBQ3RCO0lBQ0FDLFNBQVM7UUFDTCxPQUFPO1lBQ0hOLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ2ZGLFNBQVMsSUFBSSxDQUFDQSxPQUFPO1lBQ3JCTSxRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQkMsWUFBWSxJQUFJLENBQUNBLFVBQVU7UUFDL0I7SUFDSjtBQUNKO0FBQ08sTUFBTUUsNEJBQTRCWjtJQUNyQ0UsWUFBWUMsT0FBTyxFQUFFVSxhQUFhLENBQUU7UUFDaEMsS0FBSyxDQUFDVjtRQUNOLElBQUksQ0FBQ0UsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDUSxhQUFhLEdBQUdBO0lBQ3pCO0FBQ0osRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvZXJyb3JzLmpzPzRhOWEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFN0b3JhZ2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9faXNTdG9yYWdlRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU3RvcmFnZUVycm9yJztcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNTdG9yYWdlRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPT0gbnVsbCAmJiAnX19pc1N0b3JhZ2VFcnJvcicgaW4gZXJyb3I7XG59XG5leHBvcnQgY2xhc3MgU3RvcmFnZUFwaUVycm9yIGV4dGVuZHMgU3RvcmFnZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdTdG9yYWdlQXBpRXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU3RvcmFnZVVua25vd25FcnJvciBleHRlbmRzIFN0b3JhZ2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3JpZ2luYWxFcnJvcikge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1N0b3JhZ2VVbmtub3duRXJyb3InO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXJyb3IgPSBvcmlnaW5hbEVycm9yO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOlsiU3RvcmFnZUVycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJfX2lzU3RvcmFnZUVycm9yIiwibmFtZSIsImlzU3RvcmFnZUVycm9yIiwiZXJyb3IiLCJTdG9yYWdlQXBpRXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNDb2RlIiwidG9KU09OIiwiU3RvcmFnZVVua25vd25FcnJvciIsIm9yaWdpbmFsRXJyb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js":
/*!********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/fetch.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   head: () => (/* binding */ head),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   remove: () => (/* binding */ remove)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\");\n\n\n\nconst _getErrorMessage = (err)=>{\n    var _a;\n    return err.msg || err.message || err.error_description || (typeof err.error === \"string\" ? err.error : (_a = err.error) === null || _a === void 0 ? void 0 : _a.message) || JSON.stringify(err);\n};\nconst handleError = (error, reject, options)=>(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(void 0, void 0, void 0, function*() {\n        const Res = yield (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveResponse)();\n        if (error instanceof Res && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {\n            error.json().then((err)=>{\n                const status = error.status || 500;\n                const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || status + \"\";\n                reject(new _errors__WEBPACK_IMPORTED_MODULE_2__.StorageApiError(_getErrorMessage(err), status, statusCode));\n            }).catch((err)=>{\n                reject(new _errors__WEBPACK_IMPORTED_MODULE_2__.StorageUnknownError(_getErrorMessage(err), err));\n            });\n        } else {\n            reject(new _errors__WEBPACK_IMPORTED_MODULE_2__.StorageUnknownError(_getErrorMessage(error), error));\n        }\n    });\nconst _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\" || !body) {\n        return params;\n    }\n    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_1__.isPlainObject)(body)) {\n        params.headers = Object.assign({\n            \"Content-Type\": \"application/json\"\n        }, options === null || options === void 0 ? void 0 : options.headers);\n        params.body = JSON.stringify(body);\n    } else {\n        params.body = body;\n    }\n    if (options === null || options === void 0 ? void 0 : options.duplex) {\n        params.duplex = options.duplex;\n    }\n    return Object.assign(Object.assign({}, params), parameters);\n};\nfunction _handleRequest(fetcher, method, url, options, parameters, body) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function*() {\n        return new Promise((resolve, reject)=>{\n            fetcher(url, _getRequestParams(method, options, parameters, body)).then((result)=>{\n                if (!result.ok) throw result;\n                if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n                return result.json();\n            }).then((data)=>resolve(data)).catch((error)=>handleError(error, reject, options));\n        });\n    });\n}\nfunction get(fetcher, url, options, parameters) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function*() {\n        return _handleRequest(fetcher, \"GET\", url, options, parameters);\n    });\n}\nfunction post(fetcher, url, body, options, parameters) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function*() {\n        return _handleRequest(fetcher, \"POST\", url, options, parameters, body);\n    });\n}\nfunction put(fetcher, url, body, options, parameters) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function*() {\n        return _handleRequest(fetcher, \"PUT\", url, options, parameters, body);\n    });\n}\nfunction head(fetcher, url, options, parameters) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function*() {\n        return _handleRequest(fetcher, \"HEAD\", url, Object.assign(Object.assign({}, options), {\n            noResolveJson: true\n        }), parameters);\n    });\n}\nfunction remove(fetcher, url, body, options, parameters) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function*() {\n        return _handleRequest(fetcher, \"DELETE\", url, options, parameters, body);\n    });\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2ZldGNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtDO0FBQzhCO0FBQ0w7QUFDM0QsTUFBTUssbUJBQW1CLENBQUNDO0lBQ3RCLElBQUlDO0lBQ0osT0FBT0QsSUFBSUUsR0FBRyxJQUNWRixJQUFJRyxPQUFPLElBQ1hILElBQUlJLGlCQUFpQixJQUNwQixRQUFPSixJQUFJSyxLQUFLLEtBQUssV0FBV0wsSUFBSUssS0FBSyxHQUFHLENBQUNKLEtBQUtELElBQUlLLEtBQUssTUFBTSxRQUFRSixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdFLE9BQU8sS0FDN0dHLEtBQUtDLFNBQVMsQ0FBQ1A7QUFDdkI7QUFDQSxNQUFNUSxjQUFjLENBQUNILE9BQU9JLFFBQVFDLFVBQVloQixnREFBU0EsQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRztRQUM5RSxNQUFNaUIsTUFBTSxNQUFNYix5REFBZUE7UUFDakMsSUFBSU8saUJBQWlCTSxPQUFPLENBQUVELENBQUFBLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRRSxhQUFhLEdBQUc7WUFDcEdQLE1BQ0tRLElBQUksR0FDSkMsSUFBSSxDQUFDLENBQUNkO2dCQUNQLE1BQU1lLFNBQVNWLE1BQU1VLE1BQU0sSUFBSTtnQkFDL0IsTUFBTUMsYUFBYSxDQUFDaEIsUUFBUSxRQUFRQSxRQUFRLEtBQUssSUFBSSxLQUFLLElBQUlBLElBQUlnQixVQUFVLEtBQUtELFNBQVM7Z0JBQzFGTixPQUFPLElBQUlkLG9EQUFlQSxDQUFDSSxpQkFBaUJDLE1BQU1lLFFBQVFDO1lBQzlELEdBQ0tDLEtBQUssQ0FBQyxDQUFDakI7Z0JBQ1JTLE9BQU8sSUFBSWIsd0RBQW1CQSxDQUFDRyxpQkFBaUJDLE1BQU1BO1lBQzFEO1FBQ0osT0FDSztZQUNEUyxPQUFPLElBQUliLHdE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LENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdmLFVBQVU7WUFBRUUsZUFBZTtRQUFLLElBQUlRO0lBQ3BIO0FBQ0o7QUFDTyxTQUFTbUIsT0FBT1gsT0FBTyxFQUFFQyxHQUFHLEVBQUVSLElBQUksRUFBRVgsT0FBTyxFQUFFVSxVQUFVO0lBQzFELE9BQU8xQixnREFBU0EsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNuQyxPQUFPaUMsZUFBZUMsU0FBUyxVQUFVQyxLQUFLbkIsU0FBU1UsWUFBWUM7SUFDdkU7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvbW9kdWxlL2xpYi9mZXRjaC5qcz9jMDQ2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgU3RvcmFnZUFwaUVycm9yLCBTdG9yYWdlVW5rbm93bkVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgaXNQbGFpbk9iamVjdCwgcmVzb2x2ZVJlc3BvbnNlIH0gZnJvbSAnLi9oZWxwZXJzJztcbmNvbnN0IF9nZXRFcnJvck1lc3NhZ2UgPSAoZXJyKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBlcnIubXNnIHx8XG4gICAgICAgIGVyci5tZXNzYWdlIHx8XG4gICAgICAgIGVyci5lcnJvcl9kZXNjcmlwdGlvbiB8fFxuICAgICAgICAodHlwZW9mIGVyci5lcnJvciA9PT0gJ3N0cmluZycgPyBlcnIuZXJyb3IgOiAoX2EgPSBlcnIuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSB8fFxuICAgICAgICBKU09OLnN0cmluZ2lmeShlcnIpO1xufTtcbmNvbnN0IGhhbmRsZUVycm9yID0gKGVycm9yLCByZWplY3QsIG9wdGlvbnMpID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IFJlcyA9IHlpZWxkIHJlc29sdmVSZXNwb25zZSgpO1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFJlcyAmJiAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uKSkge1xuICAgICAgICBlcnJvclxuICAgICAgICAgICAgLmpzb24oKVxuICAgICAgICAgICAgLnRoZW4oKGVycikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzID0gZXJyb3Iuc3RhdHVzIHx8IDUwMDtcbiAgICAgICAgICAgIGNvbnN0IHN0YXR1c0NvZGUgPSAoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLnN0YXR1c0NvZGUpIHx8IHN0YXR1cyArICcnO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBTdG9yYWdlQXBpRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnIpLCBzdGF0dXMsIHN0YXR1c0NvZGUpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICByZWplY3QobmV3IFN0b3JhZ2VVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnIpLCBlcnIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZWplY3QobmV3IFN0b3JhZ2VVbmtub3duRXJyb3IoX2dldEVycm9yTWVzc2FnZShlcnJvciksIGVycm9yKSk7XG4gICAgfVxufSk7XG5jb25zdCBfZ2V0UmVxdWVzdFBhcmFtcyA9IChtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IG1ldGhvZCwgaGVhZGVyczogKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKSB8fCB7fSB9O1xuICAgIGlmIChtZXRob2QgPT09ICdHRVQnIHx8ICFib2R5KSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG4gICAgICAgIHBhcmFtcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyYW1zLmJvZHkgPSBib2R5O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmR1cGxleCkge1xuICAgICAgICBwYXJhbXMuZHVwbGV4ID0gb3B0aW9ucy5kdXBsZXg7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHBhcmFtZXRlcnMpO1xufTtcbmZ1bmN0aW9uIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGZldGNoZXIodXJsLCBfZ2V0UmVxdWVzdFBhcmFtcyhtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5vaylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmpzb24oKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gaGFuZGxlRXJyb3IoZXJyb3IsIHJlamVjdCwgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXQoZmV0Y2hlciwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdHRVQnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc3QoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdQT1NUJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwdXQoZmV0Y2hlciwgdXJsLCBib2R5LCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdQVVQnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhlYWQoZmV0Y2hlciwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsICdIRUFEJywgdXJsLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG5vUmVzb2x2ZUpzb246IHRydWUgfSksIHBhcmFtZXRlcnMpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ0RFTEVURScsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwiU3RvcmFnZUFwaUVycm9yIiwiU3RvcmFnZVVua25vd25FcnJvciIsImlzUGxhaW5PYmplY3QiLCJyZXNvbHZlUmVzcG9uc2UiLCJfZ2V0RXJyb3JNZXNzYWdlIiwiZXJyIiwiX2EiLCJtc2ciLCJtZXNzYWdlIiwiZXJyb3JfZGVzY3JpcHRpb24iLCJlcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJoYW5kbGVFcnJvciIsInJlamVjdCIsIm9wdGlvbnMiLCJSZXMiLCJub1Jlc29sdmVKc29uIiwianNvbiIsInRoZW4iLCJzdGF0dXMiLCJzdGF0dXNDb2RlIiwiY2F0Y2giLCJfZ2V0UmVxdWVzdFBhcmFtcyIsIm1ldGhvZCIsInBhcmFtZXRlcnMiLCJib2R5IiwicGFyYW1zIiwiaGVhZGVycyIsIk9iamVjdCIsImFzc2lnbiIsImR1cGxleCIsIl9oYW5kbGVSZXF1ZXN0IiwiZmV0Y2hlciIsInVybCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVzdWx0Iiwib2siLCJkYXRhIiwiZ2V0IiwicG9zdCIsInB1dCIsImhlYWQiLCJyZW1vdmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/helpers.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   recursiveToCamel: () => (/* binding */ recursiveToCamel),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n\nconst resolveFetch = (customFetch)=>{\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    } else if (typeof fetch === \"undefined\") {\n        _fetch = (...args)=>Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\", 23)).then(({ default: fetch1 })=>fetch1(...args));\n    } else {\n        _fetch = fetch;\n    }\n    return (...args)=>_fetch(...args);\n};\nconst resolveResponse = ()=>(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(void 0, void 0, void 0, function*() {\n        if (typeof Response === \"undefined\") {\n            // @ts-ignore\n            return (yield Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\", 23))).Response;\n        }\n        return Response;\n    });\nconst recursiveToCamel = (item)=>{\n    if (Array.isArray(item)) {\n        return item.map((el)=>recursiveToCamel(el));\n    } else if (typeof item === \"function\" || item !== Object(item)) {\n        return item;\n    }\n    const result = {};\n    Object.entries(item).forEach(([key, value])=>{\n        const newKey = key.replace(/([-_][a-z])/gi, (c)=>c.toUpperCase().replace(/[-_]/g, \"\"));\n        result[newKey] = recursiveToCamel(value);\n    });\n    return result;\n};\n/**\n * Determine if input is a plain object\n * An object is plain if it's created by either {}, new Object(), or Object.create(null)\n * source: https://github.com/sindresorhus/is-plain-obj\n */ const isPlainObject = (value)=>{\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n}; //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBa0M7QUFDM0IsTUFBTUMsZUFBZSxDQUFDQztJQUN6QixJQUFJQztJQUNKLElBQUlELGFBQWE7UUFDYkMsU0FBU0Q7SUFDYixPQUNLLElBQUksT0FBT0UsVUFBVSxhQUFhO1FBQ25DRCxTQUFTLENBQUMsR0FBR0UsT0FBUyxnTEFBTyxDQUF3QkMsSUFBSSxDQUFDLENBQUMsRUFBRUMsU0FBU0gsTUFBSyxFQUFFLEdBQUtBLFVBQVNDO0lBQy9GLE9BQ0s7UUFDREYsU0FBU0M7SUFDYjtJQUNBLE9BQU8sQ0FBQyxHQUFHQyxPQUFTRixVQUFVRTtBQUNsQyxFQUFFO0FBQ0ssTUFBTUcsa0JBQWtCLElBQU1SLGdEQUFTQSxDQUFDLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25FLElBQUksT0FBT1MsYUFBYSxhQUFhO1lBQ2pDLGFBQWE7WUFDYixPQUFPLENBQUMsTUFBTSxnTEFBNkIsRUFBR0EsUUFBUTtRQUMxRDtRQUNBLE9BQU9BO0lBQ1gsR0FBRztBQUNJLE1BQU1DLG1CQUFtQixDQUFDQztJQUM3QixJQUFJQyxNQUFNQyxPQUFPLENBQUNGLE9BQU87UUFDckIsT0FBT0EsS0FBS0csR0FBRyxDQUFDLENBQUNDLEtBQU9MLGlCQUFpQks7SUFDN0MsT0FDSyxJQUFJLE9BQU9KLFNBQVMsY0FBY0EsU0FBU0ssT0FBT0wsT0FBTztRQUMxRCxPQUFPQTtJQUNYO0lBQ0EsTUFBTU0sU0FBUyxDQUFDO0lBQ2hCRCxPQUFPRSxPQUFPLENBQUNQLE1BQU1RLE9BQU8sQ0FBQyxDQUFDLENBQUNDLEtBQUtDLE1BQU07UUFDdEMsTUFBTUMsU0FBU0YsSUFBSUcsT0FBTyxDQUFDLGlCQUFpQixDQUFDQyxJQUFNQSxFQUFFQyxXQUFXLEdBQUdGLE9BQU8sQ0FBQyxTQUFTO1FBQ3BGTixNQUFNLENBQUNLLE9BQU8sR0FBR1osaUJBQWlCVztJQUN0QztJQUNBLE9BQU9KO0FBQ1gsRUFBRTtBQUNGOzs7O0NBSUMsR0FDTSxNQUFNUyxnQkFBZ0IsQ0FBQ0w7SUFDMUIsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsTUFBTTtRQUM3QyxPQUFPO0lBQ1g7SUFDQSxNQUFNTSxZQUFZWCxPQUFPWSxjQUFjLENBQUNQO0lBQ3hDLE9BQVEsQ0FBQ00sY0FBYyxRQUNuQkEsY0FBY1gsT0FBT1csU0FBUyxJQUM5QlgsT0FBT1ksY0FBYyxDQUFDRCxlQUFlLElBQUcsS0FDeEMsQ0FBRUUsQ0FBQUEsT0FBT0MsV0FBVyxJQUFJVCxLQUFJLEtBQzVCLENBQUVRLENBQUFBLE9BQU9FLFFBQVEsSUFBSVYsS0FBSTtBQUNqQyxFQUFFLENBQ0YsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanM/YTQ3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2F3YWl0ZXIgfSBmcm9tIFwidHNsaWJcIjtcbmV4cG9ydCBjb25zdCByZXNvbHZlRmV0Y2ggPSAoY3VzdG9tRmV0Y2gpID0+IHtcbiAgICBsZXQgX2ZldGNoO1xuICAgIGlmIChjdXN0b21GZXRjaCkge1xuICAgICAgICBfZmV0Y2ggPSBjdXN0b21GZXRjaDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGZldGNoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfZmV0Y2ggPSAoLi4uYXJncykgPT4gaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcpLnRoZW4oKHsgZGVmYXVsdDogZmV0Y2ggfSkgPT4gZmV0Y2goLi4uYXJncykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgX2ZldGNoID0gZmV0Y2g7XG4gICAgfVxuICAgIHJldHVybiAoLi4uYXJncykgPT4gX2ZldGNoKC4uLmFyZ3MpO1xufTtcbmV4cG9ydCBjb25zdCByZXNvbHZlUmVzcG9uc2UgPSAoKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAodHlwZW9mIFJlc3BvbnNlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiAoeWllbGQgaW1wb3J0KCdAc3VwYWJhc2Uvbm9kZS1mZXRjaCcpKS5SZXNwb25zZTtcbiAgICB9XG4gICAgcmV0dXJuIFJlc3BvbnNlO1xufSk7XG5leHBvcnQgY29uc3QgcmVjdXJzaXZlVG9DYW1lbCA9IChpdGVtKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ubWFwKChlbCkgPT4gcmVjdXJzaXZlVG9DYW1lbChlbCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaXRlbSA9PT0gJ2Z1bmN0aW9uJyB8fCBpdGVtICE9PSBPYmplY3QoaXRlbSkpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdLZXkgPSBrZXkucmVwbGFjZSgvKFstX11bYS16XSkvZ2ksIChjKSA9PiBjLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvWy1fXS9nLCAnJykpO1xuICAgICAgICByZXN1bHRbbmV3S2V5XSA9IHJlY3Vyc2l2ZVRvQ2FtZWwodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgaW5wdXQgaXMgYSBwbGFpbiBvYmplY3RcbiAqIEFuIG9iamVjdCBpcyBwbGFpbiBpZiBpdCdzIGNyZWF0ZWQgYnkgZWl0aGVyIHt9LCBuZXcgT2JqZWN0KCksIG9yIE9iamVjdC5jcmVhdGUobnVsbClcbiAqIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9pcy1wbGFpbi1vYmpcbiAqL1xuZXhwb3J0IGNvbnN0IGlzUGxhaW5PYmplY3QgPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSk7XG4gICAgcmV0dXJuICgocHJvdG90eXBlID09PSBudWxsIHx8XG4gICAgICAgIHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fFxuICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiZcbiAgICAgICAgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpICYmXG4gICAgICAgICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwicmVzb2x2ZUZldGNoIiwiY3VzdG9tRmV0Y2giLCJfZmV0Y2giLCJmZXRjaCIsImFyZ3MiLCJ0aGVuIiwiZGVmYXVsdCIsInJlc29sdmVSZXNwb25zZSIsIlJlc3BvbnNlIiwicmVjdXJzaXZlVG9DYW1lbCIsIml0ZW0iLCJBcnJheSIsImlzQXJyYXkiLCJtYXAiLCJlbCIsIk9iamVjdCIsInJlc3VsdCIsImVudHJpZXMiLCJmb3JFYWNoIiwia2V5IiwidmFsdWUiLCJuZXdLZXkiLCJyZXBsYWNlIiwiYyIsInRvVXBwZXJDYXNlIiwiaXNQbGFpbk9iamVjdCIsInByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJpdGVyYXRvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/StorageVectorsClient.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/vectors/StorageVectorsClient.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageVectorsClient: () => (/* binding */ StorageVectorsClient),\n/* harmony export */   VectorBucketScope: () => (/* binding */ VectorBucketScope),\n/* harmony export */   VectorIndexScope: () => (/* binding */ VectorIndexScope)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _VectorIndexApi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./VectorIndexApi */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/VectorIndexApi.js\");\n/* harmony import */ var _VectorDataApi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VectorDataApi */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/VectorDataApi.js\");\n/* harmony import */ var _VectorBucketApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./VectorBucketApi */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/VectorBucketApi.js\");\n\n\n\n\n/**\n * Main client for interacting with S3 Vectors API\n * Provides access to bucket, index, and vector data operations\n *\n * **Usage Patterns:**\n *\n * 1. **Via StorageClient (recommended for most use cases):**\n * ```typescript\n * import { StorageClient } from '@supabase/storage-js'\n *\n * const storageClient = new StorageClient(url, headers)\n * const vectors = storageClient.vectors\n *\n * // Use vector operations\n * await vectors.createBucket('embeddings-prod')\n * const bucket = vectors.from('embeddings-prod')\n * await bucket.createIndex({ ... })\n * ```\n *\n * 2. **Standalone (for vector-only applications):**\n * ```typescript\n * import { StorageVectorsClient } from '@supabase/storage-js'\n *\n * const vectorsClient = new StorageVectorsClient('https://api.example.com', {\n *   headers: { 'Authorization': 'Bearer token' }\n * })\n *\n * // Access bucket operations\n * await vectorsClient.createBucket('embeddings-prod')\n *\n * // Access index operations via buckets\n * const bucket = vectorsClient.from('embeddings-prod')\n * await bucket.createIndex({\n *   indexName: 'documents',\n *   dataType: 'float32',\n *   dimension: 1536,\n *   distanceMetric: 'cosine'\n * })\n *\n * // Access vector operations via index\n * const index = bucket.index('documents')\n * await index.putVectors({\n *   vectors: [\n *     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n *   ]\n * })\n *\n * // Query similar vectors\n * const { data } = await index.queryVectors({\n *   queryVector: { float32: [...] },\n *   topK: 5,\n *   returnDistance: true\n * })\n * ```\n */ class StorageVectorsClient extends _VectorBucketApi__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor(url, options = {}){\n        super(url, options.headers || {}, options.fetch);\n    }\n    /**\n     * Access operations for a specific vector bucket\n     * Returns a scoped client for index and vector operations within the bucket\n     *\n     * @param vectorBucketName - Name of the vector bucket\n     * @returns Bucket-scoped client with index and vector operations\n     *\n     * @example\n     * ```typescript\n     * const bucket = client.bucket('embeddings-prod')\n     *\n     * // Create an index in this bucket\n     * await bucket.createIndex({\n     *   indexName: 'documents-openai',\n     *   dataType: 'float32',\n     *   dimension: 1536,\n     *   distanceMetric: 'cosine'\n     * })\n     *\n     * // List indexes in this bucket\n     * const { data } = await bucket.listIndexes()\n     * ```\n     */ from(vectorBucketName) {\n        return new VectorBucketScope(this.url, this.headers, vectorBucketName, this.fetch);\n    }\n}\n/**\n * Scoped client for operations within a specific vector bucket\n * Provides index management and access to vector operations\n */ class VectorBucketScope extends _VectorIndexApi__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n    constructor(url, headers, vectorBucketName, fetch){\n        super(url, headers, fetch);\n        this.vectorBucketName = vectorBucketName;\n    }\n    /**\n     * Creates a new vector index in this bucket\n     * Convenience method that automatically includes the bucket name\n     *\n     * @param options - Index configuration (vectorBucketName is automatically set)\n     * @returns Promise with empty response on success or error\n     *\n     * @example\n     * ```typescript\n     * const bucket = client.bucket('embeddings-prod')\n     * await bucket.createIndex({\n     *   indexName: 'documents-openai',\n     *   dataType: 'float32',\n     *   dimension: 1536,\n     *   distanceMetric: 'cosine',\n     *   metadataConfiguration: {\n     *     nonFilterableMetadataKeys: ['raw_text']\n     *   }\n     * })\n     * ```\n     */ createIndex(options) {\n        const _super = Object.create(null, {\n            createIndex: {\n                get: ()=>super.createIndex\n            }\n        });\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            return _super.createIndex.call(this, Object.assign(Object.assign({}, options), {\n                vectorBucketName: this.vectorBucketName\n            }));\n        });\n    }\n    /**\n     * Lists indexes in this bucket\n     * Convenience method that automatically includes the bucket name\n     *\n     * @param options - Listing options (vectorBucketName is automatically set)\n     * @returns Promise with list of indexes or error\n     *\n     * @example\n     * ```typescript\n     * const bucket = client.bucket('embeddings-prod')\n     * const { data } = await bucket.listIndexes({ prefix: 'documents-' })\n     * ```\n     */ listIndexes() {\n        const _super = Object.create(null, {\n            listIndexes: {\n                get: ()=>super.listIndexes\n            }\n        });\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, arguments, void 0, function*(options = {}) {\n            return _super.listIndexes.call(this, Object.assign(Object.assign({}, options), {\n                vectorBucketName: this.vectorBucketName\n            }));\n        });\n    }\n    /**\n     * Retrieves metadata for a specific index in this bucket\n     * Convenience method that automatically includes the bucket name\n     *\n     * @param indexName - Name of the index to retrieve\n     * @returns Promise with index metadata or error\n     *\n     * @example\n     * ```typescript\n     * const bucket = client.bucket('embeddings-prod')\n     * const { data } = await bucket.getIndex('documents-openai')\n     * console.log('Dimension:', data?.index.dimension)\n     * ```\n     */ getIndex(indexName) {\n        const _super = Object.create(null, {\n            getIndex: {\n                get: ()=>super.getIndex\n            }\n        });\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            return _super.getIndex.call(this, this.vectorBucketName, indexName);\n        });\n    }\n    /**\n     * Deletes an index from this bucket\n     * Convenience method that automatically includes the bucket name\n     *\n     * @param indexName - Name of the index to delete\n     * @returns Promise with empty response on success or error\n     *\n     * @example\n     * ```typescript\n     * const bucket = client.bucket('embeddings-prod')\n     * await bucket.deleteIndex('old-index')\n     * ```\n     */ deleteIndex(indexName) {\n        const _super = Object.create(null, {\n            deleteIndex: {\n                get: ()=>super.deleteIndex\n            }\n        });\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            return _super.deleteIndex.call(this, this.vectorBucketName, indexName);\n        });\n    }\n    /**\n     * Access operations for a specific index within this bucket\n     * Returns a scoped client for vector data operations\n     *\n     * @param indexName - Name of the index\n     * @returns Index-scoped client with vector data operations\n     *\n     * @example\n     * ```typescript\n     * const index = client.bucket('embeddings-prod').index('documents-openai')\n     *\n     * // Insert vectors\n     * await index.putVectors({\n     *   vectors: [\n     *     { key: 'doc-1', data: { float32: [...] }, metadata: { title: 'Intro' } }\n     *   ]\n     * })\n     *\n     * // Query similar vectors\n     * const { data } = await index.queryVectors({\n     *   queryVector: { float32: [...] },\n     *   topK: 5\n     * })\n     * ```\n     */ index(indexName) {\n        return new VectorIndexScope(this.url, this.headers, this.vectorBucketName, indexName, this.fetch);\n    }\n}\n/**\n * Scoped client for operations within a specific vector index\n * Provides vector data operations (put, get, list, query, delete)\n */ class VectorIndexScope extends _VectorDataApi__WEBPACK_IMPORTED_MODULE_3__[\"default\"] {\n    constructor(url, headers, vectorBucketName, indexName, fetch){\n        super(url, headers, fetch);\n        this.vectorBucketName = vectorBucketName;\n        this.indexName = indexName;\n    }\n    /**\n     * Inserts or updates vectors in this index\n     * Convenience method that automatically includes bucket and index names\n     *\n     * @param options - Vector insertion options (bucket and index names automatically set)\n     * @returns Promise with empty response on success or error\n     *\n     * @example\n     * ```typescript\n     * const index = client.bucket('embeddings-prod').index('documents-openai')\n     * await index.putVectors({\n     *   vectors: [\n     *     {\n     *       key: 'doc-1',\n     *       data: { float32: [0.1, 0.2, ...] },\n     *       metadata: { title: 'Introduction', page: 1 }\n     *     }\n     *   ]\n     * })\n     * ```\n     */ putVectors(options) {\n        const _super = Object.create(null, {\n            putVectors: {\n                get: ()=>super.putVectors\n            }\n        });\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            return _super.putVectors.call(this, Object.assign(Object.assign({}, options), {\n                vectorBucketName: this.vectorBucketName,\n                indexName: this.indexName\n            }));\n        });\n    }\n    /**\n     * Retrieves vectors by keys from this index\n     * Convenience method that automatically includes bucket and index names\n     *\n     * @param options - Vector retrieval options (bucket and index names automatically set)\n     * @returns Promise with array of vectors or error\n     *\n     * @example\n     * ```typescript\n     * const index = client.bucket('embeddings-prod').index('documents-openai')\n     * const { data } = await index.getVectors({\n     *   keys: ['doc-1', 'doc-2'],\n     *   returnMetadata: true\n     * })\n     * ```\n     */ getVectors(options) {\n        const _super = Object.create(null, {\n            getVectors: {\n                get: ()=>super.getVectors\n            }\n        });\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            return _super.getVectors.call(this, Object.assign(Object.assign({}, options), {\n                vectorBucketName: this.vectorBucketName,\n                indexName: this.indexName\n            }));\n        });\n    }\n    /**\n     * Lists vectors in this index with pagination\n     * Convenience method that automatically includes bucket and index names\n     *\n     * @param options - Listing options (bucket and index names automatically set)\n     * @returns Promise with array of vectors and pagination token\n     *\n     * @example\n     * ```typescript\n     * const index = client.bucket('embeddings-prod').index('documents-openai')\n     * const { data } = await index.listVectors({\n     *   maxResults: 500,\n     *   returnMetadata: true\n     * })\n     * ```\n     */ listVectors() {\n        const _super = Object.create(null, {\n            listVectors: {\n                get: ()=>super.listVectors\n            }\n        });\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, arguments, void 0, function*(options = {}) {\n            return _super.listVectors.call(this, Object.assign(Object.assign({}, options), {\n                vectorBucketName: this.vectorBucketName,\n                indexName: this.indexName\n            }));\n        });\n    }\n    /**\n     * Queries for similar vectors in this index\n     * Convenience method that automatically includes bucket and index names\n     *\n     * @param options - Query options (bucket and index names automatically set)\n     * @returns Promise with array of similar vectors ordered by distance\n     *\n     * @example\n     * ```typescript\n     * const index = client.bucket('embeddings-prod').index('documents-openai')\n     * const { data } = await index.queryVectors({\n     *   queryVector: { float32: [0.1, 0.2, ...] },\n     *   topK: 5,\n     *   filter: { category: 'technical' },\n     *   returnDistance: true,\n     *   returnMetadata: true\n     * })\n     * ```\n     */ queryVectors(options) {\n        const _super = Object.create(null, {\n            queryVectors: {\n                get: ()=>super.queryVectors\n            }\n        });\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            return _super.queryVectors.call(this, Object.assign(Object.assign({}, options), {\n                vectorBucketName: this.vectorBucketName,\n                indexName: this.indexName\n            }));\n        });\n    }\n    /**\n     * Deletes vectors by keys from this index\n     * Convenience method that automatically includes bucket and index names\n     *\n     * @param options - Deletion options (bucket and index names automatically set)\n     * @returns Promise with empty response on success or error\n     *\n     * @example\n     * ```typescript\n     * const index = client.bucket('embeddings-prod').index('documents-openai')\n     * await index.deleteVectors({\n     *   keys: ['doc-1', 'doc-2', 'doc-3']\n     * })\n     * ```\n     */ deleteVectors(options) {\n        const _super = Object.create(null, {\n            deleteVectors: {\n                get: ()=>super.deleteVectors\n            }\n        });\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            return _super.deleteVectors.call(this, Object.assign(Object.assign({}, options), {\n                vectorBucketName: this.vectorBucketName,\n                indexName: this.indexName\n            }));\n        });\n    }\n} //# sourceMappingURL=StorageVectorsClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL3ZlY3RvcnMvU3RvcmFnZVZlY3RvcnNDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFrQztBQUNZO0FBQ0Y7QUFDSTtBQUNoRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBc0RDLEdBQ00sTUFBTUksNkJBQTZCRCx3REFBZUE7SUFDckRFLFlBQVlDLEdBQUcsRUFBRUMsVUFBVSxDQUFDLENBQUMsQ0FBRTtRQUMzQixLQUFLLENBQUNELEtBQUtDLFFBQVFDLE9BQU8sSUFBSSxDQUFDLEdBQUdELFFBQVFFLEtBQUs7SUFDbkQ7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXNCQyxHQUNEQyxLQUFLQyxnQkFBZ0IsRUFBRTtRQUNuQixPQUFPLElBQUlDLGtCQUFrQixJQUFJLENBQUNOLEdBQUcsRUFBRSxJQUFJLENBQUNFLE9BQU8sRUFBRUcsa0JBQWtCLElBQUksQ0FBQ0YsS0FBSztJQUNyRjtBQUNKO0FBQ0E7OztDQUdDLEdBQ00sTUFBTUcsMEJBQTBCWCx1REFBY0E7SUFDakRJLFlBQVlDLEdBQUcsRUFBRUUsT0FBTyxFQUFFRyxnQkFBZ0IsRUFBRUYsS0FBSyxDQUFFO1FBQy9DLEtBQUssQ0FBQ0gsS0FBS0UsU0FBU0M7UUFDcEIsSUFBSSxDQUFDRSxnQkFBZ0IsR0FBR0E7SUFDNUI7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FvQkMsR0FDREUsWUFBWU4sT0FBTyxFQUFFO1FBQ2pCLE1BQU1PLFNBQVNDLE9BQU9DLE1BQU0sQ0FBQyxNQUFNO1lBQy9CSCxhQUFhO2dCQUFFSSxLQUFLLElBQU0sS0FBSyxDQUFDSjtZQUFZO1FBQ2hEO1FBQ0EsT0FBT2IsZ0RBQVNBLENBQUMsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsT0FBT2MsT0FBT0QsV0FBVyxDQUFDSyxJQUFJLENBQUMsSUFBSSxFQUFFSCxPQUFPSSxNQUFNLENBQUNKLE9BQU9JLE1BQU0sQ0FBQyxDQUFDLEdBQUdaLFVBQVU7Z0JBQUVJLGtCQUFrQixJQUFJLENBQUNBLGdCQUFnQjtZQUFDO1FBQzdIO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7O0tBWUMsR0FDRFMsY0FBYztRQUNWLE1BQU1OLFNBQVNDLE9BQU9DLE1BQU0sQ0FBQyxNQUFNO1lBQy9CSSxhQUFhO2dCQUFFSCxLQUFLLElBQU0sS0FBSyxDQUFDRztZQUFZO1FBQ2hEO1FBQ0EsT0FBT3BCLGdEQUFTQSxDQUFDLElBQUksRUFBRXFCLFdBQVcsS0FBSyxHQUFHLFVBQVdkLFVBQVUsQ0FBQyxDQUFDO1lBQzdELE9BQU9PLE9BQU9NLFdBQVcsQ0FBQ0YsSUFBSSxDQUFDLElBQUksRUFBRUgsT0FBT0ksTUFBTSxDQUFDSixPQUFPSSxNQUFNLENBQUMsQ0FBQyxHQUFHWixVQUFVO2dCQUFFSSxrQkFBa0IsSUFBSSxDQUFDQSxnQkFBZ0I7WUFBQztRQUM3SDtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7S0FhQyxHQUNEVyxTQUFTQyxTQUFTLEVBQUU7UUFDaEIsTUFBTVQsU0FBU0MsT0FBT0MsTUFBTSxDQUFDLE1BQU07WUFDL0JNLFVBQVU7Z0JBQUVMLEtBQUssSUFBTSxLQUFLLENBQUNLO1lBQVM7UUFDMUM7UUFDQSxPQUFPdEIsZ0RBQVNBLENBQUMsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsT0FBT2MsT0FBT1EsUUFBUSxDQUFDSixJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQ1AsZ0JBQWdCLEVBQUVZO1FBQzdEO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7O0tBWUMsR0FDREMsWUFBWUQsU0FBUyxFQUFFO1FBQ25CLE1BQU1ULFNBQVNDLE9BQU9DLE1BQU0sQ0FBQyxNQUFNO1lBQy9CUSxhQUFhO2dCQUFFUCxLQUFLLElBQU0sS0FBSyxDQUFDTztZQUFZO1FBQ2hEO1FBQ0EsT0FBT3hCLGdEQUFTQSxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE9BQU9jLE9BQU9VLFdBQVcsQ0FBQ04sSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUNQLGdCQUFnQixFQUFFWTtRQUNoRTtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXdCQyxHQUNERSxNQUFNRixTQUFTLEVBQUU7UUFDYixPQUFPLElBQUlHLGlCQUFpQixJQUFJLENBQUNwQixHQUFHLEVBQUUsSUFBSSxDQUFDRSxPQUFPLEVBQUUsSUFBSSxDQUFDRyxnQkFBZ0IsRUFBRVksV0FBVyxJQUFJLENBQUNkLEtBQUs7SUFDcEc7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLE1BQU1pQix5QkFBeUJ4QixzREFBYUE7SUFDL0NHLFlBQVlDLEdBQUcsRUFBRUUsT0FBTyxFQUFFRyxnQkFBZ0IsRUFBRVksU0FBUyxFQUFFZCxLQUFLLENBQUU7UUFDMUQsS0FBSyxDQUFDSCxLQUFLRSxTQUFTQztRQUNwQixJQUFJLENBQUNFLGdCQUFnQixHQUFHQTtRQUN4QixJQUFJLENBQUNZLFNBQVMsR0FBR0E7SUFDckI7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FvQkMsR0FDREksV0FBV3BCLE9BQU8sRUFBRTtRQUNoQixNQUFNTyxTQUFTQyxPQUFPQyxNQUFNLENBQUMsTUFBTTtZQUMvQlcsWUFBWTtnQkFBRVYsS0FBSyxJQUFNLEtBQUssQ0FBQ1U7WUFBVztRQUM5QztRQUNBLE9BQU8zQixnREFBU0EsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxPQUFPYyxPQUFPYSxVQUFVLENBQUNULElBQUksQ0FBQyxJQUFJLEVBQUVILE9BQU9JLE1BQU0sQ0FBQ0osT0FBT0ksTUFBTSxDQUFDLENBQUMsR0FBR1osVUFBVTtnQkFBRUksa0JBQWtCLElBQUksQ0FBQ0EsZ0JBQWdCO2dCQUFFWSxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUFDO1FBQ3ZKO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7O0tBZUMsR0FDREssV0FBV3JCLE9BQU8sRUFBRTtRQUNoQixNQUFNTyxTQUFTQyxPQUFPQyxNQUFNLENBQUMsTUFBTTtZQUMvQlksWUFBWTtnQkFBRVgsS0FBSyxJQUFNLEtBQUssQ0FBQ1c7WUFBVztRQUM5QztRQUNBLE9BQU81QixnREFBU0EsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxPQUFPYyxPQUFPYyxVQUFVLENBQUNWLElBQUksQ0FBQyxJQUFJLEVBQUVILE9BQU9JLE1BQU0sQ0FBQ0osT0FBT0ksTUFBTSxDQUFDLENBQUMsR0FBR1osVUFBVTtnQkFBRUksa0JBQWtCLElBQUksQ0FBQ0EsZ0JBQWdCO2dCQUFFWSxXQUFXLElBQUksQ0FBQ0EsU0FBUztZQUFDO1FBQ3ZKO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7O0tBZUMsR0FDRE0sY0FBYztRQUNWLE1BQU1mLFNBQVNDLE9BQU9DLE1BQU0sQ0FBQyxNQUFNO1lBQy9CYSxhQUFhO2dCQUFFWixLQUFLLElBQU0sS0FBSyxDQUFDWTtZQUFZO1FBQ2hEO1FBQ0EsT0FBTzdCLGdEQUFTQSxDQUFDLElBQUksRUFBRXFCLFdBQVcsS0FBSyxHQUFHLFVBQVdkLFVBQVUsQ0FBQyxDQUFDO1lBQzdELE9BQU9PLE9BQU9lLFdBQVcsQ0FBQ1gsSUFBSSxDQUFDLElBQUksRUFBRUgsT0FBT0ksTUFBTSxDQUFDSixPQUFPSSxNQUFNLENBQUMsQ0FBQyxHQUFHWixVQUFVO2dCQUFFSSxrQkFBa0IsSUFBSSxDQUFDQSxnQkFBZ0I7Z0JBQUVZLFdBQVcsSUFBSSxDQUFDQSxTQUFTO1lBQUM7UUFDeEo7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FrQkMsR0FDRE8sYUFBYXZCLE9BQU8sRUFBRTtRQUNsQixNQUFNTyxTQUFTQyxPQUFPQyxNQUFNLENBQUMsTUFBTTtZQUMvQmMsY0FBYztnQkFBRWIsS0FBSyxJQUFNLEtBQUssQ0FBQ2E7WUFBYTtRQUNsRDtRQUNBLE9BQU85QixnREFBU0EsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxPQUFPYyxPQUFPZ0IsWUFBWSxDQUFDWixJQUFJLENBQUMsSUFBSSxFQUFFSCxPQUFPSSxNQUFNLENBQUNKLE9BQU9JLE1BQU0sQ0FBQyxDQUFDLEdBQUdaLFVBQVU7Z0JBQUVJLGtCQUFrQixJQUFJLENBQUNBLGdCQUFnQjtnQkFBRVksV0FBVyxJQUFJLENBQUNBLFNBQVM7WUFBQztRQUN6SjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7O0tBY0MsR0FDRFEsY0FBY3hCLE9BQU8sRUFBRTtRQUNuQixNQUFNTyxTQUFTQyxPQUFPQyxNQUFNLENBQUMsTUFBTTtZQUMvQmUsZUFBZTtnQkFBRWQsS0FBSyxJQUFNLEtBQUssQ0FBQ2M7WUFBYztRQUNwRDtRQUNBLE9BQU8vQixnREFBU0EsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxPQUFPYyxPQUFPaUIsYUFBYSxDQUFDYixJQUFJLENBQUMsSUFBSSxFQUFFSCxPQUFPSSxNQUFNLENBQUNKLE9BQU9JLE1BQU0sQ0FBQyxDQUFDLEdBQUdaLFVBQVU7Z0JBQUVJLGtCQUFrQixJQUFJLENBQUNBLGdCQUFnQjtnQkFBRVksV0FBVyxJQUFJLENBQUNBLFNBQVM7WUFBQztRQUMxSjtJQUNKO0FBQ0osRUFDQSxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvdmVjdG9ycy9TdG9yYWdlVmVjdG9yc0NsaWVudC5qcz80MDNjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IFZlY3RvckluZGV4QXBpIGZyb20gJy4vVmVjdG9ySW5kZXhBcGknO1xuaW1wb3J0IFZlY3RvckRhdGFBcGkgZnJvbSAnLi9WZWN0b3JEYXRhQXBpJztcbmltcG9ydCBWZWN0b3JCdWNrZXRBcGkgZnJvbSAnLi9WZWN0b3JCdWNrZXRBcGknO1xuLyoqXG4gKiBNYWluIGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCBTMyBWZWN0b3JzIEFQSVxuICogUHJvdmlkZXMgYWNjZXNzIHRvIGJ1Y2tldCwgaW5kZXgsIGFuZCB2ZWN0b3IgZGF0YSBvcGVyYXRpb25zXG4gKlxuICogKipVc2FnZSBQYXR0ZXJuczoqKlxuICpcbiAqIDEuICoqVmlhIFN0b3JhZ2VDbGllbnQgKHJlY29tbWVuZGVkIGZvciBtb3N0IHVzZSBjYXNlcyk6KipcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IFN0b3JhZ2VDbGllbnQgfSBmcm9tICdAc3VwYWJhc2Uvc3RvcmFnZS1qcydcbiAqXG4gKiBjb25zdCBzdG9yYWdlQ2xpZW50ID0gbmV3IFN0b3JhZ2VDbGllbnQodXJsLCBoZWFkZXJzKVxuICogY29uc3QgdmVjdG9ycyA9IHN0b3JhZ2VDbGllbnQudmVjdG9yc1xuICpcbiAqIC8vIFVzZSB2ZWN0b3Igb3BlcmF0aW9uc1xuICogYXdhaXQgdmVjdG9ycy5jcmVhdGVCdWNrZXQoJ2VtYmVkZGluZ3MtcHJvZCcpXG4gKiBjb25zdCBidWNrZXQgPSB2ZWN0b3JzLmZyb20oJ2VtYmVkZGluZ3MtcHJvZCcpXG4gKiBhd2FpdCBidWNrZXQuY3JlYXRlSW5kZXgoeyAuLi4gfSlcbiAqIGBgYFxuICpcbiAqIDIuICoqU3RhbmRhbG9uZSAoZm9yIHZlY3Rvci1vbmx5IGFwcGxpY2F0aW9ucyk6KipcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGltcG9ydCB7IFN0b3JhZ2VWZWN0b3JzQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N0b3JhZ2UtanMnXG4gKlxuICogY29uc3QgdmVjdG9yc0NsaWVudCA9IG5ldyBTdG9yYWdlVmVjdG9yc0NsaWVudCgnaHR0cHM6Ly9hcGkuZXhhbXBsZS5jb20nLCB7XG4gKiAgIGhlYWRlcnM6IHsgJ0F1dGhvcml6YXRpb24nOiAnQmVhcmVyIHRva2VuJyB9XG4gKiB9KVxuICpcbiAqIC8vIEFjY2VzcyBidWNrZXQgb3BlcmF0aW9uc1xuICogYXdhaXQgdmVjdG9yc0NsaWVudC5jcmVhdGVCdWNrZXQoJ2VtYmVkZGluZ3MtcHJvZCcpXG4gKlxuICogLy8gQWNjZXNzIGluZGV4IG9wZXJhdGlvbnMgdmlhIGJ1Y2tldHNcbiAqIGNvbnN0IGJ1Y2tldCA9IHZlY3RvcnNDbGllbnQuZnJvbSgnZW1iZWRkaW5ncy1wcm9kJylcbiAqIGF3YWl0IGJ1Y2tldC5jcmVhdGVJbmRleCh7XG4gKiAgIGluZGV4TmFtZTogJ2RvY3VtZW50cycsXG4gKiAgIGRhdGFUeXBlOiAnZmxvYXQzMicsXG4gKiAgIGRpbWVuc2lvbjogMTUzNixcbiAqICAgZGlzdGFuY2VNZXRyaWM6ICdjb3NpbmUnXG4gKiB9KVxuICpcbiAqIC8vIEFjY2VzcyB2ZWN0b3Igb3BlcmF0aW9ucyB2aWEgaW5kZXhcbiAqIGNvbnN0IGluZGV4ID0gYnVja2V0LmluZGV4KCdkb2N1bWVudHMnKVxuICogYXdhaXQgaW5kZXgucHV0VmVjdG9ycyh7XG4gKiAgIHZlY3RvcnM6IFtcbiAqICAgICB7IGtleTogJ2RvYy0xJywgZGF0YTogeyBmbG9hdDMyOiBbLi4uXSB9LCBtZXRhZGF0YTogeyB0aXRsZTogJ0ludHJvJyB9IH1cbiAqICAgXVxuICogfSlcbiAqXG4gKiAvLyBRdWVyeSBzaW1pbGFyIHZlY3RvcnNcbiAqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXgucXVlcnlWZWN0b3JzKHtcbiAqICAgcXVlcnlWZWN0b3I6IHsgZmxvYXQzMjogWy4uLl0gfSxcbiAqICAgdG9wSzogNSxcbiAqICAgcmV0dXJuRGlzdGFuY2U6IHRydWVcbiAqIH0pXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFN0b3JhZ2VWZWN0b3JzQ2xpZW50IGV4dGVuZHMgVmVjdG9yQnVja2V0QXBpIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcih1cmwsIG9wdGlvbnMuaGVhZGVycyB8fCB7fSwgb3B0aW9ucy5mZXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VzcyBvcGVyYXRpb25zIGZvciBhIHNwZWNpZmljIHZlY3RvciBidWNrZXRcbiAgICAgKiBSZXR1cm5zIGEgc2NvcGVkIGNsaWVudCBmb3IgaW5kZXggYW5kIHZlY3RvciBvcGVyYXRpb25zIHdpdGhpbiB0aGUgYnVja2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmVjdG9yQnVja2V0TmFtZSAtIE5hbWUgb2YgdGhlIHZlY3RvciBidWNrZXRcbiAgICAgKiBAcmV0dXJucyBCdWNrZXQtc2NvcGVkIGNsaWVudCB3aXRoIGluZGV4IGFuZCB2ZWN0b3Igb3BlcmF0aW9uc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgYnVja2V0ID0gY2xpZW50LmJ1Y2tldCgnZW1iZWRkaW5ncy1wcm9kJylcbiAgICAgKlxuICAgICAqIC8vIENyZWF0ZSBhbiBpbmRleCBpbiB0aGlzIGJ1Y2tldFxuICAgICAqIGF3YWl0IGJ1Y2tldC5jcmVhdGVJbmRleCh7XG4gICAgICogICBpbmRleE5hbWU6ICdkb2N1bWVudHMtb3BlbmFpJyxcbiAgICAgKiAgIGRhdGFUeXBlOiAnZmxvYXQzMicsXG4gICAgICogICBkaW1lbnNpb246IDE1MzYsXG4gICAgICogICBkaXN0YW5jZU1ldHJpYzogJ2Nvc2luZSdcbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogLy8gTGlzdCBpbmRleGVzIGluIHRoaXMgYnVja2V0XG4gICAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBidWNrZXQubGlzdEluZGV4ZXMoKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZyb20odmVjdG9yQnVja2V0TmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvckJ1Y2tldFNjb3BlKHRoaXMudXJsLCB0aGlzLmhlYWRlcnMsIHZlY3RvckJ1Y2tldE5hbWUsIHRoaXMuZmV0Y2gpO1xuICAgIH1cbn1cbi8qKlxuICogU2NvcGVkIGNsaWVudCBmb3Igb3BlcmF0aW9ucyB3aXRoaW4gYSBzcGVjaWZpYyB2ZWN0b3IgYnVja2V0XG4gKiBQcm92aWRlcyBpbmRleCBtYW5hZ2VtZW50IGFuZCBhY2Nlc3MgdG8gdmVjdG9yIG9wZXJhdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIFZlY3RvckJ1Y2tldFNjb3BlIGV4dGVuZHMgVmVjdG9ySW5kZXhBcGkge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycywgdmVjdG9yQnVja2V0TmFtZSwgZmV0Y2gpIHtcbiAgICAgICAgc3VwZXIodXJsLCBoZWFkZXJzLCBmZXRjaCk7XG4gICAgICAgIHRoaXMudmVjdG9yQnVja2V0TmFtZSA9IHZlY3RvckJ1Y2tldE5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGluZGV4IGluIHRoaXMgYnVja2V0XG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gSW5kZXggY29uZmlndXJhdGlvbiAodmVjdG9yQnVja2V0TmFtZSBpcyBhdXRvbWF0aWNhbGx5IHNldClcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgYnVja2V0ID0gY2xpZW50LmJ1Y2tldCgnZW1iZWRkaW5ncy1wcm9kJylcbiAgICAgKiBhd2FpdCBidWNrZXQuY3JlYXRlSW5kZXgoe1xuICAgICAqICAgaW5kZXhOYW1lOiAnZG9jdW1lbnRzLW9wZW5haScsXG4gICAgICogICBkYXRhVHlwZTogJ2Zsb2F0MzInLFxuICAgICAqICAgZGltZW5zaW9uOiAxNTM2LFxuICAgICAqICAgZGlzdGFuY2VNZXRyaWM6ICdjb3NpbmUnLFxuICAgICAqICAgbWV0YWRhdGFDb25maWd1cmF0aW9uOiB7XG4gICAgICogICAgIG5vbkZpbHRlcmFibGVNZXRhZGF0YUtleXM6IFsncmF3X3RleHQnXVxuICAgICAqICAgfVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgY3JlYXRlSW5kZXgob3B0aW9ucykge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIGNyZWF0ZUluZGV4OiB7IGdldDogKCkgPT4gc3VwZXIuY3JlYXRlSW5kZXggfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuY3JlYXRlSW5kZXguY2FsbCh0aGlzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHZlY3RvckJ1Y2tldE5hbWU6IHRoaXMudmVjdG9yQnVja2V0TmFtZSB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyBpbmRleGVzIGluIHRoaXMgYnVja2V0XG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTGlzdGluZyBvcHRpb25zICh2ZWN0b3JCdWNrZXROYW1lIGlzIGF1dG9tYXRpY2FsbHkgc2V0KVxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBsaXN0IG9mIGluZGV4ZXMgb3IgZXJyb3JcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGJ1Y2tldCA9IGNsaWVudC5idWNrZXQoJ2VtYmVkZGluZ3MtcHJvZCcpXG4gICAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBidWNrZXQubGlzdEluZGV4ZXMoeyBwcmVmaXg6ICdkb2N1bWVudHMtJyB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGxpc3RJbmRleGVzKCkge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIGxpc3RJbmRleGVzOiB7IGdldDogKCkgPT4gc3VwZXIubGlzdEluZGV4ZXMgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24qIChvcHRpb25zID0ge30pIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIubGlzdEluZGV4ZXMuY2FsbCh0aGlzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHZlY3RvckJ1Y2tldE5hbWU6IHRoaXMudmVjdG9yQnVja2V0TmFtZSB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgaW5kZXggaW4gdGhpcyBidWNrZXRcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIHRoZSBidWNrZXQgbmFtZVxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIHJldHJpZXZlXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGluZGV4IG1ldGFkYXRhIG9yIGVycm9yXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBidWNrZXQgPSBjbGllbnQuYnVja2V0KCdlbWJlZGRpbmdzLXByb2QnKVxuICAgICAqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYnVja2V0LmdldEluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcbiAgICAgKiBjb25zb2xlLmxvZygnRGltZW5zaW9uOicsIGRhdGE/LmluZGV4LmRpbWVuc2lvbilcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXRJbmRleChpbmRleE5hbWUpIHtcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBnZXRJbmRleDogeyBnZXQ6ICgpID0+IHN1cGVyLmdldEluZGV4IH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmdldEluZGV4LmNhbGwodGhpcywgdGhpcy52ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhbiBpbmRleCBmcm9tIHRoaXMgYnVja2V0XG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgYXV0b21hdGljYWxseSBpbmNsdWRlcyB0aGUgYnVja2V0IG5hbWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleE5hbWUgLSBOYW1lIG9mIHRoZSBpbmRleCB0byBkZWxldGVcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgYnVja2V0ID0gY2xpZW50LmJ1Y2tldCgnZW1iZWRkaW5ncy1wcm9kJylcbiAgICAgKiBhd2FpdCBidWNrZXQuZGVsZXRlSW5kZXgoJ29sZC1pbmRleCcpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZGVsZXRlSW5kZXgoaW5kZXhOYW1lKSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgZGVsZXRlSW5kZXg6IHsgZ2V0OiAoKSA9PiBzdXBlci5kZWxldGVJbmRleCB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5kZWxldGVJbmRleC5jYWxsKHRoaXMsIHRoaXMudmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VzcyBvcGVyYXRpb25zIGZvciBhIHNwZWNpZmljIGluZGV4IHdpdGhpbiB0aGlzIGJ1Y2tldFxuICAgICAqIFJldHVybnMgYSBzY29wZWQgY2xpZW50IGZvciB2ZWN0b3IgZGF0YSBvcGVyYXRpb25zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXhcbiAgICAgKiBAcmV0dXJucyBJbmRleC1zY29wZWQgY2xpZW50IHdpdGggdmVjdG9yIGRhdGEgb3BlcmF0aW9uc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgaW5kZXggPSBjbGllbnQuYnVja2V0KCdlbWJlZGRpbmdzLXByb2QnKS5pbmRleCgnZG9jdW1lbnRzLW9wZW5haScpXG4gICAgICpcbiAgICAgKiAvLyBJbnNlcnQgdmVjdG9yc1xuICAgICAqIGF3YWl0IGluZGV4LnB1dFZlY3RvcnMoe1xuICAgICAqICAgdmVjdG9yczogW1xuICAgICAqICAgICB7IGtleTogJ2RvYy0xJywgZGF0YTogeyBmbG9hdDMyOiBbLi4uXSB9LCBtZXRhZGF0YTogeyB0aXRsZTogJ0ludHJvJyB9IH1cbiAgICAgKiAgIF1cbiAgICAgKiB9KVxuICAgICAqXG4gICAgICogLy8gUXVlcnkgc2ltaWxhciB2ZWN0b3JzXG4gICAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBpbmRleC5xdWVyeVZlY3RvcnMoe1xuICAgICAqICAgcXVlcnlWZWN0b3I6IHsgZmxvYXQzMjogWy4uLl0gfSxcbiAgICAgKiAgIHRvcEs6IDVcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGluZGV4KGluZGV4TmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFZlY3RvckluZGV4U2NvcGUodGhpcy51cmwsIHRoaXMuaGVhZGVycywgdGhpcy52ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUsIHRoaXMuZmV0Y2gpO1xuICAgIH1cbn1cbi8qKlxuICogU2NvcGVkIGNsaWVudCBmb3Igb3BlcmF0aW9ucyB3aXRoaW4gYSBzcGVjaWZpYyB2ZWN0b3IgaW5kZXhcbiAqIFByb3ZpZGVzIHZlY3RvciBkYXRhIG9wZXJhdGlvbnMgKHB1dCwgZ2V0LCBsaXN0LCBxdWVyeSwgZGVsZXRlKVxuICovXG5leHBvcnQgY2xhc3MgVmVjdG9ySW5kZXhTY29wZSBleHRlbmRzIFZlY3RvckRhdGFBcGkge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycywgdmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lLCBmZXRjaCkge1xuICAgICAgICBzdXBlcih1cmwsIGhlYWRlcnMsIGZldGNoKTtcbiAgICAgICAgdGhpcy52ZWN0b3JCdWNrZXROYW1lID0gdmVjdG9yQnVja2V0TmFtZTtcbiAgICAgICAgdGhpcy5pbmRleE5hbWUgPSBpbmRleE5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgb3IgdXBkYXRlcyB2ZWN0b3JzIGluIHRoaXMgaW5kZXhcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVmVjdG9yIGluc2VydGlvbiBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBpbmRleCA9IGNsaWVudC5idWNrZXQoJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcbiAgICAgKiBhd2FpdCBpbmRleC5wdXRWZWN0b3JzKHtcbiAgICAgKiAgIHZlY3RvcnM6IFtcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIGtleTogJ2RvYy0xJyxcbiAgICAgKiAgICAgICBkYXRhOiB7IGZsb2F0MzI6IFswLjEsIDAuMiwgLi4uXSB9LFxuICAgICAqICAgICAgIG1ldGFkYXRhOiB7IHRpdGxlOiAnSW50cm9kdWN0aW9uJywgcGFnZTogMSB9XG4gICAgICogICAgIH1cbiAgICAgKiAgIF1cbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1dFZlY3RvcnMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgICAgICAgIHB1dFZlY3RvcnM6IHsgZ2V0OiAoKSA9PiBzdXBlci5wdXRWZWN0b3JzIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnB1dFZlY3RvcnMuY2FsbCh0aGlzLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHZlY3RvckJ1Y2tldE5hbWU6IHRoaXMudmVjdG9yQnVja2V0TmFtZSwgaW5kZXhOYW1lOiB0aGlzLmluZGV4TmFtZSB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdmVjdG9ycyBieSBrZXlzIGZyb20gdGhpcyBpbmRleFxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgYnVja2V0IGFuZCBpbmRleCBuYW1lc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBWZWN0b3IgcmV0cmlldmFsIG9wdGlvbnMgKGJ1Y2tldCBhbmQgaW5kZXggbmFtZXMgYXV0b21hdGljYWxseSBzZXQpXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGFycmF5IG9mIHZlY3RvcnMgb3IgZXJyb3JcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGluZGV4ID0gY2xpZW50LmJ1Y2tldCgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuICAgICAqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXguZ2V0VmVjdG9ycyh7XG4gICAgICogICBrZXlzOiBbJ2RvYy0xJywgJ2RvYy0yJ10sXG4gICAgICogICByZXR1cm5NZXRhZGF0YTogdHJ1ZVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0VmVjdG9ycyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgZ2V0VmVjdG9yczogeyBnZXQ6ICgpID0+IHN1cGVyLmdldFZlY3RvcnMgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuZ2V0VmVjdG9ycy5jYWxsKHRoaXMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgdmVjdG9yQnVja2V0TmFtZTogdGhpcy52ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWU6IHRoaXMuaW5kZXhOYW1lIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIHZlY3RvcnMgaW4gdGhpcyBpbmRleCB3aXRoIHBhZ2luYXRpb25cbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTGlzdGluZyBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBhcnJheSBvZiB2ZWN0b3JzIGFuZCBwYWdpbmF0aW9uIHRva2VuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBpbmRleCA9IGNsaWVudC5idWNrZXQoJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcbiAgICAgKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGluZGV4Lmxpc3RWZWN0b3JzKHtcbiAgICAgKiAgIG1heFJlc3VsdHM6IDUwMCxcbiAgICAgKiAgIHJldHVybk1ldGFkYXRhOiB0cnVlXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBsaXN0VmVjdG9ycygpIHtcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBsaXN0VmVjdG9yczogeyBnZXQ6ICgpID0+IHN1cGVyLmxpc3RWZWN0b3JzIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uKiAob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLmxpc3RWZWN0b3JzLmNhbGwodGhpcywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyB2ZWN0b3JCdWNrZXROYW1lOiB0aGlzLnZlY3RvckJ1Y2tldE5hbWUsIGluZGV4TmFtZTogdGhpcy5pbmRleE5hbWUgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcmllcyBmb3Igc2ltaWxhciB2ZWN0b3JzIGluIHRoaXMgaW5kZXhcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBhdXRvbWF0aWNhbGx5IGluY2x1ZGVzIGJ1Y2tldCBhbmQgaW5kZXggbmFtZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUXVlcnkgb3B0aW9ucyAoYnVja2V0IGFuZCBpbmRleCBuYW1lcyBhdXRvbWF0aWNhbGx5IHNldClcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggYXJyYXkgb2Ygc2ltaWxhciB2ZWN0b3JzIG9yZGVyZWQgYnkgZGlzdGFuY2VcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGluZGV4ID0gY2xpZW50LmJ1Y2tldCgnZW1iZWRkaW5ncy1wcm9kJykuaW5kZXgoJ2RvY3VtZW50cy1vcGVuYWknKVxuICAgICAqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgaW5kZXgucXVlcnlWZWN0b3JzKHtcbiAgICAgKiAgIHF1ZXJ5VmVjdG9yOiB7IGZsb2F0MzI6IFswLjEsIDAuMiwgLi4uXSB9LFxuICAgICAqICAgdG9wSzogNSxcbiAgICAgKiAgIGZpbHRlcjogeyBjYXRlZ29yeTogJ3RlY2huaWNhbCcgfSxcbiAgICAgKiAgIHJldHVybkRpc3RhbmNlOiB0cnVlLFxuICAgICAqICAgcmV0dXJuTWV0YWRhdGE6IHRydWVcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHF1ZXJ5VmVjdG9ycyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgcXVlcnlWZWN0b3JzOiB7IGdldDogKCkgPT4gc3VwZXIucXVlcnlWZWN0b3JzIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnF1ZXJ5VmVjdG9ycy5jYWxsKHRoaXMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgdmVjdG9yQnVja2V0TmFtZTogdGhpcy52ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWU6IHRoaXMuaW5kZXhOYW1lIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdmVjdG9ycyBieSBrZXlzIGZyb20gdGhpcyBpbmRleFxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGF1dG9tYXRpY2FsbHkgaW5jbHVkZXMgYnVja2V0IGFuZCBpbmRleCBuYW1lc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBEZWxldGlvbiBvcHRpb25zIChidWNrZXQgYW5kIGluZGV4IG5hbWVzIGF1dG9tYXRpY2FsbHkgc2V0KVxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBpbmRleCA9IGNsaWVudC5idWNrZXQoJ2VtYmVkZGluZ3MtcHJvZCcpLmluZGV4KCdkb2N1bWVudHMtb3BlbmFpJylcbiAgICAgKiBhd2FpdCBpbmRleC5kZWxldGVWZWN0b3JzKHtcbiAgICAgKiAgIGtleXM6IFsnZG9jLTEnLCAnZG9jLTInLCAnZG9jLTMnXVxuICAgICAqIH0pXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZGVsZXRlVmVjdG9ycyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgZGVsZXRlVmVjdG9yczogeyBnZXQ6ICgpID0+IHN1cGVyLmRlbGV0ZVZlY3RvcnMgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIuZGVsZXRlVmVjdG9ycy5jYWxsKHRoaXMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgdmVjdG9yQnVja2V0TmFtZTogdGhpcy52ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWU6IHRoaXMuaW5kZXhOYW1lIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RvcmFnZVZlY3RvcnNDbGllbnQuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsIlZlY3RvckluZGV4QXBpIiwiVmVjdG9yRGF0YUFwaSIsIlZlY3RvckJ1Y2tldEFwaSIsIlN0b3JhZ2VWZWN0b3JzQ2xpZW50IiwiY29uc3RydWN0b3IiLCJ1cmwiLCJvcHRpb25zIiwiaGVhZGVycyIsImZldGNoIiwiZnJvbSIsInZlY3RvckJ1Y2tldE5hbWUiLCJWZWN0b3JCdWNrZXRTY29wZSIsImNyZWF0ZUluZGV4IiwiX3N1cGVyIiwiT2JqZWN0IiwiY3JlYXRlIiwiZ2V0IiwiY2FsbCIsImFzc2lnbiIsImxpc3RJbmRleGVzIiwiYXJndW1lbnRzIiwiZ2V0SW5kZXgiLCJpbmRleE5hbWUiLCJkZWxldGVJbmRleCIsImluZGV4IiwiVmVjdG9ySW5kZXhTY29wZSIsInB1dFZlY3RvcnMiLCJnZXRWZWN0b3JzIiwibGlzdFZlY3RvcnMiLCJxdWVyeVZlY3RvcnMiLCJkZWxldGVWZWN0b3JzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/StorageVectorsClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/VectorBucketApi.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/vectors/VectorBucketApi.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ VectorBucketApi)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/constants.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/errors.js\");\n/* harmony import */ var _fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fetch */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/fetch.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/helpers.js\");\n\n\n\n\n\n/**\n * API class for managing Vector Buckets\n * Provides methods for creating, reading, listing, and deleting vector buckets\n */ class VectorBucketApi {\n    /**\n     * Creates a new VectorBucketApi instance\n     * @param url - The base URL for the storage vectors API\n     * @param headers - HTTP headers to include in requests\n     * @param fetch - Optional custom fetch implementation\n     */ constructor(url, headers = {}, fetch){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = Object.assign(Object.assign({}, _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HEADERS), headers);\n        this.fetch = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n    }\n    /**\n     * Enable throwing errors instead of returning them in the response\n     * When enabled, failed operations will throw instead of returning { data: null, error }\n     *\n     * @returns This instance for method chaining\n     * @example\n     * ```typescript\n     * const client = new VectorBucketApi(url, headers)\n     * client.throwOnError()\n     * const { data } = await client.createBucket('my-bucket') // throws on error\n     * ```\n     */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n     * Creates a new vector bucket\n     * Vector buckets are containers for vector indexes and their data\n     *\n     * @param vectorBucketName - Unique name for the vector bucket\n     * @returns Promise with empty response on success or error\n     *\n     * @throws {StorageVectorsApiError} With code:\n     * - `S3VectorConflictException` if bucket already exists (HTTP 409)\n     * - `S3VectorMaxBucketsExceeded` if quota exceeded (HTTP 400)\n     * - `InternalError` for server errors (HTTP 500)\n     *\n     * @example\n     * ```typescript\n     * const { data, error } = await client.createBucket('embeddings-prod')\n     * if (error) {\n     *   console.error('Failed to create bucket:', error.message)\n     * }\n     * ```\n     */ createBucket(vectorBucketName) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/CreateVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data: data || {},\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageVectorsError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Retrieves metadata for a specific vector bucket\n     * Returns bucket configuration including encryption settings and creation time\n     *\n     * @param vectorBucketName - Name of the vector bucket to retrieve\n     * @returns Promise with bucket metadata or error\n     *\n     * @throws {StorageVectorsApiError} With code:\n     * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)\n     * - `InternalError` for server errors (HTTP 500)\n     *\n     * @example\n     * ```typescript\n     * const { data, error } = await client.getBucket('embeddings-prod')\n     * if (data) {\n     *   console.log('Bucket created at:', new Date(data.vectorBucket.creationTime! * 1000))\n     * }\n     * ```\n     */ getBucket(vectorBucketName) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/GetVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageVectorsError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Lists vector buckets with optional filtering and pagination\n     * Supports prefix-based filtering and paginated results\n     *\n     * @param options - Listing options\n     * @param options.prefix - Filter buckets by name prefix\n     * @param options.maxResults - Maximum results per page (default: 100)\n     * @param options.nextToken - Pagination token from previous response\n     * @returns Promise with list of buckets and pagination token\n     *\n     * @throws {StorageVectorsApiError} With code:\n     * - `InternalError` for server errors (HTTP 500)\n     *\n     * @example\n     * ```typescript\n     * // List all buckets with prefix 'prod-'\n     * const { data, error } = await client.listBuckets({ prefix: 'prod-' })\n     * if (data) {\n     *   console.log('Found buckets:', data.buckets.length)\n     *   // Fetch next page if available\n     *   if (data.nextToken) {\n     *     const next = await client.listBuckets({ nextToken: data.nextToken })\n     *   }\n     * }\n     * ```\n     */ listBuckets() {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, arguments, void 0, function*(options = {}) {\n            try {\n                const data = yield (0,_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/ListVectorBuckets`, options, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageVectorsError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Deletes a vector bucket\n     * Bucket must be empty before deletion (all indexes must be removed first)\n     *\n     * @param vectorBucketName - Name of the vector bucket to delete\n     * @returns Promise with empty response on success or error\n     *\n     * @throws {StorageVectorsApiError} With code:\n     * - `S3VectorBucketNotEmpty` if bucket contains indexes (HTTP 400)\n     * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)\n     * - `InternalError` for server errors (HTTP 500)\n     *\n     * @example\n     * ```typescript\n     * // Delete all indexes first, then delete bucket\n     * const { error } = await client.deleteBucket('old-bucket')\n     * if (error?.statusCode === 'S3VectorBucketNotEmpty') {\n     *   console.error('Must delete all indexes first')\n     * }\n     * ```\n     */ deleteBucket(vectorBucketName) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/DeleteVectorBucket`, {\n                    vectorBucketName\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data: data || {},\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageVectorsError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n} //# sourceMappingURL=VectorBucketApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL3ZlY3RvcnMvVmVjdG9yQnVja2V0QXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFrQztBQUNZO0FBQ0c7QUFDbEI7QUFDVTtBQUN6Qzs7O0NBR0MsR0FDYyxNQUFNSztJQUNqQjs7Ozs7S0FLQyxHQUNEQyxZQUFZQyxHQUFHLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUVDLEtBQUssQ0FBRTtRQUNsQyxJQUFJLENBQUNDLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ0gsR0FBRyxHQUFHQSxJQUFJSSxPQUFPLENBQUMsT0FBTztRQUM5QixJQUFJLENBQUNILE9BQU8sR0FBR0ksT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHWix1REFBZUEsR0FBR087UUFDakUsSUFBSSxDQUFDQyxLQUFLLEdBQUdMLHNEQUFZQSxDQUFDSztJQUM5QjtJQUNBOzs7Ozs7Ozs7OztLQVdDLEdBQ0RLLGVBQWU7UUFDWCxJQUFJLENBQUNKLGtCQUFrQixHQUFHO1FBQzFCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FtQkMsR0FDREssYUFBYUMsZ0JBQWdCLEVBQUU7UUFDM0IsT0FBT2hCLGdEQUFTQSxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUk7Z0JBQ0EsTUFBTWlCLE9BQU8sTUFBTWQsNENBQUlBLENBQUMsSUFBSSxDQUFDTSxLQUFLLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQ0YsR0FBRyxDQUFDLG1CQUFtQixDQUFDLEVBQUU7b0JBQUVTO2dCQUFpQixHQUFHO29CQUFFUixTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFBQztnQkFDcEgsT0FBTztvQkFBRVMsTUFBTUEsUUFBUSxDQUFDO29CQUFHQyxPQUFPO2dCQUFLO1lBQzNDLEVBQ0EsT0FBT0EsT0FBTztnQkFDVixJQUFJLElBQUksQ0FBQ1Isa0JBQWtCLEVBQUU7b0JBQ3pCLE1BQU1RO2dCQUNWO2dCQUNBLElBQUloQiw4REFBcUJBLENBQUNnQixRQUFRO29CQUM5QixPQUFPO3dCQUFFRCxNQUFNO3dCQUFNQztvQkFBTTtnQkFDL0I7Z0JBQ0EsTUFBTUE7WUFDVjtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBa0JDLEdBQ0RDLFVBQVVILGdCQUFnQixFQUFFO1FBQ3hCLE9BQU9oQixnREFBU0EsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJO2dCQUNBLE1BQU1pQixPQUFPLE1BQU1kLDRDQUFJQSxDQUFDLElBQUksQ0FBQ00sS0FBSyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUNGLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFO29CQUFFUztnQkFBaUIsR0FBRztvQkFBRVIsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQUM7Z0JBQ2pILE9BQU87b0JBQUVTO29CQUFNQyxPQUFPO2dCQUFLO1lBQy9CLEVBQ0EsT0FBT0EsT0FBTztnQkFDVixJQUFJLElBQUksQ0FBQ1Isa0JBQWtCLEVBQUU7b0JBQ3pCLE1BQU1RO2dCQUNWO2dCQUNBLElBQUloQiw4REFBcUJBLENBQUNnQixRQUFRO29CQUM5QixPQUFPO3dCQUFFRCxNQUFNO3dCQUFNQztvQkFBTTtnQkFDL0I7Z0JBQ0EsTUFBTUE7WUFDVjtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQXlCQyxHQUNERSxjQUFjO1FBQ1YsT0FBT3BCLGdEQUFTQSxDQUFDLElBQUksRUFBRXFCLFdBQVcsS0FBSyxHQUFHLFVBQVdDLFVBQVUsQ0FBQyxDQUFDO1lBQzdELElBQUk7Z0JBQ0EsTUFBTUwsT0FBTyxNQUFNZCw0Q0FBSUEsQ0FBQyxJQUFJLENBQUNNLEtBQUssRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMsa0JBQWtCLENBQUMsRUFBRWUsU0FBUztvQkFDMUVkLFNBQVMsSUFBSSxDQUFDQSxPQUFPO2dCQUN6QjtnQkFDQSxPQUFPO29CQUFFUztvQkFBTUMsT0FBTztnQkFBSztZQUMvQixFQUNBLE9BQU9BLE9BQU87Z0JBQ1YsSUFBSSxJQUFJLENBQUNSLGtCQUFrQixFQUFFO29CQUN6QixNQUFNUTtnQkFDVjtnQkFDQSxJQUFJaEIsOERBQXFCQSxDQUFDZ0IsUUFBUTtvQkFDOUIsT0FBTzt3QkFBRUQsTUFBTTt3QkFBTUM7b0JBQU07Z0JBQy9CO2dCQUNBLE1BQU1BO1lBQ1Y7UUFDSjtJQUNKO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBb0JDLEdBQ0RLLGFBQWFQLGdCQUFnQixFQUFFO1FBQzNCLE9BQU9oQixnREFBU0EsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJO2dCQUNBLE1BQU1pQixPQUFPLE1BQU1kLDRDQUFJQSxDQUFDLElBQUksQ0FBQ00sS0FBSyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUNGLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxFQUFFO29CQUFFUztnQkFBaUIsR0FBRztvQkFBRVIsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQUM7Z0JBQ3BILE9BQU87b0JBQUVTLE1BQU1BLFFBQVEsQ0FBQztvQkFBR0MsT0FBTztnQkFBSztZQUMzQyxFQUNBLE9BQU9BLE9BQU87Z0JBQ1YsSUFBSSxJQUFJLENBQUNSLGtCQUFrQixFQUFFO29CQUN6QixNQUFNUTtnQkFDVjtnQkFDQSxJQUFJaEIsOERBQXFCQSxDQUFDZ0IsUUFBUTtvQkFDOUIsT0FBTzt3QkFBRUQsTUFBTTt3QkFBTUM7b0JBQU07Z0JBQy9CO2dCQUNBLE1BQU1BO1lBQ1Y7UUFDSjtJQUNKO0FBQ0osRUFDQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvdmVjdG9ycy9WZWN0b3JCdWNrZXRBcGkuanM/NGMyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2F3YWl0ZXIgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IERFRkFVTFRfSEVBREVSUyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGlzU3RvcmFnZVZlY3RvcnNFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7IHBvc3QgfSBmcm9tICcuL2ZldGNoJztcbmltcG9ydCB7IHJlc29sdmVGZXRjaCB9IGZyb20gJy4vaGVscGVycyc7XG4vKipcbiAqIEFQSSBjbGFzcyBmb3IgbWFuYWdpbmcgVmVjdG9yIEJ1Y2tldHNcbiAqIFByb3ZpZGVzIG1ldGhvZHMgZm9yIGNyZWF0aW5nLCByZWFkaW5nLCBsaXN0aW5nLCBhbmQgZGVsZXRpbmcgdmVjdG9yIGJ1Y2tldHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVjdG9yQnVja2V0QXBpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFZlY3RvckJ1Y2tldEFwaSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB1cmwgLSBUaGUgYmFzZSBVUkwgZm9yIHRoZSBzdG9yYWdlIHZlY3RvcnMgQVBJXG4gICAgICogQHBhcmFtIGhlYWRlcnMgLSBIVFRQIGhlYWRlcnMgdG8gaW5jbHVkZSBpbiByZXF1ZXN0c1xuICAgICAqIEBwYXJhbSBmZXRjaCAtIE9wdGlvbmFsIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCkge1xuICAgICAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVybCA9IHVybC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfSEVBREVSUyksIGhlYWRlcnMpO1xuICAgICAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRocm93aW5nIGVycm9ycyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVtIGluIHRoZSByZXNwb25zZVxuICAgICAqIFdoZW4gZW5hYmxlZCwgZmFpbGVkIG9wZXJhdGlvbnMgd2lsbCB0aHJvdyBpbnN0ZWFkIG9mIHJldHVybmluZyB7IGRhdGE6IG51bGwsIGVycm9yIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoaXMgaW5zdGFuY2UgZm9yIG1ldGhvZCBjaGFpbmluZ1xuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGNsaWVudCA9IG5ldyBWZWN0b3JCdWNrZXRBcGkodXJsLCBoZWFkZXJzKVxuICAgICAqIGNsaWVudC50aHJvd09uRXJyb3IoKVxuICAgICAqIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgY2xpZW50LmNyZWF0ZUJ1Y2tldCgnbXktYnVja2V0JykgLy8gdGhyb3dzIG9uIGVycm9yXG4gICAgICogYGBgXG4gICAgICovXG4gICAgdGhyb3dPbkVycm9yKCkge1xuICAgICAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHZlY3RvciBidWNrZXRcbiAgICAgKiBWZWN0b3IgYnVja2V0cyBhcmUgY29udGFpbmVycyBmb3IgdmVjdG9yIGluZGV4ZXMgYW5kIHRoZWlyIGRhdGFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2ZWN0b3JCdWNrZXROYW1lIC0gVW5pcXVlIG5hbWUgZm9yIHRoZSB2ZWN0b3IgYnVja2V0XG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3JcbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge1N0b3JhZ2VWZWN0b3JzQXBpRXJyb3J9IFdpdGggY29kZTpcbiAgICAgKiAtIGBTM1ZlY3RvckNvbmZsaWN0RXhjZXB0aW9uYCBpZiBidWNrZXQgYWxyZWFkeSBleGlzdHMgKEhUVFAgNDA5KVxuICAgICAqIC0gYFMzVmVjdG9yTWF4QnVja2V0c0V4Y2VlZGVkYCBpZiBxdW90YSBleGNlZWRlZCAoSFRUUCA0MDApXG4gICAgICogLSBgSW50ZXJuYWxFcnJvcmAgZm9yIHNlcnZlciBlcnJvcnMgKEhUVFAgNTAwKVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgY2xpZW50LmNyZWF0ZUJ1Y2tldCgnZW1iZWRkaW5ncy1wcm9kJylcbiAgICAgKiBpZiAoZXJyb3IpIHtcbiAgICAgKiAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjcmVhdGUgYnVja2V0OicsIGVycm9yLm1lc3NhZ2UpXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNyZWF0ZUJ1Y2tldCh2ZWN0b3JCdWNrZXROYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9DcmVhdGVWZWN0b3JCdWNrZXRgLCB7IHZlY3RvckJ1Y2tldE5hbWUgfSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZGF0YSB8fCB7fSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgdmVjdG9yIGJ1Y2tldFxuICAgICAqIFJldHVybnMgYnVja2V0IGNvbmZpZ3VyYXRpb24gaW5jbHVkaW5nIGVuY3J5cHRpb24gc2V0dGluZ3MgYW5kIGNyZWF0aW9uIHRpbWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2ZWN0b3JCdWNrZXROYW1lIC0gTmFtZSBvZiB0aGUgdmVjdG9yIGJ1Y2tldCB0byByZXRyaWV2ZVxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBidWNrZXQgbWV0YWRhdGEgb3IgZXJyb3JcbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge1N0b3JhZ2VWZWN0b3JzQXBpRXJyb3J9IFdpdGggY29kZTpcbiAgICAgKiAtIGBTM1ZlY3Rvck5vdEZvdW5kRXhjZXB0aW9uYCBpZiBidWNrZXQgZG9lc24ndCBleGlzdCAoSFRUUCA0MDQpXG4gICAgICogLSBgSW50ZXJuYWxFcnJvcmAgZm9yIHNlcnZlciBlcnJvcnMgKEhUVFAgNTAwKVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgY2xpZW50LmdldEJ1Y2tldCgnZW1iZWRkaW5ncy1wcm9kJylcbiAgICAgKiBpZiAoZGF0YSkge1xuICAgICAqICAgY29uc29sZS5sb2coJ0J1Y2tldCBjcmVhdGVkIGF0OicsIG5ldyBEYXRlKGRhdGEudmVjdG9yQnVja2V0LmNyZWF0aW9uVGltZSEgKiAxMDAwKSlcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0QnVja2V0KHZlY3RvckJ1Y2tldE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L0dldFZlY3RvckJ1Y2tldGAsIHsgdmVjdG9yQnVja2V0TmFtZSB9LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzIHZlY3RvciBidWNrZXRzIHdpdGggb3B0aW9uYWwgZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uXG4gICAgICogU3VwcG9ydHMgcHJlZml4LWJhc2VkIGZpbHRlcmluZyBhbmQgcGFnaW5hdGVkIHJlc3VsdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gTGlzdGluZyBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMucHJlZml4IC0gRmlsdGVyIGJ1Y2tldHMgYnkgbmFtZSBwcmVmaXhcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tYXhSZXN1bHRzIC0gTWF4aW11bSByZXN1bHRzIHBlciBwYWdlIChkZWZhdWx0OiAxMDApXG4gICAgICogQHBhcmFtIG9wdGlvbnMubmV4dFRva2VuIC0gUGFnaW5hdGlvbiB0b2tlbiBmcm9tIHByZXZpb3VzIHJlc3BvbnNlXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGxpc3Qgb2YgYnVja2V0cyBhbmQgcGFnaW5hdGlvbiB0b2tlblxuICAgICAqXG4gICAgICogQHRocm93cyB7U3RvcmFnZVZlY3RvcnNBcGlFcnJvcn0gV2l0aCBjb2RlOlxuICAgICAqIC0gYEludGVybmFsRXJyb3JgIGZvciBzZXJ2ZXIgZXJyb3JzIChIVFRQIDUwMClcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIExpc3QgYWxsIGJ1Y2tldHMgd2l0aCBwcmVmaXggJ3Byb2QtJ1xuICAgICAqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudC5saXN0QnVja2V0cyh7IHByZWZpeDogJ3Byb2QtJyB9KVxuICAgICAqIGlmIChkYXRhKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnRm91bmQgYnVja2V0czonLCBkYXRhLmJ1Y2tldHMubGVuZ3RoKVxuICAgICAqICAgLy8gRmV0Y2ggbmV4dCBwYWdlIGlmIGF2YWlsYWJsZVxuICAgICAqICAgaWYgKGRhdGEubmV4dFRva2VuKSB7XG4gICAgICogICAgIGNvbnN0IG5leHQgPSBhd2FpdCBjbGllbnQubGlzdEJ1Y2tldHMoeyBuZXh0VG9rZW46IGRhdGEubmV4dFRva2VuIH0pXG4gICAgICogICB9XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGxpc3RCdWNrZXRzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiogKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vTGlzdFZlY3RvckJ1Y2tldHNgLCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSB2ZWN0b3IgYnVja2V0XG4gICAgICogQnVja2V0IG11c3QgYmUgZW1wdHkgYmVmb3JlIGRlbGV0aW9uIChhbGwgaW5kZXhlcyBtdXN0IGJlIHJlbW92ZWQgZmlyc3QpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmVjdG9yQnVja2V0TmFtZSAtIE5hbWUgb2YgdGhlIHZlY3RvciBidWNrZXQgdG8gZGVsZXRlXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGVtcHR5IHJlc3BvbnNlIG9uIHN1Y2Nlc3Mgb3IgZXJyb3JcbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge1N0b3JhZ2VWZWN0b3JzQXBpRXJyb3J9IFdpdGggY29kZTpcbiAgICAgKiAtIGBTM1ZlY3RvckJ1Y2tldE5vdEVtcHR5YCBpZiBidWNrZXQgY29udGFpbnMgaW5kZXhlcyAoSFRUUCA0MDApXG4gICAgICogLSBgUzNWZWN0b3JOb3RGb3VuZEV4Y2VwdGlvbmAgaWYgYnVja2V0IGRvZXNuJ3QgZXhpc3QgKEhUVFAgNDA0KVxuICAgICAqIC0gYEludGVybmFsRXJyb3JgIGZvciBzZXJ2ZXIgZXJyb3JzIChIVFRQIDUwMClcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIERlbGV0ZSBhbGwgaW5kZXhlcyBmaXJzdCwgdGhlbiBkZWxldGUgYnVja2V0XG4gICAgICogY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgY2xpZW50LmRlbGV0ZUJ1Y2tldCgnb2xkLWJ1Y2tldCcpXG4gICAgICogaWYgKGVycm9yPy5zdGF0dXNDb2RlID09PSAnUzNWZWN0b3JCdWNrZXROb3RFbXB0eScpIHtcbiAgICAgKiAgIGNvbnNvbGUuZXJyb3IoJ011c3QgZGVsZXRlIGFsbCBpbmRleGVzIGZpcnN0JylcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZGVsZXRlQnVja2V0KHZlY3RvckJ1Y2tldE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L0RlbGV0ZVZlY3RvckJ1Y2tldGAsIHsgdmVjdG9yQnVja2V0TmFtZSB9LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBkYXRhIHx8IHt9LCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmVjdG9yQnVja2V0QXBpLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJERUZBVUxUX0hFQURFUlMiLCJpc1N0b3JhZ2VWZWN0b3JzRXJyb3IiLCJwb3N0IiwicmVzb2x2ZUZldGNoIiwiVmVjdG9yQnVja2V0QXBpIiwiY29uc3RydWN0b3IiLCJ1cmwiLCJoZWFkZXJzIiwiZmV0Y2giLCJzaG91bGRUaHJvd09uRXJyb3IiLCJyZXBsYWNlIiwiT2JqZWN0IiwiYXNzaWduIiwidGhyb3dPbkVycm9yIiwiY3JlYXRlQnVja2V0IiwidmVjdG9yQnVja2V0TmFtZSIsImRhdGEiLCJlcnJvciIsImdldEJ1Y2tldCIsImxpc3RCdWNrZXRzIiwiYXJndW1lbnRzIiwib3B0aW9ucyIsImRlbGV0ZUJ1Y2tldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/VectorBucketApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/VectorDataApi.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/vectors/VectorDataApi.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ VectorDataApi)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/constants.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/errors.js\");\n/* harmony import */ var _fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fetch */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/fetch.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/helpers.js\");\n\n\n\n\n\n/**\n * API class for managing Vector Data within Vector Indexes\n * Provides methods for inserting, querying, listing, and deleting vector embeddings\n */ class VectorDataApi {\n    constructor(url, headers = {}, fetch){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = Object.assign(Object.assign({}, _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HEADERS), headers);\n        this.fetch = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n    }\n    /**\n     * Enable throwing errors instead of returning them in the response\n     * When enabled, failed operations will throw instead of returning { data: null, error }\n     *\n     * @returns This instance for method chaining\n     * @example\n     * ```typescript\n     * const client = new VectorDataApi(url, headers)\n     * client.throwOnError()\n     * const { data } = await client.putVectors(options) // throws on error\n     * ```\n     */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n     * Inserts or updates vectors in batch (upsert operation)\n     * Accepts 1-500 vectors per request. Larger batches should be split\n     *\n     * @param options - Vector insertion options\n     * @param options.vectorBucketName - Name of the parent vector bucket\n     * @param options.indexName - Name of the target index\n     * @param options.vectors - Array of vectors to insert/update (1-500 items)\n     * @returns Promise with empty response on success or error\n     *\n     * @throws {StorageVectorsApiError} With code:\n     * - `S3VectorConflictException` if duplicate key conflict occurs (HTTP 409)\n     * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\n     * - `InternalError` for server errors (HTTP 500)\n     *\n     * @example\n     * ```typescript\n     * const { data, error } = await client.putVectors({\n     *   vectorBucketName: 'embeddings-prod',\n     *   indexName: 'documents-openai-small',\n     *   vectors: [\n     *     {\n     *       key: 'doc-1',\n     *       data: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions\n     *       metadata: { title: 'Introduction', page: 1 }\n     *     },\n     *     {\n     *       key: 'doc-2',\n     *       data: { float32: [0.4, 0.5, 0.6, ...] },\n     *       metadata: { title: 'Conclusion', page: 42 }\n     *     }\n     *   ]\n     * })\n     * ```\n     */ putVectors(options) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                // Validate batch size\n                if (options.vectors.length < 1 || options.vectors.length > 500) {\n                    throw new Error(\"Vector batch size must be between 1 and 500 items\");\n                }\n                const data = yield (0,_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/PutVectors`, options, {\n                    headers: this.headers\n                });\n                return {\n                    data: data || {},\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageVectorsError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Retrieves vectors by their keys in batch\n     * Optionally includes vector data and/or metadata in response\n     * Additional permissions required when returning data or metadata\n     *\n     * @param options - Vector retrieval options\n     * @param options.vectorBucketName - Name of the parent vector bucket\n     * @param options.indexName - Name of the index\n     * @param options.keys - Array of vector keys to retrieve\n     * @param options.returnData - Whether to include vector embeddings (requires permission)\n     * @param options.returnMetadata - Whether to include metadata (requires permission)\n     * @returns Promise with array of vectors or error\n     *\n     * @throws {StorageVectorsApiError} With code:\n     * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\n     * - `InternalError` for server errors (HTTP 500)\n     *\n     * @example\n     * ```typescript\n     * const { data, error } = await client.getVectors({\n     *   vectorBucketName: 'embeddings-prod',\n     *   indexName: 'documents-openai-small',\n     *   keys: ['doc-1', 'doc-2', 'doc-3'],\n     *   returnData: false,     // Don't return embeddings\n     *   returnMetadata: true   // Return metadata only\n     * })\n     * if (data) {\n     *   data.vectors.forEach(v => console.log(v.key, v.metadata))\n     * }\n     * ```\n     */ getVectors(options) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/GetVectors`, options, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageVectorsError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Lists/scans vectors in an index with pagination\n     * Supports parallel scanning via segment configuration for high-throughput scenarios\n     * Additional permissions required when returning data or metadata\n     *\n     * @param options - Vector listing options\n     * @param options.vectorBucketName - Name of the parent vector bucket\n     * @param options.indexName - Name of the index\n     * @param options.maxResults - Maximum results per page (default: 500, max: 1000)\n     * @param options.nextToken - Pagination token from previous response\n     * @param options.returnData - Whether to include vector embeddings (requires permission)\n     * @param options.returnMetadata - Whether to include metadata (requires permission)\n     * @param options.segmentCount - Total parallel segments (1-16) for distributed scanning\n     * @param options.segmentIndex - Zero-based segment index (0 to segmentCount-1)\n     * @returns Promise with array of vectors, pagination token, or error\n     *\n     * @throws {StorageVectorsApiError} With code:\n     * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\n     * - `InternalError` for server errors (HTTP 500)\n     *\n     * @example\n     * ```typescript\n     * // Simple pagination\n     * let nextToken: string | undefined\n     * do {\n     *   const { data, error } = await client.listVectors({\n     *     vectorBucketName: 'embeddings-prod',\n     *     indexName: 'documents-openai-small',\n     *     maxResults: 500,\n     *     nextToken,\n     *     returnMetadata: true\n     *   })\n     *   if (error) break\n     *   console.log('Batch:', data.vectors.length)\n     *   nextToken = data.nextToken\n     * } while (nextToken)\n     *\n     * // Parallel scanning (4 concurrent workers)\n     * const workers = [0, 1, 2, 3].map(async (segmentIndex) => {\n     *   const { data } = await client.listVectors({\n     *     vectorBucketName: 'embeddings-prod',\n     *     indexName: 'documents-openai-small',\n     *     segmentCount: 4,\n     *     segmentIndex,\n     *     returnMetadata: true\n     *   })\n     *   return data?.vectors || []\n     * })\n     * const results = await Promise.all(workers)\n     * ```\n     */ listVectors(options) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                // Validate segment configuration\n                if (options.segmentCount !== undefined) {\n                    if (options.segmentCount < 1 || options.segmentCount > 16) {\n                        throw new Error(\"segmentCount must be between 1 and 16\");\n                    }\n                    if (options.segmentIndex !== undefined) {\n                        if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) {\n                            throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`);\n                        }\n                    }\n                }\n                const data = yield (0,_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/ListVectors`, options, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageVectorsError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Queries for similar vectors using approximate nearest neighbor (ANN) search\n     * Returns top-K most similar vectors based on the configured distance metric\n     * Supports optional metadata filtering (requires GetVectors permission)\n     *\n     * @param options - Query options\n     * @param options.vectorBucketName - Name of the parent vector bucket\n     * @param options.indexName - Name of the index\n     * @param options.queryVector - Query embedding to find similar vectors\n     * @param options.topK - Number of nearest neighbors to return (default: 10)\n     * @param options.filter - Optional JSON filter for metadata (requires GetVectors permission)\n     * @param options.returnDistance - Whether to include similarity distances\n     * @param options.returnMetadata - Whether to include metadata (requires GetVectors permission)\n     * @returns Promise with array of similar vectors ordered by distance\n     *\n     * @throws {StorageVectorsApiError} With code:\n     * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\n     * - `InternalError` for server errors (HTTP 500)\n     *\n     * @example\n     * ```typescript\n     * // Semantic search with filtering\n     * const { data, error } = await client.queryVectors({\n     *   vectorBucketName: 'embeddings-prod',\n     *   indexName: 'documents-openai-small',\n     *   queryVector: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions\n     *   topK: 5,\n     *   filter: {\n     *     category: 'technical',\n     *     published: true\n     *   },\n     *   returnDistance: true,\n     *   returnMetadata: true\n     * })\n     * if (data) {\n     *   data.matches.forEach(match => {\n     *     console.log(`${match.key}: distance=${match.distance}`)\n     *     console.log('Metadata:', match.metadata)\n     *   })\n     * }\n     * ```\n     */ queryVectors(options) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/QueryVectors`, options, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageVectorsError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Deletes vectors by their keys in batch\n     * Accepts 1-500 keys per request\n     *\n     * @param options - Vector deletion options\n     * @param options.vectorBucketName - Name of the parent vector bucket\n     * @param options.indexName - Name of the index\n     * @param options.keys - Array of vector keys to delete (1-500 items)\n     * @returns Promise with empty response on success or error\n     *\n     * @throws {StorageVectorsApiError} With code:\n     * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\n     * - `InternalError` for server errors (HTTP 500)\n     *\n     * @example\n     * ```typescript\n     * const { error } = await client.deleteVectors({\n     *   vectorBucketName: 'embeddings-prod',\n     *   indexName: 'documents-openai-small',\n     *   keys: ['doc-1', 'doc-2', 'doc-3']\n     * })\n     * if (!error) {\n     *   console.log('Vectors deleted successfully')\n     * }\n     * ```\n     */ deleteVectors(options) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                // Validate batch size\n                if (options.keys.length < 1 || options.keys.length > 500) {\n                    throw new Error(\"Keys batch size must be between 1 and 500 items\");\n                }\n                const data = yield (0,_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/DeleteVectors`, options, {\n                    headers: this.headers\n                });\n                return {\n                    data: data || {},\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageVectorsError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n} //# sourceMappingURL=VectorDataApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL3ZlY3RvcnMvVmVjdG9yRGF0YUFwaS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBa0M7QUFDWTtBQUNHO0FBQ2xCO0FBQ1U7QUFDekM7OztDQUdDLEdBQ2MsTUFBTUs7SUFDakJDLFlBQVlDLEdBQUcsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRUMsS0FBSyxDQUFFO1FBQ2xDLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUc7UUFDMUIsSUFBSSxDQUFDSCxHQUFHLEdBQUdBLElBQUlJLE9BQU8sQ0FBQyxPQUFPO1FBQzlCLElBQUksQ0FBQ0gsT0FBTyxHQUFHSSxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdaLHVEQUFlQSxHQUFHTztRQUNqRSxJQUFJLENBQUNDLEtBQUssR0FBR0wsc0RBQVlBLENBQUNLO0lBQzlCO0lBQ0E7Ozs7Ozs7Ozs7O0tBV0MsR0FDREssZUFBZTtRQUNYLElBQUksQ0FBQ0osa0JBQWtCLEdBQUc7UUFDMUIsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQWtDQyxHQUNESyxXQUFXQyxPQUFPLEVBQUU7UUFDaEIsT0FBT2hCLGdEQUFTQSxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUk7Z0JBQ0Esc0JBQXNCO2dCQUN0QixJQUFJZ0IsUUFBUUMsT0FBTyxDQUFDQyxNQUFNLEdBQUcsS0FBS0YsUUFBUUMsT0FBTyxDQUFDQyxNQUFNLEdBQUcsS0FBSztvQkFDNUQsTUFBTSxJQUFJQyxNQUFNO2dCQUNwQjtnQkFDQSxNQUFNQyxPQUFPLE1BQU1qQiw0Q0FBSUEsQ0FBQyxJQUFJLENBQUNNLEtBQUssRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMsV0FBVyxDQUFDLEVBQUVTLFNBQVM7b0JBQ25FUixTQUFTLElB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Q0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL3ZlY3RvcnMvVmVjdG9yRGF0YUFwaS5qcz80ZWI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgREVGQVVMVF9IRUFERVJTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgaXNTdG9yYWdlVmVjdG9yc0Vycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHsgcG9zdCB9IGZyb20gJy4vZmV0Y2gnO1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi9oZWxwZXJzJztcbi8qKlxuICogQVBJIGNsYXNzIGZvciBtYW5hZ2luZyBWZWN0b3IgRGF0YSB3aXRoaW4gVmVjdG9yIEluZGV4ZXNcbiAqIFByb3ZpZGVzIG1ldGhvZHMgZm9yIGluc2VydGluZywgcXVlcnlpbmcsIGxpc3RpbmcsIGFuZCBkZWxldGluZyB2ZWN0b3IgZW1iZWRkaW5nc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWN0b3JEYXRhQXBpIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gpIHtcbiAgICAgICAgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0aHJvd2luZyBlcnJvcnMgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlbSBpbiB0aGUgcmVzcG9uc2VcbiAgICAgKiBXaGVuIGVuYWJsZWQsIGZhaWxlZCBvcGVyYXRpb25zIHdpbGwgdGhyb3cgaW5zdGVhZCBvZiByZXR1cm5pbmcgeyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGlzIGluc3RhbmNlIGZvciBtZXRob2QgY2hhaW5pbmdcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBjbGllbnQgPSBuZXcgVmVjdG9yRGF0YUFwaSh1cmwsIGhlYWRlcnMpXG4gICAgICogY2xpZW50LnRocm93T25FcnJvcigpXG4gICAgICogY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBjbGllbnQucHV0VmVjdG9ycyhvcHRpb25zKSAvLyB0aHJvd3Mgb24gZXJyb3JcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB0aHJvd09uRXJyb3IoKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgb3IgdXBkYXRlcyB2ZWN0b3JzIGluIGJhdGNoICh1cHNlcnQgb3BlcmF0aW9uKVxuICAgICAqIEFjY2VwdHMgMS01MDAgdmVjdG9ycyBwZXIgcmVxdWVzdC4gTGFyZ2VyIGJhdGNoZXMgc2hvdWxkIGJlIHNwbGl0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFZlY3RvciBpbnNlcnRpb24gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnZlY3RvckJ1Y2tldE5hbWUgLSBOYW1lIG9mIHRoZSBwYXJlbnQgdmVjdG9yIGJ1Y2tldFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIHRhcmdldCBpbmRleFxuICAgICAqIEBwYXJhbSBvcHRpb25zLnZlY3RvcnMgLSBBcnJheSBvZiB2ZWN0b3JzIHRvIGluc2VydC91cGRhdGUgKDEtNTAwIGl0ZW1zKVxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtTdG9yYWdlVmVjdG9yc0FwaUVycm9yfSBXaXRoIGNvZGU6XG4gICAgICogLSBgUzNWZWN0b3JDb25mbGljdEV4Y2VwdGlvbmAgaWYgZHVwbGljYXRlIGtleSBjb25mbGljdCBvY2N1cnMgKEhUVFAgNDA5KVxuICAgICAqIC0gYFMzVmVjdG9yTm90Rm91bmRFeGNlcHRpb25gIGlmIGJ1Y2tldCBvciBpbmRleCBkb2Vzbid0IGV4aXN0IChIVFRQIDQwNClcbiAgICAgKiAtIGBJbnRlcm5hbEVycm9yYCBmb3Igc2VydmVyIGVycm9ycyAoSFRUUCA1MDApXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBjbGllbnQucHV0VmVjdG9ycyh7XG4gICAgICogICB2ZWN0b3JCdWNrZXROYW1lOiAnZW1iZWRkaW5ncy1wcm9kJyxcbiAgICAgKiAgIGluZGV4TmFtZTogJ2RvY3VtZW50cy1vcGVuYWktc21hbGwnLFxuICAgICAqICAgdmVjdG9yczogW1xuICAgICAqICAgICB7XG4gICAgICogICAgICAga2V5OiAnZG9jLTEnLFxuICAgICAqICAgICAgIGRhdGE6IHsgZmxvYXQzMjogWzAuMSwgMC4yLCAwLjMsIC4uLl0gfSwgLy8gMTUzNiBkaW1lbnNpb25zXG4gICAgICogICAgICAgbWV0YWRhdGE6IHsgdGl0bGU6ICdJbnRyb2R1Y3Rpb24nLCBwYWdlOiAxIH1cbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIGtleTogJ2RvYy0yJyxcbiAgICAgKiAgICAgICBkYXRhOiB7IGZsb2F0MzI6IFswLjQsIDAuNSwgMC42LCAuLi5dIH0sXG4gICAgICogICAgICAgbWV0YWRhdGE6IHsgdGl0bGU6ICdDb25jbHVzaW9uJywgcGFnZTogNDIgfVxuICAgICAqICAgICB9XG4gICAgICogICBdXG4gICAgICogfSlcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdXRWZWN0b3JzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgYmF0Y2ggc2l6ZVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnZlY3RvcnMubGVuZ3RoIDwgMSB8fCBvcHRpb25zLnZlY3RvcnMubGVuZ3RoID4gNTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVjdG9yIGJhdGNoIHNpemUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDUwMCBpdGVtcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vUHV0VmVjdG9yc2AsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGRhdGEgfHwge30sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHZlY3RvcnMgYnkgdGhlaXIga2V5cyBpbiBiYXRjaFxuICAgICAqIE9wdGlvbmFsbHkgaW5jbHVkZXMgdmVjdG9yIGRhdGEgYW5kL29yIG1ldGFkYXRhIGluIHJlc3BvbnNlXG4gICAgICogQWRkaXRpb25hbCBwZXJtaXNzaW9ucyByZXF1aXJlZCB3aGVuIHJldHVybmluZyBkYXRhIG9yIG1ldGFkYXRhXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFZlY3RvciByZXRyaWV2YWwgb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnZlY3RvckJ1Y2tldE5hbWUgLSBOYW1lIG9mIHRoZSBwYXJlbnQgdmVjdG9yIGJ1Y2tldFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4XG4gICAgICogQHBhcmFtIG9wdGlvbnMua2V5cyAtIEFycmF5IG9mIHZlY3RvciBrZXlzIHRvIHJldHJpZXZlXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmV0dXJuRGF0YSAtIFdoZXRoZXIgdG8gaW5jbHVkZSB2ZWN0b3IgZW1iZWRkaW5ncyAocmVxdWlyZXMgcGVybWlzc2lvbilcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZXR1cm5NZXRhZGF0YSAtIFdoZXRoZXIgdG8gaW5jbHVkZSBtZXRhZGF0YSAocmVxdWlyZXMgcGVybWlzc2lvbilcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggYXJyYXkgb2YgdmVjdG9ycyBvciBlcnJvclxuICAgICAqXG4gICAgICogQHRocm93cyB7U3RvcmFnZVZlY3RvcnNBcGlFcnJvcn0gV2l0aCBjb2RlOlxuICAgICAqIC0gYFMzVmVjdG9yTm90Rm91bmRFeGNlcHRpb25gIGlmIGJ1Y2tldCBvciBpbmRleCBkb2Vzbid0IGV4aXN0IChIVFRQIDQwNClcbiAgICAgKiAtIGBJbnRlcm5hbEVycm9yYCBmb3Igc2VydmVyIGVycm9ycyAoSFRUUCA1MDApXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBjbGllbnQuZ2V0VmVjdG9ycyh7XG4gICAgICogICB2ZWN0b3JCdWNrZXROYW1lOiAnZW1iZWRkaW5ncy1wcm9kJyxcbiAgICAgKiAgIGluZGV4TmFtZTogJ2RvY3VtZW50cy1vcGVuYWktc21hbGwnLFxuICAgICAqICAga2V5czogWydkb2MtMScsICdkb2MtMicsICdkb2MtMyddLFxuICAgICAqICAgcmV0dXJuRGF0YTogZmFsc2UsICAgICAvLyBEb24ndCByZXR1cm4gZW1iZWRkaW5nc1xuICAgICAqICAgcmV0dXJuTWV0YWRhdGE6IHRydWUgICAvLyBSZXR1cm4gbWV0YWRhdGEgb25seVxuICAgICAqIH0pXG4gICAgICogaWYgKGRhdGEpIHtcbiAgICAgKiAgIGRhdGEudmVjdG9ycy5mb3JFYWNoKHYgPT4gY29uc29sZS5sb2codi5rZXksIHYubWV0YWRhdGEpKVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXRWZWN0b3JzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L0dldFZlY3RvcnNgLCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RzL3NjYW5zIHZlY3RvcnMgaW4gYW4gaW5kZXggd2l0aCBwYWdpbmF0aW9uXG4gICAgICogU3VwcG9ydHMgcGFyYWxsZWwgc2Nhbm5pbmcgdmlhIHNlZ21lbnQgY29uZmlndXJhdGlvbiBmb3IgaGlnaC10aHJvdWdocHV0IHNjZW5hcmlvc1xuICAgICAqIEFkZGl0aW9uYWwgcGVybWlzc2lvbnMgcmVxdWlyZWQgd2hlbiByZXR1cm5pbmcgZGF0YSBvciBtZXRhZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBWZWN0b3IgbGlzdGluZyBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMudmVjdG9yQnVja2V0TmFtZSAtIE5hbWUgb2YgdGhlIHBhcmVudCB2ZWN0b3IgYnVja2V0XG4gICAgICogQHBhcmFtIG9wdGlvbnMuaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXhcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tYXhSZXN1bHRzIC0gTWF4aW11bSByZXN1bHRzIHBlciBwYWdlIChkZWZhdWx0OiA1MDAsIG1heDogMTAwMClcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uZXh0VG9rZW4gLSBQYWdpbmF0aW9uIHRva2VuIGZyb20gcHJldmlvdXMgcmVzcG9uc2VcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZXR1cm5EYXRhIC0gV2hldGhlciB0byBpbmNsdWRlIHZlY3RvciBlbWJlZGRpbmdzIChyZXF1aXJlcyBwZXJtaXNzaW9uKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJldHVybk1ldGFkYXRhIC0gV2hldGhlciB0byBpbmNsdWRlIG1ldGFkYXRhIChyZXF1aXJlcyBwZXJtaXNzaW9uKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNlZ21lbnRDb3VudCAtIFRvdGFsIHBhcmFsbGVsIHNlZ21lbnRzICgxLTE2KSBmb3IgZGlzdHJpYnV0ZWQgc2Nhbm5pbmdcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zZWdtZW50SW5kZXggLSBaZXJvLWJhc2VkIHNlZ21lbnQgaW5kZXggKDAgdG8gc2VnbWVudENvdW50LTEpXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGFycmF5IG9mIHZlY3RvcnMsIHBhZ2luYXRpb24gdG9rZW4sIG9yIGVycm9yXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtTdG9yYWdlVmVjdG9yc0FwaUVycm9yfSBXaXRoIGNvZGU6XG4gICAgICogLSBgUzNWZWN0b3JOb3RGb3VuZEV4Y2VwdGlvbmAgaWYgYnVja2V0IG9yIGluZGV4IGRvZXNuJ3QgZXhpc3QgKEhUVFAgNDA0KVxuICAgICAqIC0gYEludGVybmFsRXJyb3JgIGZvciBzZXJ2ZXIgZXJyb3JzIChIVFRQIDUwMClcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIFNpbXBsZSBwYWdpbmF0aW9uXG4gICAgICogbGV0IG5leHRUb2tlbjogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgICogZG8ge1xuICAgICAqICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgY2xpZW50Lmxpc3RWZWN0b3JzKHtcbiAgICAgKiAgICAgdmVjdG9yQnVja2V0TmFtZTogJ2VtYmVkZGluZ3MtcHJvZCcsXG4gICAgICogICAgIGluZGV4TmFtZTogJ2RvY3VtZW50cy1vcGVuYWktc21hbGwnLFxuICAgICAqICAgICBtYXhSZXN1bHRzOiA1MDAsXG4gICAgICogICAgIG5leHRUb2tlbixcbiAgICAgKiAgICAgcmV0dXJuTWV0YWRhdGE6IHRydWVcbiAgICAgKiAgIH0pXG4gICAgICogICBpZiAoZXJyb3IpIGJyZWFrXG4gICAgICogICBjb25zb2xlLmxvZygnQmF0Y2g6JywgZGF0YS52ZWN0b3JzLmxlbmd0aClcbiAgICAgKiAgIG5leHRUb2tlbiA9IGRhdGEubmV4dFRva2VuXG4gICAgICogfSB3aGlsZSAobmV4dFRva2VuKVxuICAgICAqXG4gICAgICogLy8gUGFyYWxsZWwgc2Nhbm5pbmcgKDQgY29uY3VycmVudCB3b3JrZXJzKVxuICAgICAqIGNvbnN0IHdvcmtlcnMgPSBbMCwgMSwgMiwgM10ubWFwKGFzeW5jIChzZWdtZW50SW5kZXgpID0+IHtcbiAgICAgKiAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgY2xpZW50Lmxpc3RWZWN0b3JzKHtcbiAgICAgKiAgICAgdmVjdG9yQnVja2V0TmFtZTogJ2VtYmVkZGluZ3MtcHJvZCcsXG4gICAgICogICAgIGluZGV4TmFtZTogJ2RvY3VtZW50cy1vcGVuYWktc21hbGwnLFxuICAgICAqICAgICBzZWdtZW50Q291bnQ6IDQsXG4gICAgICogICAgIHNlZ21lbnRJbmRleCxcbiAgICAgKiAgICAgcmV0dXJuTWV0YWRhdGE6IHRydWVcbiAgICAgKiAgIH0pXG4gICAgICogICByZXR1cm4gZGF0YT8udmVjdG9ycyB8fCBbXVxuICAgICAqIH0pXG4gICAgICogY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHdvcmtlcnMpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgbGlzdFZlY3RvcnMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSBzZWdtZW50IGNvbmZpZ3VyYXRpb25cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zZWdtZW50Q291bnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zZWdtZW50Q291bnQgPCAxIHx8IG9wdGlvbnMuc2VnbWVudENvdW50ID4gMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2VnbWVudENvdW50IG11c3QgYmUgYmV0d2VlbiAxIGFuZCAxNicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNlZ21lbnRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zZWdtZW50SW5kZXggPCAwIHx8IG9wdGlvbnMuc2VnbWVudEluZGV4ID49IG9wdGlvbnMuc2VnbWVudENvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzZWdtZW50SW5kZXggbXVzdCBiZSBiZXR3ZWVuIDAgYW5kICR7b3B0aW9ucy5zZWdtZW50Q291bnQgLSAxfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9MaXN0VmVjdG9yc2AsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcmllcyBmb3Igc2ltaWxhciB2ZWN0b3JzIHVzaW5nIGFwcHJveGltYXRlIG5lYXJlc3QgbmVpZ2hib3IgKEFOTikgc2VhcmNoXG4gICAgICogUmV0dXJucyB0b3AtSyBtb3N0IHNpbWlsYXIgdmVjdG9ycyBiYXNlZCBvbiB0aGUgY29uZmlndXJlZCBkaXN0YW5jZSBtZXRyaWNcbiAgICAgKiBTdXBwb3J0cyBvcHRpb25hbCBtZXRhZGF0YSBmaWx0ZXJpbmcgKHJlcXVpcmVzIEdldFZlY3RvcnMgcGVybWlzc2lvbilcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUXVlcnkgb3B0aW9uc1xuICAgICAqIEBwYXJhbSBvcHRpb25zLnZlY3RvckJ1Y2tldE5hbWUgLSBOYW1lIG9mIHRoZSBwYXJlbnQgdmVjdG9yIGJ1Y2tldFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4XG4gICAgICogQHBhcmFtIG9wdGlvbnMucXVlcnlWZWN0b3IgLSBRdWVyeSBlbWJlZGRpbmcgdG8gZmluZCBzaW1pbGFyIHZlY3RvcnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50b3BLIC0gTnVtYmVyIG9mIG5lYXJlc3QgbmVpZ2hib3JzIHRvIHJldHVybiAoZGVmYXVsdDogMTApXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZmlsdGVyIC0gT3B0aW9uYWwgSlNPTiBmaWx0ZXIgZm9yIG1ldGFkYXRhIChyZXF1aXJlcyBHZXRWZWN0b3JzIHBlcm1pc3Npb24pXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmV0dXJuRGlzdGFuY2UgLSBXaGV0aGVyIHRvIGluY2x1ZGUgc2ltaWxhcml0eSBkaXN0YW5jZXNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZXR1cm5NZXRhZGF0YSAtIFdoZXRoZXIgdG8gaW5jbHVkZSBtZXRhZGF0YSAocmVxdWlyZXMgR2V0VmVjdG9ycyBwZXJtaXNzaW9uKVxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBhcnJheSBvZiBzaW1pbGFyIHZlY3RvcnMgb3JkZXJlZCBieSBkaXN0YW5jZVxuICAgICAqXG4gICAgICogQHRocm93cyB7U3RvcmFnZVZlY3RvcnNBcGlFcnJvcn0gV2l0aCBjb2RlOlxuICAgICAqIC0gYFMzVmVjdG9yTm90Rm91bmRFeGNlcHRpb25gIGlmIGJ1Y2tldCBvciBpbmRleCBkb2Vzbid0IGV4aXN0IChIVFRQIDQwNClcbiAgICAgKiAtIGBJbnRlcm5hbEVycm9yYCBmb3Igc2VydmVyIGVycm9ycyAoSFRUUCA1MDApXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBTZW1hbnRpYyBzZWFyY2ggd2l0aCBmaWx0ZXJpbmdcbiAgICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBjbGllbnQucXVlcnlWZWN0b3JzKHtcbiAgICAgKiAgIHZlY3RvckJ1Y2tldE5hbWU6ICdlbWJlZGRpbmdzLXByb2QnLFxuICAgICAqICAgaW5kZXhOYW1lOiAnZG9jdW1lbnRzLW9wZW5haS1zbWFsbCcsXG4gICAgICogICBxdWVyeVZlY3RvcjogeyBmbG9hdDMyOiBbMC4xLCAwLjIsIDAuMywgLi4uXSB9LCAvLyAxNTM2IGRpbWVuc2lvbnNcbiAgICAgKiAgIHRvcEs6IDUsXG4gICAgICogICBmaWx0ZXI6IHtcbiAgICAgKiAgICAgY2F0ZWdvcnk6ICd0ZWNobmljYWwnLFxuICAgICAqICAgICBwdWJsaXNoZWQ6IHRydWVcbiAgICAgKiAgIH0sXG4gICAgICogICByZXR1cm5EaXN0YW5jZTogdHJ1ZSxcbiAgICAgKiAgIHJldHVybk1ldGFkYXRhOiB0cnVlXG4gICAgICogfSlcbiAgICAgKiBpZiAoZGF0YSkge1xuICAgICAqICAgZGF0YS5tYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhgJHttYXRjaC5rZXl9OiBkaXN0YW5jZT0ke21hdGNoLmRpc3RhbmNlfWApXG4gICAgICogICAgIGNvbnNvbGUubG9nKCdNZXRhZGF0YTonLCBtYXRjaC5tZXRhZGF0YSlcbiAgICAgKiAgIH0pXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHF1ZXJ5VmVjdG9ycyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9RdWVyeVZlY3RvcnNgLCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuaGVhZGVycyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlVmVjdG9yc0Vycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdmVjdG9ycyBieSB0aGVpciBrZXlzIGluIGJhdGNoXG4gICAgICogQWNjZXB0cyAxLTUwMCBrZXlzIHBlciByZXF1ZXN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFZlY3RvciBkZWxldGlvbiBvcHRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMudmVjdG9yQnVja2V0TmFtZSAtIE5hbWUgb2YgdGhlIHBhcmVudCB2ZWN0b3IgYnVja2V0XG4gICAgICogQHBhcmFtIG9wdGlvbnMuaW5kZXhOYW1lIC0gTmFtZSBvZiB0aGUgaW5kZXhcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5rZXlzIC0gQXJyYXkgb2YgdmVjdG9yIGtleXMgdG8gZGVsZXRlICgxLTUwMCBpdGVtcylcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggZW1wdHkgcmVzcG9uc2Ugb24gc3VjY2VzcyBvciBlcnJvclxuICAgICAqXG4gICAgICogQHRocm93cyB7U3RvcmFnZVZlY3RvcnNBcGlFcnJvcn0gV2l0aCBjb2RlOlxuICAgICAqIC0gYFMzVmVjdG9yTm90Rm91bmRFeGNlcHRpb25gIGlmIGJ1Y2tldCBvciBpbmRleCBkb2Vzbid0IGV4aXN0IChIVFRQIDQwNClcbiAgICAgKiAtIGBJbnRlcm5hbEVycm9yYCBmb3Igc2VydmVyIGVycm9ycyAoSFRUUCA1MDApXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBjbGllbnQuZGVsZXRlVmVjdG9ycyh7XG4gICAgICogICB2ZWN0b3JCdWNrZXROYW1lOiAnZW1iZWRkaW5ncy1wcm9kJyxcbiAgICAgKiAgIGluZGV4TmFtZTogJ2RvY3VtZW50cy1vcGVuYWktc21hbGwnLFxuICAgICAqICAga2V5czogWydkb2MtMScsICdkb2MtMicsICdkb2MtMyddXG4gICAgICogfSlcbiAgICAgKiBpZiAoIWVycm9yKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnVmVjdG9ycyBkZWxldGVkIHN1Y2Nlc3NmdWxseScpXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGRlbGV0ZVZlY3RvcnMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSBiYXRjaCBzaXplXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMua2V5cy5sZW5ndGggPCAxIHx8IG9wdGlvbnMua2V5cy5sZW5ndGggPiA1MDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdLZXlzIGJhdGNoIHNpemUgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDUwMCBpdGVtcycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vRGVsZXRlVmVjdG9yc2AsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IGRhdGEgfHwge30sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WZWN0b3JEYXRhQXBpLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJERUZBVUxUX0hFQURFUlMiLCJpc1N0b3JhZ2VWZWN0b3JzRXJyb3IiLCJwb3N0IiwicmVzb2x2ZUZldGNoIiwiVmVjdG9yRGF0YUFwaSIsImNvbnN0cnVjdG9yIiwidXJsIiwiaGVhZGVycyIsImZldGNoIiwic2hvdWxkVGhyb3dPbkVycm9yIiwicmVwbGFjZSIsIk9iamVjdCIsImFzc2lnbiIsInRocm93T25FcnJvciIsInB1dFZlY3RvcnMiLCJvcHRpb25zIiwidmVjdG9ycyIsImxlbmd0aCIsIkVycm9yIiwiZGF0YSIsImVycm9yIiwiZ2V0VmVjdG9ycyIsImxpc3RWZWN0b3JzIiwic2VnbWVudENvdW50IiwidW5kZWZpbmVkIiwic2VnbWVudEluZGV4IiwicXVlcnlWZWN0b3JzIiwiZGVsZXRlVmVjdG9ycyIsImtleXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/VectorDataApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/VectorIndexApi.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/vectors/VectorIndexApi.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ VectorIndexApi)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/constants.js\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/errors.js\");\n/* harmony import */ var _fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fetch */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/fetch.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/helpers.js\");\n\n\n\n\n\n/**\n * API class for managing Vector Indexes within Vector Buckets\n * Provides methods for creating, reading, listing, and deleting vector indexes\n */ class VectorIndexApi {\n    constructor(url, headers = {}, fetch){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = Object.assign(Object.assign({}, _constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HEADERS), headers);\n        this.fetch = (0,_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n    }\n    /**\n     * Enable throwing errors instead of returning them in the response\n     * When enabled, failed operations will throw instead of returning { data: null, error }\n     *\n     * @returns This instance for method chaining\n     * @example\n     * ```typescript\n     * const client = new VectorIndexApi(url, headers)\n     * client.throwOnError()\n     * const { data } = await client.createIndex(options) // throws on error\n     * ```\n     */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n     * Creates a new vector index within a bucket\n     * Defines the schema for vectors including dimensionality, distance metric, and metadata config\n     *\n     * @param options - Index configuration\n     * @param options.vectorBucketName - Name of the parent vector bucket\n     * @param options.indexName - Unique name for the index within the bucket\n     * @param options.dataType - Data type for vector components (currently only 'float32')\n     * @param options.dimension - Dimensionality of vectors (e.g., 384, 768, 1536)\n     * @param options.distanceMetric - Similarity metric ('cosine', 'euclidean', 'dotproduct')\n     * @param options.metadataConfiguration - Optional config for non-filterable metadata keys\n     * @returns Promise with empty response on success or error\n     *\n     * @throws {StorageVectorsApiError} With code:\n     * - `S3VectorConflictException` if index already exists (HTTP 409)\n     * - `S3VectorMaxIndexesExceeded` if quota exceeded (HTTP 400)\n     * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)\n     * - `InternalError` for server errors (HTTP 500)\n     *\n     * @example\n     * ```typescript\n     * const { data, error } = await client.createIndex({\n     *   vectorBucketName: 'embeddings-prod',\n     *   indexName: 'documents-openai-small',\n     *   dataType: 'float32',\n     *   dimension: 1536,\n     *   distanceMetric: 'cosine',\n     *   metadataConfiguration: {\n     *     nonFilterableMetadataKeys: ['raw_text', 'internal_id']\n     *   }\n     * })\n     * ```\n     */ createIndex(options) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/CreateIndex`, options, {\n                    headers: this.headers\n                });\n                return {\n                    data: data || {},\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageVectorsError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Retrieves metadata for a specific vector index\n     * Returns index configuration including dimension, distance metric, and metadata settings\n     *\n     * @param vectorBucketName - Name of the parent vector bucket\n     * @param indexName - Name of the index to retrieve\n     * @returns Promise with index metadata or error\n     *\n     * @throws {StorageVectorsApiError} With code:\n     * - `S3VectorNotFoundException` if index or bucket doesn't exist (HTTP 404)\n     * - `InternalError` for server errors (HTTP 500)\n     *\n     * @example\n     * ```typescript\n     * const { data, error } = await client.getIndex('embeddings-prod', 'documents-openai-small')\n     * if (data) {\n     *   console.log('Index dimension:', data.index.dimension)\n     *   console.log('Distance metric:', data.index.distanceMetric)\n     * }\n     * ```\n     */ getIndex(vectorBucketName, indexName) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/GetIndex`, {\n                    vectorBucketName,\n                    indexName\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageVectorsError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Lists vector indexes within a bucket with optional filtering and pagination\n     * Supports prefix-based filtering and paginated results\n     *\n     * @param options - Listing options\n     * @param options.vectorBucketName - Name of the parent vector bucket\n     * @param options.prefix - Filter indexes by name prefix\n     * @param options.maxResults - Maximum results per page (default: 100)\n     * @param options.nextToken - Pagination token from previous response\n     * @returns Promise with list of indexes and pagination token\n     *\n     * @throws {StorageVectorsApiError} With code:\n     * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)\n     * - `InternalError` for server errors (HTTP 500)\n     *\n     * @example\n     * ```typescript\n     * // List all indexes in a bucket\n     * const { data, error } = await client.listIndexes({\n     *   vectorBucketName: 'embeddings-prod',\n     *   prefix: 'documents-'\n     * })\n     * if (data) {\n     *   console.log('Found indexes:', data.indexes.map(i => i.indexName))\n     *   // Fetch next page if available\n     *   if (data.nextToken) {\n     *     const next = await client.listIndexes({\n     *       vectorBucketName: 'embeddings-prod',\n     *       nextToken: data.nextToken\n     *     })\n     *   }\n     * }\n     * ```\n     */ listIndexes(options) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/ListIndexes`, options, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageVectorsError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Deletes a vector index and all its data\n     * This operation removes the index schema and all vectors stored in the index\n     *\n     * @param vectorBucketName - Name of the parent vector bucket\n     * @param indexName - Name of the index to delete\n     * @returns Promise with empty response on success or error\n     *\n     * @throws {StorageVectorsApiError} With code:\n     * - `S3VectorNotFoundException` if index or bucket doesn't exist (HTTP 404)\n     * - `InternalError` for server errors (HTTP 500)\n     *\n     * @example\n     * ```typescript\n     * // Delete an index and all its vectors\n     * const { error } = await client.deleteIndex('embeddings-prod', 'old-index')\n     * if (!error) {\n     *   console.log('Index deleted successfully')\n     * }\n     * ```\n     */ deleteIndex(vectorBucketName, indexName) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/DeleteIndex`, {\n                    vectorBucketName,\n                    indexName\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data: data || {},\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageVectorsError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n} //# sourceMappingURL=VectorIndexApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL3ZlY3RvcnMvVmVjdG9ySW5kZXhBcGkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtDO0FBQ1k7QUFDRztBQUNsQjtBQUNVO0FBQ3pDOzs7Q0FHQyxHQUNjLE1BQU1LO0lBQ2pCQyxZQUFZQyxHQUFHLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUVDLEtBQUssQ0FBRTtRQUNsQyxJQUFJLENBQUNDLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ0gsR0FBRyxHQUFHQSxJQUFJSSxPQUFPLENBQUMsT0FBTztRQUM5QixJQUFJLENBQUNILE9BQU8sR0FBR0ksT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHWix1REFBZUEsR0FBR087UUFDakUsSUFBSSxDQUFDQyxLQUFLLEdBQUdMLHNEQUFZQSxDQUFDSztJQUM5QjtJQUNBOzs7Ozs7Ozs7OztLQVdDLEdBQ0RLLGVBQWU7UUFDWCxJQUFJLENBQUNKLGtCQUFrQixHQUFHO1FBQzFCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBZ0NDLEdBQ0RLLFlBQVlDLE9BQU8sRUFBRTtRQUNqQixPQUFPaEIsZ0RBQVNBLENBQUMsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSTtnQkFDQSxNQUFNaUIsT0FBTyxNQUFNZCw0Q0FBSUEsQ0FBQyxJQUFJLENBQUNNLEtBQUssRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMsWUFBWSxDQUFDLEVBQUVTLFNBQVM7b0JBQ3BFUixTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDekI7Z0JBQ0EsT0FBTztvQkFBRVMsTUFBTUEsUUFBUSxDQUFDO29CQUFHQyxPQUFPO2dCQUFLO1lBQzNDLEVBQ0EsT0FBT0EsT0FBTztnQkFDVixJQUFJLElBQUksQ0FBQ1Isa0JBQWtCLEVBQUU7b0JBQ3pCLE1BQU1RO2dCQUNWO2dCQUNBLElBQUloQiw4REFBcUJBLENBQUNnQixRQUFRO29CQUM5QixPQUFPO3dCQUFFRCxNQUFNO3dCQUFNQztvQkFBTTtnQkFDL0I7Z0JBQ0EsTUFBTUE7WUFDVjtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FvQkMsR0FDREMsU0FBU0MsZ0JBQWdCLEVBQUVDLFNBQVMsRUFBRTtRQUNsQyxPQUFPckIsZ0RBQVNBLENBQUMsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSTtnQkFDQSxNQUFNaUIsT0FBTyxNQUFNZCw0Q0FBSUEsQ0FBQyxJQUFJLENBQUNNLEtBQUssRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMsU0FBUyxDQUFDLEVBQUU7b0JBQUVhO29CQUFrQkM7Z0JBQVUsR0FBRztvQkFBRWIsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQUM7Z0JBQ3JILE9BQU87b0JBQUVTO29CQUFNQyxPQUFPO2dCQUFLO1lBQy9CLEVBQ0EsT0FBT0EsT0FBTztnQkFDVixJQUFJLElBQUksQ0FBQ1Isa0JBQWtCLEVBQUU7b0JBQ3pCLE1BQU1RO2dCQUNWO2dCQUNBLElBQUloQiw4REFBcUJBLENBQUNnQixRQUFRO29CQUM5QixPQUFPO3dCQUFFRCxNQUFNO3dCQUFNQztvQkFBTTtnQkFDL0I7Z0JBQ0EsTUFBTUE7WUFDVjtRQUNKO0lBQ0o7SUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBaUNDLEdBQ0RJLFlBQVlOLE9BQU8sRUFBRTtRQUNqQixPQUFPaEIsZ0RBQVNBLENBQUMsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSTtnQkFDQSxNQUFNaUIsT0FBTyxNQUFNZCw0Q0FBSUEsQ0FBQyxJQUFJLENBQUNNLEtBQUssRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDRixHQUFHLENBQUMsWUFBWSxDQUFDLEVBQUVTLFNBQVM7b0JBQ3BFUixTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFDekI7Z0JBQ0EsT0FBTztvQkFBRVM7b0JBQU1DLE9BQU87Z0JBQUs7WUFDL0IsRUFDQSxPQUFPQSxPQUFPO2dCQUNWLElBQUksSUFBSSxDQUFDUixrQkFBa0IsRUFBRTtvQkFDekIsTUFBTVE7Z0JBQ1Y7Z0JBQ0EsSUFBSWhCLDhEQUFxQkEsQ0FBQ2dCLFFBQVE7b0JBQzlCLE9BQU87d0JBQUVELE1BQU07d0JBQU1DO29CQUFNO2dCQUMvQjtnQkFDQSxNQUFNQTtZQUNWO1FBQ0o7SUFDSjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztLQW9CQyxHQUNESyxZQUFZSCxnQkFBZ0IsRUFBRUMsU0FBUyxFQUFFO1FBQ3JDLE9BQU9yQixnREFBU0EsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJO2dCQUNBLE1BQU1pQixPQUFPLE1BQU1kLDRDQUFJQSxDQUFDLElBQUksQ0FBQ00sS0FBSyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUNGLEdBQUcsQ0FBQyxZQUFZLENBQUMsRUFBRTtvQkFBRWE7b0JBQWtCQztnQkFBVSxHQUFHO29CQUFFYixTQUFTLElBQUksQ0FBQ0EsT0FBTztnQkFBQztnQkFDeEgsT0FBTztvQkFBRVMsTUFBTUEsUUFBUSxDQUFDO29CQUFHQyxPQUFPO2dCQUFLO1lBQzNDLEVBQ0EsT0FBT0EsT0FBTztnQkFDVixJQUFJLElBQUksQ0FBQ1Isa0JBQWtCLEVBQUU7b0JBQ3pCLE1BQU1RO2dCQUNWO2dCQUNBLElBQUloQiw4REFBcUJBLENBQUNnQixRQUFRO29CQUM5QixPQUFPO3dCQUFFRCxNQUFNO3dCQUFNQztvQkFBTTtnQkFDL0I7Z0JBQ0EsTUFBTUE7WUFDVjtRQUNKO0lBQ0o7QUFDSixFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdG9yYWdlLWpzL2Rpc3QvbW9kdWxlL2xpYi92ZWN0b3JzL1ZlY3RvckluZGV4QXBpLmpzPzNhYzYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBERUZBVUxUX0hFQURFUlMgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBpc1N0b3JhZ2VWZWN0b3JzRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBwb3N0IH0gZnJvbSAnLi9mZXRjaCc7XG5pbXBvcnQgeyByZXNvbHZlRmV0Y2ggfSBmcm9tICcuL2hlbHBlcnMnO1xuLyoqXG4gKiBBUEkgY2xhc3MgZm9yIG1hbmFnaW5nIFZlY3RvciBJbmRleGVzIHdpdGhpbiBWZWN0b3IgQnVja2V0c1xuICogUHJvdmlkZXMgbWV0aG9kcyBmb3IgY3JlYXRpbmcsIHJlYWRpbmcsIGxpc3RpbmcsIGFuZCBkZWxldGluZyB2ZWN0b3IgaW5kZXhlc1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWZWN0b3JJbmRleEFwaSB7XG4gICAgY29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGZldGNoKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXJsID0gdXJsLnJlcGxhY2UoL1xcLyQvLCAnJyk7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9IRUFERVJTKSwgaGVhZGVycyk7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSByZXNvbHZlRmV0Y2goZmV0Y2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgdGhyb3dpbmcgZXJyb3JzIGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZW0gaW4gdGhlIHJlc3BvbnNlXG4gICAgICogV2hlbiBlbmFibGVkLCBmYWlsZWQgb3BlcmF0aW9ucyB3aWxsIHRocm93IGluc3RlYWQgb2YgcmV0dXJuaW5nIHsgZGF0YTogbnVsbCwgZXJyb3IgfVxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhpcyBpbnN0YW5jZSBmb3IgbWV0aG9kIGNoYWluaW5nXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgY2xpZW50ID0gbmV3IFZlY3RvckluZGV4QXBpKHVybCwgaGVhZGVycylcbiAgICAgKiBjbGllbnQudGhyb3dPbkVycm9yKClcbiAgICAgKiBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGNsaWVudC5jcmVhdGVJbmRleChvcHRpb25zKSAvLyB0aHJvd3Mgb24gZXJyb3JcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICB0aHJvd09uRXJyb3IoKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdmVjdG9yIGluZGV4IHdpdGhpbiBhIGJ1Y2tldFxuICAgICAqIERlZmluZXMgdGhlIHNjaGVtYSBmb3IgdmVjdG9ycyBpbmNsdWRpbmcgZGltZW5zaW9uYWxpdHksIGRpc3RhbmNlIG1ldHJpYywgYW5kIG1ldGFkYXRhIGNvbmZpZ1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBJbmRleCBjb25maWd1cmF0aW9uXG4gICAgICogQHBhcmFtIG9wdGlvbnMudmVjdG9yQnVja2V0TmFtZSAtIE5hbWUgb2YgdGhlIHBhcmVudCB2ZWN0b3IgYnVja2V0XG4gICAgICogQHBhcmFtIG9wdGlvbnMuaW5kZXhOYW1lIC0gVW5pcXVlIG5hbWUgZm9yIHRoZSBpbmRleCB3aXRoaW4gdGhlIGJ1Y2tldFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRhdGFUeXBlIC0gRGF0YSB0eXBlIGZvciB2ZWN0b3IgY29tcG9uZW50cyAoY3VycmVudGx5IG9ubHkgJ2Zsb2F0MzInKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRpbWVuc2lvbiAtIERpbWVuc2lvbmFsaXR5IG9mIHZlY3RvcnMgKGUuZy4sIDM4NCwgNzY4LCAxNTM2KVxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRpc3RhbmNlTWV0cmljIC0gU2ltaWxhcml0eSBtZXRyaWMgKCdjb3NpbmUnLCAnZXVjbGlkZWFuJywgJ2RvdHByb2R1Y3QnKVxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1ldGFkYXRhQ29uZmlndXJhdGlvbiAtIE9wdGlvbmFsIGNvbmZpZyBmb3Igbm9uLWZpbHRlcmFibGUgbWV0YWRhdGEga2V5c1xuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtTdG9yYWdlVmVjdG9yc0FwaUVycm9yfSBXaXRoIGNvZGU6XG4gICAgICogLSBgUzNWZWN0b3JDb25mbGljdEV4Y2VwdGlvbmAgaWYgaW5kZXggYWxyZWFkeSBleGlzdHMgKEhUVFAgNDA5KVxuICAgICAqIC0gYFMzVmVjdG9yTWF4SW5kZXhlc0V4Y2VlZGVkYCBpZiBxdW90YSBleGNlZWRlZCAoSFRUUCA0MDApXG4gICAgICogLSBgUzNWZWN0b3JOb3RGb3VuZEV4Y2VwdGlvbmAgaWYgYnVja2V0IGRvZXNuJ3QgZXhpc3QgKEhUVFAgNDA0KVxuICAgICAqIC0gYEludGVybmFsRXJyb3JgIGZvciBzZXJ2ZXIgZXJyb3JzIChIVFRQIDUwMClcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudC5jcmVhdGVJbmRleCh7XG4gICAgICogICB2ZWN0b3JCdWNrZXROYW1lOiAnZW1iZWRkaW5ncy1wcm9kJyxcbiAgICAgKiAgIGluZGV4TmFtZTogJ2RvY3VtZW50cy1vcGVuYWktc21hbGwnLFxuICAgICAqICAgZGF0YVR5cGU6ICdmbG9hdDMyJyxcbiAgICAgKiAgIGRpbWVuc2lvbjogMTUzNixcbiAgICAgKiAgIGRpc3RhbmNlTWV0cmljOiAnY29zaW5lJyxcbiAgICAgKiAgIG1ldGFkYXRhQ29uZmlndXJhdGlvbjoge1xuICAgICAqICAgICBub25GaWx0ZXJhYmxlTWV0YWRhdGFLZXlzOiBbJ3Jhd190ZXh0JywgJ2ludGVybmFsX2lkJ11cbiAgICAgKiAgIH1cbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNyZWF0ZUluZGV4KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L0NyZWF0ZUluZGV4YCwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZGF0YSB8fCB7fSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgbWV0YWRhdGEgZm9yIGEgc3BlY2lmaWMgdmVjdG9yIGluZGV4XG4gICAgICogUmV0dXJucyBpbmRleCBjb25maWd1cmF0aW9uIGluY2x1ZGluZyBkaW1lbnNpb24sIGRpc3RhbmNlIG1ldHJpYywgYW5kIG1ldGFkYXRhIHNldHRpbmdzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmVjdG9yQnVja2V0TmFtZSAtIE5hbWUgb2YgdGhlIHBhcmVudCB2ZWN0b3IgYnVja2V0XG4gICAgICogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIHJldHJpZXZlXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIGluZGV4IG1ldGFkYXRhIG9yIGVycm9yXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtTdG9yYWdlVmVjdG9yc0FwaUVycm9yfSBXaXRoIGNvZGU6XG4gICAgICogLSBgUzNWZWN0b3JOb3RGb3VuZEV4Y2VwdGlvbmAgaWYgaW5kZXggb3IgYnVja2V0IGRvZXNuJ3QgZXhpc3QgKEhUVFAgNDA0KVxuICAgICAqIC0gYEludGVybmFsRXJyb3JgIGZvciBzZXJ2ZXIgZXJyb3JzIChIVFRQIDUwMClcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IGF3YWl0IGNsaWVudC5nZXRJbmRleCgnZW1iZWRkaW5ncy1wcm9kJywgJ2RvY3VtZW50cy1vcGVuYWktc21hbGwnKVxuICAgICAqIGlmIChkYXRhKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnSW5kZXggZGltZW5zaW9uOicsIGRhdGEuaW5kZXguZGltZW5zaW9uKVxuICAgICAqICAgY29uc29sZS5sb2coJ0Rpc3RhbmNlIG1ldHJpYzonLCBkYXRhLmluZGV4LmRpc3RhbmNlTWV0cmljKVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXRJbmRleCh2ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L0dldEluZGV4YCwgeyB2ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUgfSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0cyB2ZWN0b3IgaW5kZXhlcyB3aXRoaW4gYSBidWNrZXQgd2l0aCBvcHRpb25hbCBmaWx0ZXJpbmcgYW5kIHBhZ2luYXRpb25cbiAgICAgKiBTdXBwb3J0cyBwcmVmaXgtYmFzZWQgZmlsdGVyaW5nIGFuZCBwYWdpbmF0ZWQgcmVzdWx0c1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBMaXN0aW5nIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy52ZWN0b3JCdWNrZXROYW1lIC0gTmFtZSBvZiB0aGUgcGFyZW50IHZlY3RvciBidWNrZXRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wcmVmaXggLSBGaWx0ZXIgaW5kZXhlcyBieSBuYW1lIHByZWZpeFxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1heFJlc3VsdHMgLSBNYXhpbXVtIHJlc3VsdHMgcGVyIHBhZ2UgKGRlZmF1bHQ6IDEwMClcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uZXh0VG9rZW4gLSBQYWdpbmF0aW9uIHRva2VuIGZyb20gcHJldmlvdXMgcmVzcG9uc2VcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggbGlzdCBvZiBpbmRleGVzIGFuZCBwYWdpbmF0aW9uIHRva2VuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtTdG9yYWdlVmVjdG9yc0FwaUVycm9yfSBXaXRoIGNvZGU6XG4gICAgICogLSBgUzNWZWN0b3JOb3RGb3VuZEV4Y2VwdGlvbmAgaWYgYnVja2V0IGRvZXNuJ3QgZXhpc3QgKEhUVFAgNDA0KVxuICAgICAqIC0gYEludGVybmFsRXJyb3JgIGZvciBzZXJ2ZXIgZXJyb3JzIChIVFRQIDUwMClcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIExpc3QgYWxsIGluZGV4ZXMgaW4gYSBidWNrZXRcbiAgICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBjbGllbnQubGlzdEluZGV4ZXMoe1xuICAgICAqICAgdmVjdG9yQnVja2V0TmFtZTogJ2VtYmVkZGluZ3MtcHJvZCcsXG4gICAgICogICBwcmVmaXg6ICdkb2N1bWVudHMtJ1xuICAgICAqIH0pXG4gICAgICogaWYgKGRhdGEpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKCdGb3VuZCBpbmRleGVzOicsIGRhdGEuaW5kZXhlcy5tYXAoaSA9PiBpLmluZGV4TmFtZSkpXG4gICAgICogICAvLyBGZXRjaCBuZXh0IHBhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICogICBpZiAoZGF0YS5uZXh0VG9rZW4pIHtcbiAgICAgKiAgICAgY29uc3QgbmV4dCA9IGF3YWl0IGNsaWVudC5saXN0SW5kZXhlcyh7XG4gICAgICogICAgICAgdmVjdG9yQnVja2V0TmFtZTogJ2VtYmVkZGluZ3MtcHJvZCcsXG4gICAgICogICAgICAgbmV4dFRva2VuOiBkYXRhLm5leHRUb2tlblxuICAgICAqICAgICB9KVxuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBsaXN0SW5kZXhlcyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9MaXN0SW5kZXhlc2AsIG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VWZWN0b3JzRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhIHZlY3RvciBpbmRleCBhbmQgYWxsIGl0cyBkYXRhXG4gICAgICogVGhpcyBvcGVyYXRpb24gcmVtb3ZlcyB0aGUgaW5kZXggc2NoZW1hIGFuZCBhbGwgdmVjdG9ycyBzdG9yZWQgaW4gdGhlIGluZGV4XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmVjdG9yQnVja2V0TmFtZSAtIE5hbWUgb2YgdGhlIHBhcmVudCB2ZWN0b3IgYnVja2V0XG4gICAgICogQHBhcmFtIGluZGV4TmFtZSAtIE5hbWUgb2YgdGhlIGluZGV4IHRvIGRlbGV0ZVxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBlbXB0eSByZXNwb25zZSBvbiBzdWNjZXNzIG9yIGVycm9yXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtTdG9yYWdlVmVjdG9yc0FwaUVycm9yfSBXaXRoIGNvZGU6XG4gICAgICogLSBgUzNWZWN0b3JOb3RGb3VuZEV4Y2VwdGlvbmAgaWYgaW5kZXggb3IgYnVja2V0IGRvZXNuJ3QgZXhpc3QgKEhUVFAgNDA0KVxuICAgICAqIC0gYEludGVybmFsRXJyb3JgIGZvciBzZXJ2ZXIgZXJyb3JzIChIVFRQIDUwMClcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIERlbGV0ZSBhbiBpbmRleCBhbmQgYWxsIGl0cyB2ZWN0b3JzXG4gICAgICogY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgY2xpZW50LmRlbGV0ZUluZGV4KCdlbWJlZGRpbmdzLXByb2QnLCAnb2xkLWluZGV4JylcbiAgICAgKiBpZiAoIWVycm9yKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnSW5kZXggZGVsZXRlZCBzdWNjZXNzZnVsbHknKVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBkZWxldGVJbmRleCh2ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L0RlbGV0ZUluZGV4YCwgeyB2ZWN0b3JCdWNrZXROYW1lLCBpbmRleE5hbWUgfSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZGF0YSB8fCB7fSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZlY3RvckluZGV4QXBpLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJERUZBVUxUX0hFQURFUlMiLCJpc1N0b3JhZ2VWZWN0b3JzRXJyb3IiLCJwb3N0IiwicmVzb2x2ZUZldGNoIiwiVmVjdG9ySW5kZXhBcGkiLCJjb25zdHJ1Y3RvciIsInVybCIsImhlYWRlcnMiLCJmZXRjaCIsInNob3VsZFRocm93T25FcnJvciIsInJlcGxhY2UiLCJPYmplY3QiLCJhc3NpZ24iLCJ0aHJvd09uRXJyb3IiLCJjcmVhdGVJbmRleCIsIm9wdGlvbnMiLCJkYXRhIiwiZXJyb3IiLCJnZXRJbmRleCIsInZlY3RvckJ1Y2tldE5hbWUiLCJpbmRleE5hbWUiLCJsaXN0SW5kZXhlcyIsImRlbGV0ZUluZGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/VectorIndexApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/constants.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/vectors/constants.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/version.js\");\n\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `storage-js/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`,\n    \"Content-Type\": \"application/json\"\n}; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL3ZlY3RvcnMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFDO0FBQzlCLE1BQU1DLGtCQUFrQjtJQUMzQixpQkFBaUIsQ0FBQyxXQUFXLEVBQUVELDZDQUFPQSxDQUFDLENBQUM7SUFDeEMsZ0JBQWdCO0FBQ3BCLEVBQUUsQ0FDRixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvdmVjdG9ycy9jb25zdGFudHMuanM/OWZiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi4vdmVyc2lvbic7XG5leHBvcnQgY29uc3QgREVGQVVMVF9IRUFERVJTID0ge1xuICAgICdYLUNsaWVudC1JbmZvJzogYHN0b3JhZ2UtanMvJHt2ZXJzaW9ufWAsXG4gICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iLCJERUZBVUxUX0hFQURFUlMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/errors.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/vectors/errors.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageVectorsApiError: () => (/* binding */ StorageVectorsApiError),\n/* harmony export */   StorageVectorsError: () => (/* binding */ StorageVectorsError),\n/* harmony export */   StorageVectorsErrorCode: () => (/* binding */ StorageVectorsErrorCode),\n/* harmony export */   StorageVectorsUnknownError: () => (/* binding */ StorageVectorsUnknownError),\n/* harmony export */   isStorageVectorsError: () => (/* binding */ isStorageVectorsError)\n/* harmony export */ });\n/**\n * Base error class for all Storage Vectors errors\n */ class StorageVectorsError extends Error {\n    constructor(message){\n        super(message);\n        this.__isStorageVectorsError = true;\n        this.name = \"StorageVectorsError\";\n    }\n}\n/**\n * Type guard to check if an error is a StorageVectorsError\n * @param error - The error to check\n * @returns True if the error is a StorageVectorsError\n */ function isStorageVectorsError(error) {\n    return typeof error === \"object\" && error !== null && \"__isStorageVectorsError\" in error;\n}\n/**\n * API error returned from S3 Vectors service\n * Includes HTTP status code and service-specific error code\n */ class StorageVectorsApiError extends StorageVectorsError {\n    constructor(message, status, statusCode){\n        super(message);\n        this.name = \"StorageVectorsApiError\";\n        this.status = status;\n        this.statusCode = statusCode;\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            status: this.status,\n            statusCode: this.statusCode\n        };\n    }\n}\n/**\n * Unknown error that doesn't match expected error patterns\n * Wraps the original error for debugging\n */ class StorageVectorsUnknownError extends StorageVectorsError {\n    constructor(message, originalError){\n        super(message);\n        this.name = \"StorageVectorsUnknownError\";\n        this.originalError = originalError;\n    }\n}\n/**\n * Error codes specific to S3 Vectors API\n * Maps AWS service errors to application-friendly error codes\n */ var StorageVectorsErrorCode;\n(function(StorageVectorsErrorCode) {\n    /** Internal server fault (HTTP 500) */ StorageVectorsErrorCode[\"InternalError\"] = \"InternalError\";\n    /** Resource already exists / conflict (HTTP 409) */ StorageVectorsErrorCode[\"S3VectorConflictException\"] = \"S3VectorConflictException\";\n    /** Resource not found (HTTP 404) */ StorageVectorsErrorCode[\"S3VectorNotFoundException\"] = \"S3VectorNotFoundException\";\n    /** Delete bucket while not empty (HTTP 400) */ StorageVectorsErrorCode[\"S3VectorBucketNotEmpty\"] = \"S3VectorBucketNotEmpty\";\n    /** Exceeds bucket quota/limit (HTTP 400) */ StorageVectorsErrorCode[\"S3VectorMaxBucketsExceeded\"] = \"S3VectorMaxBucketsExceeded\";\n    /** Exceeds index quota/limit (HTTP 400) */ StorageVectorsErrorCode[\"S3VectorMaxIndexesExceeded\"] = \"S3VectorMaxIndexesExceeded\";\n})(StorageVectorsErrorCode || (StorageVectorsErrorCode = {})); //# sourceMappingURL=errors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL3ZlY3RvcnMvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FDTSxNQUFNQSw0QkFBNEJDO0lBQ3JDQyxZQUFZQyxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsdUJBQXVCLEdBQUc7UUFDL0IsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSjtBQUNBOzs7O0NBSUMsR0FDTSxTQUFTQyxzQkFBc0JDLEtBQUs7SUFDdkMsT0FBTyxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUSw2QkFBNkJBO0FBQ3ZGO0FBQ0E7OztDQUdDLEdBQ00sTUFBTUMsK0JBQStCUjtJQUN4Q0UsWUFBWUMsT0FBTyxFQUFFTSxNQUFNLEVBQUVDLFVBQVUsQ0FBRTtRQUNyQyxLQUFLLENBQUNQO1FBQ04sSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNJLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFVBQVUsR0FBR0E7SUFDdEI7SUFDQUMsU0FBUztRQUNMLE9BQU87WUFDSE4sTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDZkYsU0FBUyxJQUFJLENBQUNBLE9BQU87WUFDckJNLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ25CQyxZQUFZLElBQUksQ0FBQ0EsVUFBVTtRQUMvQjtJQUNKO0FBQ0o7QUFDQTs7O0NBR0MsR0FDTSxNQUFNRSxtQ0FBbUNaO0lBQzVDRSxZQUFZQyxPQUFPLEVBQUVVLGFBQWEsQ0FBRTtRQUNoQyxLQUFLLENBQUNWO1FBQ04sSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNRLGFBQWEsR0FBR0E7SUFDekI7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLElBQUlDLHdCQUF3QjtBQUNsQyxVQUFVQSx1QkFBdUI7SUFDOUIscUNBQXFDLEdBQ3JDQSx1QkFBdUIsQ0FBQyxnQkFBZ0IsR0FBRztJQUMzQyxrREFBa0QsR0FDbERBLHVCQUF1QixDQUFDLDRCQUE0QixHQUFHO0lBQ3ZELGtDQUFrQyxHQUNsQ0EsdUJBQXVCLENBQUMsNEJBQTRCLEdBQUc7SUFDdkQsNkNBQTZDLEdBQzdDQSx1QkFBdUIsQ0FBQyx5QkFBeUIsR0FBRztJQUNwRCwwQ0FBMEMsR0FDMUNBLHVCQUF1QixDQUFDLDZCQUE2QixHQUFHO0lBQ3hELHlDQUF5QyxHQUN6Q0EsdUJBQXVCLENBQUMsNkJBQTZCLEdBQUc7QUFDNUQsR0FBR0EsMkJBQTRCQSxDQUFBQSwwQkFBMEIsQ0FBQyxLQUMxRCxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvdmVjdG9ycy9lcnJvcnMuanM/MmRjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJhc2UgZXJyb3IgY2xhc3MgZm9yIGFsbCBTdG9yYWdlIFZlY3RvcnMgZXJyb3JzXG4gKi9cbmV4cG9ydCBjbGFzcyBTdG9yYWdlVmVjdG9yc0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX19pc1N0b3JhZ2VWZWN0b3JzRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU3RvcmFnZVZlY3RvcnNFcnJvcic7XG4gICAgfVxufVxuLyoqXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGFuIGVycm9yIGlzIGEgU3RvcmFnZVZlY3RvcnNFcnJvclxuICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIHRvIGNoZWNrXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBlcnJvciBpcyBhIFN0b3JhZ2VWZWN0b3JzRXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU3RvcmFnZVZlY3RvcnNFcnJvcihlcnJvcikge1xuICAgIHJldHVybiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmICdfX2lzU3RvcmFnZVZlY3RvcnNFcnJvcicgaW4gZXJyb3I7XG59XG4vKipcbiAqIEFQSSBlcnJvciByZXR1cm5lZCBmcm9tIFMzIFZlY3RvcnMgc2VydmljZVxuICogSW5jbHVkZXMgSFRUUCBzdGF0dXMgY29kZSBhbmQgc2VydmljZS1zcGVjaWZpYyBlcnJvciBjb2RlXG4gKi9cbmV4cG9ydCBjbGFzcyBTdG9yYWdlVmVjdG9yc0FwaUVycm9yIGV4dGVuZHMgU3RvcmFnZVZlY3RvcnNFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU3RvcmFnZVZlY3RvcnNBcGlFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlLFxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuICogVW5rbm93biBlcnJvciB0aGF0IGRvZXNuJ3QgbWF0Y2ggZXhwZWN0ZWQgZXJyb3IgcGF0dGVybnNcbiAqIFdyYXBzIHRoZSBvcmlnaW5hbCBlcnJvciBmb3IgZGVidWdnaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBTdG9yYWdlVmVjdG9yc1Vua25vd25FcnJvciBleHRlbmRzIFN0b3JhZ2VWZWN0b3JzRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9yaWdpbmFsRXJyb3IpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdTdG9yYWdlVmVjdG9yc1Vua25vd25FcnJvcic7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFcnJvciA9IG9yaWdpbmFsRXJyb3I7XG4gICAgfVxufVxuLyoqXG4gKiBFcnJvciBjb2RlcyBzcGVjaWZpYyB0byBTMyBWZWN0b3JzIEFQSVxuICogTWFwcyBBV1Mgc2VydmljZSBlcnJvcnMgdG8gYXBwbGljYXRpb24tZnJpZW5kbHkgZXJyb3IgY29kZXNcbiAqL1xuZXhwb3J0IHZhciBTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZTtcbihmdW5jdGlvbiAoU3RvcmFnZVZlY3RvcnNFcnJvckNvZGUpIHtcbiAgICAvKiogSW50ZXJuYWwgc2VydmVyIGZhdWx0IChIVFRQIDUwMCkgKi9cbiAgICBTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZVtcIkludGVybmFsRXJyb3JcIl0gPSBcIkludGVybmFsRXJyb3JcIjtcbiAgICAvKiogUmVzb3VyY2UgYWxyZWFkeSBleGlzdHMgLyBjb25mbGljdCAoSFRUUCA0MDkpICovXG4gICAgU3RvcmFnZVZlY3RvcnNFcnJvckNvZGVbXCJTM1ZlY3RvckNvbmZsaWN0RXhjZXB0aW9uXCJdID0gXCJTM1ZlY3RvckNvbmZsaWN0RXhjZXB0aW9uXCI7XG4gICAgLyoqIFJlc291cmNlIG5vdCBmb3VuZCAoSFRUUCA0MDQpICovXG4gICAgU3RvcmFnZVZlY3RvcnNFcnJvckNvZGVbXCJTM1ZlY3Rvck5vdEZvdW5kRXhjZXB0aW9uXCJdID0gXCJTM1ZlY3Rvck5vdEZvdW5kRXhjZXB0aW9uXCI7XG4gICAgLyoqIERlbGV0ZSBidWNrZXQgd2hpbGUgbm90IGVtcHR5IChIVFRQIDQwMCkgKi9cbiAgICBTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZVtcIlMzVmVjdG9yQnVja2V0Tm90RW1wdHlcIl0gPSBcIlMzVmVjdG9yQnVja2V0Tm90RW1wdHlcIjtcbiAgICAvKiogRXhjZWVkcyBidWNrZXQgcXVvdGEvbGltaXQgKEhUVFAgNDAwKSAqL1xuICAgIFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlW1wiUzNWZWN0b3JNYXhCdWNrZXRzRXhjZWVkZWRcIl0gPSBcIlMzVmVjdG9yTWF4QnVja2V0c0V4Y2VlZGVkXCI7XG4gICAgLyoqIEV4Y2VlZHMgaW5kZXggcXVvdGEvbGltaXQgKEhUVFAgNDAwKSAqL1xuICAgIFN0b3JhZ2VWZWN0b3JzRXJyb3JDb2RlW1wiUzNWZWN0b3JNYXhJbmRleGVzRXhjZWVkZWRcIl0gPSBcIlMzVmVjdG9yTWF4SW5kZXhlc0V4Y2VlZGVkXCI7XG59KShTdG9yYWdlVmVjdG9yc0Vycm9yQ29kZSB8fCAoU3RvcmFnZVZlY3RvcnNFcnJvckNvZGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6WyJTdG9yYWdlVmVjdG9yc0Vycm9yIiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJfX2lzU3RvcmFnZVZlY3RvcnNFcnJvciIsIm5hbWUiLCJpc1N0b3JhZ2VWZWN0b3JzRXJyb3IiLCJlcnJvciIsIlN0b3JhZ2VWZWN0b3JzQXBpRXJyb3IiLCJzdGF0dXMiLCJzdGF0dXNDb2RlIiwidG9KU09OIiwiU3RvcmFnZVZlY3RvcnNVbmtub3duRXJyb3IiLCJvcmlnaW5hbEVycm9yIiwiU3RvcmFnZVZlY3RvcnNFcnJvckNvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/fetch.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/vectors/fetch.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   remove: () => (/* binding */ remove)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/errors.js\");\n/* harmony import */ var _helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/helpers.js\");\n\n\n\n/**\n * Extracts error message from various error response formats\n * @param err - Error object from API\n * @returns Human-readable error message\n */ const _getErrorMessage = (err)=>err.msg || err.message || err.error_description || err.error || JSON.stringify(err);\n/**\n * Handles fetch errors and converts them to StorageVectors error types\n * @param error - The error caught from fetch\n * @param reject - Promise rejection function\n * @param options - Fetch options that may affect error handling\n */ const handleError = (error, reject, options)=>(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(void 0, void 0, void 0, function*() {\n        // Check if error is a Response-like object (has status and ok properties)\n        // This is more reliable than instanceof which can fail across realms\n        const isResponseLike = error && typeof error === \"object\" && \"status\" in error && \"ok\" in error && typeof error.status === \"number\";\n        if (isResponseLike && !(options === null || options === void 0 ? void 0 : options.noResolveJson)) {\n            const status = error.status || 500;\n            const responseError = error;\n            // Try to parse JSON body if available\n            if (typeof responseError.json === \"function\") {\n                responseError.json().then((err)=>{\n                    const statusCode = (err === null || err === void 0 ? void 0 : err.statusCode) || (err === null || err === void 0 ? void 0 : err.code) || status + \"\";\n                    reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageVectorsApiError(_getErrorMessage(err), status, statusCode));\n                }).catch(()=>{\n                    // If JSON parsing fails, create an ApiError with the HTTP status code\n                    const statusCode = status + \"\";\n                    const message = responseError.statusText || `HTTP ${status} error`;\n                    reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageVectorsApiError(message, status, statusCode));\n                });\n            } else {\n                // No json() method available, create error from status\n                const statusCode = status + \"\";\n                const message = responseError.statusText || `HTTP ${status} error`;\n                reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageVectorsApiError(message, status, statusCode));\n            }\n        } else {\n            reject(new _errors__WEBPACK_IMPORTED_MODULE_1__.StorageVectorsUnknownError(_getErrorMessage(error), error));\n        }\n    });\n/**\n * Builds request parameters for fetch calls\n * @param method - HTTP method\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters like AbortSignal\n * @param body - Request body (will be JSON stringified if plain object)\n * @returns Complete fetch request parameters\n */ const _getRequestParams = (method, options, parameters, body)=>{\n    const params = {\n        method,\n        headers: (options === null || options === void 0 ? void 0 : options.headers) || {}\n    };\n    if (method === \"GET\" || !body) {\n        return params;\n    }\n    if ((0,_helpers__WEBPACK_IMPORTED_MODULE_2__.isPlainObject)(body)) {\n        params.headers = Object.assign({\n            \"Content-Type\": \"application/json\"\n        }, options === null || options === void 0 ? void 0 : options.headers);\n        params.body = JSON.stringify(body);\n    } else {\n        params.body = body;\n    }\n    return Object.assign(Object.assign({}, params), parameters);\n};\n/**\n * Internal request handler that wraps fetch with error handling\n * @param fetcher - Fetch function to use\n * @param method - HTTP method\n * @param url - Request URL\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @param body - Request body\n * @returns Promise with parsed response or error\n */ function _handleRequest(fetcher, method, url, options, parameters, body) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function*() {\n        return new Promise((resolve, reject)=>{\n            fetcher(url, _getRequestParams(method, options, parameters, body)).then((result)=>{\n                if (!result.ok) throw result;\n                if (options === null || options === void 0 ? void 0 : options.noResolveJson) return result;\n                // Handle empty responses (204, empty body)\n                const contentType = result.headers.get(\"content-type\");\n                if (!contentType || !contentType.includes(\"application/json\")) {\n                    return {};\n                }\n                return result.json();\n            }).then((data)=>resolve(data)).catch((error)=>handleError(error, reject, options));\n        });\n    });\n}\n/**\n * Performs a GET request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */ function get(fetcher, url, options, parameters) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function*() {\n        return _handleRequest(fetcher, \"GET\", url, options, parameters);\n    });\n}\n/**\n * Performs a POST request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param body - Request body to be JSON stringified\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */ function post(fetcher, url, body, options, parameters) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function*() {\n        return _handleRequest(fetcher, \"POST\", url, options, parameters, body);\n    });\n}\n/**\n * Performs a PUT request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param body - Request body to be JSON stringified\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */ function put(fetcher, url, body, options, parameters) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function*() {\n        return _handleRequest(fetcher, \"PUT\", url, options, parameters, body);\n    });\n}\n/**\n * Performs a DELETE request\n * @param fetcher - Fetch function to use\n * @param url - Request URL\n * @param body - Request body to be JSON stringified\n * @param options - Custom fetch options\n * @param parameters - Additional fetch parameters\n * @returns Promise with parsed response\n */ function remove(fetcher, url, body, options, parameters) {\n    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function*() {\n        return _handleRequest(fetcher, \"DELETE\", url, options, parameters, body);\n    });\n} //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL3ZlY3RvcnMvZmV0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFrQztBQUM0QztBQUNwQztBQUMxQzs7OztDQUlDLEdBQ0QsTUFBTUksbUJBQW1CLENBQUNDLE1BQVFBLElBQUlDLEdBQUcsSUFBSUQsSUFBSUUsT0FBTyxJQUFJRixJQUFJRyxpQkFBaUIsSUFBSUgsSUFBSUksS0FBSyxJQUFJQyxLQUFLQyxTQUFTLENBQUNOO0FBQ2pIOzs7OztDQUtDLEdBQ0QsTUFBTU8sY0FBYyxDQUFDSCxPQUFPSSxRQUFRQyxVQUFZZCxnREFBU0EsQ0FBQyxLQUFLLEdBQUcsS0FBSyxHQUFHLEtBQUssR0FBRztRQUM5RSwwRUFBMEU7UUFDMUUscUVBQXFFO1FBQ3JFLE1BQU1lLGlCQUFpQk4sU0FDbkIsT0FBT0EsVUFBVSxZQUNqQixZQUFZQSxTQUNaLFFBQVFBLFNBQ1IsT0FBT0EsTUFBTU8sTUFBTSxLQUFLO1FBQzVCLElBQUlELGtCQUFrQixDQUFFRCxDQUFBQSxZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUUcsYUFBYSxHQUFHO1lBQzlGLE1BQU1ELFNBQVNQLE1BQU1PLE1BQU0sSUFBSTtZQUMvQixNQUFNRSxnQkFBZ0JUO1lBQ3RCLHNDQUFzQztZQUN0QyxJQUFJLE9BQU9TLGNBQWNDLElBQUksS0FBSyxZQUFZO2dCQUMxQ0QsY0FDS0MsSUFBSSxHQUNKQyxJQUFJLENBQUMsQ0FBQ2Y7b0JBQ1AsTUFBTWdCLGFBQWEsQ0FBQ2hCLFFBQVEsUUFBUUEsUUFBUSxLQUFLLElBQUksS0FBSyxJQUFJQSxJQUFJZ0IsVUFBVSxLQUFNaEIsQ0FBQUEsUUFBUSxRQUFRQSxRQUFRLEtBQUssSUFBSSxLQUFLLElBQUlBLElBQUlpQixJQUFJLEtBQUtOLFNBQVM7b0JBQ2xKSCxPQUFPLElBQUlaLDJEQUFzQkEsQ0FBQ0csaUJBQWlCQyxNQUFN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SSxFQUFFZCxPQUFPLEVBQUVhLFVBQVU7SUFDeEQsT0FBTzNCLGdEQUFTQSxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1FBQ25DLE9BQU9pQyxlQUFlQyxTQUFTLFFBQVFDLEtBQUtyQixTQUFTYSxZQUFZQztJQUNyRTtBQUNKO0FBQ0E7Ozs7Ozs7O0NBUUMsR0FDTSxTQUFTaUIsSUFBSVgsT0FBTyxFQUFFQyxHQUFHLEVBQUVQLElBQUksRUFBRWQsT0FBTyxFQUFFYSxVQUFVO0lBQ3ZELE9BQU8zQixnREFBU0EsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztRQUNuQyxPQUFPaUMsZUFBZUMsU0FBUyxPQUFPQyxLQUFLckIsU0FBU2EsWUFBWUM7SUFDcEU7QUFDSjtBQUNBOzs7Ozs7OztDQVFDLEdBQ00sU0FBU2tCLE9BQU9aLE9BQU8sRUFBRUMsR0FBRyxFQUFFUCxJQUFJLEVBQUVkLE9BQU8sRUFBRWEsVUFBVTtJQUMxRCxPQUFPM0IsZ0RBQVNBLENBQUMsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDbkMsT0FBT2lDLGVBQWVDLFNBQVMsVUFBVUMsS0FBS3JCLFNBQVNhLFlBQVlDO0lBQ3ZFO0FBQ0osRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvdmVjdG9ycy9mZXRjaC5qcz80MDk2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgU3RvcmFnZVZlY3RvcnNBcGlFcnJvciwgU3RvcmFnZVZlY3RvcnNVbmtub3duRXJyb3IgfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnLi9oZWxwZXJzJztcbi8qKlxuICogRXh0cmFjdHMgZXJyb3IgbWVzc2FnZSBmcm9tIHZhcmlvdXMgZXJyb3IgcmVzcG9uc2UgZm9ybWF0c1xuICogQHBhcmFtIGVyciAtIEVycm9yIG9iamVjdCBmcm9tIEFQSVxuICogQHJldHVybnMgSHVtYW4tcmVhZGFibGUgZXJyb3IgbWVzc2FnZVxuICovXG5jb25zdCBfZ2V0RXJyb3JNZXNzYWdlID0gKGVycikgPT4gZXJyLm1zZyB8fCBlcnIubWVzc2FnZSB8fCBlcnIuZXJyb3JfZGVzY3JpcHRpb24gfHwgZXJyLmVycm9yIHx8IEpTT04uc3RyaW5naWZ5KGVycik7XG4vKipcbiAqIEhhbmRsZXMgZmV0Y2ggZXJyb3JzIGFuZCBjb252ZXJ0cyB0aGVtIHRvIFN0b3JhZ2VWZWN0b3JzIGVycm9yIHR5cGVzXG4gKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgY2F1Z2h0IGZyb20gZmV0Y2hcbiAqIEBwYXJhbSByZWplY3QgLSBQcm9taXNlIHJlamVjdGlvbiBmdW5jdGlvblxuICogQHBhcmFtIG9wdGlvbnMgLSBGZXRjaCBvcHRpb25zIHRoYXQgbWF5IGFmZmVjdCBlcnJvciBoYW5kbGluZ1xuICovXG5jb25zdCBoYW5kbGVFcnJvciA9IChlcnJvciwgcmVqZWN0LCBvcHRpb25zKSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAvLyBDaGVjayBpZiBlcnJvciBpcyBhIFJlc3BvbnNlLWxpa2Ugb2JqZWN0IChoYXMgc3RhdHVzIGFuZCBvayBwcm9wZXJ0aWVzKVxuICAgIC8vIFRoaXMgaXMgbW9yZSByZWxpYWJsZSB0aGFuIGluc3RhbmNlb2Ygd2hpY2ggY2FuIGZhaWwgYWNyb3NzIHJlYWxtc1xuICAgIGNvbnN0IGlzUmVzcG9uc2VMaWtlID0gZXJyb3IgJiZcbiAgICAgICAgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnc3RhdHVzJyBpbiBlcnJvciAmJlxuICAgICAgICAnb2snIGluIGVycm9yICYmXG4gICAgICAgIHR5cGVvZiBlcnJvci5zdGF0dXMgPT09ICdudW1iZXInO1xuICAgIGlmIChpc1Jlc3BvbnNlTGlrZSAmJiAhKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ub1Jlc29sdmVKc29uKSkge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBlcnJvci5zdGF0dXMgfHwgNTAwO1xuICAgICAgICBjb25zdCByZXNwb25zZUVycm9yID0gZXJyb3I7XG4gICAgICAgIC8vIFRyeSB0byBwYXJzZSBKU09OIGJvZHkgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2VFcnJvci5qc29uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXNwb25zZUVycm9yXG4gICAgICAgICAgICAgICAgLmpzb24oKVxuICAgICAgICAgICAgICAgIC50aGVuKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gKGVyciA9PT0gbnVsbCB8fCBlcnIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVyci5zdGF0dXNDb2RlKSB8fCAoZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLmNvZGUpIHx8IHN0YXR1cyArICcnO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgU3RvcmFnZVZlY3RvcnNBcGlFcnJvcihfZ2V0RXJyb3JNZXNzYWdlKGVyciksIHN0YXR1cywgc3RhdHVzQ29kZSkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIEpTT04gcGFyc2luZyBmYWlscywgY3JlYXRlIGFuIEFwaUVycm9yIHdpdGggdGhlIEhUVFAgc3RhdHVzIGNvZGVcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gc3RhdHVzICsgJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlc3BvbnNlRXJyb3Iuc3RhdHVzVGV4dCB8fCBgSFRUUCAke3N0YXR1c30gZXJyb3JgO1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgU3RvcmFnZVZlY3RvcnNBcGlFcnJvcihtZXNzYWdlLCBzdGF0dXMsIHN0YXR1c0NvZGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8ganNvbigpIG1ldGhvZCBhdmFpbGFibGUsIGNyZWF0ZSBlcnJvciBmcm9tIHN0YXR1c1xuICAgICAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IHN0YXR1cyArICcnO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlc3BvbnNlRXJyb3Iuc3RhdHVzVGV4dCB8fCBgSFRUUCAke3N0YXR1c30gZXJyb3JgO1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBTdG9yYWdlVmVjdG9yc0FwaUVycm9yKG1lc3NhZ2UsIHN0YXR1cywgc3RhdHVzQ29kZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZWplY3QobmV3IFN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yKF9nZXRFcnJvck1lc3NhZ2UoZXJyb3IpLCBlcnJvcikpO1xuICAgIH1cbn0pO1xuLyoqXG4gKiBCdWlsZHMgcmVxdWVzdCBwYXJhbWV0ZXJzIGZvciBmZXRjaCBjYWxsc1xuICogQHBhcmFtIG1ldGhvZCAtIEhUVFAgbWV0aG9kXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBmZXRjaCBvcHRpb25zXG4gKiBAcGFyYW0gcGFyYW1ldGVycyAtIEFkZGl0aW9uYWwgZmV0Y2ggcGFyYW1ldGVycyBsaWtlIEFib3J0U2lnbmFsXG4gKiBAcGFyYW0gYm9keSAtIFJlcXVlc3QgYm9keSAod2lsbCBiZSBKU09OIHN0cmluZ2lmaWVkIGlmIHBsYWluIG9iamVjdClcbiAqIEByZXR1cm5zIENvbXBsZXRlIGZldGNoIHJlcXVlc3QgcGFyYW1ldGVyc1xuICovXG5jb25zdCBfZ2V0UmVxdWVzdFBhcmFtcyA9IChtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IG1ldGhvZCwgaGVhZGVyczogKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKSB8fCB7fSB9O1xuICAgIGlmIChtZXRob2QgPT09ICdHRVQnIHx8ICFib2R5KSB7XG4gICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgIGlmIChpc1BsYWluT2JqZWN0KGJvZHkpKSB7XG4gICAgICAgIHBhcmFtcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBwYXJhbXMuYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyYW1zLmJvZHkgPSBib2R5O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCBwYXJhbWV0ZXJzKTtcbn07XG4vKipcbiAqIEludGVybmFsIHJlcXVlc3QgaGFuZGxlciB0aGF0IHdyYXBzIGZldGNoIHdpdGggZXJyb3IgaGFuZGxpbmdcbiAqIEBwYXJhbSBmZXRjaGVyIC0gRmV0Y2ggZnVuY3Rpb24gdG8gdXNlXG4gKiBAcGFyYW0gbWV0aG9kIC0gSFRUUCBtZXRob2RcbiAqIEBwYXJhbSB1cmwgLSBSZXF1ZXN0IFVSTFxuICogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZmV0Y2ggb3B0aW9uc1xuICogQHBhcmFtIHBhcmFtZXRlcnMgLSBBZGRpdGlvbmFsIGZldGNoIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSBib2R5IC0gUmVxdWVzdCBib2R5XG4gKiBAcmV0dXJucyBQcm9taXNlIHdpdGggcGFyc2VkIHJlc3BvbnNlIG9yIGVycm9yXG4gKi9cbmZ1bmN0aW9uIF9oYW5kbGVSZXF1ZXN0KGZldGNoZXIsIG1ldGhvZCwgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGZldGNoZXIodXJsLCBfZ2V0UmVxdWVzdFBhcmFtcyhtZXRob2QsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpKVxuICAgICAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5vaylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubm9SZXNvbHZlSnNvbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZW1wdHkgcmVzcG9uc2VzICgyMDQsIGVtcHR5IGJvZHkpXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXN1bHQuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgICAgICAgICAgIGlmICghY29udGVudFR5cGUgfHwgIWNvbnRlbnRUeXBlLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmpzb24oKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHJlc29sdmUoZGF0YSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4gaGFuZGxlRXJyb3IoZXJyb3IsIHJlamVjdCwgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBHRVQgcmVxdWVzdFxuICogQHBhcmFtIGZldGNoZXIgLSBGZXRjaCBmdW5jdGlvbiB0byB1c2VcbiAqIEBwYXJhbSB1cmwgLSBSZXF1ZXN0IFVSTFxuICogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZmV0Y2ggb3B0aW9uc1xuICogQHBhcmFtIHBhcmFtZXRlcnMgLSBBZGRpdGlvbmFsIGZldGNoIHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBwYXJzZWQgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldChmZXRjaGVyLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ0dFVCcsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycyk7XG4gICAgfSk7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgUE9TVCByZXF1ZXN0XG4gKiBAcGFyYW0gZmV0Y2hlciAtIEZldGNoIGZ1bmN0aW9uIHRvIHVzZVxuICogQHBhcmFtIHVybCAtIFJlcXVlc3QgVVJMXG4gKiBAcGFyYW0gYm9keSAtIFJlcXVlc3QgYm9keSB0byBiZSBKU09OIHN0cmluZ2lmaWVkXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBmZXRjaCBvcHRpb25zXG4gKiBAcGFyYW0gcGFyYW1ldGVycyAtIEFkZGl0aW9uYWwgZmV0Y2ggcGFyYW1ldGVyc1xuICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHBhcnNlZCByZXNwb25zZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9zdChmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ1BPU1QnLCB1cmwsIG9wdGlvbnMsIHBhcmFtZXRlcnMsIGJvZHkpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBQZXJmb3JtcyBhIFBVVCByZXF1ZXN0XG4gKiBAcGFyYW0gZmV0Y2hlciAtIEZldGNoIGZ1bmN0aW9uIHRvIHVzZVxuICogQHBhcmFtIHVybCAtIFJlcXVlc3QgVVJMXG4gKiBAcGFyYW0gYm9keSAtIFJlcXVlc3QgYm9keSB0byBiZSBKU09OIHN0cmluZ2lmaWVkXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBmZXRjaCBvcHRpb25zXG4gKiBAcGFyYW0gcGFyYW1ldGVycyAtIEFkZGl0aW9uYWwgZmV0Y2ggcGFyYW1ldGVyc1xuICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHBhcnNlZCByZXNwb25zZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHV0KGZldGNoZXIsIHVybCwgYm9keSwgb3B0aW9ucywgcGFyYW1ldGVycykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiBfaGFuZGxlUmVxdWVzdChmZXRjaGVyLCAnUFVUJywgdXJsLCBvcHRpb25zLCBwYXJhbWV0ZXJzLCBib2R5KTtcbiAgICB9KTtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBERUxFVEUgcmVxdWVzdFxuICogQHBhcmFtIGZldGNoZXIgLSBGZXRjaCBmdW5jdGlvbiB0byB1c2VcbiAqIEBwYXJhbSB1cmwgLSBSZXF1ZXN0IFVSTFxuICogQHBhcmFtIGJvZHkgLSBSZXF1ZXN0IGJvZHkgdG8gYmUgSlNPTiBzdHJpbmdpZmllZFxuICogQHBhcmFtIG9wdGlvbnMgLSBDdXN0b20gZmV0Y2ggb3B0aW9uc1xuICogQHBhcmFtIHBhcmFtZXRlcnMgLSBBZGRpdGlvbmFsIGZldGNoIHBhcmFtZXRlcnNcbiAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBwYXJzZWQgcmVzcG9uc2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShmZXRjaGVyLCB1cmwsIGJvZHksIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gX2hhbmRsZVJlcXVlc3QoZmV0Y2hlciwgJ0RFTEVURScsIHVybCwgb3B0aW9ucywgcGFyYW1ldGVycywgYm9keSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwiU3RvcmFnZVZlY3RvcnNBcGlFcnJvciIsIlN0b3JhZ2VWZWN0b3JzVW5rbm93bkVycm9yIiwiaXNQbGFpbk9iamVjdCIsIl9nZXRFcnJvck1lc3NhZ2UiLCJlcnIiLCJtc2ciLCJtZXNzYWdlIiwiZXJyb3JfZGVzY3JpcHRpb24iLCJlcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJoYW5kbGVFcnJvciIsInJlamVjdCIsIm9wdGlvbnMiLCJpc1Jlc3BvbnNlTGlrZSIsInN0YXR1cyIsIm5vUmVzb2x2ZUpzb24iLCJyZXNwb25zZUVycm9yIiwianNvbiIsInRoZW4iLCJzdGF0dXNDb2RlIiwiY29kZSIsImNhdGNoIiwic3RhdHVzVGV4dCIsIl9nZXRSZXF1ZXN0UGFyYW1zIiwibWV0aG9kIiwicGFyYW1ldGVycyIsImJvZHkiLCJwYXJhbXMiLCJoZWFkZXJzIiwiT2JqZWN0IiwiYXNzaWduIiwiX2hhbmRsZVJlcXVlc3QiLCJmZXRjaGVyIiwidXJsIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZXN1bHQiLCJvayIsImNvbnRlbnRUeXBlIiwiZ2V0IiwiaW5jbHVkZXMiLCJkYXRhIiwicG9zdCIsInB1dCIsInJlbW92ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/helpers.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/vectors/helpers.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   normalizeToFloat32: () => (/* binding */ normalizeToFloat32),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse),\n/* harmony export */   validateVectorDimension: () => (/* binding */ validateVectorDimension)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n\n/**\n * Resolves the fetch implementation to use\n * Uses custom fetch if provided, otherwise falls back to:\n * - Native fetch in browser/modern environments\n * - @supabase/node-fetch polyfill in Node.js environments without fetch\n *\n * @param customFetch - Optional custom fetch implementation\n * @returns Resolved fetch function\n */ const resolveFetch = (customFetch)=>{\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    } else if (typeof fetch === \"undefined\") {\n        _fetch = (...args)=>Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\", 23)).then(({ default: fetch1 })=>fetch1(...args));\n    } else {\n        _fetch = fetch;\n    }\n    return (...args)=>_fetch(...args);\n};\n/**\n * Resolves the Response constructor to use\n * Uses native Response in browser/modern environments\n * Falls back to @supabase/node-fetch polyfill in Node.js environments\n *\n * @returns Response constructor\n */ const resolveResponse = ()=>(0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(void 0, void 0, void 0, function*() {\n        if (typeof Response === \"undefined\") {\n            // @ts-ignore\n            return (yield Promise.resolve(/*! import() */).then(__webpack_require__.t.bind(__webpack_require__, /*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\", 23))).Response;\n        }\n        return Response;\n    });\n/**\n * Determine if input is a plain object\n * An object is plain if it's created by either {}, new Object(), or Object.create(null)\n *\n * @param value - Value to check\n * @returns True if value is a plain object\n * @source https://github.com/sindresorhus/is-plain-obj\n */ const isPlainObject = (value)=>{\n    if (typeof value !== \"object\" || value === null) {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n};\n/**\n * Normalizes a number array to float32 format\n * Ensures all vector values are valid 32-bit floats\n *\n * @param values - Array of numbers to normalize\n * @returns Normalized float32 array\n */ const normalizeToFloat32 = (values)=>{\n    // Use Float32Array to ensure proper precision\n    return Array.from(new Float32Array(values));\n};\n/**\n * Validates vector dimensions match expected dimension\n * Throws error if dimensions don't match\n *\n * @param vector - Vector data to validate\n * @param expectedDimension - Expected vector dimension\n * @throws Error if dimensions don't match\n */ const validateVectorDimension = (vector, expectedDimension)=>{\n    if (expectedDimension !== undefined && vector.float32.length !== expectedDimension) {\n        throw new Error(`Vector dimension mismatch: expected ${expectedDimension}, got ${vector.float32.length}`);\n    }\n}; //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL3ZlY3RvcnMvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBa0M7QUFDbEM7Ozs7Ozs7O0NBUUMsR0FDTSxNQUFNQyxlQUFlLENBQUNDO0lBQ3pCLElBQUlDO0lBQ0osSUFBSUQsYUFBYTtRQUNiQyxTQUFTRDtJQUNiLE9BQ0ssSUFBSSxPQUFPRSxVQUFVLGFBQWE7UUFDbkNELFNBQVMsQ0FBQyxHQUFHRSxPQUFTLGdMQUFPLENBQXdCQyxJQUFJLENBQUMsQ0FBQyxFQUFFQyxTQUFTSCxNQUFLLEVBQUUsR0FBS0EsVUFBU0M7SUFDL0YsT0FDSztRQUNERixTQUFTQztJQUNiO0lBQ0EsT0FBTyxDQUFDLEdBQUdDLE9BQVNGLFVBQVVFO0FBQ2xDLEVBQUU7QUFDRjs7Ozs7O0NBTUMsR0FDTSxNQUFNRyxrQkFBa0IsSUFBTVIsZ0RBQVNBLENBQUMsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUc7UUFDbkUsSUFBSSxPQUFPUyxhQUFhLGFBQWE7WUFDakMsYUFBYTtZQUNiLE9BQU8sQ0FBQyxNQUFNLGdMQUE2QixFQUFHQSxRQUFRO1FBQzFEO1FBQ0EsT0FBT0E7SUFDWCxHQUFHO0FBQ0g7Ozs7Ozs7Q0FPQyxHQUNNLE1BQU1DLGdCQUFnQixDQUFDQztJQUMxQixJQUFJLE9BQU9BLFVBQVUsWUFBWUEsVUFBVSxNQUFNO1FBQzdDLE9BQU87SUFDWDtJQUNBLE1BQU1DLFlBQVlDLE9BQU9DLGNBQWMsQ0FBQ0g7SUFDeEMsT0FBUSxDQUFDQyxjQUFjLFFBQ25CQSxjQUFjQyxPQUFPRCxTQUFTLElBQzlCQyxPQUFPQyxjQUFjLENBQUNGLGVBQWUsSUFBRyxLQUN4QyxDQUFFRyxDQUFBQSxPQUFPQyxXQUFXLElBQUlMLEtBQUksS0FDNUIsQ0FBRUksQ0FBQUEsT0FBT0UsUUFBUSxJQUFJTixLQUFJO0FBQ2pDLEVBQUU7QUFDRjs7Ozs7O0NBTUMsR0FDTSxNQUFNTyxxQkFBcUIsQ0FBQ0M7SUFDL0IsOENBQThDO0lBQzlDLE9BQU9DLE1BQU1DLElBQUksQ0FBQyxJQUFJQyxhQUFhSDtBQUN2QyxFQUFFO0FBQ0Y7Ozs7Ozs7Q0FPQyxHQUNNLE1BQU1JLDBCQUEwQixDQUFDQyxRQUFRQztJQUM1QyxJQUFJQSxzQkFBc0JDLGFBQWFGLE9BQU9HLE9BQU8sQ0FBQ0MsTUFBTSxLQUFLSCxtQkFBbUI7UUFDaEYsTUFBTSxJQUFJSSxNQUFNLENBQUMsb0NBQW9DLEVBQUVKLGtCQUFrQixNQUFNLEVBQUVELE9BQU9HLE9BQU8sQ0FBQ0MsTUFBTSxDQUFDLENBQUM7SUFDNUc7QUFDSixFQUFFLENBQ0YsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL3ZlY3RvcnMvaGVscGVycy5qcz9kNTk1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuLyoqXG4gKiBSZXNvbHZlcyB0aGUgZmV0Y2ggaW1wbGVtZW50YXRpb24gdG8gdXNlXG4gKiBVc2VzIGN1c3RvbSBmZXRjaCBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIGZhbGxzIGJhY2sgdG86XG4gKiAtIE5hdGl2ZSBmZXRjaCBpbiBicm93c2VyL21vZGVybiBlbnZpcm9ubWVudHNcbiAqIC0gQHN1cGFiYXNlL25vZGUtZmV0Y2ggcG9seWZpbGwgaW4gTm9kZS5qcyBlbnZpcm9ubWVudHMgd2l0aG91dCBmZXRjaFxuICpcbiAqIEBwYXJhbSBjdXN0b21GZXRjaCAtIE9wdGlvbmFsIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybnMgUmVzb2x2ZWQgZmV0Y2ggZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuICAgIGxldCBfZmV0Y2g7XG4gICAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIF9mZXRjaCA9ICguLi5hcmdzKSA9PiBpbXBvcnQoJ0BzdXBhYmFzZS9ub2RlLWZldGNoJykudGhlbigoeyBkZWZhdWx0OiBmZXRjaCB9KSA9PiBmZXRjaCguLi5hcmdzKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfZmV0Y2ggPSBmZXRjaDtcbiAgICB9XG4gICAgcmV0dXJuICguLi5hcmdzKSA9PiBfZmV0Y2goLi4uYXJncyk7XG59O1xuLyoqXG4gKiBSZXNvbHZlcyB0aGUgUmVzcG9uc2UgY29uc3RydWN0b3IgdG8gdXNlXG4gKiBVc2VzIG5hdGl2ZSBSZXNwb25zZSBpbiBicm93c2VyL21vZGVybiBlbnZpcm9ubWVudHNcbiAqIEZhbGxzIGJhY2sgdG8gQHN1cGFiYXNlL25vZGUtZmV0Y2ggcG9seWZpbGwgaW4gTm9kZS5qcyBlbnZpcm9ubWVudHNcbiAqXG4gKiBAcmV0dXJucyBSZXNwb25zZSBjb25zdHJ1Y3RvclxuICovXG5leHBvcnQgY29uc3QgcmVzb2x2ZVJlc3BvbnNlID0gKCkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgaWYgKHR5cGVvZiBSZXNwb25zZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gKHlpZWxkIGltcG9ydCgnQHN1cGFiYXNlL25vZGUtZmV0Y2gnKSkuUmVzcG9uc2U7XG4gICAgfVxuICAgIHJldHVybiBSZXNwb25zZTtcbn0pO1xuLyoqXG4gKiBEZXRlcm1pbmUgaWYgaW5wdXQgaXMgYSBwbGFpbiBvYmplY3RcbiAqIEFuIG9iamVjdCBpcyBwbGFpbiBpZiBpdCdzIGNyZWF0ZWQgYnkgZWl0aGVyIHt9LCBuZXcgT2JqZWN0KCksIG9yIE9iamVjdC5jcmVhdGUobnVsbClcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBjaGVja1xuICogQHJldHVybnMgVHJ1ZSBpZiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdFxuICogQHNvdXJjZSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2lzLXBsYWluLW9ialxuICovXG5leHBvcnQgY29uc3QgaXNQbGFpbk9iamVjdCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcbiAgICByZXR1cm4gKChwcm90b3R5cGUgPT09IG51bGwgfHxcbiAgICAgICAgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlIHx8XG4gICAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90b3R5cGUpID09PSBudWxsKSAmJlxuICAgICAgICAhKFN5bWJvbC50b1N0cmluZ1RhZyBpbiB2YWx1ZSkgJiZcbiAgICAgICAgIShTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUpKTtcbn07XG4vKipcbiAqIE5vcm1hbGl6ZXMgYSBudW1iZXIgYXJyYXkgdG8gZmxvYXQzMiBmb3JtYXRcbiAqIEVuc3VyZXMgYWxsIHZlY3RvciB2YWx1ZXMgYXJlIHZhbGlkIDMyLWJpdCBmbG9hdHNcbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gQXJyYXkgb2YgbnVtYmVycyB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgZmxvYXQzMiBhcnJheVxuICovXG5leHBvcnQgY29uc3Qgbm9ybWFsaXplVG9GbG9hdDMyID0gKHZhbHVlcykgPT4ge1xuICAgIC8vIFVzZSBGbG9hdDMyQXJyYXkgdG8gZW5zdXJlIHByb3BlciBwcmVjaXNpb25cbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgRmxvYXQzMkFycmF5KHZhbHVlcykpO1xufTtcbi8qKlxuICogVmFsaWRhdGVzIHZlY3RvciBkaW1lbnNpb25zIG1hdGNoIGV4cGVjdGVkIGRpbWVuc2lvblxuICogVGhyb3dzIGVycm9yIGlmIGRpbWVuc2lvbnMgZG9uJ3QgbWF0Y2hcbiAqXG4gKiBAcGFyYW0gdmVjdG9yIC0gVmVjdG9yIGRhdGEgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSBleHBlY3RlZERpbWVuc2lvbiAtIEV4cGVjdGVkIHZlY3RvciBkaW1lbnNpb25cbiAqIEB0aHJvd3MgRXJyb3IgaWYgZGltZW5zaW9ucyBkb24ndCBtYXRjaFxuICovXG5leHBvcnQgY29uc3QgdmFsaWRhdGVWZWN0b3JEaW1lbnNpb24gPSAodmVjdG9yLCBleHBlY3RlZERpbWVuc2lvbikgPT4ge1xuICAgIGlmIChleHBlY3RlZERpbWVuc2lvbiAhPT0gdW5kZWZpbmVkICYmIHZlY3Rvci5mbG9hdDMyLmxlbmd0aCAhPT0gZXhwZWN0ZWREaW1lbnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWZWN0b3IgZGltZW5zaW9uIG1pc21hdGNoOiBleHBlY3RlZCAke2V4cGVjdGVkRGltZW5zaW9ufSwgZ290ICR7dmVjdG9yLmZsb2F0MzIubGVuZ3RofWApO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJyZXNvbHZlRmV0Y2giLCJjdXN0b21GZXRjaCIsIl9mZXRjaCIsImZldGNoIiwiYXJncyIsInRoZW4iLCJkZWZhdWx0IiwicmVzb2x2ZVJlc3BvbnNlIiwiUmVzcG9uc2UiLCJpc1BsYWluT2JqZWN0IiwidmFsdWUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiaXRlcmF0b3IiLCJub3JtYWxpemVUb0Zsb2F0MzIiLCJ2YWx1ZXMiLCJBcnJheSIsImZyb20iLCJGbG9hdDMyQXJyYXkiLCJ2YWxpZGF0ZVZlY3RvckRpbWVuc2lvbiIsInZlY3RvciIsImV4cGVjdGVkRGltZW5zaW9uIiwidW5kZWZpbmVkIiwiZmxvYXQzMiIsImxlbmd0aCIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/vectors/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/version.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/lib/version.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nconst version = \"2.78.0\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvbGliL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLDZFQUE2RTtBQUM3RSxnRUFBZ0U7QUFDaEUsdUVBQXVFO0FBQ3ZFLGlFQUFpRTtBQUNqRSxrRUFBa0U7QUFDbEUsaUVBQWlFO0FBQzFELE1BQU1BLFVBQVUsU0FBUyxDQUNoQyxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9saWIvdmVyc2lvbi5qcz9mYTM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIEdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5IGR1cmluZyByZWxlYXNlcyBieSBzY3JpcHRzL3VwZGF0ZS12ZXJzaW9uLWZpbGVzLnRzXG4vLyBUaGlzIGZpbGUgcHJvdmlkZXMgcnVudGltZSBhY2Nlc3MgdG8gdGhlIHBhY2thZ2UgdmVyc2lvbiBmb3I6XG4vLyAtIEhUVFAgcmVxdWVzdCBoZWFkZXJzIChlLmcuLCBYLUNsaWVudC1JbmZvIGhlYWRlciBmb3IgQVBJIHJlcXVlc3RzKVxuLy8gLSBEZWJ1Z2dpbmcgYW5kIHN1cHBvcnQgKGlkZW50aWZ5aW5nIHdoaWNoIHZlcnNpb24gaXMgcnVubmluZylcbi8vIC0gVGVsZW1ldHJ5IGFuZCBsb2dnaW5nICh2ZXJzaW9uIHJlcG9ydGluZyBpbiBlcnJvcnMvYW5hbHl0aWNzKVxuLy8gLSBFbnN1cmluZyBidWlsZCBhcnRpZmFjdHMgbWF0Y2ggdGhlIHB1Ymxpc2hlZCBwYWNrYWdlIHZlcnNpb25cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gJzIuNzguMCc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/BlobDownloadBuilder.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/packages/BlobDownloadBuilder.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/errors */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n/* harmony import */ var _StreamDownloadBuilder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StreamDownloadBuilder */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StreamDownloadBuilder.js\");\nvar _a;\n\n\n\nclass BlobDownloadBuilder {\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n        this[_a] = \"BlobDownloadBuilder\";\n        this.promise = null;\n    }\n    asStream() {\n        return new _StreamDownloadBuilder__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.downloadFn, this.shouldThrowOnError);\n    }\n    then(onfulfilled, onrejected) {\n        return this.getPromise().then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.getPromise().catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.getPromise().finally(onfinally);\n    }\n    getPromise() {\n        if (!this.promise) {\n            this.promise = this.execute();\n        }\n        return this.promise;\n    }\n    execute() {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const result = yield this.downloadFn();\n                return {\n                    data: yield result.blob(),\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_2__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n}\n_a = Symbol.toStringTag;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BlobDownloadBuilder); //# sourceMappingURL=BlobDownloadBuilder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvcGFja2FnZXMvQmxvYkRvd25sb2FkQnVpbGRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsSUFBSUE7QUFDOEI7QUFDYTtBQUNhO0FBQzVELE1BQU1JO0lBQ0ZDLFlBQVlDLFVBQVUsRUFBRUMsa0JBQWtCLENBQUU7UUFDeEMsSUFBSSxDQUFDRCxVQUFVLEdBQUdBO1FBQ2xCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUdBO1FBQzFCLElBQUksQ0FBQ1AsR0FBRyxHQUFHO1FBQ1gsSUFBSSxDQUFDUSxPQUFPLEdBQUc7SUFDbkI7SUFDQUMsV0FBVztRQUNQLE9BQU8sSUFBSU4sOERBQXFCQSxDQUFDLElBQUksQ0FBQ0csVUFBVSxFQUFFLElBQUksQ0FBQ0Msa0JBQWtCO0lBQzdFO0lBQ0FHLEtBQUtDLFdBQVcsRUFBRUMsVUFBVSxFQUFFO1FBQzFCLE9BQU8sSUFBSSxDQUFDQyxVQUFVLEdBQUdILElBQUksQ0FBQ0MsYUFBYUM7SUFDL0M7SUFDQUUsTUFBTUYsVUFBVSxFQUFFO1FBQ2QsT0FBTyxJQUFJLENBQUNDLFVBQVUsR0FBR0MsS0FBSyxDQUFDRjtJQUNuQztJQUNBRyxRQUFRQyxTQUFTLEVBQUU7UUFDZixPQUFPLElBQUksQ0FBQ0gsVUFBVSxHQUFHRSxPQUFPLENBQUNDO0lBQ3JDO0lBQ0FILGFBQWE7UUFDVCxJQUFJLENBQUMsSUFBSSxDQUFDTCxPQUFPLEVBQUU7WUFDZixJQUFJLENBQUNBLE9BQU8sR0FBRyxJQUFJLENBQUNTLE9BQU87UUFDL0I7UUFDQSxPQUFPLElBQUksQ0FBQ1QsT0FBTztJQUN2QjtJQUNBUyxVQUFVO1FBQ04sT0FBT2hCLGdEQUFTQSxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUk7Z0JBQ0EsTUFBTWlCLFNBQVMsTUFBTSxJQUFJLENBQUNaLFVBQVU7Z0JBQ3BDLE9BQU87b0JBQ0hhLE1BQU0sTUFBTUQsT0FBT0UsSUFBSTtvQkFDdkJDLE9BQU87Z0JBQ1g7WUFDSixFQUNBLE9BQU9BLE9BQU87Z0JBQ1YsSUFBSSxJQUFJLENBQUNkLGtCQUFrQixFQUFFO29CQUN6QixNQUFNYztnQkFDVjtnQkFDQSxJQUFJbkIsMkRBQWNBLENBQUNtQixRQUFRO29CQUN2QixPQUFPO3dCQUFFRixNQUFNO3dCQUFNRTtvQkFBTTtnQkFDL0I7Z0JBQ0EsTUFBTUE7WUFDVjtRQUNKO0lBQ0o7QUFDSjtBQUNBckIsS0FBS3NCLE9BQU9DLFdBQVc7QUFDdkIsaUVBQWVuQixtQkFBbUJBLEVBQUMsQ0FDbkMsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvcGFja2FnZXMvQmxvYkRvd25sb2FkQnVpbGRlci5qcz9hNjE4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfYTtcbmltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgaXNTdG9yYWdlRXJyb3IgfSBmcm9tICcuLi9saWIvZXJyb3JzJztcbmltcG9ydCBTdHJlYW1Eb3dubG9hZEJ1aWxkZXIgZnJvbSAnLi9TdHJlYW1Eb3dubG9hZEJ1aWxkZXInO1xuY2xhc3MgQmxvYkRvd25sb2FkQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoZG93bmxvYWRGbiwgc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgIHRoaXMuZG93bmxvYWRGbiA9IGRvd25sb2FkRm47XG4gICAgICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gc2hvdWxkVGhyb3dPbkVycm9yO1xuICAgICAgICB0aGlzW19hXSA9ICdCbG9iRG93bmxvYWRCdWlsZGVyJztcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbnVsbDtcbiAgICB9XG4gICAgYXNTdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtRG93bmxvYWRCdWlsZGVyKHRoaXMuZG93bmxvYWRGbiwgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IpO1xuICAgIH1cbiAgICB0aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByb21pc2UoKS50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKTtcbiAgICB9XG4gICAgY2F0Y2gob25yZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9taXNlKCkuY2F0Y2gob25yZWplY3RlZCk7XG4gICAgfVxuICAgIGZpbmFsbHkob25maW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByb21pc2UoKS5maW5hbGx5KG9uZmluYWxseSk7XG4gICAgfVxuICAgIGdldFByb21pc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLmV4ZWN1dGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIH1cbiAgICBleGVjdXRlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLmRvd25sb2FkRm4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB5aWVsZCByZXN1bHQuYmxvYigpLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5fYSA9IFN5bWJvbC50b1N0cmluZ1RhZztcbmV4cG9ydCBkZWZhdWx0IEJsb2JEb3dubG9hZEJ1aWxkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CbG9iRG93bmxvYWRCdWlsZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJfYSIsIl9fYXdhaXRlciIsImlzU3RvcmFnZUVycm9yIiwiU3RyZWFtRG93bmxvYWRCdWlsZGVyIiwiQmxvYkRvd25sb2FkQnVpbGRlciIsImNvbnN0cnVjdG9yIiwiZG93bmxvYWRGbiIsInNob3VsZFRocm93T25FcnJvciIsInByb21pc2UiLCJhc1N0cmVhbSIsInRoZW4iLCJvbmZ1bGZpbGxlZCIsIm9ucmVqZWN0ZWQiLCJnZXRQcm9taXNlIiwiY2F0Y2giLCJmaW5hbGx5Iiwib25maW5hbGx5IiwiZXhlY3V0ZSIsInJlc3VsdCIsImRhdGEiLCJibG9iIiwiZXJyb3IiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/BlobDownloadBuilder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StorageAnalyticsApi.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/packages/StorageAnalyticsApi.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StorageAnalyticsApi)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/constants */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/errors */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/fetch */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/helpers */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\");\n\n\n\n\n\n/**\n * API class for managing Analytics Buckets using Iceberg tables\n * Provides methods for creating, listing, and deleting analytics buckets\n */ class StorageAnalyticsApi {\n    /**\n     * Creates a new StorageAnalyticsApi instance\n     * @param url - The base URL for the storage API\n     * @param headers - HTTP headers to include in requests\n     * @param fetch - Optional custom fetch implementation\n     */ constructor(url, headers = {}, fetch){\n        this.shouldThrowOnError = false;\n        this.url = url.replace(/\\/$/, \"\");\n        this.headers = Object.assign(Object.assign({}, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HEADERS), headers);\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n    }\n    /**\n     * Enable throwing errors instead of returning them in the response\n     * When enabled, failed operations will throw instead of returning { data: null, error }\n     *\n     * @returns This instance for method chaining\n     */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n     * Creates a new analytics bucket using Iceberg tables\n     * Analytics buckets are optimized for analytical queries and data processing\n     *\n     * @param name A unique name for the bucket you are creating\n     * @returns Promise with newly created bucket name or error\n     *\n     * @example\n     * ```typescript\n     * const { data, error } = await storage.analytics.createBucket('analytics-data')\n     * if (error) {\n     *   console.error('Failed to create analytics bucket:', error.message)\n     * } else {\n     *   console.log('Created bucket:', data.name)\n     * }\n     * ```\n     */ createBucket(name) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/bucket`, {\n                    name\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Retrieves the details of all Analytics Storage buckets within an existing project\n     * Only returns buckets of type 'ANALYTICS'\n     *\n     * @param options Query parameters for listing buckets\n     * @param options.limit Maximum number of buckets to return\n     * @param options.offset Number of buckets to skip\n     * @param options.sortColumn Column to sort by ('id', 'name', 'created_at', 'updated_at')\n     * @param options.sortOrder Sort order ('asc' or 'desc')\n     * @param options.search Search term to filter bucket names\n     * @returns Promise with list of analytics buckets or error\n     *\n     * @example\n     * ```typescript\n     * const { data, error } = await storage.analytics.listBuckets({\n     *   limit: 10,\n     *   offset: 0,\n     *   sortColumn: 'created_at',\n     *   sortOrder: 'desc',\n     *   search: 'analytics'\n     * })\n     * if (data) {\n     *   console.log('Found analytics buckets:', data.length)\n     *   data.forEach(bucket => console.log(`- ${bucket.name}`))\n     * }\n     * ```\n     */ listBuckets(options) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                // Build query string from options\n                const queryParams = new URLSearchParams();\n                if ((options === null || options === void 0 ? void 0 : options.limit) !== undefined) queryParams.set(\"limit\", options.limit.toString());\n                if ((options === null || options === void 0 ? void 0 : options.offset) !== undefined) queryParams.set(\"offset\", options.offset.toString());\n                if (options === null || options === void 0 ? void 0 : options.sortColumn) queryParams.set(\"sortColumn\", options.sortColumn);\n                if (options === null || options === void 0 ? void 0 : options.sortOrder) queryParams.set(\"sortOrder\", options.sortOrder);\n                if (options === null || options === void 0 ? void 0 : options.search) queryParams.set(\"search\", options.search);\n                const queryString = queryParams.toString();\n                const url = queryString ? `${this.url}/bucket?${queryString}` : `${this.url}/bucket`;\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__.get)(this.fetch, url, {\n                    headers: this.headers\n                });\n                return {\n                    data: data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Deletes an existing analytics bucket\n     * A bucket can't be deleted with existing objects inside it\n     * You must first empty the bucket before deletion\n     *\n     * @param bucketId The unique identifier of the bucket you would like to delete\n     * @returns Promise with success message or error\n     *\n     * @example\n     * ```typescript\n     * const { data, error } = await analyticsApi.deleteBucket('old-analytics-bucket')\n     * if (error) {\n     *   console.error('Failed to delete bucket:', error.message)\n     * } else {\n     *   console.log('Bucket deleted successfully:', data.message)\n     * }\n     * ```\n     */ deleteBucket(bucketId) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__.remove)(this.fetch, `${this.url}/bucket/${bucketId}`, {}, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n} //# sourceMappingURL=StorageAnalyticsApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvcGFja2FnZXMvU3RvcmFnZUFuYWx5dGljc0FwaS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBa0M7QUFDaUI7QUFDSjtBQUNFO0FBQ0g7QUFDOUM7OztDQUdDLEdBQ2MsTUFBTU87SUFDakI7Ozs7O0tBS0MsR0FDREMsWUFBWUMsR0FBRyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFQyxLQUFLLENBQUU7UUFDbEMsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztRQUMxQixJQUFJLENBQUNILEdBQUcsR0FBR0EsSUFBSUksT0FBTyxDQUFDLE9BQU87UUFDOUIsSUFBSSxDQUFDSCxPQUFPLEdBQUdJLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR2QsMkRBQWVBLEdBQUdTO1FBQ2pFLElBQUksQ0FBQ0MsS0FBSyxHQUFHTCwwREFBWUEsQ0FBQ0s7SUFDOUI7SUFDQTs7Ozs7S0FLQyxHQUNESyxlQUFlO1FBQ1gsSUFBSSxDQUFDSixrQkFBa0IsR0FBRztRQUMxQixPQUFPLElBQUk7SUFDZjtJQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0tBZ0JDLEdBQ0RLLGFBQWFDLElBQUksRUFBRTtRQUNmLE9BQU9sQixnREFBU0EsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJO2dCQUNBLE1BQU1tQixPQUFPLE1BQU1mLGdEQUFJQSxDQUFDLElBQUksQ0FBQ08sS0FBSyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUNGLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRTtvQkFBRVM7Z0JBQUssR0FBRztvQkFBRVIsU0FBUyxJQUFJLENBQUNBLE9BQU87Z0JBQUM7Z0JBQzVGLE9BQU87b0JBQUVTO29CQUFNQyxPQUFPO2dCQUFLO1lBQy9CLEVBQ0EsT0FBT0EsT0FBTztnQkFDVixJQUFJLElBQUksQ0FBQ1Isa0JBQWtCLEVBQUU7b0JBQ3pC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Q0EsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvcGFja2FnZXMvU3RvcmFnZUFuYWx5dGljc0FwaS5qcz8yYTg1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgREVGQVVMVF9IRUFERVJTIH0gZnJvbSAnLi4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBpc1N0b3JhZ2VFcnJvciB9IGZyb20gJy4uL2xpYi9lcnJvcnMnO1xuaW1wb3J0IHsgZ2V0LCBwb3N0LCByZW1vdmUgfSBmcm9tICcuLi9saWIvZmV0Y2gnO1xuaW1wb3J0IHsgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi4vbGliL2hlbHBlcnMnO1xuLyoqXG4gKiBBUEkgY2xhc3MgZm9yIG1hbmFnaW5nIEFuYWx5dGljcyBCdWNrZXRzIHVzaW5nIEljZWJlcmcgdGFibGVzXG4gKiBQcm92aWRlcyBtZXRob2RzIGZvciBjcmVhdGluZywgbGlzdGluZywgYW5kIGRlbGV0aW5nIGFuYWx5dGljcyBidWNrZXRzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JhZ2VBbmFseXRpY3NBcGkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU3RvcmFnZUFuYWx5dGljc0FwaSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB1cmwgLSBUaGUgYmFzZSBVUkwgZm9yIHRoZSBzdG9yYWdlIEFQSVxuICAgICAqIEBwYXJhbSBoZWFkZXJzIC0gSFRUUCBoZWFkZXJzIHRvIGluY2x1ZGUgaW4gcmVxdWVzdHNcbiAgICAgKiBAcGFyYW0gZmV0Y2ggLSBPcHRpb25hbCBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1cmwsIGhlYWRlcnMgPSB7fSwgZmV0Y2gpIHtcbiAgICAgICAgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cmwgPSB1cmwucmVwbGFjZSgvXFwvJC8sICcnKTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0hFQURFUlMpLCBoZWFkZXJzKTtcbiAgICAgICAgdGhpcy5mZXRjaCA9IHJlc29sdmVGZXRjaChmZXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZSB0aHJvd2luZyBlcnJvcnMgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlbSBpbiB0aGUgcmVzcG9uc2VcbiAgICAgKiBXaGVuIGVuYWJsZWQsIGZhaWxlZCBvcGVyYXRpb25zIHdpbGwgdGhyb3cgaW5zdGVhZCBvZiByZXR1cm5pbmcgeyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGlzIGluc3RhbmNlIGZvciBtZXRob2QgY2hhaW5pbmdcbiAgICAgKi9cbiAgICB0aHJvd09uRXJyb3IoKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYW5hbHl0aWNzIGJ1Y2tldCB1c2luZyBJY2ViZXJnIHRhYmxlc1xuICAgICAqIEFuYWx5dGljcyBidWNrZXRzIGFyZSBvcHRpbWl6ZWQgZm9yIGFuYWx5dGljYWwgcXVlcmllcyBhbmQgZGF0YSBwcm9jZXNzaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBBIHVuaXF1ZSBuYW1lIGZvciB0aGUgYnVja2V0IHlvdSBhcmUgY3JlYXRpbmdcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdpdGggbmV3bHkgY3JlYXRlZCBidWNrZXQgbmFtZSBvciBlcnJvclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3RvcmFnZS5hbmFseXRpY3MuY3JlYXRlQnVja2V0KCdhbmFseXRpY3MtZGF0YScpXG4gICAgICogaWYgKGVycm9yKSB7XG4gICAgICogICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIGFuYWx5dGljcyBidWNrZXQ6JywgZXJyb3IubWVzc2FnZSlcbiAgICAgKiB9IGVsc2Uge1xuICAgICAqICAgY29uc29sZS5sb2coJ0NyZWF0ZWQgYnVja2V0OicsIGRhdGEubmFtZSlcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY3JlYXRlQnVja2V0KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L2J1Y2tldGAsIHsgbmFtZSB9LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFsbCBBbmFseXRpY3MgU3RvcmFnZSBidWNrZXRzIHdpdGhpbiBhbiBleGlzdGluZyBwcm9qZWN0XG4gICAgICogT25seSByZXR1cm5zIGJ1Y2tldHMgb2YgdHlwZSAnQU5BTFlUSUNTJ1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgUXVlcnkgcGFyYW1ldGVycyBmb3IgbGlzdGluZyBidWNrZXRzXG4gICAgICogQHBhcmFtIG9wdGlvbnMubGltaXQgTWF4aW11bSBudW1iZXIgb2YgYnVja2V0cyB0byByZXR1cm5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vZmZzZXQgTnVtYmVyIG9mIGJ1Y2tldHMgdG8gc2tpcFxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNvcnRDb2x1bW4gQ29sdW1uIHRvIHNvcnQgYnkgKCdpZCcsICduYW1lJywgJ2NyZWF0ZWRfYXQnLCAndXBkYXRlZF9hdCcpXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc29ydE9yZGVyIFNvcnQgb3JkZXIgKCdhc2MnIG9yICdkZXNjJylcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zZWFyY2ggU2VhcmNoIHRlcm0gdG8gZmlsdGVyIGJ1Y2tldCBuYW1lc1xuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2l0aCBsaXN0IG9mIGFuYWx5dGljcyBidWNrZXRzIG9yIGVycm9yXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdG9yYWdlLmFuYWx5dGljcy5saXN0QnVja2V0cyh7XG4gICAgICogICBsaW1pdDogMTAsXG4gICAgICogICBvZmZzZXQ6IDAsXG4gICAgICogICBzb3J0Q29sdW1uOiAnY3JlYXRlZF9hdCcsXG4gICAgICogICBzb3J0T3JkZXI6ICdkZXNjJyxcbiAgICAgKiAgIHNlYXJjaDogJ2FuYWx5dGljcydcbiAgICAgKiB9KVxuICAgICAqIGlmIChkYXRhKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnRm91bmQgYW5hbHl0aWNzIGJ1Y2tldHM6JywgZGF0YS5sZW5ndGgpXG4gICAgICogICBkYXRhLmZvckVhY2goYnVja2V0ID0+IGNvbnNvbGUubG9nKGAtICR7YnVja2V0Lm5hbWV9YCkpXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGxpc3RCdWNrZXRzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgcXVlcnkgc3RyaW5nIGZyb20gb3B0aW9uc1xuICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgICAgICAgICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmxpbWl0KSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5zZXQoJ2xpbWl0Jywgb3B0aW9ucy5saW1pdC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQpICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zLnNldCgnb2Zmc2V0Jywgb3B0aW9ucy5vZmZzZXQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zb3J0Q29sdW1uKVxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5zZXQoJ3NvcnRDb2x1bW4nLCBvcHRpb25zLnNvcnRDb2x1bW4pO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc29ydE9yZGVyKVxuICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5zZXQoJ3NvcnRPcmRlcicsIG9wdGlvbnMuc29ydE9yZGVyKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNlYXJjaClcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMuc2V0KCdzZWFyY2gnLCBvcHRpb25zLnNlYXJjaCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnlTdHJpbmcgPSBxdWVyeVBhcmFtcy50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IHF1ZXJ5U3RyaW5nID8gYCR7dGhpcy51cmx9L2J1Y2tldD8ke3F1ZXJ5U3RyaW5nfWAgOiBgJHt0aGlzLnVybH0vYnVja2V0YDtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgZ2V0KHRoaXMuZmV0Y2gsIHVybCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYW4gZXhpc3RpbmcgYW5hbHl0aWNzIGJ1Y2tldFxuICAgICAqIEEgYnVja2V0IGNhbid0IGJlIGRlbGV0ZWQgd2l0aCBleGlzdGluZyBvYmplY3RzIGluc2lkZSBpdFxuICAgICAqIFlvdSBtdXN0IGZpcnN0IGVtcHR5IHRoZSBidWNrZXQgYmVmb3JlIGRlbGV0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnVja2V0SWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gZGVsZXRlXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aXRoIHN1Y2Nlc3MgbWVzc2FnZSBvciBlcnJvclxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgYW5hbHl0aWNzQXBpLmRlbGV0ZUJ1Y2tldCgnb2xkLWFuYWx5dGljcy1idWNrZXQnKVxuICAgICAqIGlmIChlcnJvcikge1xuICAgICAqICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGRlbGV0ZSBidWNrZXQ6JywgZXJyb3IubWVzc2FnZSlcbiAgICAgKiB9IGVsc2Uge1xuICAgICAqICAgY29uc29sZS5sb2coJ0J1Y2tldCBkZWxldGVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhLm1lc3NhZ2UpXG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGRlbGV0ZUJ1Y2tldChidWNrZXRJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcmVtb3ZlKHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXQvJHtidWNrZXRJZH1gLCB7fSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RvcmFnZUFuYWx5dGljc0FwaS5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwiREVGQVVMVF9IRUFERVJTIiwiaXNTdG9yYWdlRXJyb3IiLCJnZXQiLCJwb3N0IiwicmVtb3ZlIiwicmVzb2x2ZUZldGNoIiwiU3RvcmFnZUFuYWx5dGljc0FwaSIsImNvbnN0cnVjdG9yIiwidXJsIiwiaGVhZGVycyIsImZldGNoIiwic2hvdWxkVGhyb3dPbkVycm9yIiwicmVwbGFjZSIsIk9iamVjdCIsImFzc2lnbiIsInRocm93T25FcnJvciIsImNyZWF0ZUJ1Y2tldCIsIm5hbWUiLCJkYXRhIiwiZXJyb3IiLCJsaXN0QnVja2V0cyIsIm9wdGlvbnMiLCJxdWVyeVBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsImxpbWl0IiwidW5kZWZpbmVkIiwic2V0IiwidG9TdHJpbmciLCJvZmZzZXQiLCJzb3J0Q29sdW1uIiwic29ydE9yZGVyIiwic2VhcmNoIiwicXVlcnlTdHJpbmciLCJkZWxldGVCdWNrZXQiLCJidWNrZXRJZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StorageAnalyticsApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StorageBucketApi)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/constants */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/errors */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/fetch */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/helpers */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\");\n\n\n\n\n\nclass StorageBucketApi {\n    constructor(url, headers = {}, fetch, opts){\n        this.shouldThrowOnError = false;\n        const baseUrl = new URL(url);\n        // if legacy uri is used, replace with new storage host (disables request buffering to allow > 50GB uploads)\n        // \"project-ref.supabase.co\" becomes \"project-ref.storage.supabase.co\"\n        if (opts === null || opts === void 0 ? void 0 : opts.useNewHostname) {\n            const isSupabaseHost = /supabase\\.(co|in|red)$/.test(baseUrl.hostname);\n            if (isSupabaseHost && !baseUrl.hostname.includes(\"storage.supabase.\")) {\n                baseUrl.hostname = baseUrl.hostname.replace(\"supabase.\", \"storage.supabase.\");\n            }\n        }\n        this.url = baseUrl.href.replace(/\\/$/, \"\");\n        this.headers = Object.assign(Object.assign({}, _lib_constants__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_HEADERS), headers);\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_1__.resolveFetch)(fetch);\n    }\n    /**\n     * Enable throwing errors instead of returning them.\n     */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n     * Retrieves the details of all Storage buckets within an existing project.\n     */ listBuckets(options) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const queryString = this.listBucketOptionsToQueryString(options);\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__.get)(this.fetch, `${this.url}/bucket${queryString}`, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Retrieves the details of an existing Storage bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to retrieve.\n     */ getBucket(id) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__.get)(this.fetch, `${this.url}/bucket/${id}`, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a new Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are creating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     * @returns newly created bucket id\n     * @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.\n     *   - default bucket type is `STANDARD`\n     */ createBucket(id_1) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, arguments, void 0, function*(id, options = {\n            public: false\n        }) {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/bucket`, {\n                    id,\n                    name: id,\n                    type: options.type,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Updates a Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are updating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     */ updateBucket(id, options) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__.put)(this.fetch, `${this.url}/bucket/${id}`, {\n                    id,\n                    name: id,\n                    public: options.public,\n                    file_size_limit: options.fileSizeLimit,\n                    allowed_mime_types: options.allowedMimeTypes\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Removes all objects inside a single bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to empty.\n     */ emptyBucket(id) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__.post)(this.fetch, `${this.url}/bucket/${id}/empty`, {}, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n     * You must first `empty()` the bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to delete.\n     */ deleteBucket(id) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_2__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_3__.remove)(this.fetch, `${this.url}/bucket/${id}`, {}, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_4__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    listBucketOptionsToQueryString(options) {\n        const params = {};\n        if (options) {\n            if (\"limit\" in options) {\n                params.limit = String(options.limit);\n            }\n            if (\"offset\" in options) {\n                params.offset = String(options.offset);\n            }\n            if (options.search) {\n                params.search = options.search;\n            }\n            if (options.sortColumn) {\n                params.sortColumn = options.sortColumn;\n            }\n            if (options.sortOrder) {\n                params.sortOrder = options.sortOrder;\n            }\n        }\n        return Object.keys(params).length > 0 ? \"?\" + new URLSearchParams(params).toString() : \"\";\n    }\n} //# sourceMappingURL=StorageBucketApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvcGFja2FnZXMvU3RvcmFnZUJ1Y2tldEFwaS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBa0M7QUFDaUI7QUFDSjtBQUNPO0FBQ1I7QUFDL0IsTUFBTVE7SUFDakJDLFlBQVlDLEdBQUcsRUFBRUMsVUFBVSxDQUFDLENBQUMsRUFBRUMsS0FBSyxFQUFFQyxJQUFJLENBQUU7UUFDeEMsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRztRQUMxQixNQUFNQyxVQUFVLElBQUlDLElBQUlOO1FBQ3hCLDRHQUE0RztRQUM1RyxzRUFBc0U7UUFDdEUsSUFBSUcsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSSxLQUFLLElBQUlBLEtBQUtJLGNBQWMsRUFBRTtZQUNqRSxNQUFNQyxpQkFBaUIseUJBQXlCQyxJQUFJLENBQUNKLFFBQVFLLFFBQVE7WUFDckUsSUFBSUYsa0JBQWtCLENBQUNILFFBQVFLLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDLHNCQUFzQjtnQkFDbkVOLFFBQVFLLFFBQVEsR0FBR0wsUUFBUUssUUFBUSxDQUFDRSxPQUFPLENBQUMsYUFBYTtZQUM3RDtRQUNKO1FBQ0EsSUFBSSxDQUFDWixHQUFHLEdBQUdLLFFBQVFRLElBQUksQ0FBQ0QsT0FBTyxDQUFDLE9BQU87UUFDdkMsSUFBSSxDQUFDWCxPQUFPLEdBQUdhLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR3hCLDJEQUFlQSxHQUFHVTtRQUNqRSxJQUFJLENBQUNDLEtBQUssR0FBR0wsMERBQVlBLENBQUNLO0lBQzlCO0lBQ0E7O0tBRUMsR0FDRGMsZUFBZTtRQUNYLElBQUksQ0FBQ1osa0JBQWtCLEdBQUc7UUFDMUIsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7S0FFQyxHQUNEYSxZQUFZQyxPQUFPLEVBQUU7UUFDakIsT0FBTzVCLGdEQUFTQSxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUcsS0FB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LElBQUlDLGdCQUFnQlQsUUFBUVUsUUFBUSxLQUFLO0lBQzNGO0FBQ0osRUFDQSw0Q0FBNEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3RvcmFnZS1qcy9kaXN0L21vZHVsZS9wYWNrYWdlcy9TdG9yYWdlQnVja2V0QXBpLmpzP2I1MjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBERUZBVUxUX0hFQURFUlMgfSBmcm9tICcuLi9saWIvY29uc3RhbnRzJztcbmltcG9ydCB7IGlzU3RvcmFnZUVycm9yIH0gZnJvbSAnLi4vbGliL2Vycm9ycyc7XG5pbXBvcnQgeyBnZXQsIHBvc3QsIHB1dCwgcmVtb3ZlIH0gZnJvbSAnLi4vbGliL2ZldGNoJztcbmltcG9ydCB7IHJlc29sdmVGZXRjaCB9IGZyb20gJy4uL2xpYi9oZWxwZXJzJztcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0b3JhZ2VCdWNrZXRBcGkge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycyA9IHt9LCBmZXRjaCwgb3B0cykge1xuICAgICAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGZhbHNlO1xuICAgICAgICBjb25zdCBiYXNlVXJsID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICAvLyBpZiBsZWdhY3kgdXJpIGlzIHVzZWQsIHJlcGxhY2Ugd2l0aCBuZXcgc3RvcmFnZSBob3N0IChkaXNhYmxlcyByZXF1ZXN0IGJ1ZmZlcmluZyB0byBhbGxvdyA+IDUwR0IgdXBsb2FkcylcbiAgICAgICAgLy8gXCJwcm9qZWN0LXJlZi5zdXBhYmFzZS5jb1wiIGJlY29tZXMgXCJwcm9qZWN0LXJlZi5zdG9yYWdlLnN1cGFiYXNlLmNvXCJcbiAgICAgICAgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy51c2VOZXdIb3N0bmFtZSkge1xuICAgICAgICAgICAgY29uc3QgaXNTdXBhYmFzZUhvc3QgPSAvc3VwYWJhc2VcXC4oY298aW58cmVkKSQvLnRlc3QoYmFzZVVybC5ob3N0bmFtZSk7XG4gICAgICAgICAgICBpZiAoaXNTdXBhYmFzZUhvc3QgJiYgIWJhc2VVcmwuaG9zdG5hbWUuaW5jbHVkZXMoJ3N0b3JhZ2Uuc3VwYWJhc2UuJykpIHtcbiAgICAgICAgICAgICAgICBiYXNlVXJsLmhvc3RuYW1lID0gYmFzZVVybC5ob3N0bmFtZS5yZXBsYWNlKCdzdXBhYmFzZS4nLCAnc3RvcmFnZS5zdXBhYmFzZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVybCA9IGJhc2VVcmwuaHJlZi5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfSEVBREVSUyksIGhlYWRlcnMpO1xuICAgICAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRocm93aW5nIGVycm9ycyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVtLlxuICAgICAqL1xuICAgIHRocm93T25FcnJvcigpIHtcbiAgICAgICAgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFsbCBTdG9yYWdlIGJ1Y2tldHMgd2l0aGluIGFuIGV4aXN0aW5nIHByb2plY3QuXG4gICAgICovXG4gICAgbGlzdEJ1Y2tldHMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWVyeVN0cmluZyA9IHRoaXMubGlzdEJ1Y2tldE9wdGlvbnNUb1F1ZXJ5U3RyaW5nKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBnZXQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L2J1Y2tldCR7cXVlcnlTdHJpbmd9YCwge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZGV0YWlscyBvZiBhbiBleGlzdGluZyBTdG9yYWdlIGJ1Y2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIGJ1Y2tldCB5b3Ugd291bGQgbGlrZSB0byByZXRyaWV2ZS5cbiAgICAgKi9cbiAgICBnZXRCdWNrZXQoaWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIGdldCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU3RvcmFnZSBidWNrZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYnVja2V0IHlvdSBhcmUgY3JlYXRpbmcuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucHVibGljIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidWNrZXQuIFB1YmxpYyBidWNrZXRzIGRvbid0IHJlcXVpcmUgYW4gYXV0aG9yaXphdGlvbiB0b2tlbiB0byBkb3dubG9hZCBvYmplY3RzLCBidXQgc3RpbGwgcmVxdWlyZSBhIHZhbGlkIHRva2VuIGZvciBhbGwgb3RoZXIgb3BlcmF0aW9ucy4gQnkgZGVmYXVsdCwgYnVja2V0cyBhcmUgcHJpdmF0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5maWxlU2l6ZUxpbWl0IHNwZWNpZmllcyB0aGUgbWF4IGZpbGUgc2l6ZSBpbiBieXRlcyB0aGF0IGNhbiBiZSB1cGxvYWRlZCB0byB0aGlzIGJ1Y2tldC5cbiAgICAgKiBUaGUgZ2xvYmFsIGZpbGUgc2l6ZSBsaW1pdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcyB2YWx1ZS5cbiAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBkb2Vzbid0IHNldCBhIHBlciBidWNrZXQgZmlsZSBzaXplIGxpbWl0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMgc3BlY2lmaWVzIHRoZSBhbGxvd2VkIG1pbWUgdHlwZXMgdGhhdCB0aGlzIGJ1Y2tldCBjYW4gYWNjZXB0IGR1cmluZyB1cGxvYWQuXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggYWxsb3dzIGZpbGVzIHdpdGggYWxsIG1pbWUgdHlwZXMgdG8gYmUgdXBsb2FkZWQuXG4gICAgICogRWFjaCBtaW1lIHR5cGUgc3BlY2lmaWVkIGNhbiBiZSBhIHdpbGRjYXJkLCBlLmcuIGltYWdlLyosIG9yIGEgc3BlY2lmaWMgbWltZSB0eXBlLCBlLmcuIGltYWdlL3BuZy5cbiAgICAgKiBAcmV0dXJucyBuZXdseSBjcmVhdGVkIGJ1Y2tldCBpZFxuICAgICAqIEBwYXJhbSBvcHRpb25zLnR5cGUgKHByaXZhdGUtYmV0YSkgc3BlY2lmaWVzIHRoZSBidWNrZXQgdHlwZS4gc2VlIGBCdWNrZXRUeXBlYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqICAgLSBkZWZhdWx0IGJ1Y2tldCB0eXBlIGlzIGBTVEFOREFSRGBcbiAgICAgKi9cbiAgICBjcmVhdGVCdWNrZXQoaWRfMSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiogKGlkLCBvcHRpb25zID0ge1xuICAgICAgICAgICAgcHVibGljOiBmYWxzZSxcbiAgICAgICAgfSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0YCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcHVibGljOiBvcHRpb25zLnB1YmxpYyxcbiAgICAgICAgICAgICAgICAgICAgZmlsZV9zaXplX2xpbWl0OiBvcHRpb25zLmZpbGVTaXplTGltaXQsXG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWRfbWltZV90eXBlczogb3B0aW9ucy5hbGxvd2VkTWltZVR5cGVzLFxuICAgICAgICAgICAgICAgIH0sIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgU3RvcmFnZSBidWNrZXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBBIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgYnVja2V0IHlvdSBhcmUgdXBkYXRpbmcuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucHVibGljIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBidWNrZXQuIFB1YmxpYyBidWNrZXRzIGRvbid0IHJlcXVpcmUgYW4gYXV0aG9yaXphdGlvbiB0b2tlbiB0byBkb3dubG9hZCBvYmplY3RzLCBidXQgc3RpbGwgcmVxdWlyZSBhIHZhbGlkIHRva2VuIGZvciBhbGwgb3RoZXIgb3BlcmF0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5maWxlU2l6ZUxpbWl0IHNwZWNpZmllcyB0aGUgbWF4IGZpbGUgc2l6ZSBpbiBieXRlcyB0aGF0IGNhbiBiZSB1cGxvYWRlZCB0byB0aGlzIGJ1Y2tldC5cbiAgICAgKiBUaGUgZ2xvYmFsIGZpbGUgc2l6ZSBsaW1pdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgdGhpcyB2YWx1ZS5cbiAgICAgKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBudWxsLCB3aGljaCBkb2Vzbid0IHNldCBhIHBlciBidWNrZXQgZmlsZSBzaXplIGxpbWl0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFsbG93ZWRNaW1lVHlwZXMgc3BlY2lmaWVzIHRoZSBhbGxvd2VkIG1pbWUgdHlwZXMgdGhhdCB0aGlzIGJ1Y2tldCBjYW4gYWNjZXB0IGR1cmluZyB1cGxvYWQuXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgbnVsbCwgd2hpY2ggYWxsb3dzIGZpbGVzIHdpdGggYWxsIG1pbWUgdHlwZXMgdG8gYmUgdXBsb2FkZWQuXG4gICAgICogRWFjaCBtaW1lIHR5cGUgc3BlY2lmaWVkIGNhbiBiZSBhIHdpbGRjYXJkLCBlLmcuIGltYWdlLyosIG9yIGEgc3BlY2lmaWMgbWltZSB0eXBlLCBlLmcuIGltYWdlL3BuZy5cbiAgICAgKi9cbiAgICB1cGRhdGVCdWNrZXQoaWQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHB1dCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vYnVja2V0LyR7aWR9YCwge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogaWQsXG4gICAgICAgICAgICAgICAgICAgIHB1YmxpYzogb3B0aW9ucy5wdWJsaWMsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVfc2l6ZV9saW1pdDogb3B0aW9ucy5maWxlU2l6ZUxpbWl0LFxuICAgICAgICAgICAgICAgICAgICBhbGxvd2VkX21pbWVfdHlwZXM6IG9wdGlvbnMuYWxsb3dlZE1pbWVUeXBlcyxcbiAgICAgICAgICAgICAgICB9LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgb2JqZWN0cyBpbnNpZGUgYSBzaW5nbGUgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIFRoZSB1bmlxdWUgaWRlbnRpZmllciBvZiB0aGUgYnVja2V0IHlvdSB3b3VsZCBsaWtlIHRvIGVtcHR5LlxuICAgICAqL1xuICAgIGVtcHR5QnVja2V0KGlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH0vZW1wdHlgLCB7fSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYW4gZXhpc3RpbmcgYnVja2V0LiBBIGJ1Y2tldCBjYW4ndCBiZSBkZWxldGVkIHdpdGggZXhpc3Rpbmcgb2JqZWN0cyBpbnNpZGUgaXQuXG4gICAgICogWW91IG11c3QgZmlyc3QgYGVtcHR5KClgIHRoZSBidWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgVGhlIHVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSBidWNrZXQgeW91IHdvdWxkIGxpa2UgdG8gZGVsZXRlLlxuICAgICAqL1xuICAgIGRlbGV0ZUJ1Y2tldChpZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcmVtb3ZlKHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9idWNrZXQvJHtpZH1gLCB7fSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3RCdWNrZXRPcHRpb25zVG9RdWVyeVN0cmluZyhvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCdsaW1pdCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5saW1pdCA9IFN0cmluZyhvcHRpb25zLmxpbWl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnb2Zmc2V0JyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLm9mZnNldCA9IFN0cmluZyhvcHRpb25zLm9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zZWFyY2gpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc2VhcmNoID0gb3B0aW9ucy5zZWFyY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zb3J0Q29sdW1uKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnNvcnRDb2x1bW4gPSBvcHRpb25zLnNvcnRDb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zb3J0T3JkZXIpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc29ydE9yZGVyID0gb3B0aW9ucy5zb3J0T3JkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID4gMCA/ICc/JyArIG5ldyBVUkxTZWFyY2hQYXJhbXMocGFyYW1zKS50b1N0cmluZygpIDogJyc7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RvcmFnZUJ1Y2tldEFwaS5qcy5tYXAiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwiREVGQVVMVF9IRUFERVJTIiwiaXNTdG9yYWdlRXJyb3IiLCJnZXQiLCJwb3N0IiwicHV0IiwicmVtb3ZlIiwicmVzb2x2ZUZldGNoIiwiU3RvcmFnZUJ1Y2tldEFwaSIsImNvbnN0cnVjdG9yIiwidXJsIiwiaGVhZGVycyIsImZldGNoIiwib3B0cyIsInNob3VsZFRocm93T25FcnJvciIsImJhc2VVcmwiLCJVUkwiLCJ1c2VOZXdIb3N0bmFtZSIsImlzU3VwYWJhc2VIb3N0IiwidGVzdCIsImhvc3RuYW1lIiwiaW5jbHVkZXMiLCJyZXBsYWNlIiwiaHJlZiIsIk9iamVjdCIsImFzc2lnbiIsInRocm93T25FcnJvciIsImxpc3RCdWNrZXRzIiwib3B0aW9ucyIsInF1ZXJ5U3RyaW5nIiwibGlzdEJ1Y2tldE9wdGlvbnNUb1F1ZXJ5U3RyaW5nIiwiZGF0YSIsImVycm9yIiwiZ2V0QnVja2V0IiwiaWQiLCJjcmVhdGVCdWNrZXQiLCJpZF8xIiwiYXJndW1lbnRzIiwicHVibGljIiwibmFtZSIsInR5cGUiLCJmaWxlX3NpemVfbGltaXQiLCJmaWxlU2l6ZUxpbWl0IiwiYWxsb3dlZF9taW1lX3R5cGVzIiwiYWxsb3dlZE1pbWVUeXBlcyIsInVwZGF0ZUJ1Y2tldCIsImVtcHR5QnVja2V0IiwiZGVsZXRlQnVja2V0IiwicGFyYW1zIiwibGltaXQiLCJTdHJpbmciLCJvZmZzZXQiLCJzZWFyY2giLCJzb3J0Q29sdW1uIiwic29ydE9yZGVyIiwia2V5cyIsImxlbmd0aCIsIlVSTFNlYXJjaFBhcmFtcyIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StorageBucketApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StorageFileApi)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/errors */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/fetch */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/helpers */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _BlobDownloadBuilder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BlobDownloadBuilder */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/BlobDownloadBuilder.js\");\n\n\n\n\n\nconst DEFAULT_SEARCH_OPTIONS = {\n    limit: 100,\n    offset: 0,\n    sortBy: {\n        column: \"name\",\n        order: \"asc\"\n    }\n};\nconst DEFAULT_FILE_OPTIONS = {\n    cacheControl: \"3600\",\n    contentType: \"text/plain;charset=UTF-8\",\n    upsert: false\n};\nclass StorageFileApi {\n    constructor(url, headers = {}, bucketId, fetch){\n        this.shouldThrowOnError = false;\n        this.url = url;\n        this.headers = headers;\n        this.bucketId = bucketId;\n        this.fetch = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_0__.resolveFetch)(fetch);\n    }\n    /**\n     * Enable throwing errors instead of returning them.\n     */ throwOnError() {\n        this.shouldThrowOnError = true;\n        return this;\n    }\n    /**\n     * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n     *\n     * @param method HTTP method.\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */ uploadOrUpdate(method, path, fileBody, fileOptions) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                let body;\n                const options = Object.assign(Object.assign({}, DEFAULT_FILE_OPTIONS), fileOptions);\n                let headers = Object.assign(Object.assign({}, this.headers), method === \"POST\" && {\n                    \"x-upsert\": String(options.upsert)\n                });\n                const metadata = options.metadata;\n                if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                    body = new FormData();\n                    body.append(\"cacheControl\", options.cacheControl);\n                    if (metadata) {\n                        body.append(\"metadata\", this.encodeMetadata(metadata));\n                    }\n                    body.append(\"\", fileBody);\n                } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                    body = fileBody;\n                    body.append(\"cacheControl\", options.cacheControl);\n                    if (metadata) {\n                        body.append(\"metadata\", this.encodeMetadata(metadata));\n                    }\n                } else {\n                    body = fileBody;\n                    headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                    headers[\"content-type\"] = options.contentType;\n                    if (metadata) {\n                        headers[\"x-metadata\"] = this.toBase64(this.encodeMetadata(metadata));\n                    }\n                }\n                if (fileOptions === null || fileOptions === void 0 ? void 0 : fileOptions.headers) {\n                    headers = Object.assign(Object.assign({}, headers), fileOptions.headers);\n                }\n                const cleanPath = this._removeEmptyFolders(path);\n                const _path = this._getFinalPath(cleanPath);\n                const data = yield (method == \"PUT\" ? _lib_fetch__WEBPACK_IMPORTED_MODULE_2__.put : _lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/${_path}`, body, Object.assign({\n                    headers\n                }, (options === null || options === void 0 ? void 0 : options.duplex) ? {\n                    duplex: options.duplex\n                } : {}));\n                return {\n                    data: {\n                        path: cleanPath,\n                        id: data.Id,\n                        fullPath: data.Key\n                    },\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Uploads a file to an existing bucket.\n     *\n     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */ upload(path, fileBody, fileOptions) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {\n            return this.uploadOrUpdate(\"POST\", path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Upload a file with a token generated from `createSignedUploadUrl`.\n     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param token The token generated from `createSignedUploadUrl`\n     * @param fileBody The body of the file to be stored in the bucket.\n     */ uploadToSignedUrl(path, token, fileBody, fileOptions) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {\n            const cleanPath = this._removeEmptyFolders(path);\n            const _path = this._getFinalPath(cleanPath);\n            const url = new URL(this.url + `/object/upload/sign/${_path}`);\n            url.searchParams.set(\"token\", token);\n            try {\n                let body;\n                const options = Object.assign({\n                    upsert: DEFAULT_FILE_OPTIONS.upsert\n                }, fileOptions);\n                const headers = Object.assign(Object.assign({}, this.headers), {\n                    \"x-upsert\": String(options.upsert)\n                });\n                if (typeof Blob !== \"undefined\" && fileBody instanceof Blob) {\n                    body = new FormData();\n                    body.append(\"cacheControl\", options.cacheControl);\n                    body.append(\"\", fileBody);\n                } else if (typeof FormData !== \"undefined\" && fileBody instanceof FormData) {\n                    body = fileBody;\n                    body.append(\"cacheControl\", options.cacheControl);\n                } else {\n                    body = fileBody;\n                    headers[\"cache-control\"] = `max-age=${options.cacheControl}`;\n                    headers[\"content-type\"] = options.contentType;\n                }\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.put)(this.fetch, url.toString(), body, {\n                    headers\n                });\n                return {\n                    data: {\n                        path: cleanPath,\n                        fullPath: data.Key\n                    },\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a signed upload URL.\n     * Signed upload URLs can be used to upload files to the bucket without further authentication.\n     * They are valid for 2 hours.\n     * @param path The file path, including the current file name. For example `folder/image.png`.\n     * @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n     */ createSignedUploadUrl(path, options) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                let _path = this._getFinalPath(path);\n                const headers = Object.assign({}, this.headers);\n                if (options === null || options === void 0 ? void 0 : options.upsert) {\n                    headers[\"x-upsert\"] = \"true\";\n                }\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/upload/sign/${_path}`, {}, {\n                    headers\n                });\n                const url = new URL(this.url + data.url);\n                const token = url.searchParams.get(\"token\");\n                if (!token) {\n                    throw new _lib_errors__WEBPACK_IMPORTED_MODULE_3__.StorageError(\"No token returned by API\");\n                }\n                return {\n                    data: {\n                        signedUrl: url.toString(),\n                        path,\n                        token\n                    },\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Replaces an existing file at the specified path with a new one.\n     *\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */ update(path, fileBody, fileOptions) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {\n            return this.uploadOrUpdate(\"PUT\", path, fileBody, fileOptions);\n        });\n    }\n    /**\n     * Moves an existing file to a new path in the same bucket.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n     * @param options The destination options.\n     */ move(fromPath, toPath, options) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/move`, {\n                    bucketId: this.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Copies an existing file to a new path in the same bucket.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n     * @param options The destination options.\n     */ copy(fromPath, toPath, options) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/copy`, {\n                    bucketId: this.bucketId,\n                    sourceKey: fromPath,\n                    destinationKey: toPath,\n                    destinationBucket: options === null || options === void 0 ? void 0 : options.destinationBucket\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data: {\n                        path: data.Key\n                    },\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n     *\n     * @param path The file path, including the current file name. For example `folder/image.png`.\n     * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     * @param options.transform Transform the asset before serving it to the client.\n     */ createSignedUrl(path, expiresIn, options) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                let _path = this._getFinalPath(path);\n                let data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/sign/${_path}`, Object.assign({\n                    expiresIn\n                }, (options === null || options === void 0 ? void 0 : options.transform) ? {\n                    transform: options.transform\n                } : {}), {\n                    headers: this.headers\n                });\n                const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n                const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);\n                data = {\n                    signedUrl\n                };\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n     *\n     * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n     * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     */ createSignedUrls(paths, expiresIn, options) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/sign/${this.bucketId}`, {\n                    expiresIn,\n                    paths\n                }, {\n                    headers: this.headers\n                });\n                const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `&download=${options.download === true ? \"\" : options.download}` : \"\";\n                return {\n                    data: data.map((datum)=>Object.assign(Object.assign({}, datum), {\n                            signedUrl: datum.signedURL ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`) : null\n                        })),\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n     *\n     * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n     * @param options.transform Transform the asset before serving it to the client.\n     */ download(path, options) {\n        const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\";\n        const renderPath = wantsTransformation ? \"render/image/authenticated\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        const queryString = transformationQuery ? `?${transformationQuery}` : \"\";\n        const _path = this._getFinalPath(path);\n        const downloadFn = ()=>(0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n                headers: this.headers,\n                noResolveJson: true\n            });\n        return new _BlobDownloadBuilder__WEBPACK_IMPORTED_MODULE_4__[\"default\"](downloadFn, this.shouldThrowOnError);\n    }\n    /**\n     * Retrieves the details of an existing file.\n     * @param path\n     */ info(path) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {\n            const _path = this._getFinalPath(path);\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.get)(this.fetch, `${this.url}/object/info/${_path}`, {\n                    headers: this.headers\n                });\n                return {\n                    data: (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_0__.recursiveToCamel)(data),\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Checks the existence of a file.\n     * @param path\n     */ exists(path) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {\n            const _path = this._getFinalPath(path);\n            try {\n                yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.head)(this.fetch, `${this.url}/object/${_path}`, {\n                    headers: this.headers\n                });\n                return {\n                    data: true,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error) && error instanceof _lib_errors__WEBPACK_IMPORTED_MODULE_3__.StorageUnknownError) {\n                    const originalError = error.originalError;\n                    if ([\n                        400,\n                        404\n                    ].includes(originalError === null || originalError === void 0 ? void 0 : originalError.status)) {\n                        return {\n                            data: false,\n                            error\n                        };\n                    }\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n     * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n     *\n     * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n     * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     * @param options.transform Transform the asset before serving it to the client.\n     */ getPublicUrl(path, options) {\n        const _path = this._getFinalPath(path);\n        const _queryString = [];\n        const downloadQueryParam = (options === null || options === void 0 ? void 0 : options.download) ? `download=${options.download === true ? \"\" : options.download}` : \"\";\n        if (downloadQueryParam !== \"\") {\n            _queryString.push(downloadQueryParam);\n        }\n        const wantsTransformation = typeof (options === null || options === void 0 ? void 0 : options.transform) !== \"undefined\";\n        const renderPath = wantsTransformation ? \"render/image\" : \"object\";\n        const transformationQuery = this.transformOptsToQueryString((options === null || options === void 0 ? void 0 : options.transform) || {});\n        if (transformationQuery !== \"\") {\n            _queryString.push(transformationQuery);\n        }\n        let queryString = _queryString.join(\"&\");\n        if (queryString !== \"\") {\n            queryString = `?${queryString}`;\n        }\n        return {\n            data: {\n                publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`)\n            }\n        };\n    }\n    /**\n     * Deletes files within the same bucket\n     *\n     * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n     */ remove(paths) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.remove)(this.fetch, `${this.url}/object/${this.bucketId}`, {\n                    prefixes: paths\n                }, {\n                    headers: this.headers\n                });\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * Get file metadata\n     * @param id the file id to retrieve metadata\n     */ // async getMetadata(\n    //   id: string\n    // ): Promise<\n    //   | {\n    //       data: Metadata\n    //       error: null\n    //     }\n    //   | {\n    //       data: null\n    //       error: StorageError\n    //     }\n    // > {\n    //   try {\n    //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     if (isStorageError(error)) {\n    //       return { data: null, error }\n    //     }\n    //     throw error\n    //   }\n    // }\n    /**\n     * Update file metadata\n     * @param id the file id to update metadata\n     * @param meta the new file metadata\n     */ // async updateMetadata(\n    //   id: string,\n    //   meta: Metadata\n    // ): Promise<\n    //   | {\n    //       data: Metadata\n    //       error: null\n    //     }\n    //   | {\n    //       data: null\n    //       error: StorageError\n    //     }\n    // > {\n    //   try {\n    //     const data = await post(\n    //       this.fetch,\n    //       `${this.url}/metadata/${id}`,\n    //       { ...meta },\n    //       { headers: this.headers }\n    //     )\n    //     return { data, error: null }\n    //   } catch (error) {\n    //     if (isStorageError(error)) {\n    //       return { data: null, error }\n    //     }\n    //     throw error\n    //   }\n    // }\n    /**\n     * Lists all the files and folders within a path of the bucket.\n     * @param path The folder path.\n     * @param options Search options including limit (defaults to 100), offset, sortBy, and search\n     */ list(path, options, parameters) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const body = Object.assign(Object.assign(Object.assign({}, DEFAULT_SEARCH_OPTIONS), options), {\n                    prefix: path || \"\"\n                });\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/list/${this.bucketId}`, body, {\n                    headers: this.headers\n                }, parameters);\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    /**\n     * @experimental this method signature might change in the future\n     * @param options search options\n     * @param parameters\n     */ listV2(options, parameters) {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const body = Object.assign({}, options);\n                const data = yield (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_2__.post)(this.fetch, `${this.url}/object/list-v2/${this.bucketId}`, body, {\n                    headers: this.headers\n                }, parameters);\n                return {\n                    data,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_3__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n    encodeMetadata(metadata) {\n        return JSON.stringify(metadata);\n    }\n    toBase64(data) {\n        if (typeof Buffer !== \"undefined\") {\n            return Buffer.from(data).toString(\"base64\");\n        }\n        return btoa(data);\n    }\n    _getFinalPath(path) {\n        return `${this.bucketId}/${path.replace(/^\\/+/, \"\")}`;\n    }\n    _removeEmptyFolders(path) {\n        return path.replace(/^\\/|\\/$/g, \"\").replace(/\\/+/g, \"/\");\n    }\n    transformOptsToQueryString(transform) {\n        const params = [];\n        if (transform.width) {\n            params.push(`width=${transform.width}`);\n        }\n        if (transform.height) {\n            params.push(`height=${transform.height}`);\n        }\n        if (transform.resize) {\n            params.push(`resize=${transform.resize}`);\n        }\n        if (transform.format) {\n            params.push(`format=${transform.format}`);\n        }\n        if (transform.quality) {\n            params.push(`quality=${transform.quality}`);\n        }\n        return params.join(\"&\");\n    }\n} //# sourceMappingURL=StorageFileApi.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvcGFja2FnZXMvU3RvcmFnZUZpbGVBcGkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtDO0FBQ2dEO0FBQ3RCO0FBQ0k7QUFDUjtBQUN4RCxNQUFNWSx5QkFBeUI7SUFDM0JDLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxRQUFRO1FBQ0pDLFFBQVE7UUFDUkMsT0FBTztJQUNYO0FBQ0o7QUFDQSxNQUFNQyx1QkFBdUI7SUFDekJDLGNBQWM7SUFDZEMsYUFBYTtJQUNiQyxRQUFRO0FBQ1o7QUFDZSxNQUFNQztJQUNqQkMsWUFBWUMsR0FBRyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxFQUFFQyxRQUFRLEVBQUVDLEtBQUssQ0FBRTtRQUM1QyxJQUFJLENBQUNDLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ0osR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUNDLEtBQUssR0FBR2pCLDBEQUFZQSxDQUFDaUI7SUFDOUI7SUFDQTs7S0FFQyxHQUNERSxlQUFlO1FBQ1gsSUFBSSxDQUFDRCxrQkFBa0IsR0FBRztRQUMxQixPQUFPLElBQUk7SUFDZjtJQUNBOzs7Ozs7S0FNQyxHQUNERSxlQUFlQyxNQUFNLEVBQUVDLElBQUksRUFBRUMsUUFBUSxFQUFFQyxXQUFXLEVBQUU7UUFDaEQsT0FBT2xDLGdEQUFTQSxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUk7Z0JBQ0EsSUFBSW1DO2dCQUNKLE1BQU1DLFVBQVVDLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR3BCLHVCQUF1QmdCO2dCQUN2RSxJQUFJVCxVQUFVWSxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDYixPQUFP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WSxJQUFJQSxPQUFPLENBQUMsUUFBUTtJQUN4RDtJQUNBeEIsMkJBQTJCWixTQUFTLEVBQUU7UUFDbEMsTUFBTXFDLFNBQVMsRUFBRTtRQUNqQixJQUFJckMsVUFBVXNDLEtBQUssRUFBRTtZQUNqQkQsT0FBT2QsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFdkIsVUFBVXNDLEtBQUssQ0FBQyxDQUFDO1FBQzFDO1FBQ0EsSUFBSXRDLFVBQVV1QyxNQUFNLEVBQUU7WUFDbEJGLE9BQU9kLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRXZCLFVBQVV1QyxNQUFNLENBQUMsQ0FBQztRQUM1QztRQUNBLElBQUl2QyxVQUFVd0MsTUFBTSxFQUFFO1lBQ2xCSCxPQUFPZCxJQUFJLENBQUMsQ0FBQyxPQUFPLEVBQUV2QixVQUFVd0MsTUFBTSxDQUFDLENBQUM7UUFDNUM7UUFDQSxJQUFJeEMsVUFBVXlDLE1BQU0sRUFBRTtZQUNsQkosT0FBT2QsSUFBSSxDQUFDLENBQUMsT0FBTyxFQUFFdkIsVUFBVXlDLE1BQU0sQ0FBQyxDQUFDO1FBQzVDO1FBQ0EsSUFBSXpDLFVBQVUwQyxPQUFPLEVBQUU7WUFDbkJMLE9BQU9kLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRXZCLFVBQVUwQyxPQUFPLENBQUMsQ0FBQztRQUM5QztRQUNBLE9BQU9MLE9BQU9iLElBQUksQ0FBQztJQUN2QjtBQUNKLEVBQ0EsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvcGFja2FnZXMvU3RvcmFnZUZpbGVBcGkuanM/MTU4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBfX2F3YWl0ZXIgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGlzU3RvcmFnZUVycm9yLCBTdG9yYWdlRXJyb3IsIFN0b3JhZ2VVbmtub3duRXJyb3IgfSBmcm9tICcuLi9saWIvZXJyb3JzJztcbmltcG9ydCB7IGdldCwgaGVhZCwgcG9zdCwgcHV0LCByZW1vdmUgfSBmcm9tICcuLi9saWIvZmV0Y2gnO1xuaW1wb3J0IHsgcmVjdXJzaXZlVG9DYW1lbCwgcmVzb2x2ZUZldGNoIH0gZnJvbSAnLi4vbGliL2hlbHBlcnMnO1xuaW1wb3J0IEJsb2JEb3dubG9hZEJ1aWxkZXIgZnJvbSAnLi9CbG9iRG93bmxvYWRCdWlsZGVyJztcbmNvbnN0IERFRkFVTFRfU0VBUkNIX09QVElPTlMgPSB7XG4gICAgbGltaXQ6IDEwMCxcbiAgICBvZmZzZXQ6IDAsXG4gICAgc29ydEJ5OiB7XG4gICAgICAgIGNvbHVtbjogJ25hbWUnLFxuICAgICAgICBvcmRlcjogJ2FzYycsXG4gICAgfSxcbn07XG5jb25zdCBERUZBVUxUX0ZJTEVfT1BUSU9OUyA9IHtcbiAgICBjYWNoZUNvbnRyb2w6ICczNjAwJyxcbiAgICBjb250ZW50VHlwZTogJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcsXG4gICAgdXBzZXJ0OiBmYWxzZSxcbn07XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdG9yYWdlRmlsZUFwaSB7XG4gICAgY29uc3RydWN0b3IodXJsLCBoZWFkZXJzID0ge30sIGJ1Y2tldElkLCBmZXRjaCkge1xuICAgICAgICB0aGlzLnNob3VsZFRocm93T25FcnJvciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5idWNrZXRJZCA9IGJ1Y2tldElkO1xuICAgICAgICB0aGlzLmZldGNoID0gcmVzb2x2ZUZldGNoKGZldGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIHRocm93aW5nIGVycm9ycyBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGVtLlxuICAgICAqL1xuICAgIHRocm93T25FcnJvcigpIHtcbiAgICAgICAgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyBhIGZpbGUgdG8gYW4gZXhpc3RpbmcgYnVja2V0IG9yIHJlcGxhY2VzIGFuIGV4aXN0aW5nIGZpbGUgYXQgdGhlIHNwZWNpZmllZCBwYXRoIHdpdGggYSBuZXcgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldGhvZCBIVFRQIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcmVsYXRpdmUgZmlsZSBwYXRoLiBTaG91bGQgYmUgb2YgdGhlIGZvcm1hdCBgZm9sZGVyL3N1YmZvbGRlci9maWxlbmFtZS5wbmdgLiBUaGUgYnVja2V0IG11c3QgYWxyZWFkeSBleGlzdCBiZWZvcmUgYXR0ZW1wdGluZyB0byB1cGxvYWQuXG4gICAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgICAqL1xuICAgIHVwbG9hZE9yVXBkYXRlKG1ldGhvZCwgcGF0aCwgZmlsZUJvZHksIGZpbGVPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBib2R5O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfRklMRV9PUFRJT05TKSwgZmlsZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGxldCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMpLCAobWV0aG9kID09PSAnUE9TVCcgJiYgeyAneC11cHNlcnQnOiBTdHJpbmcob3B0aW9ucy51cHNlcnQpIH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG9wdGlvbnMubWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCdtZXRhZGF0YScsIHRoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgnJywgZmlsZUJvZHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnICYmIGZpbGVCb2R5IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZpbGVCb2R5O1xuICAgICAgICAgICAgICAgICAgICBib2R5LmFwcGVuZCgnY2FjaGVDb250cm9sJywgb3B0aW9ucy5jYWNoZUNvbnRyb2wpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkuYXBwZW5kKCdtZXRhZGF0YScsIHRoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSA9IGZpbGVCb2R5O1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydjYWNoZS1jb250cm9sJ10gPSBgbWF4LWFnZT0ke29wdGlvbnMuY2FjaGVDb250cm9sfWA7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gb3B0aW9ucy5jb250ZW50VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWyd4LW1ldGFkYXRhJ10gPSB0aGlzLnRvQmFzZTY0KHRoaXMuZW5jb2RlTWV0YWRhdGEobWV0YWRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsZU9wdGlvbnMgPT09IG51bGwgfHwgZmlsZU9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbGVPcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaGVhZGVycyksIGZpbGVPcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjbGVhblBhdGggPSB0aGlzLl9yZW1vdmVFbXB0eUZvbGRlcnMocGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgoY2xlYW5QYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgKG1ldGhvZCA9PSAnUFVUJyA/IHB1dCA6IHBvc3QpKHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvJHtfcGF0aH1gLCBib2R5LCBPYmplY3QuYXNzaWduKHsgaGVhZGVycyB9LCAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kdXBsZXgpID8geyBkdXBsZXg6IG9wdGlvbnMuZHVwbGV4IH0gOiB7fSkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHBhdGg6IGNsZWFuUGF0aCwgaWQ6IGRhdGEuSWQsIGZ1bGxQYXRoOiBkYXRhLktleSB9LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyBhIGZpbGUgdG8gYW4gZXhpc3RpbmcgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBmaWxlIG5hbWUuIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwbG9hZC5cbiAgICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAgICovXG4gICAgdXBsb2FkKHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBsb2FkT3JVcGRhdGUoJ1BPU1QnLCBwYXRoLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkIGEgZmlsZSB3aXRoIGEgdG9rZW4gZ2VuZXJhdGVkIGZyb20gYGNyZWF0ZVNpZ25lZFVwbG9hZFVybGAuXG4gICAgICogQHBhcmFtIHBhdGggVGhlIGZpbGUgcGF0aCwgaW5jbHVkaW5nIHRoZSBmaWxlIG5hbWUuIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwbG9hZC5cbiAgICAgKiBAcGFyYW0gdG9rZW4gVGhlIHRva2VuIGdlbmVyYXRlZCBmcm9tIGBjcmVhdGVTaWduZWRVcGxvYWRVcmxgXG4gICAgICogQHBhcmFtIGZpbGVCb2R5IFRoZSBib2R5IG9mIHRoZSBmaWxlIHRvIGJlIHN0b3JlZCBpbiB0aGUgYnVja2V0LlxuICAgICAqL1xuICAgIHVwbG9hZFRvU2lnbmVkVXJsKHBhdGgsIHRva2VuLCBmaWxlQm9keSwgZmlsZU9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsZWFuUGF0aCA9IHRoaXMuX3JlbW92ZUVtcHR5Rm9sZGVycyhwYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKGNsZWFuUGF0aCk7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHRoaXMudXJsICsgYC9vYmplY3QvdXBsb2FkL3NpZ24vJHtfcGF0aH1gKTtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCd0b2tlbicsIHRva2VuKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGJvZHk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyB1cHNlcnQ6IERFRkFVTFRfRklMRV9PUFRJT05TLnVwc2VydCB9LCBmaWxlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5oZWFkZXJzKSwgeyAneC11cHNlcnQnOiBTdHJpbmcob3B0aW9ucy51cHNlcnQpIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCcgJiYgZmlsZUJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5hcHBlbmQoJ2NhY2hlQ29udHJvbCcsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5hcHBlbmQoJycsIGZpbGVCb2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJyAmJiBmaWxlQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmaWxlQm9keTtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5hcHBlbmQoJ2NhY2hlQ29udHJvbCcsIG9wdGlvbnMuY2FjaGVDb250cm9sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSBmaWxlQm9keTtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1snY2FjaGUtY29udHJvbCddID0gYG1heC1hZ2U9JHtvcHRpb25zLmNhY2hlQ29udHJvbH1gO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IG9wdGlvbnMuY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwdXQodGhpcy5mZXRjaCwgdXJsLnRvU3RyaW5nKCksIGJvZHksIHsgaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHBhdGg6IGNsZWFuUGF0aCwgZnVsbFBhdGg6IGRhdGEuS2V5IH0sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2lnbmVkIHVwbG9hZCBVUkwuXG4gICAgICogU2lnbmVkIHVwbG9hZCBVUkxzIGNhbiBiZSB1c2VkIHRvIHVwbG9hZCBmaWxlcyB0byB0aGUgYnVja2V0IHdpdGhvdXQgZnVydGhlciBhdXRoZW50aWNhdGlvbi5cbiAgICAgKiBUaGV5IGFyZSB2YWxpZCBmb3IgMiBob3Vycy5cbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIGN1cnJlbnQgZmlsZSBuYW1lLiBGb3IgZXhhbXBsZSBgZm9sZGVyL2ltYWdlLnBuZ2AuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudXBzZXJ0IElmIHNldCB0byB0cnVlLCBhbGxvd3MgdGhlIGZpbGUgdG8gYmUgb3ZlcndyaXR0ZW4gaWYgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAgICovXG4gICAgY3JlYXRlU2lnbmVkVXBsb2FkVXJsKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudXBzZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ3gtdXBzZXJ0J10gPSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvdXBsb2FkL3NpZ24vJHtfcGF0aH1gLCB7fSwgeyBoZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGhpcy51cmwgKyBkYXRhLnVybCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB1cmwuc2VhcmNoUGFyYW1zLmdldCgndG9rZW4nKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTdG9yYWdlRXJyb3IoJ05vIHRva2VuIHJldHVybmVkIGJ5IEFQSScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiB7IHNpZ25lZFVybDogdXJsLnRvU3RyaW5nKCksIHBhdGgsIHRva2VuIH0sIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbiBleGlzdGluZyBmaWxlIGF0IHRoZSBzcGVjaWZpZWQgcGF0aCB3aXRoIGEgbmV3IG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSByZWxhdGl2ZSBmaWxlIHBhdGguIFNob3VsZCBiZSBvZiB0aGUgZm9ybWF0IGBmb2xkZXIvc3ViZm9sZGVyL2ZpbGVuYW1lLnBuZ2AuIFRoZSBidWNrZXQgbXVzdCBhbHJlYWR5IGV4aXN0IGJlZm9yZSBhdHRlbXB0aW5nIHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0gZmlsZUJvZHkgVGhlIGJvZHkgb2YgdGhlIGZpbGUgdG8gYmUgc3RvcmVkIGluIHRoZSBidWNrZXQuXG4gICAgICovXG4gICAgdXBkYXRlKHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBsb2FkT3JVcGRhdGUoJ1BVVCcsIHBhdGgsIGZpbGVCb2R5LCBmaWxlT3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3ZlcyBhbiBleGlzdGluZyBmaWxlIHRvIGEgbmV3IHBhdGggaW4gdGhlIHNhbWUgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb21QYXRoIFRoZSBvcmlnaW5hbCBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICAgKiBAcGFyYW0gdG9QYXRoIFRoZSBuZXcgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIG5ldyBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UtbmV3LnBuZ2AuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGRlc3RpbmF0aW9uIG9wdGlvbnMuXG4gICAgICovXG4gICAgbW92ZShmcm9tUGF0aCwgdG9QYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvbW92ZWAsIHtcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0SWQ6IHRoaXMuYnVja2V0SWQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZUtleTogZnJvbVBhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uS2V5OiB0b1BhdGgsXG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uQnVja2V0OiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25CdWNrZXQsXG4gICAgICAgICAgICAgICAgfSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvcGllcyBhbiBleGlzdGluZyBmaWxlIHRvIGEgbmV3IHBhdGggaW4gdGhlIHNhbWUgYnVja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb21QYXRoIFRoZSBvcmlnaW5hbCBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICAgKiBAcGFyYW0gdG9QYXRoIFRoZSBuZXcgZmlsZSBwYXRoLCBpbmNsdWRpbmcgdGhlIG5ldyBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UtY29weS5wbmdgLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFRoZSBkZXN0aW5hdGlvbiBvcHRpb25zLlxuICAgICAqL1xuICAgIGNvcHkoZnJvbVBhdGgsIHRvUGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0L2NvcHlgLCB7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldElkOiB0aGlzLmJ1Y2tldElkLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VLZXk6IGZyb21QYXRoLFxuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbktleTogdG9QYXRoLFxuICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkJ1Y2tldDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRlc3RpbmF0aW9uQnVja2V0LFxuICAgICAgICAgICAgICAgIH0sIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHsgcGF0aDogZGF0YS5LZXkgfSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaWduZWQgVVJMLiBVc2UgYSBzaWduZWQgVVJMIHRvIHNoYXJlIGEgZmlsZSBmb3IgYSBmaXhlZCBhbW91bnQgb2YgdGltZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBmaWxlIHBhdGgsIGluY2x1ZGluZyB0aGUgY3VycmVudCBmaWxlIG5hbWUuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICAgKiBAcGFyYW0gZXhwaXJlc0luIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyB1bnRpbCB0aGUgc2lnbmVkIFVSTCBleHBpcmVzLiBGb3IgZXhhbXBsZSwgYDYwYCBmb3IgYSBVUkwgd2hpY2ggaXMgdmFsaWQgZm9yIG9uZSBtaW51dGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZG93bmxvYWQgdHJpZ2dlcnMgdGhlIGZpbGUgYXMgYSBkb3dubG9hZCBpZiBzZXQgdG8gdHJ1ZS4gU2V0IHRoaXMgcGFyYW1ldGVyIGFzIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGlmIHlvdSB3YW50IHRvIHRyaWdnZXIgdGhlIGRvd25sb2FkIHdpdGggYSBkaWZmZXJlbnQgZmlsZW5hbWUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudHJhbnNmb3JtIFRyYW5zZm9ybSB0aGUgYXNzZXQgYmVmb3JlIHNlcnZpbmcgaXQgdG8gdGhlIGNsaWVudC5cbiAgICAgKi9cbiAgICBjcmVhdGVTaWduZWRVcmwocGF0aCwgZXhwaXJlc0luLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGxldCBfcGF0aCA9IHRoaXMuX2dldEZpbmFsUGF0aChwYXRoKTtcbiAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC9zaWduLyR7X3BhdGh9YCwgT2JqZWN0LmFzc2lnbih7IGV4cGlyZXNJbiB9LCAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pID8geyB0cmFuc2Zvcm06IG9wdGlvbnMudHJhbnNmb3JtIH0gOiB7fSkpLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBkb3dubG9hZFF1ZXJ5UGFyYW0gPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRvd25sb2FkKVxuICAgICAgICAgICAgICAgICAgICA/IGAmZG93bmxvYWQ9JHtvcHRpb25zLmRvd25sb2FkID09PSB0cnVlID8gJycgOiBvcHRpb25zLmRvd25sb2FkfWBcbiAgICAgICAgICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRVcmwgPSBlbmNvZGVVUkkoYCR7dGhpcy51cmx9JHtkYXRhLnNpZ25lZFVSTH0ke2Rvd25sb2FkUXVlcnlQYXJhbX1gKTtcbiAgICAgICAgICAgICAgICBkYXRhID0geyBzaWduZWRVcmwgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBtdWx0aXBsZSBzaWduZWQgVVJMcy4gVXNlIGEgc2lnbmVkIFVSTCB0byBzaGFyZSBhIGZpbGUgZm9yIGEgZml4ZWQgYW1vdW50IG9mIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aHMgVGhlIGZpbGUgcGF0aHMgdG8gYmUgZG93bmxvYWRlZCwgaW5jbHVkaW5nIHRoZSBjdXJyZW50IGZpbGUgbmFtZXMuIEZvciBleGFtcGxlIGBbJ2ZvbGRlci9pbWFnZS5wbmcnLCAnZm9sZGVyMi9pbWFnZTIucG5nJ11gLlxuICAgICAqIEBwYXJhbSBleHBpcmVzSW4gVGhlIG51bWJlciBvZiBzZWNvbmRzIHVudGlsIHRoZSBzaWduZWQgVVJMcyBleHBpcmUuIEZvciBleGFtcGxlLCBgNjBgIGZvciBVUkxzIHdoaWNoIGFyZSB2YWxpZCBmb3Igb25lIG1pbnV0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCB0cmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cbiAgICAgKi9cbiAgICBjcmVhdGVTaWduZWRVcmxzKHBhdGhzLCBleHBpcmVzSW4sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHBvc3QodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC9zaWduLyR7dGhpcy5idWNrZXRJZH1gLCB7IGV4cGlyZXNJbiwgcGF0aHMgfSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZClcbiAgICAgICAgICAgICAgICAgICAgPyBgJmRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/ICcnIDogb3B0aW9ucy5kb3dubG9hZH1gXG4gICAgICAgICAgICAgICAgICAgIDogJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YS5tYXAoKGRhdHVtKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkYXR1bSksIHsgc2lnbmVkVXJsOiBkYXR1bS5zaWduZWRVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGVuY29kZVVSSShgJHt0aGlzLnVybH0ke2RhdHVtLnNpZ25lZFVSTH0ke2Rvd25sb2FkUXVlcnlQYXJhbX1gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCB9KSkpLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGEgZmlsZSBmcm9tIGEgcHJpdmF0ZSBidWNrZXQuIEZvciBwdWJsaWMgYnVja2V0cywgbWFrZSBhIHJlcXVlc3QgdG8gdGhlIFVSTCByZXR1cm5lZCBmcm9tIGBnZXRQdWJsaWNVcmxgIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgZnVsbCBwYXRoIGFuZCBmaWxlIG5hbWUgb2YgdGhlIGZpbGUgdG8gYmUgZG93bmxvYWRlZC4gRm9yIGV4YW1wbGUgYGZvbGRlci9pbWFnZS5wbmdgLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnRyYW5zZm9ybSBUcmFuc2Zvcm0gdGhlIGFzc2V0IGJlZm9yZSBzZXJ2aW5nIGl0IHRvIHRoZSBjbGllbnQuXG4gICAgICovXG4gICAgZG93bmxvYWQocGF0aCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB3YW50c1RyYW5zZm9ybWF0aW9uID0gdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGNvbnN0IHJlbmRlclBhdGggPSB3YW50c1RyYW5zZm9ybWF0aW9uID8gJ3JlbmRlci9pbWFnZS9hdXRoZW50aWNhdGVkJyA6ICdvYmplY3QnO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1hdGlvblF1ZXJ5ID0gdGhpcy50cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZygob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRyYW5zZm9ybSkgfHwge30pO1xuICAgICAgICBjb25zdCBxdWVyeVN0cmluZyA9IHRyYW5zZm9ybWF0aW9uUXVlcnkgPyBgPyR7dHJhbnNmb3JtYXRpb25RdWVyeX1gIDogJyc7XG4gICAgICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuICAgICAgICBjb25zdCBkb3dubG9hZEZuID0gKCkgPT4gZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9LyR7X3BhdGh9JHtxdWVyeVN0cmluZ31gLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBub1Jlc29sdmVKc29uOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iRG93bmxvYWRCdWlsZGVyKGRvd25sb2FkRm4sIHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBkZXRhaWxzIG9mIGFuIGV4aXN0aW5nIGZpbGUuXG4gICAgICogQHBhcmFtIHBhdGhcbiAgICAgKi9cbiAgICBpbmZvKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvaW5mby8ke19wYXRofWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHJlY3Vyc2l2ZVRvQ2FtZWwoZGF0YSksIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIGV4aXN0ZW5jZSBvZiBhIGZpbGUuXG4gICAgICogQHBhcmFtIHBhdGhcbiAgICAgKi9cbiAgICBleGlzdHMocGF0aCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgX3BhdGggPSB0aGlzLl9nZXRGaW5hbFBhdGgocGF0aCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGhlYWQodGhpcy5mZXRjaCwgYCR7dGhpcy51cmx9L29iamVjdC8ke19wYXRofWAsIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogdGhpcy5oZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IHRydWUsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikgJiYgZXJyb3IgaW5zdGFuY2VvZiBTdG9yYWdlVW5rbm93bkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRXJyb3IgPSBlcnJvci5vcmlnaW5hbEVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoWzQwMCwgNDA0XS5pbmNsdWRlcyhvcmlnaW5hbEVycm9yID09PSBudWxsIHx8IG9yaWdpbmFsRXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsRXJyb3Iuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogZmFsc2UsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgdGhlIFVSTCBmb3IgYW4gYXNzZXQgaW4gYSBwdWJsaWMgYnVja2V0LiBJZiB5b3UgZG8gbm90IHdhbnQgdG8gdXNlIHRoaXMgZnVuY3Rpb24sIHlvdSBjYW4gY29uc3RydWN0IHRoZSBwdWJsaWMgVVJMIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIGJ1Y2tldCBVUkwgd2l0aCB0aGUgcGF0aCB0byB0aGUgYXNzZXQuXG4gICAgICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCB2ZXJpZnkgaWYgdGhlIGJ1Y2tldCBpcyBwdWJsaWMuIElmIGEgcHVibGljIFVSTCBpcyBjcmVhdGVkIGZvciBhIGJ1Y2tldCB3aGljaCBpcyBub3QgcHVibGljLCB5b3Ugd2lsbCBub3QgYmUgYWJsZSB0byBkb3dubG9hZCB0aGUgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCBhbmQgbmFtZSBvZiB0aGUgZmlsZSB0byBnZW5lcmF0ZSB0aGUgcHVibGljIFVSTCBmb3IuIEZvciBleGFtcGxlIGBmb2xkZXIvaW1hZ2UucG5nYC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5kb3dubG9hZCBUcmlnZ2VycyB0aGUgZmlsZSBhcyBhIGRvd25sb2FkIGlmIHNldCB0byB0cnVlLiBTZXQgdGhpcyBwYXJhbWV0ZXIgYXMgdGhlIG5hbWUgb2YgdGhlIGZpbGUgaWYgeW91IHdhbnQgdG8gdHJpZ2dlciB0aGUgZG93bmxvYWQgd2l0aCBhIGRpZmZlcmVudCBmaWxlbmFtZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy50cmFuc2Zvcm0gVHJhbnNmb3JtIHRoZSBhc3NldCBiZWZvcmUgc2VydmluZyBpdCB0byB0aGUgY2xpZW50LlxuICAgICAqL1xuICAgIGdldFB1YmxpY1VybChwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IF9wYXRoID0gdGhpcy5fZ2V0RmluYWxQYXRoKHBhdGgpO1xuICAgICAgICBjb25zdCBfcXVlcnlTdHJpbmcgPSBbXTtcbiAgICAgICAgY29uc3QgZG93bmxvYWRRdWVyeVBhcmFtID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kb3dubG9hZClcbiAgICAgICAgICAgID8gYGRvd25sb2FkPSR7b3B0aW9ucy5kb3dubG9hZCA9PT0gdHJ1ZSA/ICcnIDogb3B0aW9ucy5kb3dubG9hZH1gXG4gICAgICAgICAgICA6ICcnO1xuICAgICAgICBpZiAoZG93bmxvYWRRdWVyeVBhcmFtICE9PSAnJykge1xuICAgICAgICAgICAgX3F1ZXJ5U3RyaW5nLnB1c2goZG93bmxvYWRRdWVyeVBhcmFtKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YW50c1RyYW5zZm9ybWF0aW9uID0gdHlwZW9mIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGNvbnN0IHJlbmRlclBhdGggPSB3YW50c1RyYW5zZm9ybWF0aW9uID8gJ3JlbmRlci9pbWFnZScgOiAnb2JqZWN0JztcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtYXRpb25RdWVyeSA9IHRoaXMudHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmcoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pIHx8IHt9KTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWF0aW9uUXVlcnkgIT09ICcnKSB7XG4gICAgICAgICAgICBfcXVlcnlTdHJpbmcucHVzaCh0cmFuc2Zvcm1hdGlvblF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcXVlcnlTdHJpbmcgPSBfcXVlcnlTdHJpbmcuam9pbignJicpO1xuICAgICAgICBpZiAocXVlcnlTdHJpbmcgIT09ICcnKSB7XG4gICAgICAgICAgICBxdWVyeVN0cmluZyA9IGA/JHtxdWVyeVN0cmluZ31gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB7IHB1YmxpY1VybDogZW5jb2RlVVJJKGAke3RoaXMudXJsfS8ke3JlbmRlclBhdGh9L3B1YmxpYy8ke19wYXRofSR7cXVlcnlTdHJpbmd9YCkgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBmaWxlcyB3aXRoaW4gdGhlIHNhbWUgYnVja2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aHMgQW4gYXJyYXkgb2YgZmlsZXMgdG8gZGVsZXRlLCBpbmNsdWRpbmcgdGhlIHBhdGggYW5kIGZpbGUgbmFtZS4gRm9yIGV4YW1wbGUgW2AnZm9sZGVyL2ltYWdlLnBuZydgXS5cbiAgICAgKi9cbiAgICByZW1vdmUocGF0aHMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHlpZWxkIHJlbW92ZSh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0LyR7dGhpcy5idWNrZXRJZH1gLCB7IHByZWZpeGVzOiBwYXRocyB9LCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhLCBlcnJvcjogbnVsbCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkVGhyb3dPbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTdG9yYWdlRXJyb3IoZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGE6IG51bGwsIGVycm9yIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGZpbGUgbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gcmV0cmlldmUgbWV0YWRhdGFcbiAgICAgKi9cbiAgICAvLyBhc3luYyBnZXRNZXRhZGF0YShcbiAgICAvLyAgIGlkOiBzdHJpbmdcbiAgICAvLyApOiBQcm9taXNlPFxuICAgIC8vICAgfCB7XG4gICAgLy8gICAgICAgZGF0YTogTWV0YWRhdGFcbiAgICAvLyAgICAgICBlcnJvcjogbnVsbFxuICAgIC8vICAgICB9XG4gICAgLy8gICB8IHtcbiAgICAvLyAgICAgICBkYXRhOiBudWxsXG4gICAgLy8gICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgIC8vICAgICB9XG4gICAgLy8gPiB7XG4gICAgLy8gICB0cnkge1xuICAgIC8vICAgICBjb25zdCBkYXRhID0gYXdhaXQgZ2V0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9tZXRhZGF0YS8ke2lkfWAsIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0pXG4gICAgLy8gICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICAvLyAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAvLyAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgdGhyb3cgZXJyb3JcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGZpbGUgbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0gaWQgdGhlIGZpbGUgaWQgdG8gdXBkYXRlIG1ldGFkYXRhXG4gICAgICogQHBhcmFtIG1ldGEgdGhlIG5ldyBmaWxlIG1ldGFkYXRhXG4gICAgICovXG4gICAgLy8gYXN5bmMgdXBkYXRlTWV0YWRhdGEoXG4gICAgLy8gICBpZDogc3RyaW5nLFxuICAgIC8vICAgbWV0YTogTWV0YWRhdGFcbiAgICAvLyApOiBQcm9taXNlPFxuICAgIC8vICAgfCB7XG4gICAgLy8gICAgICAgZGF0YTogTWV0YWRhdGFcbiAgICAvLyAgICAgICBlcnJvcjogbnVsbFxuICAgIC8vICAgICB9XG4gICAgLy8gICB8IHtcbiAgICAvLyAgICAgICBkYXRhOiBudWxsXG4gICAgLy8gICAgICAgZXJyb3I6IFN0b3JhZ2VFcnJvclxuICAgIC8vICAgICB9XG4gICAgLy8gPiB7XG4gICAgLy8gICB0cnkge1xuICAgIC8vICAgICBjb25zdCBkYXRhID0gYXdhaXQgcG9zdChcbiAgICAvLyAgICAgICB0aGlzLmZldGNoLFxuICAgIC8vICAgICAgIGAke3RoaXMudXJsfS9tZXRhZGF0YS8ke2lkfWAsXG4gICAgLy8gICAgICAgeyAuLi5tZXRhIH0sXG4gICAgLy8gICAgICAgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfVxuICAgIC8vICAgICApXG4gICAgLy8gICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH1cbiAgICAvLyAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAvLyAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgdGhyb3cgZXJyb3JcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgYWxsIHRoZSBmaWxlcyBhbmQgZm9sZGVycyB3aXRoaW4gYSBwYXRoIG9mIHRoZSBidWNrZXQuXG4gICAgICogQHBhcmFtIHBhdGggVGhlIGZvbGRlciBwYXRoLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFNlYXJjaCBvcHRpb25zIGluY2x1ZGluZyBsaW1pdCAoZGVmYXVsdHMgdG8gMTAwKSwgb2Zmc2V0LCBzb3J0QnksIGFuZCBzZWFyY2hcbiAgICAgKi9cbiAgICBsaXN0KHBhdGgsIG9wdGlvbnMsIHBhcmFtZXRlcnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFQVJDSF9PUFRJT05TKSwgb3B0aW9ucyksIHsgcHJlZml4OiBwYXRoIHx8ICcnIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB5aWVsZCBwb3N0KHRoaXMuZmV0Y2gsIGAke3RoaXMudXJsfS9vYmplY3QvbGlzdC8ke3RoaXMuYnVja2V0SWR9YCwgYm9keSwgeyBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSwgcGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YSwgZXJyb3I6IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBleHBlcmltZW50YWwgdGhpcyBtZXRob2Qgc2lnbmF0dXJlIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgc2VhcmNoIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIGxpc3RWMihvcHRpb25zLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0geWllbGQgcG9zdCh0aGlzLmZldGNoLCBgJHt0aGlzLnVybH0vb2JqZWN0L2xpc3QtdjIvJHt0aGlzLmJ1Y2tldElkfWAsIGJvZHksIHsgaGVhZGVyczogdGhpcy5oZWFkZXJzIH0sIHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGRhdGEsIGVycm9yOiBudWxsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1N0b3JhZ2VFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZGF0YTogbnVsbCwgZXJyb3IgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpO1xuICAgIH1cbiAgICB0b0Jhc2U2NChkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnRvYShkYXRhKTtcbiAgICB9XG4gICAgX2dldEZpbmFsUGF0aChwYXRoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmJ1Y2tldElkfS8ke3BhdGgucmVwbGFjZSgvXlxcLysvLCAnJyl9YDtcbiAgICB9XG4gICAgX3JlbW92ZUVtcHR5Rm9sZGVycyhwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL15cXC98XFwvJC9nLCAnJykucmVwbGFjZSgvXFwvKy9nLCAnLycpO1xuICAgIH1cbiAgICB0cmFuc2Zvcm1PcHRzVG9RdWVyeVN0cmluZyh0cmFuc2Zvcm0pIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gW107XG4gICAgICAgIGlmICh0cmFuc2Zvcm0ud2lkdGgpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGB3aWR0aD0ke3RyYW5zZm9ybS53aWR0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNmb3JtLmhlaWdodCkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2goYGhlaWdodD0ke3RyYW5zZm9ybS5oZWlnaHR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zZm9ybS5yZXNpemUpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGByZXNpemU9JHt0cmFuc2Zvcm0ucmVzaXplfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2Zvcm0uZm9ybWF0KSB7XG4gICAgICAgICAgICBwYXJhbXMucHVzaChgZm9ybWF0PSR7dHJhbnNmb3JtLmZvcm1hdH1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhbnNmb3JtLnF1YWxpdHkpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKGBxdWFsaXR5PSR7dHJhbnNmb3JtLnF1YWxpdHl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5qb2luKCcmJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RvcmFnZUZpbGVBcGkuanMubWFwIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsImlzU3RvcmFnZUVycm9yIiwiU3RvcmFnZUVycm9yIiwiU3RvcmFnZVVua25vd25FcnJvciIsImdldCIsImhlYWQiLCJwb3N0IiwicHV0IiwicmVtb3ZlIiwicmVjdXJzaXZlVG9DYW1lbCIsInJlc29sdmVGZXRjaCIsIkJsb2JEb3dubG9hZEJ1aWxkZXIiLCJERUZBVUxUX1NFQVJDSF9PUFRJT05TIiwibGltaXQiLCJvZmZzZXQiLCJzb3J0QnkiLCJjb2x1bW4iLCJvcmRlciIsIkRFRkFVTFRfRklMRV9PUFRJT05TIiwiY2FjaGVDb250cm9sIiwiY29udGVudFR5cGUiLCJ1cHNlcnQiLCJTdG9yYWdlRmlsZUFwaSIsImNvbnN0cnVjdG9yIiwidXJsIiwiaGVhZGVycyIsImJ1Y2tldElkIiwiZmV0Y2giLCJzaG91bGRUaHJvd09uRXJyb3IiLCJ0aHJvd09uRXJyb3IiLCJ1cGxvYWRPclVwZGF0ZSIsIm1ldGhvZCIsInBhdGgiLCJmaWxlQm9keSIsImZpbGVPcHRpb25zIiwiYm9keSIsIm9wdGlvbnMiLCJPYmplY3QiLCJhc3NpZ24iLCJTdHJpbmciLCJtZXRhZGF0YSIsIkJsb2IiLCJGb3JtRGF0YSIsImFwcGVuZCIsImVuY29kZU1ldGFkYXRhIiwidG9CYXNlNjQiLCJjbGVhblBhdGgiLCJfcmVtb3ZlRW1wdHlGb2xkZXJzIiwiX3BhdGgiLCJfZ2V0RmluYWxQYXRoIiwiZGF0YSIsImR1cGxleCIsImlkIiwiSWQiLCJmdWxsUGF0aCIsIktleSIsImVycm9yIiwidXBsb2FkIiwidXBsb2FkVG9TaWduZWRVcmwiLCJ0b2tlbiIsIlVSTCIsInNlYXJjaFBhcmFtcyIsInNldCIsInRvU3RyaW5nIiwiY3JlYXRlU2lnbmVkVXBsb2FkVXJsIiwic2lnbmVkVXJsIiwidXBkYXRlIiwibW92ZSIsImZyb21QYXRoIiwidG9QYXRoIiwic291cmNlS2V5IiwiZGVzdGluYXRpb25LZXkiLCJkZXN0aW5hdGlvbkJ1Y2tldCIsImNvcHkiLCJjcmVhdGVTaWduZWRVcmwiLCJleHBpcmVzSW4iLCJ0cmFuc2Zvcm0iLCJkb3dubG9hZFF1ZXJ5UGFyYW0iLCJkb3dubG9hZCIsImVuY29kZVVSSSIsInNpZ25lZFVSTCIsImNyZWF0ZVNpZ25lZFVybHMiLCJwYXRocyIsIm1hcCIsImRhdHVtIiwid2FudHNUcmFuc2Zvcm1hdGlvbiIsInJlbmRlclBhdGgiLCJ0cmFuc2Zvcm1hdGlvblF1ZXJ5IiwidHJhbnNmb3JtT3B0c1RvUXVlcnlTdHJpbmciLCJxdWVyeVN0cmluZyIsImRvd25sb2FkRm4iLCJub1Jlc29sdmVKc29uIiwiaW5mbyIsImV4aXN0cyIsIm9yaWdpbmFsRXJyb3IiLCJpbmNsdWRlcyIsInN0YXR1cyIsImdldFB1YmxpY1VybCIsIl9xdWVyeVN0cmluZyIsInB1c2giLCJqb2luIiwicHVibGljVXJsIiwicHJlZml4ZXMiLCJsaXN0IiwicGFyYW1ldGVycyIsInByZWZpeCIsImxpc3RWMiIsIkpTT04iLCJzdHJpbmdpZnkiLCJCdWZmZXIiLCJmcm9tIiwiYnRvYSIsInJlcGxhY2UiLCJwYXJhbXMiLCJ3aWR0aCIsImhlaWdodCIsInJlc2l6ZSIsImZvcm1hdCIsInF1YWxpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StorageFileApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StreamDownloadBuilder.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@supabase/storage-js/dist/module/packages/StreamDownloadBuilder.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ StreamDownloadBuilder)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _lib_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/errors */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/lib/errors.js\");\n\n\nclass StreamDownloadBuilder {\n    constructor(downloadFn, shouldThrowOnError){\n        this.downloadFn = downloadFn;\n        this.shouldThrowOnError = shouldThrowOnError;\n    }\n    then(onfulfilled, onrejected) {\n        return this.execute().then(onfulfilled, onrejected);\n    }\n    execute() {\n        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function*() {\n            try {\n                const result = yield this.downloadFn();\n                return {\n                    data: result.body,\n                    error: null\n                };\n            } catch (error) {\n                if (this.shouldThrowOnError) {\n                    throw error;\n                }\n                if ((0,_lib_errors__WEBPACK_IMPORTED_MODULE_1__.isStorageError)(error)) {\n                    return {\n                        data: null,\n                        error\n                    };\n                }\n                throw error;\n            }\n        });\n    }\n} //# sourceMappingURL=StreamDownloadBuilder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvcGFja2FnZXMvU3RyZWFtRG93bmxvYWRCdWlsZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFrQztBQUNhO0FBQ2hDLE1BQU1FO0lBQ2pCQyxZQUFZQyxVQUFVLEVBQUVDLGtCQUFrQixDQUFFO1FBQ3hDLElBQUksQ0FBQ0QsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLGtCQUFrQixHQUFHQTtJQUM5QjtJQUNBQyxLQUFLQyxXQUFXLEVBQUVDLFVBQVUsRUFBRTtRQUMxQixPQUFPLElBQUksQ0FBQ0MsT0FBTyxHQUFHSCxJQUFJLENBQUNDLGFBQWFDO0lBQzVDO0lBQ0FDLFVBQVU7UUFDTixPQUFPVCxnREFBU0EsQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJO2dCQUNBLE1BQU1VLFNBQVMsTUFBTSxJQUFJLENBQUNOLFVBQVU7Z0JBQ3BDLE9BQU87b0JBQ0hPLE1BQU1ELE9BQU9FLElBQUk7b0JBQ2pCQyxPQUFPO2dCQUNYO1lBQ0osRUFDQSxPQUFPQSxPQUFPO2dCQUNWLElBQUksSUFBSSxDQUFDUixrQkFBa0IsRUFBRTtvQkFDekIsTUFBTVE7Z0JBQ1Y7Z0JBQ0EsSUFBSVosMkRBQWNBLENBQUNZLFFBQVE7b0JBQ3ZCLE9BQU87d0JBQUVGLE1BQU07d0JBQU1FO29CQUFNO2dCQUMvQjtnQkFDQSxNQUFNQTtZQUNWO1FBQ0o7SUFDSjtBQUNKLEVBQ0EsaURBQWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N0b3JhZ2UtanMvZGlzdC9tb2R1bGUvcGFja2FnZXMvU3RyZWFtRG93bmxvYWRCdWlsZGVyLmpzPzAzMzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBpc1N0b3JhZ2VFcnJvciB9IGZyb20gJy4uL2xpYi9lcnJvcnMnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RyZWFtRG93bmxvYWRCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihkb3dubG9hZEZuLCBzaG91bGRUaHJvd09uRXJyb3IpIHtcbiAgICAgICAgdGhpcy5kb3dubG9hZEZuID0gZG93bmxvYWRGbjtcbiAgICAgICAgdGhpcy5zaG91bGRUaHJvd09uRXJyb3IgPSBzaG91bGRUaHJvd09uRXJyb3I7XG4gICAgfVxuICAgIHRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZSgpLnRoZW4ob25mdWxmaWxsZWQsIG9ucmVqZWN0ZWQpO1xuICAgIH1cbiAgICBleGVjdXRlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLmRvd25sb2FkRm4oKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiByZXN1bHQuYm9keSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZFRocm93T25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU3RvcmFnZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkYXRhOiBudWxsLCBlcnJvciB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RyZWFtRG93bmxvYWRCdWlsZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJpc1N0b3JhZ2VFcnJvciIsIlN0cmVhbURvd25sb2FkQnVpbGRlciIsImNvbnN0cnVjdG9yIiwiZG93bmxvYWRGbiIsInNob3VsZFRocm93T25FcnJvciIsInRoZW4iLCJvbmZ1bGZpbGxlZCIsIm9ucmVqZWN0ZWQiLCJleGVjdXRlIiwicmVzdWx0IiwiZGF0YSIsImJvZHkiLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/storage-js/dist/module/packages/StreamDownloadBuilder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SupabaseClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @supabase/functions-js */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/FunctionsClient.js\");\n/* harmony import */ var _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/postgrest-js */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs\");\n/* harmony import */ var _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/realtime-js */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/index.js\");\n/* harmony import */ var _supabase_storage_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @supabase/storage-js */ \"(ssr)/./node_modules/@supabase/storage-js/dist/module/StorageClient.js\");\n/* harmony import */ var _lib_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/constants */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/constants.js\");\n/* harmony import */ var _lib_fetch__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/fetch */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js\");\n/* harmony import */ var _lib_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/helpers */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js\");\n/* harmony import */ var _lib_SupabaseAuthClient__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/SupabaseAuthClient */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js\");\n\n\n\n\n\n\n\n\n/**\n * Supabase Client.\n *\n * An isomorphic Javascript client for interacting with Postgres.\n */ class SupabaseClient {\n    /**\n     * Create a new client for use in the browser.\n     * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\n     * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\n     * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\n     * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\n     * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\n     * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\n     * @param options.realtime Options passed along to realtime-js constructor.\n     * @param options.storage Options passed along to the storage-js constructor.\n     * @param options.global.fetch A custom fetch implementation.\n     * @param options.global.headers Any additional headers to send with each network request.\n     */ constructor(supabaseUrl, supabaseKey, options){\n        var _a, _b, _c;\n        this.supabaseUrl = supabaseUrl;\n        this.supabaseKey = supabaseKey;\n        const baseUrl = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_2__.validateSupabaseUrl)(supabaseUrl);\n        if (!supabaseKey) throw new Error(\"supabaseKey is required.\");\n        this.realtimeUrl = new URL(\"realtime/v1\", baseUrl);\n        this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace(\"http\", \"ws\");\n        this.authUrl = new URL(\"auth/v1\", baseUrl);\n        this.storageUrl = new URL(\"storage/v1\", baseUrl);\n        this.functionsUrl = new URL(\"functions/v1\", baseUrl);\n        // default storage key uses the supabase project ref as a namespace\n        const defaultStorageKey = `sb-${baseUrl.hostname.split(\".\")[0]}-auth-token`;\n        const DEFAULTS = {\n            db: _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_DB_OPTIONS,\n            realtime: _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_REALTIME_OPTIONS,\n            auth: Object.assign(Object.assign({}, _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_AUTH_OPTIONS), {\n                storageKey: defaultStorageKey\n            }),\n            global: _lib_constants__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_GLOBAL_OPTIONS\n        };\n        const settings = (0,_lib_helpers__WEBPACK_IMPORTED_MODULE_2__.applySettingDefaults)(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n        this.storageKey = (_a = settings.auth.storageKey) !== null && _a !== void 0 ? _a : \"\";\n        this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};\n        if (!settings.accessToken) {\n            this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);\n        } else {\n            this.accessToken = settings.accessToken;\n            this.auth = new Proxy({}, {\n                get: (_, prop)=>{\n                    throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(prop)} is not possible`);\n                }\n            });\n        }\n        this.fetch = (0,_lib_fetch__WEBPACK_IMPORTED_MODULE_4__.fetchWithAuth)(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);\n        this.realtime = this._initRealtimeClient(Object.assign({\n            headers: this.headers,\n            accessToken: this._getAccessToken.bind(this)\n        }, settings.realtime));\n        this.rest = new _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_0__.PostgrestClient(new URL(\"rest/v1\", baseUrl).href, {\n            headers: this.headers,\n            schema: settings.db.schema,\n            fetch: this.fetch\n        });\n        this.storage = new _supabase_storage_js__WEBPACK_IMPORTED_MODULE_5__.StorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);\n        if (!settings.accessToken) {\n            this._listenForAuthEvents();\n        }\n    }\n    /**\n     * Supabase Functions allows you to deploy and invoke edge functions.\n     */ get functions() {\n        return new _supabase_functions_js__WEBPACK_IMPORTED_MODULE_6__.FunctionsClient(this.functionsUrl.href, {\n            headers: this.headers,\n            customFetch: this.fetch\n        });\n    }\n    /**\n     * Perform a query on a table or a view.\n     *\n     * @param relation - The table or view name to query\n     */ from(relation) {\n        return this.rest.from(relation);\n    }\n    // NOTE: signatures must be kept in sync with PostgrestClient.schema\n    /**\n     * Select a schema to query or perform an function (rpc) call.\n     *\n     * The schema needs to be on the list of exposed schemas inside Supabase.\n     *\n     * @param schema - The schema to query\n     */ schema(schema) {\n        return this.rest.schema(schema);\n    }\n    // NOTE: signatures must be kept in sync with PostgrestClient.rpc\n    /**\n     * Perform a function call.\n     *\n     * @param fn - The function name to call\n     * @param args - The arguments to pass to the function call\n     * @param options - Named parameters\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     * @param options.get - When set to `true`, the function will be called with\n     * read-only access mode.\n     * @param options.count - Count algorithm to use to count rows returned by the\n     * function. Only applicable for [set-returning\n     * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */ rpc(fn, args = {}, options = {\n        head: false,\n        get: false,\n        count: undefined\n    }) {\n        return this.rest.rpc(fn, args, options);\n    }\n    /**\n     * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\n     *\n     * @param {string} name - The name of the Realtime channel.\n     * @param {Object} opts - The options to pass to the Realtime channel.\n     *\n     */ channel(name, opts = {\n        config: {}\n    }) {\n        return this.realtime.channel(name, opts);\n    }\n    /**\n     * Returns all Realtime channels.\n     */ getChannels() {\n        return this.realtime.getChannels();\n    }\n    /**\n     * Unsubscribes and removes Realtime channel from Realtime client.\n     *\n     * @param {RealtimeChannel} channel - The name of the Realtime channel.\n     *\n     */ removeChannel(channel) {\n        return this.realtime.removeChannel(channel);\n    }\n    /**\n     * Unsubscribes and removes all Realtime channels from Realtime client.\n     */ removeAllChannels() {\n        return this.realtime.removeAllChannels();\n    }\n    async _getAccessToken() {\n        var _a, _b;\n        if (this.accessToken) {\n            return await this.accessToken();\n        }\n        const { data } = await this.auth.getSession();\n        return (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;\n    }\n    _initSupabaseAuthClient({ autoRefreshToken, persistSession, detectSessionInUrl, storage, userStorage, storageKey, flowType, lock, debug }, headers, fetch) {\n        const authHeaders = {\n            Authorization: `Bearer ${this.supabaseKey}`,\n            apikey: `${this.supabaseKey}`\n        };\n        return new _lib_SupabaseAuthClient__WEBPACK_IMPORTED_MODULE_7__.SupabaseAuthClient({\n            url: this.authUrl.href,\n            headers: Object.assign(Object.assign({}, authHeaders), headers),\n            storageKey: storageKey,\n            autoRefreshToken,\n            persistSession,\n            detectSessionInUrl,\n            storage,\n            userStorage,\n            flowType,\n            lock,\n            debug,\n            fetch,\n            // auth checks if there is a custom authorizaiton header using this flag\n            // so it knows whether to return an error when getUser is called with no session\n            hasCustomAuthorizationHeader: Object.keys(this.headers).some((key)=>key.toLowerCase() === \"authorization\")\n        });\n    }\n    _initRealtimeClient(options) {\n        return new _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_1__.RealtimeClient(this.realtimeUrl.href, Object.assign(Object.assign({}, options), {\n            params: Object.assign({\n                apikey: this.supabaseKey\n            }, options === null || options === void 0 ? void 0 : options.params)\n        }));\n    }\n    _listenForAuthEvents() {\n        const data = this.auth.onAuthStateChange((event, session)=>{\n            this._handleTokenChanged(event, \"CLIENT\", session === null || session === void 0 ? void 0 : session.access_token);\n        });\n        return data;\n    }\n    _handleTokenChanged(event, source, token) {\n        if ((event === \"TOKEN_REFRESHED\" || event === \"SIGNED_IN\") && this.changedAccessToken !== token) {\n            this.changedAccessToken = token;\n            this.realtime.setAuth(token);\n        } else if (event === \"SIGNED_OUT\") {\n            this.realtime.setAuth();\n            if (source == \"STORAGE\") this.auth.signOut();\n            this.changedAccessToken = undefined;\n        }\n    }\n} //# sourceMappingURL=SupabaseClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL1N1cGFiYXNlQ2xpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF5RDtBQUNDO0FBQ0Y7QUFDc0I7QUFDZ0Q7QUFDbEY7QUFDOEI7QUFDWjtBQUM5RDs7OztDQUlDLEdBQ2MsTUFBTWE7SUFDakI7Ozs7Ozs7Ozs7OztLQVlDLEdBQ0RDLFlBQVlDLFdBQVcsRUFBRUMsV0FBVyxFQUFFQyxPQUFPLENBQUU7UUFDM0MsSUFBSUMsSUFBSUMsSUFBSUM7UUFDWixJQUFJLENBQUNMLFdBQVcsR0FBR0E7UUFDbkIsSUFBSSxDQUFDQyxXQUFXLEdBQUdBO1FBQ25CLE1BQU1LLFVBQVVWLGlFQUFtQkEsQ0FBQ0k7UUFDcEMsSUFBSSxDQUFDQyxhQUNELE1BQU0sSUFBSU0sTUFBTTtRQUNwQixJQUFJLENBQUNDLFdBQVcsR0FBRyxJQUFJQyxJQUFJLGVBQWVIO1FBQzFDLElBQUksQ0FBQ0UsV0FBVyxDQUFDRSxRQUFRLEdBQUcsSUFBSSxDQUFDRixXQUFXLENBQUNFLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDLFFBQVE7UUFDdEUsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUgsSUFBSSxXQUFXSDtRQUNsQyxJQUFJLENBQUNPLFVBQVUsR0FBRyxJQUFJSixJQUFJLGNBQWNIO1FBQ3hDLElBQUksQ0FBQ1EsWUFBWSxHQUFHLElBQUlMLElBQUksZ0JBQWdCSDtRQUM1QyxtRUFBbUU7UUFDbkUsTUFBTVMsb0JBQW9CLENBQUMsR0FBRyxFQUFFVCxRQUFRVSxRQUFRLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQztRQUMzRSxNQUFNQyxXQUFXO1lBQ2JDLElBQUk1Qiw4REFBa0JBO1lBQ3RCNkIsVUFBVTNCLG9FQUF3QkE7WUFDbEM0QixNQUFNQyxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdqQyxnRUFBb0JB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QUFDeEMsSUFBSSxDQUFDNkQsaUJBQWlCLENBQUMsQ0FBQ0MsT0FBT3BCO1lBQzdDLElBQUksQ0FBQ3FCLG1CQUFtQixDQUFDRCxPQUFPLFVBQVVwQixZQUFZLFFBQVFBLFlBQVksS0FBSyxJQUFJLEtBQUssSUFBSUEsUUFBUUMsWUFBWTtRQUNwSDtRQUNBLE9BQU9IO0lBQ1g7SUFDQXVCLG9CQUFvQkQsS0FBSyxFQUFFRSxNQUFNLEVBQUVDLEtBQUssRUFBRTtRQUN0QyxJQUFJLENBQUNILFVBQVUscUJBQXFCQSxVQUFVLFdBQVUsS0FDcEQsSUFBSSxDQUFDSSxrQkFBa0IsS0FBS0QsT0FBTztZQUNuQyxJQUFJLENBQUNDLGtCQUFrQixHQUFHRDtZQUMxQixJQUFJLENBQUNsRSxRQUFRLENBQUNvRSxPQUFPLENBQUNGO1FBQzFCLE9BQ0ssSUFBSUgsVUFBVSxjQUFjO1lBQzdCLElBQUksQ0FBQy9ELFFBQVEsQ0FBQ29FLE9BQU87WUFDckIsSUFBSUgsVUFBVSxXQUNWLElBQUksQ0FBQ2hFLElBQUksQ0FBQ29FLE9BQU87WUFDckIsSUFBSSxDQUFDRixrQkFBa0IsR0FBR2xDO1FBQzlCO0lBQ0o7QUFDSixFQUNBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9kaXN0L21vZHVsZS9TdXBhYmFzZUNsaWVudC5qcz8zZjcyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZ1bmN0aW9uc0NsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9mdW5jdGlvbnMtanMnO1xuaW1wb3J0IHsgUG9zdGdyZXN0Q2xpZW50LCB9IGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnO1xuaW1wb3J0IHsgUmVhbHRpbWVDbGllbnQsIH0gZnJvbSAnQHN1cGFiYXNlL3JlYWx0aW1lLWpzJztcbmltcG9ydCB7IFN0b3JhZ2VDbGllbnQgYXMgU3VwYWJhc2VTdG9yYWdlQ2xpZW50IH0gZnJvbSAnQHN1cGFiYXNlL3N0b3JhZ2UtanMnO1xuaW1wb3J0IHsgREVGQVVMVF9BVVRIX09QVElPTlMsIERFRkFVTFRfREJfT1BUSU9OUywgREVGQVVMVF9HTE9CQUxfT1BUSU9OUywgREVGQVVMVF9SRUFMVElNRV9PUFRJT05TLCB9IGZyb20gJy4vbGliL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBmZXRjaFdpdGhBdXRoIH0gZnJvbSAnLi9saWIvZmV0Y2gnO1xuaW1wb3J0IHsgYXBwbHlTZXR0aW5nRGVmYXVsdHMsIHZhbGlkYXRlU3VwYWJhc2VVcmwgfSBmcm9tICcuL2xpYi9oZWxwZXJzJztcbmltcG9ydCB7IFN1cGFiYXNlQXV0aENsaWVudCB9IGZyb20gJy4vbGliL1N1cGFiYXNlQXV0aENsaWVudCc7XG4vKipcbiAqIFN1cGFiYXNlIENsaWVudC5cbiAqXG4gKiBBbiBpc29tb3JwaGljIEphdmFzY3JpcHQgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIFBvc3RncmVzLlxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdXBhYmFzZUNsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGNsaWVudCBmb3IgdXNlIGluIHRoZSBicm93c2VyLlxuICAgICAqIEBwYXJhbSBzdXBhYmFzZVVybCBUaGUgdW5pcXVlIFN1cGFiYXNlIFVSTCB3aGljaCBpcyBzdXBwbGllZCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgcHJvamVjdCBpbiB5b3VyIHByb2plY3QgZGFzaGJvYXJkLlxuICAgICAqIEBwYXJhbSBzdXBhYmFzZUtleSBUaGUgdW5pcXVlIFN1cGFiYXNlIEtleSB3aGljaCBpcyBzdXBwbGllZCB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgcHJvamVjdCBpbiB5b3VyIHByb2plY3QgZGFzaGJvYXJkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmRiLnNjaGVtYSBZb3UgY2FuIHN3aXRjaCBpbiBiZXR3ZWVuIHNjaGVtYXMuIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hdXRoLmF1dG9SZWZyZXNoVG9rZW4gU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVmcmVzaCB0aGUgdG9rZW4gYmVmb3JlIGV4cGlyaW5nLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmF1dGgucGVyc2lzdFNlc3Npb24gU2V0IHRvIFwidHJ1ZVwiIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgc2F2ZSB0aGUgdXNlciBzZXNzaW9uIGludG8gbG9jYWwgc3RvcmFnZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5hdXRoLmRldGVjdFNlc3Npb25JblVybCBTZXQgdG8gXCJ0cnVlXCIgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSBkZXRlY3RzIE9BdXRoIGdyYW50cyBpbiB0aGUgVVJMIGFuZCBzaWducyBpbiB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWFsdGltZSBPcHRpb25zIHBhc3NlZCBhbG9uZyB0byByZWFsdGltZS1qcyBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdG9yYWdlIE9wdGlvbnMgcGFzc2VkIGFsb25nIHRvIHRoZSBzdG9yYWdlLWpzIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdsb2JhbC5mZXRjaCBBIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nbG9iYWwuaGVhZGVycyBBbnkgYWRkaXRpb25hbCBoZWFkZXJzIHRvIHNlbmQgd2l0aCBlYWNoIG5ldHdvcmsgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHRoaXMuc3VwYWJhc2VVcmwgPSBzdXBhYmFzZVVybDtcbiAgICAgICAgdGhpcy5zdXBhYmFzZUtleSA9IHN1cGFiYXNlS2V5O1xuICAgICAgICBjb25zdCBiYXNlVXJsID0gdmFsaWRhdGVTdXBhYmFzZVVybChzdXBhYmFzZVVybCk7XG4gICAgICAgIGlmICghc3VwYWJhc2VLZXkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N1cGFiYXNlS2V5IGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB0aGlzLnJlYWx0aW1lVXJsID0gbmV3IFVSTCgncmVhbHRpbWUvdjEnLCBiYXNlVXJsKTtcbiAgICAgICAgdGhpcy5yZWFsdGltZVVybC5wcm90b2NvbCA9IHRoaXMucmVhbHRpbWVVcmwucHJvdG9jb2wucmVwbGFjZSgnaHR0cCcsICd3cycpO1xuICAgICAgICB0aGlzLmF1dGhVcmwgPSBuZXcgVVJMKCdhdXRoL3YxJywgYmFzZVVybCk7XG4gICAgICAgIHRoaXMuc3RvcmFnZVVybCA9IG5ldyBVUkwoJ3N0b3JhZ2UvdjEnLCBiYXNlVXJsKTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbnNVcmwgPSBuZXcgVVJMKCdmdW5jdGlvbnMvdjEnLCBiYXNlVXJsKTtcbiAgICAgICAgLy8gZGVmYXVsdCBzdG9yYWdlIGtleSB1c2VzIHRoZSBzdXBhYmFzZSBwcm9qZWN0IHJlZiBhcyBhIG5hbWVzcGFjZVxuICAgICAgICBjb25zdCBkZWZhdWx0U3RvcmFnZUtleSA9IGBzYi0ke2Jhc2VVcmwuaG9zdG5hbWUuc3BsaXQoJy4nKVswXX0tYXV0aC10b2tlbmA7XG4gICAgICAgIGNvbnN0IERFRkFVTFRTID0ge1xuICAgICAgICAgICAgZGI6IERFRkFVTFRfREJfT1BUSU9OUyxcbiAgICAgICAgICAgIHJlYWx0aW1lOiBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsXG4gICAgICAgICAgICBhdXRoOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfQVVUSF9PUFRJT05TKSwgeyBzdG9yYWdlS2V5OiBkZWZhdWx0U3RvcmFnZUtleSB9KSxcbiAgICAgICAgICAgIGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OUyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBhcHBseVNldHRpbmdEZWZhdWx0cyhvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSwgREVGQVVMVFMpO1xuICAgICAgICB0aGlzLnN0b3JhZ2VLZXkgPSAoX2EgPSBzZXR0aW5ncy5hdXRoLnN0b3JhZ2VLZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSAoX2IgPSBzZXR0aW5ncy5nbG9iYWwuaGVhZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDoge307XG4gICAgICAgIGlmICghc2V0dGluZ3MuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aCA9IHRoaXMuX2luaXRTdXBhYmFzZUF1dGhDbGllbnQoKF9jID0gc2V0dGluZ3MuYXV0aCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30sIHRoaXMuaGVhZGVycywgc2V0dGluZ3MuZ2xvYmFsLmZldGNoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSBzZXR0aW5ncy5hY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgIHRoaXMuYXV0aCA9IG5ldyBQcm94eSh7fSwge1xuICAgICAgICAgICAgICAgIGdldDogKF8sIHByb3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBAc3VwYWJhc2Uvc3VwYWJhc2UtanM6IFN1cGFiYXNlIENsaWVudCBpcyBjb25maWd1cmVkIHdpdGggdGhlIGFjY2Vzc1Rva2VuIG9wdGlvbiwgYWNjZXNzaW5nIHN1cGFiYXNlLmF1dGguJHtTdHJpbmcocHJvcCl9IGlzIG5vdCBwb3NzaWJsZWApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZldGNoID0gZmV0Y2hXaXRoQXV0aChzdXBhYmFzZUtleSwgdGhpcy5fZ2V0QWNjZXNzVG9rZW4uYmluZCh0aGlzKSwgc2V0dGluZ3MuZ2xvYmFsLmZldGNoKTtcbiAgICAgICAgdGhpcy5yZWFsdGltZSA9IHRoaXMuX2luaXRSZWFsdGltZUNsaWVudChPYmplY3QuYXNzaWduKHsgaGVhZGVyczogdGhpcy5oZWFkZXJzLCBhY2Nlc3NUb2tlbjogdGhpcy5fZ2V0QWNjZXNzVG9rZW4uYmluZCh0aGlzKSB9LCBzZXR0aW5ncy5yZWFsdGltZSkpO1xuICAgICAgICB0aGlzLnJlc3QgPSBuZXcgUG9zdGdyZXN0Q2xpZW50KG5ldyBVUkwoJ3Jlc3QvdjEnLCBiYXNlVXJsKS5ocmVmLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBzY2hlbWE6IHNldHRpbmdzLmRiLnNjaGVtYSxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gbmV3IFN1cGFiYXNlU3RvcmFnZUNsaWVudCh0aGlzLnN0b3JhZ2VVcmwuaHJlZiwgdGhpcy5oZWFkZXJzLCB0aGlzLmZldGNoLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RvcmFnZSk7XG4gICAgICAgIGlmICghc2V0dGluZ3MuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbkZvckF1dGhFdmVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdXBhYmFzZSBGdW5jdGlvbnMgYWxsb3dzIHlvdSB0byBkZXBsb3kgYW5kIGludm9rZSBlZGdlIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBnZXQgZnVuY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uc0NsaWVudCh0aGlzLmZ1bmN0aW9uc1VybC5ocmVmLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBjdXN0b21GZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBxdWVyeSBvbiBhIHRhYmxlIG9yIGEgdmlldy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWxhdGlvbiAtIFRoZSB0YWJsZSBvciB2aWV3IG5hbWUgdG8gcXVlcnlcbiAgICAgKi9cbiAgICBmcm9tKHJlbGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3QuZnJvbShyZWxhdGlvbik7XG4gICAgfVxuICAgIC8vIE5PVEU6IHNpZ25hdHVyZXMgbXVzdCBiZSBrZXB0IGluIHN5bmMgd2l0aCBQb3N0Z3Jlc3RDbGllbnQuc2NoZW1hXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGEgc2NoZW1hIHRvIHF1ZXJ5IG9yIHBlcmZvcm0gYW4gZnVuY3Rpb24gKHJwYykgY2FsbC5cbiAgICAgKlxuICAgICAqIFRoZSBzY2hlbWEgbmVlZHMgdG8gYmUgb24gdGhlIGxpc3Qgb2YgZXhwb3NlZCBzY2hlbWFzIGluc2lkZSBTdXBhYmFzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIHRvIHF1ZXJ5XG4gICAgICovXG4gICAgc2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN0LnNjaGVtYShzY2hlbWEpO1xuICAgIH1cbiAgICAvLyBOT1RFOiBzaWduYXR1cmVzIG11c3QgYmUga2VwdCBpbiBzeW5jIHdpdGggUG9zdGdyZXN0Q2xpZW50LnJwY1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYSBmdW5jdGlvbiBjYWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIC0gVGhlIGZ1bmN0aW9uIG5hbWUgdG8gY2FsbFxuICAgICAqIEBwYXJhbSBhcmdzIC0gVGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvbiBjYWxsXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBOYW1lZCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaGVhZCAtIFdoZW4gc2V0IHRvIGB0cnVlYCwgYGRhdGFgIHdpbGwgbm90IGJlIHJldHVybmVkLlxuICAgICAqIFVzZWZ1bCBpZiB5b3Ugb25seSBuZWVkIHRoZSBjb3VudC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXQgLSBXaGVuIHNldCB0byBgdHJ1ZWAsIHRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoXG4gICAgICogcmVhZC1vbmx5IGFjY2VzcyBtb2RlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNvdW50IC0gQ291bnQgYWxnb3JpdGhtIHRvIHVzZSB0byBjb3VudCByb3dzIHJldHVybmVkIGJ5IHRoZVxuICAgICAqIGZ1bmN0aW9uLiBPbmx5IGFwcGxpY2FibGUgZm9yIFtzZXQtcmV0dXJuaW5nXG4gICAgICogZnVuY3Rpb25zXShodHRwczovL3d3dy5wb3N0Z3Jlc3FsLm9yZy9kb2NzL2N1cnJlbnQvZnVuY3Rpb25zLXNyZi5odG1sKS5cbiAgICAgKlxuICAgICAqIGBcImV4YWN0XCJgOiBFeGFjdCBidXQgc2xvdyBjb3VudCBhbGdvcml0aG0uIFBlcmZvcm1zIGEgYENPVU5UKCopYCB1bmRlciB0aGVcbiAgICAgKiBob29kLlxuICAgICAqXG4gICAgICogYFwicGxhbm5lZFwiYDogQXBwcm94aW1hdGVkIGJ1dCBmYXN0IGNvdW50IGFsZ29yaXRobS4gVXNlcyB0aGUgUG9zdGdyZXNcbiAgICAgKiBzdGF0aXN0aWNzIHVuZGVyIHRoZSBob29kLlxuICAgICAqXG4gICAgICogYFwiZXN0aW1hdGVkXCJgOiBVc2VzIGV4YWN0IGNvdW50IGZvciBsb3cgbnVtYmVycyBhbmQgcGxhbm5lZCBjb3VudCBmb3IgaGlnaFxuICAgICAqIG51bWJlcnMuXG4gICAgICovXG4gICAgcnBjKGZuLCBhcmdzID0ge30sIG9wdGlvbnMgPSB7XG4gICAgICAgIGhlYWQ6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZhbHNlLFxuICAgICAgICBjb3VudDogdW5kZWZpbmVkLFxuICAgIH0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdC5ycGMoZm4sIGFyZ3MsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgUmVhbHRpbWUgY2hhbm5lbCB3aXRoIEJyb2FkY2FzdCwgUHJlc2VuY2UsIGFuZCBQb3N0Z3JlcyBDaGFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgUmVhbHRpbWUgY2hhbm5lbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIFRoZSBvcHRpb25zIHRvIHBhc3MgdG8gdGhlIFJlYWx0aW1lIGNoYW5uZWwuXG4gICAgICpcbiAgICAgKi9cbiAgICBjaGFubmVsKG5hbWUsIG9wdHMgPSB7IGNvbmZpZzoge30gfSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFsdGltZS5jaGFubmVsKG5hbWUsIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCBSZWFsdGltZSBjaGFubmVscy5cbiAgICAgKi9cbiAgICBnZXRDaGFubmVscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhbHRpbWUuZ2V0Q2hhbm5lbHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGFuZCByZW1vdmVzIFJlYWx0aW1lIGNoYW5uZWwgZnJvbSBSZWFsdGltZSBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWx0aW1lQ2hhbm5lbH0gY2hhbm5lbCAtIFRoZSBuYW1lIG9mIHRoZSBSZWFsdGltZSBjaGFubmVsLlxuICAgICAqXG4gICAgICovXG4gICAgcmVtb3ZlQ2hhbm5lbChjaGFubmVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLnJlbW92ZUNoYW5uZWwoY2hhbm5lbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBhbmQgcmVtb3ZlcyBhbGwgUmVhbHRpbWUgY2hhbm5lbHMgZnJvbSBSZWFsdGltZSBjbGllbnQuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsQ2hhbm5lbHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWx0aW1lLnJlbW92ZUFsbENoYW5uZWxzKCk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRBY2Nlc3NUb2tlbigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmFjY2Vzc1Rva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCB0aGlzLmF1dGguZ2V0U2Vzc2lvbigpO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gZGF0YS5zZXNzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjZXNzX3Rva2VuKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLnN1cGFiYXNlS2V5O1xuICAgIH1cbiAgICBfaW5pdFN1cGFiYXNlQXV0aENsaWVudCh7IGF1dG9SZWZyZXNoVG9rZW4sIHBlcnNpc3RTZXNzaW9uLCBkZXRlY3RTZXNzaW9uSW5VcmwsIHN0b3JhZ2UsIHVzZXJTdG9yYWdlLCBzdG9yYWdlS2V5LCBmbG93VHlwZSwgbG9jaywgZGVidWcsIH0sIGhlYWRlcnMsIGZldGNoKSB7XG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0ge1xuICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuc3VwYWJhc2VLZXl9YCxcbiAgICAgICAgICAgIGFwaWtleTogYCR7dGhpcy5zdXBhYmFzZUtleX1gLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFN1cGFiYXNlQXV0aENsaWVudCh7XG4gICAgICAgICAgICB1cmw6IHRoaXMuYXV0aFVybC5ocmVmLFxuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhdXRoSGVhZGVycyksIGhlYWRlcnMpLFxuICAgICAgICAgICAgc3RvcmFnZUtleTogc3RvcmFnZUtleSxcbiAgICAgICAgICAgIGF1dG9SZWZyZXNoVG9rZW4sXG4gICAgICAgICAgICBwZXJzaXN0U2Vzc2lvbixcbiAgICAgICAgICAgIGRldGVjdFNlc3Npb25JblVybCxcbiAgICAgICAgICAgIHN0b3JhZ2UsXG4gICAgICAgICAgICB1c2VyU3RvcmFnZSxcbiAgICAgICAgICAgIGZsb3dUeXBlLFxuICAgICAgICAgICAgbG9jayxcbiAgICAgICAgICAgIGRlYnVnLFxuICAgICAgICAgICAgZmV0Y2gsXG4gICAgICAgICAgICAvLyBhdXRoIGNoZWNrcyBpZiB0aGVyZSBpcyBhIGN1c3RvbSBhdXRob3JpemFpdG9uIGhlYWRlciB1c2luZyB0aGlzIGZsYWdcbiAgICAgICAgICAgIC8vIHNvIGl0IGtub3dzIHdoZXRoZXIgdG8gcmV0dXJuIGFuIGVycm9yIHdoZW4gZ2V0VXNlciBpcyBjYWxsZWQgd2l0aCBubyBzZXNzaW9uXG4gICAgICAgICAgICBoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyOiBPYmplY3Qua2V5cyh0aGlzLmhlYWRlcnMpLnNvbWUoKGtleSkgPT4ga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdhdXRob3JpemF0aW9uJyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfaW5pdFJlYWx0aW1lQ2xpZW50KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFsdGltZUNsaWVudCh0aGlzLnJlYWx0aW1lVXJsLmhyZWYsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgcGFyYW1zOiBPYmplY3QuYXNzaWduKHsgYXBpa2V5OiB0aGlzLnN1cGFiYXNlS2V5IH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpIH0pKTtcbiAgICB9XG4gICAgX2xpc3RlbkZvckF1dGhFdmVudHMoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmF1dGgub25BdXRoU3RhdGVDaGFuZ2UoKGV2ZW50LCBzZXNzaW9uKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVUb2tlbkNoYW5nZWQoZXZlbnQsICdDTElFTlQnLCBzZXNzaW9uID09PSBudWxsIHx8IHNlc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlc3Npb24uYWNjZXNzX3Rva2VuKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBfaGFuZGxlVG9rZW5DaGFuZ2VkKGV2ZW50LCBzb3VyY2UsIHRva2VuKSB7XG4gICAgICAgIGlmICgoZXZlbnQgPT09ICdUT0tFTl9SRUZSRVNIRUQnIHx8IGV2ZW50ID09PSAnU0lHTkVEX0lOJykgJiZcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZEFjY2Vzc1Rva2VuICE9PSB0b2tlbikge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuc2V0QXV0aCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQgPT09ICdTSUdORURfT1VUJykge1xuICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5zZXRBdXRoKCk7XG4gICAgICAgICAgICBpZiAoc291cmNlID09ICdTVE9SQUdFJylcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGguc2lnbk91dCgpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkQWNjZXNzVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdXBhYmFzZUNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiRnVuY3Rpb25zQ2xpZW50IiwiUG9zdGdyZXN0Q2xpZW50IiwiUmVhbHRpbWVDbGllbnQiLCJTdG9yYWdlQ2xpZW50IiwiU3VwYWJhc2VTdG9yYWdlQ2xpZW50IiwiREVGQVVMVF9BVVRIX09QVElPTlMiLCJERUZBVUxUX0RCX09QVElPTlMiLCJERUZBVUxUX0dMT0JBTF9PUFRJT05TIiwiREVGQVVMVF9SRUFMVElNRV9PUFRJT05TIiwiZmV0Y2hXaXRoQXV0aCIsImFwcGx5U2V0dGluZ0RlZmF1bHRzIiwidmFsaWRhdGVTdXBhYmFzZVVybCIsIlN1cGFiYXNlQXV0aENsaWVudCIsIlN1cGFiYXNlQ2xpZW50IiwiY29uc3RydWN0b3IiLCJzdXBhYmFzZVVybCIsInN1cGFiYXNlS2V5Iiwib3B0aW9ucyIsIl9hIiwiX2IiLCJfYyIsImJhc2VVcmwiLCJFcnJvciIsInJlYWx0aW1lVXJsIiwiVVJMIiwicHJvdG9jb2wiLCJyZXBsYWNlIiwiYXV0aFVybCIsInN0b3JhZ2VVcmwiLCJmdW5jdGlvbnNVcmwiLCJkZWZhdWx0U3RvcmFnZUtleSIsImhvc3RuYW1lIiwic3BsaXQiLCJERUZBVUxUUyIsImRiIiwicmVhbHRpbWUiLCJhdXRoIiwiT2JqZWN0IiwiYXNzaWduIiwic3RvcmFnZUtleSIsImdsb2JhbCIsInNldHRpbmdzIiwiaGVhZGVycyIsImFjY2Vzc1Rva2VuIiwiX2luaXRTdXBhYmFzZUF1dGhDbGllbnQiLCJmZXRjaCIsIlByb3h5IiwiZ2V0IiwiXyIsInByb3AiLCJTdHJpbmciLCJfZ2V0QWNjZXNzVG9rZW4iLCJiaW5kIiwiX2luaXRSZWFsdGltZUNsaWVudCIsInJlc3QiLCJocmVmIiwic2NoZW1hIiwic3RvcmFnZSIsIl9saXN0ZW5Gb3JBdXRoRXZlbnRzIiwiZnVuY3Rpb25zIiwiY3VzdG9tRmV0Y2giLCJmcm9tIiwicmVsYXRpb24iLCJycGMiLCJmbiIsImFyZ3MiLCJoZWFkIiwiY291bnQiLCJ1bmRlZmluZWQiLCJjaGFubmVsIiwibmFtZSIsIm9wdHMiLCJjb25maWciLCJnZXRDaGFubmVscyIsInJlbW92ZUNoYW5uZWwiLCJyZW1vdmVBbGxDaGFubmVscyIsImRhdGEiLCJnZXRTZXNzaW9uIiwic2Vzc2lvbiIsImFjY2Vzc190b2tlbiIsImF1dG9SZWZyZXNoVG9rZW4iLCJwZXJzaXN0U2Vzc2lvbiIsImRldGVjdFNlc3Npb25JblVybCIsInVzZXJTdG9yYWdlIiwiZmxvd1R5cGUiLCJsb2NrIiwiZGVidWciLCJhdXRoSGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJhcGlrZXkiLCJ1cmwiLCJoYXNDdXN0b21BdXRob3JpemF0aW9uSGVhZGVyIiwia2V5cyIsInNvbWUiLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsInBhcmFtcyIsIm9uQXV0aFN0YXRlQ2hhbmdlIiwiZXZlbnQiLCJfaGFuZGxlVG9rZW5DaGFuZ2VkIiwic291cmNlIiwidG9rZW4iLCJjaGFuZ2VkQWNjZXNzVG9rZW4iLCJzZXRBdXRoIiwic2lnbk91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/module/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthAdminApi: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthAdminApi),\n/* harmony export */   AuthApiError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthApiError),\n/* harmony export */   AuthClient: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthClient),\n/* harmony export */   AuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthError),\n/* harmony export */   AuthImplicitGrantRedirectError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthImplicitGrantRedirectError),\n/* harmony export */   AuthInvalidCredentialsError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthInvalidCredentialsError),\n/* harmony export */   AuthInvalidJwtError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthInvalidJwtError),\n/* harmony export */   AuthInvalidTokenResponseError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthInvalidTokenResponseError),\n/* harmony export */   AuthPKCEGrantCodeExchangeError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthPKCEGrantCodeExchangeError),\n/* harmony export */   AuthRetryableFetchError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthRetryableFetchError),\n/* harmony export */   AuthSessionMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthSessionMissingError),\n/* harmony export */   AuthUnknownError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthUnknownError),\n/* harmony export */   AuthWeakPasswordError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthWeakPasswordError),\n/* harmony export */   CustomAuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.CustomAuthError),\n/* harmony export */   FunctionRegion: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionRegion),\n/* harmony export */   FunctionsError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsError),\n/* harmony export */   FunctionsFetchError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsFetchError),\n/* harmony export */   FunctionsHttpError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsHttpError),\n/* harmony export */   FunctionsRelayError: () => (/* reexport safe */ _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__.FunctionsRelayError),\n/* harmony export */   GoTrueAdminApi: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.GoTrueAdminApi),\n/* harmony export */   GoTrueClient: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.GoTrueClient),\n/* harmony export */   NavigatorLockAcquireTimeoutError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.NavigatorLockAcquireTimeoutError),\n/* harmony export */   PostgrestError: () => (/* reexport safe */ _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_1__.PostgrestError),\n/* harmony export */   REALTIME_CHANNEL_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_CHANNEL_STATES),\n/* harmony export */   REALTIME_LISTEN_TYPES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_LISTEN_TYPES),\n/* harmony export */   REALTIME_POSTGRES_CHANGES_LISTEN_EVENT: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_POSTGRES_CHANGES_LISTEN_EVENT),\n/* harmony export */   REALTIME_PRESENCE_LISTEN_EVENTS: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_PRESENCE_LISTEN_EVENTS),\n/* harmony export */   REALTIME_SUBSCRIBE_STATES: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.REALTIME_SUBSCRIBE_STATES),\n/* harmony export */   RealtimeChannel: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.RealtimeChannel),\n/* harmony export */   RealtimeClient: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.RealtimeClient),\n/* harmony export */   RealtimePresence: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.RealtimePresence),\n/* harmony export */   SIGN_OUT_SCOPES: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.SIGN_OUT_SCOPES),\n/* harmony export */   SupabaseClient: () => (/* reexport safe */ _SupabaseClient__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   WebSocketFactory: () => (/* reexport safe */ _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__.WebSocketFactory),\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   isAuthApiError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthApiError),\n/* harmony export */   isAuthError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthError),\n/* harmony export */   isAuthImplicitGrantRedirectError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthImplicitGrantRedirectError),\n/* harmony export */   isAuthRetryableFetchError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthRetryableFetchError),\n/* harmony export */   isAuthSessionMissingError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthSessionMissingError),\n/* harmony export */   isAuthWeakPasswordError: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.isAuthWeakPasswordError),\n/* harmony export */   lockInternals: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.lockInternals),\n/* harmony export */   navigatorLock: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.navigatorLock),\n/* harmony export */   processLock: () => (/* reexport safe */ _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.processLock)\n/* harmony export */ });\n/* harmony import */ var _SupabaseClient__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SupabaseClient */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/module/SupabaseClient.js\");\n/* harmony import */ var _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-js */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/index.js\");\n/* harmony import */ var _supabase_postgrest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @supabase/postgrest-js */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs\");\n/* harmony import */ var _supabase_functions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/functions-js */ \"(ssr)/./node_modules/@supabase/functions-js/dist/module/types.js\");\n/* harmony import */ var _supabase_realtime_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @supabase/realtime-js */ \"(ssr)/./node_modules/@supabase/realtime-js/dist/module/index.js\");\n\n\n\n\n\n\n/**\n * Creates a new Supabase Client.\n */ const createClient = (supabaseUrl, supabaseKey, options)=>{\n    return new _SupabaseClient__WEBPACK_IMPORTED_MODULE_4__[\"default\"](supabaseUrl, supabaseKey, options);\n};\n// Check for Node.js <= 18 deprecation\nfunction shouldShowDeprecationWarning() {\n    // Skip in browser environments\n    if (false) {}\n    // Skip if process is not available (e.g., Edge Runtime)\n    if (typeof process === \"undefined\") {\n        return false;\n    }\n    // Use dynamic property access to avoid Next.js Edge Runtime static analysis warnings\n    const processVersion = process[\"version\"];\n    if (processVersion === undefined || processVersion === null) {\n        return false;\n    }\n    const versionMatch = processVersion.match(/^v(\\d+)\\./);\n    if (!versionMatch) {\n        return false;\n    }\n    const majorVersion = parseInt(versionMatch[1], 10);\n    return majorVersion <= 18;\n}\nif (shouldShowDeprecationWarning()) {\n    console.warn(`  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. ` + `Please upgrade to Node.js 20 or later. ` + `For more information, visit: https://github.com/orgs/supabase/discussions/37217`);\n} //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDWjtBQUN1QjtBQUM4RTtBQUNqRztBQUN1QjtBQUM3RDs7Q0FFQyxHQUNNLE1BQU1RLGVBQWUsQ0FBQ0MsYUFBYUMsYUFBYUM7SUFDbkQsT0FBTyxJQUFJWCx1REFBY0EsQ0FBQ1MsYUFBYUMsYUFBYUM7QUFDeEQsRUFBRTtBQUNGLHNDQUFzQztBQUN0QyxTQUFTQztJQUNMLCtCQUErQjtJQUMvQixJQUFJLEtBQWtCLEVBQWEsRUFFbEM7SUFDRCx3REFBd0Q7SUFDeEQsSUFBSSxPQUFPQyxZQUFZLGFBQWE7UUFDaEMsT0FBTztJQUNYO0lBQ0EscUZBQXFGO0lBQ3JGLE1BQU1DLGlCQUFpQkQsT0FBTyxDQUFDLFVBQVU7SUFDekMsSUFBSUMsbUJBQW1CQyxhQUFhRCxtQkFBbUIsTUFBTTtRQUN6RCxPQUFPO0lBQ1g7SUFDQSxNQUFNRSxlQUFlRixlQUFlRyxLQUFLLENBQUM7SUFDMUMsSUFBSSxDQUFDRCxjQUFjO1FBQ2YsT0FBTztJQUNYO0lBQ0EsTUFBTUUsZUFBZUMsU0FBU0gsWUFBWSxDQUFDLEVBQUUsRUFBRTtJQUMvQyxPQUFPRSxnQkFBZ0I7QUFDM0I7QUFDQSxJQUFJTixnQ0FBZ0M7SUFDaENRLFFBQVFDLElBQUksQ0FBQyxDQUFDLHFIQUFxSCxDQUFDLEdBQ2hJLENBQUMsdUNBQXVDLENBQUMsR0FDekMsQ0FBQywrRUFBK0UsQ0FBQztBQUN6RixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9kaXN0L21vZHVsZS9pbmRleC5qcz9iMzI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTdXBhYmFzZUNsaWVudCBmcm9tICcuL1N1cGFiYXNlQ2xpZW50JztcbmV4cG9ydCAqIGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJztcbmV4cG9ydCB7IFBvc3RncmVzdEVycm9yLCB9IGZyb20gJ0BzdXBhYmFzZS9wb3N0Z3Jlc3QtanMnO1xuZXhwb3J0IHsgRnVuY3Rpb25zSHR0cEVycm9yLCBGdW5jdGlvbnNGZXRjaEVycm9yLCBGdW5jdGlvbnNSZWxheUVycm9yLCBGdW5jdGlvbnNFcnJvciwgRnVuY3Rpb25SZWdpb24sIH0gZnJvbSAnQHN1cGFiYXNlL2Z1bmN0aW9ucy1qcyc7XG5leHBvcnQgKiBmcm9tICdAc3VwYWJhc2UvcmVhbHRpbWUtanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTdXBhYmFzZUNsaWVudCB9IGZyb20gJy4vU3VwYWJhc2VDbGllbnQnO1xuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFN1cGFiYXNlIENsaWVudC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNsaWVudCA9IChzdXBhYmFzZVVybCwgc3VwYWJhc2VLZXksIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gbmV3IFN1cGFiYXNlQ2xpZW50KHN1cGFiYXNlVXJsLCBzdXBhYmFzZUtleSwgb3B0aW9ucyk7XG59O1xuLy8gQ2hlY2sgZm9yIE5vZGUuanMgPD0gMTggZGVwcmVjYXRpb25cbmZ1bmN0aW9uIHNob3VsZFNob3dEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gICAgLy8gU2tpcCBpbiBicm93c2VyIGVudmlyb25tZW50c1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFNraXAgaWYgcHJvY2VzcyBpcyBub3QgYXZhaWxhYmxlIChlLmcuLCBFZGdlIFJ1bnRpbWUpXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFVzZSBkeW5hbWljIHByb3BlcnR5IGFjY2VzcyB0byBhdm9pZCBOZXh0LmpzIEVkZ2UgUnVudGltZSBzdGF0aWMgYW5hbHlzaXMgd2FybmluZ3NcbiAgICBjb25zdCBwcm9jZXNzVmVyc2lvbiA9IHByb2Nlc3NbJ3ZlcnNpb24nXTtcbiAgICBpZiAocHJvY2Vzc1ZlcnNpb24gPT09IHVuZGVmaW5lZCB8fCBwcm9jZXNzVmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb25NYXRjaCA9IHByb2Nlc3NWZXJzaW9uLm1hdGNoKC9edihcXGQrKVxcLi8pO1xuICAgIGlmICghdmVyc2lvbk1hdGNoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQodmVyc2lvbk1hdGNoWzFdLCAxMCk7XG4gICAgcmV0dXJuIG1ham9yVmVyc2lvbiA8PSAxODtcbn1cbmlmIChzaG91bGRTaG93RGVwcmVjYXRpb25XYXJuaW5nKCkpIHtcbiAgICBjb25zb2xlLndhcm4oYOKaoO+4jyAgTm9kZS5qcyAxOCBhbmQgYmVsb3cgYXJlIGRlcHJlY2F0ZWQgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgQHN1cGFiYXNlL3N1cGFiYXNlLWpzLiBgICtcbiAgICAgICAgYFBsZWFzZSB1cGdyYWRlIHRvIE5vZGUuanMgMjAgb3IgbGF0ZXIuIGAgK1xuICAgICAgICBgRm9yIG1vcmUgaW5mb3JtYXRpb24sIHZpc2l0OiBodHRwczovL2dpdGh1Yi5jb20vb3Jncy9zdXBhYmFzZS9kaXNjdXNzaW9ucy8zNzIxN2ApO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIlN1cGFiYXNlQ2xpZW50IiwiUG9zdGdyZXN0RXJyb3IiLCJGdW5jdGlvbnNIdHRwRXJyb3IiLCJGdW5jdGlvbnNGZXRjaEVycm9yIiwiRnVuY3Rpb25zUmVsYXlFcnJvciIsIkZ1bmN0aW9uc0Vycm9yIiwiRnVuY3Rpb25SZWdpb24iLCJkZWZhdWx0IiwiY3JlYXRlQ2xpZW50Iiwic3VwYWJhc2VVcmwiLCJzdXBhYmFzZUtleSIsIm9wdGlvbnMiLCJzaG91bGRTaG93RGVwcmVjYXRpb25XYXJuaW5nIiwicHJvY2VzcyIsInByb2Nlc3NWZXJzaW9uIiwidW5kZWZpbmVkIiwidmVyc2lvbk1hdGNoIiwibWF0Y2giLCJtYWpvclZlcnNpb24iLCJwYXJzZUludCIsImNvbnNvbGUiLCJ3YXJuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/module/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SupabaseAuthClient: () => (/* binding */ SupabaseAuthClient)\n/* harmony export */ });\n/* harmony import */ var _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-js */ \"(ssr)/./node_modules/@supabase/auth-js/dist/module/index.js\");\n\nclass SupabaseAuthClient extends _supabase_auth_js__WEBPACK_IMPORTED_MODULE_0__.AuthClient {\n    constructor(options){\n        super(options);\n    }\n} //# sourceMappingURL=SupabaseAuthClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi9TdXBhYmFzZUF1dGhDbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0M7QUFDeEMsTUFBTUMsMkJBQTJCRCx5REFBVUE7SUFDOUNFLFlBQVlDLE9BQU8sQ0FBRTtRQUNqQixLQUFLLENBQUNBO0lBQ1Y7QUFDSixFQUNBLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9kaXN0L21vZHVsZS9saWIvU3VwYWJhc2VBdXRoQ2xpZW50LmpzPzFkMjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXV0aENsaWVudCB9IGZyb20gJ0BzdXBhYmFzZS9hdXRoLWpzJztcbmV4cG9ydCBjbGFzcyBTdXBhYmFzZUF1dGhDbGllbnQgZXh0ZW5kcyBBdXRoQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1cGFiYXNlQXV0aENsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiQXV0aENsaWVudCIsIlN1cGFiYXNlQXV0aENsaWVudCIsImNvbnN0cnVjdG9yIiwib3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/SupabaseAuthClient.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/constants.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/constants.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_AUTH_OPTIONS: () => (/* binding */ DEFAULT_AUTH_OPTIONS),\n/* harmony export */   DEFAULT_DB_OPTIONS: () => (/* binding */ DEFAULT_DB_OPTIONS),\n/* harmony export */   DEFAULT_GLOBAL_OPTIONS: () => (/* binding */ DEFAULT_GLOBAL_OPTIONS),\n/* harmony export */   DEFAULT_HEADERS: () => (/* binding */ DEFAULT_HEADERS),\n/* harmony export */   DEFAULT_REALTIME_OPTIONS: () => (/* binding */ DEFAULT_REALTIME_OPTIONS)\n/* harmony export */ });\n/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ \"(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/version.js\");\n\nlet JS_ENV = \"\";\n// @ts-ignore\nif (typeof Deno !== \"undefined\") {\n    JS_ENV = \"deno\";\n} else if (typeof document !== \"undefined\") {\n    JS_ENV = \"web\";\n} else if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\n    JS_ENV = \"react-native\";\n} else {\n    JS_ENV = \"node\";\n}\nconst DEFAULT_HEADERS = {\n    \"X-Client-Info\": `supabase-js-${JS_ENV}/${_version__WEBPACK_IMPORTED_MODULE_0__.version}`\n};\nconst DEFAULT_GLOBAL_OPTIONS = {\n    headers: DEFAULT_HEADERS\n};\nconst DEFAULT_DB_OPTIONS = {\n    schema: \"public\"\n};\nconst DEFAULT_AUTH_OPTIONS = {\n    autoRefreshToken: true,\n    persistSession: true,\n    detectSessionInUrl: true,\n    flowType: \"implicit\"\n};\nconst DEFAULT_REALTIME_OPTIONS = {}; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW9DO0FBQ3BDLElBQUlDLFNBQVM7QUFDYixhQUFhO0FBQ2IsSUFBSSxPQUFPQyxTQUFTLGFBQWE7SUFDN0JELFNBQVM7QUFDYixPQUNLLElBQUksT0FBT0UsYUFBYSxhQUFhO0lBQ3RDRixTQUFTO0FBQ2IsT0FDSyxJQUFJLE9BQU9HLGNBQWMsZUFBZUEsVUFBVUMsT0FBTyxLQUFLLGVBQWU7SUFDOUVKLFNBQVM7QUFDYixPQUNLO0lBQ0RBLFNBQVM7QUFDYjtBQUNPLE1BQU1LLGtCQUFrQjtJQUFFLGlCQUFpQixDQUFDLFlBQVksRUFBRUwsT0FBTyxDQUFDLEVBQUVELDZDQUFPQSxDQUFDLENBQUM7QUFBQyxFQUFFO0FBQ2hGLE1BQU1PLHlCQUF5QjtJQUNsQ0MsU0FBU0Y7QUFDYixFQUFFO0FBQ0ssTUFBTUcscUJBQXFCO0lBQzlCQyxRQUFRO0FBQ1osRUFBRTtBQUNLLE1BQU1DLHVCQUF1QjtJQUNoQ0Msa0JBQWtCO0lBQ2xCQyxnQkFBZ0I7SUFDaEJDLG9CQUFvQjtJQUNwQkMsVUFBVTtBQUNkLEVBQUU7QUFDSyxNQUFNQywyQkFBMkIsQ0FBQyxFQUFFLENBQzNDLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZhemVuZG8tcG9saXRpY2Etd2ViLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9zdXBhYmFzZS1qcy9kaXN0L21vZHVsZS9saWIvY29uc3RhbnRzLmpzP2JlNzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7XG5sZXQgSlNfRU5WID0gJyc7XG4vLyBAdHMtaWdub3JlXG5pZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgSlNfRU5WID0gJ2Rlbm8nO1xufVxuZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIEpTX0VOViA9ICd3ZWInO1xufVxuZWxzZSBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgICBKU19FTlYgPSAncmVhY3QtbmF0aXZlJztcbn1cbmVsc2Uge1xuICAgIEpTX0VOViA9ICdub2RlJztcbn1cbmV4cG9ydCBjb25zdCBERUZBVUxUX0hFQURFUlMgPSB7ICdYLUNsaWVudC1JbmZvJzogYHN1cGFiYXNlLWpzLSR7SlNfRU5WfS8ke3ZlcnNpb259YCB9O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfR0xPQkFMX09QVElPTlMgPSB7XG4gICAgaGVhZGVyczogREVGQVVMVF9IRUFERVJTLFxufTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX0RCX09QVElPTlMgPSB7XG4gICAgc2NoZW1hOiAncHVibGljJyxcbn07XG5leHBvcnQgY29uc3QgREVGQVVMVF9BVVRIX09QVElPTlMgPSB7XG4gICAgYXV0b1JlZnJlc2hUb2tlbjogdHJ1ZSxcbiAgICBwZXJzaXN0U2Vzc2lvbjogdHJ1ZSxcbiAgICBkZXRlY3RTZXNzaW9uSW5Vcmw6IHRydWUsXG4gICAgZmxvd1R5cGU6ICdpbXBsaWNpdCcsXG59O1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyA9IHt9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJ2ZXJzaW9uIiwiSlNfRU5WIiwiRGVubyIsImRvY3VtZW50IiwibmF2aWdhdG9yIiwicHJvZHVjdCIsIkRFRkFVTFRfSEVBREVSUyIsIkRFRkFVTFRfR0xPQkFMX09QVElPTlMiLCJoZWFkZXJzIiwiREVGQVVMVF9EQl9PUFRJT05TIiwic2NoZW1hIiwiREVGQVVMVF9BVVRIX09QVElPTlMiLCJhdXRvUmVmcmVzaFRva2VuIiwicGVyc2lzdFNlc3Npb24iLCJkZXRlY3RTZXNzaW9uSW5VcmwiLCJmbG93VHlwZSIsIkRFRkFVTFRfUkVBTFRJTUVfT1BUSU9OUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchWithAuth: () => (/* binding */ fetchWithAuth),\n/* harmony export */   resolveFetch: () => (/* binding */ resolveFetch),\n/* harmony export */   resolveHeadersConstructor: () => (/* binding */ resolveHeadersConstructor)\n/* harmony export */ });\n/* harmony import */ var _supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/node-fetch */ \"(ssr)/./node_modules/@supabase/node-fetch/lib/index.js\");\n/* harmony import */ var _supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0__);\n// @ts-ignore\n\nconst resolveFetch = (customFetch)=>{\n    let _fetch;\n    if (customFetch) {\n        _fetch = customFetch;\n    } else if (typeof fetch === \"undefined\") {\n        _fetch = (_supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0___default());\n    } else {\n        _fetch = fetch;\n    }\n    return (...args)=>_fetch(...args);\n};\nconst resolveHeadersConstructor = ()=>{\n    if (typeof Headers === \"undefined\") {\n        return _supabase_node_fetch__WEBPACK_IMPORTED_MODULE_0__.Headers;\n    }\n    return Headers;\n};\nconst fetchWithAuth = (supabaseKey, getAccessToken, customFetch)=>{\n    const fetch1 = resolveFetch(customFetch);\n    const HeadersConstructor = resolveHeadersConstructor();\n    return async (input, init)=>{\n        var _a;\n        const accessToken = (_a = await getAccessToken()) !== null && _a !== void 0 ? _a : supabaseKey;\n        let headers = new HeadersConstructor(init === null || init === void 0 ? void 0 : init.headers);\n        if (!headers.has(\"apikey\")) {\n            headers.set(\"apikey\", supabaseKey);\n        }\n        if (!headers.has(\"Authorization\")) {\n            headers.set(\"Authorization\", `Bearer ${accessToken}`);\n        }\n        return fetch1(input, Object.assign(Object.assign({}, init), {\n            headers\n        }));\n    };\n}; //# sourceMappingURL=fetch.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi9mZXRjaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLGFBQWE7QUFDaUU7QUFDdkUsTUFBTUcsZUFBZSxDQUFDQztJQUN6QixJQUFJQztJQUNKLElBQUlELGFBQWE7UUFDYkMsU0FBU0Q7SUFDYixPQUNLLElBQUksT0FBT0UsVUFBVSxhQUFhO1FBQ25DRCxTQUFTTCw2REFBU0E7SUFDdEIsT0FDSztRQUNESyxTQUFTQztJQUNiO0lBQ0EsT0FBTyxDQUFDLEdBQUdDLE9BQVNGLFVBQVVFO0FBQ2xDLEVBQUU7QUFDSyxNQUFNQyw0QkFBNEI7SUFDckMsSUFBSSxPQUFPUCxZQUFZLGFBQWE7UUFDaEMsT0FBT0MseURBQWdCQTtJQUMzQjtJQUNBLE9BQU9EO0FBQ1gsRUFBRTtBQUNLLE1BQU1RLGdCQUFnQixDQUFDQyxhQUFhQyxnQkFBZ0JQO0lBQ3ZELE1BQU1FLFNBQVFILGFBQWFDO0lBQzNCLE1BQU1RLHFCQUFxQko7SUFDM0IsT0FBTyxPQUFPSyxPQUFPQztRQUNqQixJQUFJQztRQUNKLE1BQU1DLGNBQWMsQ0FBQ0QsS0FBTSxNQUFNSixnQkFBZ0IsTUFBTyxRQUFRSSxPQUFPLEtBQUssSUFBSUEsS0FBS0w7UUFDckYsSUFBSU8sVUFBVSxJQUFJTCxtQkFBbUJFLFNBQVMsUUFBUUEsU0FBUyxLQUFLLElBQUksS0FBSyxJQUFJQSxLQUFLRyxPQUFPO1FBQzdGLElBQUksQ0FBQ0EsUUFBUUMsR0FBRyxDQUFDLFdBQVc7WUFDeEJELFFBQVFFLEdBQUcsQ0FBQyxVQUFVVDtRQUMxQjtRQUNBLElBQUksQ0FBQ08sUUFBUUMsR0FBRyxDQUFDLGtCQUFrQjtZQUMvQkQsUUFBUUUsR0FBRyxDQUFDLGlCQUFpQixDQUFDLE9BQU8sRUFBRUgsWUFBWSxDQUFDO1FBQ3hEO1FBQ0EsT0FBT1YsT0FBTU8sT0FBT08sT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHUCxPQUFPO1lBQUVHO1FBQVE7SUFDekU7QUFDSixFQUFFLENBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi9mZXRjaC5qcz8yNTRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1pZ25vcmVcbmltcG9ydCBub2RlRmV0Y2gsIHsgSGVhZGVycyBhcyBOb2RlRmV0Y2hIZWFkZXJzIH0gZnJvbSAnQHN1cGFiYXNlL25vZGUtZmV0Y2gnO1xuZXhwb3J0IGNvbnN0IHJlc29sdmVGZXRjaCA9IChjdXN0b21GZXRjaCkgPT4ge1xuICAgIGxldCBfZmV0Y2g7XG4gICAgaWYgKGN1c3RvbUZldGNoKSB7XG4gICAgICAgIF9mZXRjaCA9IGN1c3RvbUZldGNoO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIF9mZXRjaCA9IG5vZGVGZXRjaDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIF9mZXRjaCA9IGZldGNoO1xuICAgIH1cbiAgICByZXR1cm4gKC4uLmFyZ3MpID0+IF9mZXRjaCguLi5hcmdzKTtcbn07XG5leHBvcnQgY29uc3QgcmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvciA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIEhlYWRlcnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBOb2RlRmV0Y2hIZWFkZXJzO1xuICAgIH1cbiAgICByZXR1cm4gSGVhZGVycztcbn07XG5leHBvcnQgY29uc3QgZmV0Y2hXaXRoQXV0aCA9IChzdXBhYmFzZUtleSwgZ2V0QWNjZXNzVG9rZW4sIGN1c3RvbUZldGNoKSA9PiB7XG4gICAgY29uc3QgZmV0Y2ggPSByZXNvbHZlRmV0Y2goY3VzdG9tRmV0Y2gpO1xuICAgIGNvbnN0IEhlYWRlcnNDb25zdHJ1Y3RvciA9IHJlc29sdmVIZWFkZXJzQ29uc3RydWN0b3IoKTtcbiAgICByZXR1cm4gYXN5bmMgKGlucHV0LCBpbml0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW4gPSAoX2EgPSAoYXdhaXQgZ2V0QWNjZXNzVG9rZW4oKSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHN1cGFiYXNlS2V5O1xuICAgICAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzQ29uc3RydWN0b3IoaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMpO1xuICAgICAgICBpZiAoIWhlYWRlcnMuaGFzKCdhcGlrZXknKSkge1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoJ2FwaWtleScsIHN1cGFiYXNlS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhlYWRlcnMuaGFzKCdBdXRob3JpemF0aW9uJykpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KCdBdXRob3JpemF0aW9uJywgYEJlYXJlciAke2FjY2Vzc1Rva2VufWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZXRjaChpbnB1dCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbml0KSwgeyBoZWFkZXJzIH0pKTtcbiAgICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZldGNoLmpzLm1hcCJdLCJuYW1lcyI6WyJub2RlRmV0Y2giLCJIZWFkZXJzIiwiTm9kZUZldGNoSGVhZGVycyIsInJlc29sdmVGZXRjaCIsImN1c3RvbUZldGNoIiwiX2ZldGNoIiwiZmV0Y2giLCJhcmdzIiwicmVzb2x2ZUhlYWRlcnNDb25zdHJ1Y3RvciIsImZldGNoV2l0aEF1dGgiLCJzdXBhYmFzZUtleSIsImdldEFjY2Vzc1Rva2VuIiwiSGVhZGVyc0NvbnN0cnVjdG9yIiwiaW5wdXQiLCJpbml0IiwiX2EiLCJhY2Nlc3NUb2tlbiIsImhlYWRlcnMiLCJoYXMiLCJzZXQiLCJPYmplY3QiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/fetch.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applySettingDefaults: () => (/* binding */ applySettingDefaults),\n/* harmony export */   ensureTrailingSlash: () => (/* binding */ ensureTrailingSlash),\n/* harmony export */   isBrowser: () => (/* binding */ isBrowser),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   validateSupabaseUrl: () => (/* binding */ validateSupabaseUrl)\n/* harmony export */ });\nfunction uuid() {\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function(c) {\n        var r = Math.random() * 16 | 0, v = c == \"x\" ? r : r & 0x3 | 0x8;\n        return v.toString(16);\n    });\n}\nfunction ensureTrailingSlash(url) {\n    return url.endsWith(\"/\") ? url : url + \"/\";\n}\nconst isBrowser = ()=>\"undefined\" !== \"undefined\";\nfunction applySettingDefaults(options, defaults) {\n    var _a, _b;\n    const { db: dbOptions, auth: authOptions, realtime: realtimeOptions, global: globalOptions } = options;\n    const { db: DEFAULT_DB_OPTIONS, auth: DEFAULT_AUTH_OPTIONS, realtime: DEFAULT_REALTIME_OPTIONS, global: DEFAULT_GLOBAL_OPTIONS } = defaults;\n    const result = {\n        db: Object.assign(Object.assign({}, DEFAULT_DB_OPTIONS), dbOptions),\n        auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), authOptions),\n        realtime: Object.assign(Object.assign({}, DEFAULT_REALTIME_OPTIONS), realtimeOptions),\n        storage: {},\n        global: Object.assign(Object.assign(Object.assign({}, DEFAULT_GLOBAL_OPTIONS), globalOptions), {\n            headers: Object.assign(Object.assign({}, (_a = DEFAULT_GLOBAL_OPTIONS === null || DEFAULT_GLOBAL_OPTIONS === void 0 ? void 0 : DEFAULT_GLOBAL_OPTIONS.headers) !== null && _a !== void 0 ? _a : {}), (_b = globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.headers) !== null && _b !== void 0 ? _b : {})\n        }),\n        accessToken: async ()=>\"\"\n    };\n    if (options.accessToken) {\n        result.accessToken = options.accessToken;\n    } else {\n        // hack around Required<>\n        delete result.accessToken;\n    }\n    return result;\n}\n/**\n * Validates a Supabase client URL\n *\n * @param {string} supabaseUrl - The Supabase client URL string.\n * @returns {URL} - The validated base URL.\n * @throws {Error}\n */ function validateSupabaseUrl(supabaseUrl) {\n    const trimmedUrl = supabaseUrl === null || supabaseUrl === void 0 ? void 0 : supabaseUrl.trim();\n    if (!trimmedUrl) {\n        throw new Error(\"supabaseUrl is required.\");\n    }\n    if (!trimmedUrl.match(/^https?:\\/\\//i)) {\n        throw new Error(\"Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.\");\n    }\n    try {\n        return new URL(ensureTrailingSlash(trimmedUrl));\n    } catch (_a) {\n        throw Error(\"Invalid supabaseUrl: Provided URL is malformed.\");\n    }\n} //# sourceMappingURL=helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi9oZWxwZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQU8sU0FBU0E7SUFDWixPQUFPLHVDQUF1Q0MsT0FBTyxDQUFDLFNBQVMsU0FBVUMsQ0FBQztRQUN0RSxJQUFJQyxJQUFJLEtBQU1FLE1BQU0sS0FBSyxLQUFNLEdBQUdDLElBQUlKLEtBQUssTUFBTUMsSUFBSSxJQUFLLE1BQU87UUFDakUsT0FBT0csRUFBRUMsUUFBUSxDQUFDO0lBQ3RCO0FBQ0o7QUFDTyxTQUFTQyxvQkFBb0JDLEdBQUc7SUFDbkMsT0FBT0EsSUFBSUMsUUFBUSxDQUFDLE9BQU9ELE1BQU1BLE1BQU07QUFDM0M7QUFDTyxNQUFNRSxZQUFZLElBQU0sZ0JBQWtCLFlBQVk7QUFDdEQsU0FBU0MscUJBQXFCQyxPQUFPLEVBQUVDLFFBQVE7SUFDbEQsSUFBSUMsSUFBSUM7SUFDUixNQUFNLEVBQUVDLElBQUlDLFNBQVMsRUFBRUMsTUFBTUMsV0FBVyxFQUFFQyxVQUFVQyxlQUFlLEVBQUVDLFFBQVFDLGFBQWEsRUFBRyxHQUFHWDtJQUNoRyxNQUFNLEVBQUVJLElBQUlRLGtCQUFrQixFQUFFTixNQUFNTyxvQkFBb0IsRUFBRUwsVUFBVU0sd0JBQXdCLEVBQUVKLFFBQVFLLHNCQUFzQixFQUFHLEdBQUdkO0lBQ3BJLE1BQU1lLFNBQVM7UUFDWFosSUFBSWEsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHTixxQkFBcUJQO1FBQ3pEQyxNQUFNVyxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUdMLHVCQUF1Qk47UUFDN0RDLFVBQVVTLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR0osMkJBQTJCTDtRQUNyRVUsU0FBUyxDQUFDO1FBQ1ZULFFBQVFPLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT0MsTUFBTSxDQUFDRCxPQUFPQyxNQUFNLENBQUMsQ0FBQyxHQUFHSCx5QkFBeUJKLGdCQUFnQjtZQUFFUyxTQUFTSCxPQUFPQyxNQUFNLENBQUNELE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUksQ0FBQ2hCLEtBQUthLDJCQUEyQixRQUFRQSwyQkFBMkIsS0FBSyxJQUFJLEtBQUssSUFBSUEsdUJBQXVCSyxPQUFPLE1BQU0sUUFBUWxCLE9BQU8sS0FBSyxJQUFJQSxLQUFLLENBQUMsSUFBTSxDQUFDQyxLQUFLUSxrQkFBa0IsUUFBUUEsa0JBQWtCLEtBQUssSUFBSSxLQUFLLElBQUlBLGNBQWNTLE9BQU8sTUFBTSxRQUFRakIsT0FBTyxLQUFLLElBQUlBLEtBQUssQ0FBQztRQUFJO1FBQzFha0IsYUFBYSxVQUFZO0lBQzdCO0lBQ0EsSUFBSXJCLFFBQVFxQixXQUFXLEVBQUU7UUFDckJMLE9BQU9LLFdBQVcsR0FBR3JCLFFBQVFxQixXQUFXO0lBQzVDLE9BQ0s7UUFDRCx5QkFBeUI7UUFDekIsT0FBT0wsT0FBT0ssV0FBVztJQUM3QjtJQUNBLE9BQU9MO0FBQ1g7QUFDQTs7Ozs7O0NBTUMsR0FDTSxTQUFTTSxvQkFBb0JDLFdBQVc7SUFDM0MsTUFBTUMsYUFBYUQsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLElBQUksS0FBSyxJQUFJQSxZQUFZRSxJQUFJO0lBQzdGLElBQUksQ0FBQ0QsWUFBWTtRQUNiLE1BQU0sSUFBSUUsTUFBTTtJQUNwQjtJQUNBLElBQUksQ0FBQ0YsV0FBV0csS0FBSyxDQUFDLGtCQUFrQjtRQUNwQyxNQUFNLElBQUlELE1BQU07SUFDcEI7SUFDQSxJQUFJO1FBQ0EsT0FBTyxJQUFJRSxJQUFJakMsb0JBQW9CNkI7SUFDdkMsRUFDQSxPQUFPdEIsSUFBSTtRQUNQLE1BQU13QixNQUFNO0lBQ2hCO0FBQ0osRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2Uvc3VwYWJhc2UtanMvZGlzdC9tb2R1bGUvbGliL2hlbHBlcnMuanM/OWE2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gdXVpZCgpIHtcbiAgICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCwgdiA9IGMgPT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVRyYWlsaW5nU2xhc2godXJsKSB7XG4gICAgcmV0dXJuIHVybC5lbmRzV2l0aCgnLycpID8gdXJsIDogdXJsICsgJy8nO1xufVxuZXhwb3J0IGNvbnN0IGlzQnJvd3NlciA9ICgpID0+IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U2V0dGluZ0RlZmF1bHRzKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IGRiOiBkYk9wdGlvbnMsIGF1dGg6IGF1dGhPcHRpb25zLCByZWFsdGltZTogcmVhbHRpbWVPcHRpb25zLCBnbG9iYWw6IGdsb2JhbE9wdGlvbnMsIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgZGI6IERFRkFVTFRfREJfT1BUSU9OUywgYXV0aDogREVGQVVMVF9BVVRIX09QVElPTlMsIHJlYWx0aW1lOiBERUZBVUxUX1JFQUxUSU1FX09QVElPTlMsIGdsb2JhbDogREVGQVVMVF9HTE9CQUxfT1BUSU9OUywgfSA9IGRlZmF1bHRzO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgZGI6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9EQl9PUFRJT05TKSwgZGJPcHRpb25zKSxcbiAgICAgICAgYXV0aDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX0FVVEhfT1BUSU9OUyksIGF1dGhPcHRpb25zKSxcbiAgICAgICAgcmVhbHRpbWU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9SRUFMVElNRV9PUFRJT05TKSwgcmVhbHRpbWVPcHRpb25zKSxcbiAgICAgICAgc3RvcmFnZToge30sXG4gICAgICAgIGdsb2JhbDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfR0xPQkFMX09QVElPTlMpLCBnbG9iYWxPcHRpb25zKSwgeyBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgoX2EgPSBERUZBVUxUX0dMT0JBTF9PUFRJT05TID09PSBudWxsIHx8IERFRkFVTFRfR0xPQkFMX09QVElPTlMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IERFRkFVTFRfR0xPQkFMX09QVElPTlMuaGVhZGVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pKSwgKChfYiA9IGdsb2JhbE9wdGlvbnMgPT09IG51bGwgfHwgZ2xvYmFsT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2xvYmFsT3B0aW9ucy5oZWFkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSkpIH0pLFxuICAgICAgICBhY2Nlc3NUb2tlbjogYXN5bmMgKCkgPT4gJycsXG4gICAgfTtcbiAgICBpZiAob3B0aW9ucy5hY2Nlc3NUb2tlbikge1xuICAgICAgICByZXN1bHQuYWNjZXNzVG9rZW4gPSBvcHRpb25zLmFjY2Vzc1Rva2VuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gaGFjayBhcm91bmQgUmVxdWlyZWQ8PlxuICAgICAgICBkZWxldGUgcmVzdWx0LmFjY2Vzc1Rva2VuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBTdXBhYmFzZSBjbGllbnQgVVJMXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN1cGFiYXNlVXJsIC0gVGhlIFN1cGFiYXNlIGNsaWVudCBVUkwgc3RyaW5nLlxuICogQHJldHVybnMge1VSTH0gLSBUaGUgdmFsaWRhdGVkIGJhc2UgVVJMLlxuICogQHRocm93cyB7RXJyb3J9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVN1cGFiYXNlVXJsKHN1cGFiYXNlVXJsKSB7XG4gICAgY29uc3QgdHJpbW1lZFVybCA9IHN1cGFiYXNlVXJsID09PSBudWxsIHx8IHN1cGFiYXNlVXJsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdXBhYmFzZVVybC50cmltKCk7XG4gICAgaWYgKCF0cmltbWVkVXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3VwYWJhc2VVcmwgaXMgcmVxdWlyZWQuJyk7XG4gICAgfVxuICAgIGlmICghdHJpbW1lZFVybC5tYXRjaCgvXmh0dHBzPzpcXC9cXC8vaSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN1cGFiYXNlVXJsOiBNdXN0IGJlIGEgdmFsaWQgSFRUUCBvciBIVFRQUyBVUkwuJyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgVVJMKGVuc3VyZVRyYWlsaW5nU2xhc2godHJpbW1lZFVybCkpO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgc3VwYWJhc2VVcmw6IFByb3ZpZGVkIFVSTCBpcyBtYWxmb3JtZWQuJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiXSwibmFtZXMiOlsidXVpZCIsInJlcGxhY2UiLCJjIiwiciIsIk1hdGgiLCJyYW5kb20iLCJ2IiwidG9TdHJpbmciLCJlbnN1cmVUcmFpbGluZ1NsYXNoIiwidXJsIiwiZW5kc1dpdGgiLCJpc0Jyb3dzZXIiLCJhcHBseVNldHRpbmdEZWZhdWx0cyIsIm9wdGlvbnMiLCJkZWZhdWx0cyIsIl9hIiwiX2IiLCJkYiIsImRiT3B0aW9ucyIsImF1dGgiLCJhdXRoT3B0aW9ucyIsInJlYWx0aW1lIiwicmVhbHRpbWVPcHRpb25zIiwiZ2xvYmFsIiwiZ2xvYmFsT3B0aW9ucyIsIkRFRkFVTFRfREJfT1BUSU9OUyIsIkRFRkFVTFRfQVVUSF9PUFRJT05TIiwiREVGQVVMVF9SRUFMVElNRV9PUFRJT05TIiwiREVGQVVMVF9HTE9CQUxfT1BUSU9OUyIsInJlc3VsdCIsIk9iamVjdCIsImFzc2lnbiIsInN0b3JhZ2UiLCJoZWFkZXJzIiwiYWNjZXNzVG9rZW4iLCJ2YWxpZGF0ZVN1cGFiYXNlVXJsIiwic3VwYWJhc2VVcmwiLCJ0cmltbWVkVXJsIiwidHJpbSIsIkVycm9yIiwibWF0Y2giLCJVUkwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/version.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@supabase/supabase-js/dist/module/lib/version.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n// Generated automatically during releases by scripts/update-version-files.ts\n// This file provides runtime access to the package version for:\n// - HTTP request headers (e.g., X-Client-Info header for API requests)\n// - Debugging and support (identifying which version is running)\n// - Telemetry and logging (version reporting in errors/analytics)\n// - Ensuring build artifacts match the published package version\nconst version = \"2.78.0\"; //# sourceMappingURL=version.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSw2RUFBNkU7QUFDN0UsZ0VBQWdFO0FBQ2hFLHVFQUF1RTtBQUN2RSxpRUFBaUU7QUFDakUsa0VBQWtFO0FBQ2xFLGlFQUFpRTtBQUMxRCxNQUFNQSxVQUFVLFNBQVMsQ0FDaEMsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmF6ZW5kby1wb2xpdGljYS13ZWIvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3N1cGFiYXNlLWpzL2Rpc3QvbW9kdWxlL2xpYi92ZXJzaW9uLmpzPzQ4MjciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2VuZXJhdGVkIGF1dG9tYXRpY2FsbHkgZHVyaW5nIHJlbGVhc2VzIGJ5IHNjcmlwdHMvdXBkYXRlLXZlcnNpb24tZmlsZXMudHNcbi8vIFRoaXMgZmlsZSBwcm92aWRlcyBydW50aW1lIGFjY2VzcyB0byB0aGUgcGFja2FnZSB2ZXJzaW9uIGZvcjpcbi8vIC0gSFRUUCByZXF1ZXN0IGhlYWRlcnMgKGUuZy4sIFgtQ2xpZW50LUluZm8gaGVhZGVyIGZvciBBUEkgcmVxdWVzdHMpXG4vLyAtIERlYnVnZ2luZyBhbmQgc3VwcG9ydCAoaWRlbnRpZnlpbmcgd2hpY2ggdmVyc2lvbiBpcyBydW5uaW5nKVxuLy8gLSBUZWxlbWV0cnkgYW5kIGxvZ2dpbmcgKHZlcnNpb24gcmVwb3J0aW5nIGluIGVycm9ycy9hbmFseXRpY3MpXG4vLyAtIEVuc3VyaW5nIGJ1aWxkIGFydGlmYWN0cyBtYXRjaCB0aGUgcHVibGlzaGVkIHBhY2thZ2UgdmVyc2lvblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMi43OC4wJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZlcnNpb24uanMubWFwIl0sIm5hbWVzIjpbInZlcnNpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/supabase-js/dist/module/lib/version.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var _cjs_index_js__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PostgrestBuilder: () => (/* binding */ PostgrestBuilder),\n/* harmony export */   PostgrestClient: () => (/* binding */ PostgrestClient),\n/* harmony export */   PostgrestError: () => (/* binding */ PostgrestError),\n/* harmony export */   PostgrestFilterBuilder: () => (/* binding */ PostgrestFilterBuilder),\n/* harmony export */   PostgrestQueryBuilder: () => (/* binding */ PostgrestQueryBuilder),\n/* harmony export */   PostgrestTransformBuilder: () => (/* binding */ PostgrestTransformBuilder),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cjs/index.js */ \"(ssr)/./node_modules/@supabase/postgrest-js/dist/cjs/index.js\");\n\nconst { PostgrestClient, PostgrestQueryBuilder, PostgrestFilterBuilder, PostgrestTransformBuilder, PostgrestBuilder, PostgrestError } = _cjs_index_js__WEBPACK_IMPORTED_MODULE_0__ || /*#__PURE__*/ (_cjs_index_js__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (_cjs_index_js__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(_cjs_index_js__WEBPACK_IMPORTED_MODULE_0__, 2)));\n\n// compatibility with CJS output\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    PostgrestClient,\n    PostgrestQueryBuilder,\n    PostgrestFilterBuilder,\n    PostgrestTransformBuilder,\n    PostgrestBuilder,\n    PostgrestError\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL3Bvc3RncmVzdC1qcy9kaXN0L2VzbS93cmFwcGVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBd0M7QUFDeEMsTUFBTSxFQUNKQyxlQUFlLEVBQ2ZDLHFCQUFxQixFQUNyQkMsc0JBQXNCLEVBQ3RCQyx5QkFBeUIsRUFDekJDLGdCQUFnQixFQUNoQkMsY0FBYyxFQUNmLEdBQUdOLDBDQUFhLElBQUlBLGlOQUFLQTtBQVN6QjtBQUVELGdDQUFnQztBQUNoQyxpRUFBZTtJQUNiQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztJQUNBQztBQUNGLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mYXplbmRvLXBvbGl0aWNhLXdlYi8uL25vZGVfbW9kdWxlcy9Ac3VwYWJhc2UvcG9zdGdyZXN0LWpzL2Rpc3QvZXNtL3dyYXBwZXIubWpzP2Y5ZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgaW5kZXggZnJvbSAnLi4vY2pzL2luZGV4LmpzJ1xuY29uc3Qge1xuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0RmlsdGVyQnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0QnVpbGRlcixcbiAgUG9zdGdyZXN0RXJyb3IsXG59ID0gaW5kZXguZGVmYXVsdCB8fCBpbmRleFxuXG5leHBvcnQge1xuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RDbGllbnQsXG4gIFBvc3RncmVzdEZpbHRlckJ1aWxkZXIsXG4gIFBvc3RncmVzdFF1ZXJ5QnVpbGRlcixcbiAgUG9zdGdyZXN0VHJhbnNmb3JtQnVpbGRlcixcbiAgUG9zdGdyZXN0RXJyb3IsXG59XG5cbi8vIGNvbXBhdGliaWxpdHkgd2l0aCBDSlMgb3V0cHV0XG5leHBvcnQgZGVmYXVsdCB7XG4gIFBvc3RncmVzdENsaWVudCxcbiAgUG9zdGdyZXN0UXVlcnlCdWlsZGVyLFxuICBQb3N0Z3Jlc3RGaWx0ZXJCdWlsZGVyLFxuICBQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyLFxuICBQb3N0Z3Jlc3RCdWlsZGVyLFxuICBQb3N0Z3Jlc3RFcnJvcixcbn1cbiJdLCJuYW1lcyI6WyJpbmRleCIsIlBvc3RncmVzdENsaWVudCIsIlBvc3RncmVzdFF1ZXJ5QnVpbGRlciIsIlBvc3RncmVzdEZpbHRlckJ1aWxkZXIiLCJQb3N0Z3Jlc3RUcmFuc2Zvcm1CdWlsZGVyIiwiUG9zdGdyZXN0QnVpbGRlciIsIlBvc3RncmVzdEVycm9yIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@supabase/postgrest-js/dist/esm/wrapper.mjs\n");

/***/ })

};
;